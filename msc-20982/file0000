*DECK DIGITER 
      PROGRAM DIGITER(INPUT,OUTPUT,TAPE5=INPUT,TAPE6=OUTPUT,TAPE99) 
C** 
C** COMPUTER-AIDED DIGITAL FILTER DESIGN USE FLETCHER AND 
C** POWELL METHOD. THE PROCESS IS DESCRIBED IN THE PAPER
C** "COMPUTER-AIDED DESIGN OF RECURSIVE DIGITAL FILTER",
C** KENNETH STEIGLITH, IEEE TRANSACTIONS ON AUDIO AND 
C** ELECTROACOUSTICS, VOL. AU-18, NO.2 JUNE 1970. 
C** 
C** 
C** VARIABLES DEFINITIONS%  
C** 
C**    NPOINT     %NUMBER OF DATA POINTS FOR THE DESIRED FILTER.
C**    NCS        %NUMBER OF THE CASCADE SECTIONS WITH THE FORM 
C**                (Z**2+A*Z+B)/(Z**2+C*Z+D)
C**    LIMIT      %ITERATIONS BEFORE POLE-ZERO INVERSION
C**    ILOOP      %MAXIMUM LOOPING THROUGH SUBROUTINE DFMFP 
C**    ICHECK     % 0  NO DETAIL PRINTOUT 
C**               % 1  DETAIL PRINTOUT FOR CHECKOUT 
C**    DT         %SAMPLING INTERVAL (SEC)
C**    FREQ(I)    %DESIRED FILTER FREQUENCY DATA POINTS (RAD/SEC) 
C**    AMP(I)     %DESIRED FILTER AMPLITUDE AT FREQ(I) (DB) 
C**    PHASE(I)   %DESIRED FILTER PHASE AT FREQ(I) (DEG)
C**    WEIGHT(1,I)%WEIHGTING ROW MATRIX FOR AMPLITUDE 
C**    WEIGHT(2,I)%WEIHGTING ROW MATRIX FOR PHASE 
C**    ASTAR      %DESIGNED FILTER GAIN 
C**    FSTART     %FREQUENCY RESPONSE START FREQUENCY(RAD/SEC)
C**    DELF       %FREQUENCY INCREMENT IN FREQUENCY RESPONSE(RAD/SEC) 
C**    FSTOP      %FREQUENCY RESPONSE STOP FREQUENCY(RAD/SEC) 
C**    X(I)       %DIGITAL FILTER COEFFICIENTS TO BE DESIGNED.
C**                STORED IN ORDER OF A1,B1,C1,D1,A2,B2,C2,D2,... 
C**     IPLOT      0 NO PLOT,1 BODE,2 GAIN-PHASE,3 BOTH 
      COMMON /DATAI/FREQ(100),AMP(100),PHASE(100),WEIGHT(2,100) 
      COMMON /CMPLXF/Z(100),ROOT(2) 
      COMMON /DATAI/NPOINT,ICHECK,ILOOP,IGUESS
      COMMON /DATAR/ASTAR,DT,FNYQST,PIE,F1,F2,DTR 
      COMMON /PLOT/ IPLOT,IFREQR(2),XMAX(7),XMIN(7),YMAX(7),YMIN(7) 
      DIMENSION X(40),H(1000),G(40),SYM(4)
      COMPLEX Z,ROOT
      DOUBLE PRECISION X,F,H,G
      EXTERNAL FUNCT
      DATA SYM/3HNUM,3HDEM,4H*NUM,4H*DEM/ 
      DATA XMIN/-1000.0,-200.0,1.0,1.0,-200.0,0.0,0.0/
      DATA XMAX/1000.0,200.0,1.E10,1.E10,200.0,1.E10,1.E6/
      DATA YMIN/-200.0,-20.0,-200.0,-1000.0,-200.0,-1.E38,-1.E38/ 
      DATA YMAX/200.0,20.0,200.0,1000.0,200.0,1.E38,1.E38/
C** 
C** INITIALIZATION
C** 
55    F1PAST=0. 
      F2PAST=0. 
      DTR=57.29577951 
      IPLOT=1 
      ICHECK=0
C** 
C** INPUT DATA
C** 
      WRITE(6,24) 
24    FORMAT(1H1,14X,26H*****PRINT INPUT DATA*****//) 
      READ(5,1) NPOINT,NCS,LIMIT,ILOOP,ICHECK 
1     FORMAT(5I5) 
      WRITE(6,20) NPOINT,NCS,LIMIT,ILOOP
20    FORMAT(1H0,14X,27HDESIRED FILTER DATA POINTS=,I5//
     *          15X,23HCASCADE SECTION NUMBER=,I5// 
     *          15X,38HITERATIONS BEFORE POLE-ZERO INVERSION=,I5//
     *          15X,17HMAXIMUM LOOPPING=,I5/) 
      READ(5,9) DT,EST,EPS
      WRITE(6,21)DT,EST,EPS 
21    FORMAT(1H0,14X,23HSAMPLING TIME INTERVAL=,F8.6,4H SEC// 
     *          15X,30HESTIMATED MINIMUM INDEX VALUE=,E20.7// 
     *          15X,24HEXPECTED ABSOLUTE ERROR=,E20.7)
9     FORMAT(3E20.7)
C** 
C** CALCULATE NYQUIST FREQUENCY (RAD/SEC) 
C** 
44    PIE=3.141592654 
      FNYQST=PIE/DT 
C** 
C** INITIAL GUESS OF THE FILTER COEFFICIENTS
C** 
      WRITE(6,51) 
 51   FORMAT(1H0,10X,36H*** INITIAL GUESS OF FILTER GAIN ***,//)
      READ(5,8) ASTAR 
      WRITE(6,52) ASTAR 
52    FORMAT(1H0,15X,5HGAIN=,E20.7) 
      WRITE(6,27) 
27    FORMAT(1H0,10X,42H***INITIAL GUESS OF FILTER COEFFICIENTS***////
     *     10X,7HSECTION,14X,1HA,14X,1HB,14X,1HC,14X,1HD//) 
      DO 7 I=1,NCS
      K=4*(I-1)+1 
      READ(5,8) X(K),X(K+1),X(K+2),X(K+3) 
8     FORMAT(4E15.7)
      WRITE(6,28) I,X(K),X(K+1),X(K+2),X(K+3) 
28    FORMAT(1H0,9X,I4,10X,4F15.8)
7     CONTINUE
C** 
C** INITIAL GUESS FILTER FREQUENCY RESPONSE 
      WRITE(6,16) 
 16   FORMAT(1H1,5X,42H INITIAL GUESSED FILTER FREQUENCY RESPONSE//)
C** 
      CALL FREQR(NCS,X,ASTAR,DT)
C** 
C** INPUT DESIRED FILTER
C** 
      WRITE(6,25) 
25    FORMAT(1H1,11X,9HFREQUENCY,11X,9HAMPLITUDE,11X,5HPHASE,15X, 
     *      9HAMPLITUDE,11X,5HPHASE/12X,9H(RAD/SEC),11X,4H(DB), 
     *      16X,8H(DEGREE),12X,6HWEIGHT,14X,6HWEIGHT//) 
      DO 2 I=1,NPOINT 
      READ(5,3) FREQ(I),AMP(I),PHASE(I),WEIGHT(1,I),WEIGHT(2,I) 
2     WRITE(6,23) FREQ(I),AMP(I),PHASE(I),WEIGHT(1,I),WEIGHT(2,I) 
23    FORMAT(1H0,5F20.7)
3     FORMAT(5E10.4)
      IF (ICHECK.EQ.0) GO TO 54 
      WRITE(6,43) 
43    FORMAT(1H1) 
C** 
C** STORE Z VALUES FOR FREQ(I)
C** 
54    DO 4 I=1,NPOINT 
      RATIO=FREQ(I)/FNYQST
      IF (RATIO.LE.1.) GO TO 5
      WRITE(6,6) FNYQST,I,FREQ(I) 
6     FORMAT(1H1,10X,18HNYQUIST FREQUENCY=,F8.3/10X,10HDATA POINT,I5, 
     *13H   FREQUENCY=,F8.3)
      STOP
5     Z(I)=CMPLX(0.0,RATIO*PIE) 
      Z(I)=CEXP(Z(I)) 
      IF (ICHECK.EQ.0) GO TO 4
      WRITE(6,26) I,Z(I)
26    FORMAT(1H0,10X,I5,10X,2E20.7) 
4     CONTINUE
C** 
C** START NUMERICAL ITERATION 
C** 
      IGUESS=1
45    NVAR=4*NCS
      IF (ICHECK.EQ.0) GO TO 19 
      WRITE(6,42) 
42    FORMAT(1H1) 
19    CALL DFMFP(FUNCT,NVAR,X,F,G,EST,ESP,LIMIT,IER,H)
      ICHECK=0
      IF (ABS(F1PAST-F1).LT.EPS .AND. ABS(F2PAST-F2).LT.EPS)
     *GO TO 40
      F1PAST=F1 
      F2PAST=F2 
56    WRITE(6,29) IGUESS,ASTAR
29    FORMAT(1H1,10X,12HLOOP NUMBER=,I3,10X,
     *12HFILTER GAIN=,E15.7////)
      WRITE(6,50) F,F1,F2 
50    FORMAT(1H0,10X,12HTOTAL ERROR=,E15.7,5X,16HAMPLITUDE ERROR=,
     *E15.7,5X,12HANGLE ERROR=,E15.7) 
48    WRITE(6,30) IGUESS
30    FORMAT(1H0,10X,11HLOOP NUMBER,I5,4X,12HCOEFFICIENTS//// 
     *     11X,7HSECTION,14X,1HA,14X,1HB,14X,1HC,14X,1HD/)
      DO 31 I=1,NCS 
      K=4*(I-1)+1 
      WRITE(6,32) I,X(K),X(K+1),X(K+2),X(K+3) 
32    FORMAT(1H0,9X,I4,10X,4F15.8/) 
31    CONTINUE
C** 
C** INVERT ROOTS IF OUTSIDE UNIT CIRCLE 
C** 
39    IFLAG=0 
      I3=1
      WRITE(6,33) IGUESS
33    FORMAT(1H0,10X,11HLOOP NUMBER,I5,4X,5HROOTS//// 
     *    10X,7HSECTION,14X,4HREAL,11X,9HIMAGINERY,6X,
     *     9HAMPLITUDE,6X,5HANGLE,10X,9HFREQUENCY,6X,7HDAMPING/)
      DO 14 I=1,NCS 
      DO 34 I1=1,2
      K=2*(I3-1)+1
C** 
C** CHECK REAL OR IMAGINARY ROOTS 
C** 
      CALL ROOTER(X,K,ROOT) 
36    IFLG=0
      DO 37 I2=1,2
      AMPRT=CABS(ROOT(I2))
      ROOTR=REAL(ROOT(I2))
      ROOTI=AIMAG(ROOT(I2)) 
      IF (ROOTR.NE.0.) GO TO 61 
      IF (ROOTI.GT. 0.) ANGRT=90. 
      IF (ROOTI.LT. 0.) ANGRT=-90.
      GO TO 62
61    ANGRT=ATAN2(ROOTI,ROOTR)*DTR
62    ATTEN=-ALOG(AMPRT)/DT 
      OMEGA=ABS(ANGRT)/(DT*DTR) 
57    IF (OMEGA.NE.0.) GO TO 59 
      ZETA=1. 
      GO TO 58
59    ZOW=ATTEN/OMEGA 
      ZETA=ZOW/SQRT(1.+ZOW**2)
58    WRITE(6,38)I,SYM(I1),ROOTR,ROOTI,AMPRT,ANGRT,OMEGA,ZETA 
38    FORMAT(1H0,9X,I2,1X,A4,8X,6F15.7) 
      IF (AMPRT.LE.1.) GO TO 37 
      IFLG=1
      IFLAG=1 
      ROOT(I2)=1./ROOT(I2)
37    CONTINUE
      IF (IFLG.EQ.0) GO TO 34 
      X(K)=-ROOT(1)-ROOT(2) 
      X(K+1)=ROOT(1)*ROOT(2)
34    I3=I3+1 
14    CONTINUE
      IF (IFLAG.EQ.0) GO TO 46
      WRITE(6,47) 
47    FORMAT(1H1,10X,32HINVERT ROOTS OUTSIDE UNIT CIRCLE//) 
      GO TO 48
46    IF (IER.NE.1) GO TO 40
      IGUESS=IGUESS+1 
      IF (IGUESS.LE.(ILOOP+5)) GO TO 45 
40    WRITE(6,10) NCS 
10    FORMAT(1H1,10X,23HCASCADED FILTER NUMBER=,I5//) 
      WRITE(6,49) ASTAR 
49    FORMAT(1H0,7X,12HFILTER GAIN=,E20.7//)
      WRITE(6,11) 
11    FORMAT(1H0,7X,22HNUMERATOR COEFFICIENTS,18X,
     *24HDENOMINATOR COEFFICIENTS/) 
      DO 12 I=1,NCS 
      K=4*(I-1)+1 
12    WRITE(6,13) X(K),X(K+1),X(K+2),X(K+3) 
13    FORMAT(1H0,4E20.7)
C** 
C** PLOT STATEMENTS 
C** 
      WRITE(6,65) 
 65   FORMAT(1H1,10X,33HDESIRED FILTER FREQUENCY RESPONSE,/)
      CALL FREQR(NCS,X,ASTAR,DT)
      WRITE(6,41) IER 
41    FORMAT(1H1,10X,10HSTOP CODE=,I3)
      READ(5,1) ISTOP 
      IF (ISTOP.NE.1) GO TO 55
      STOP
      END 
*DECK FUNCT 
      SUBROUTINE FUNCT(N,X,F,G) 
      COMMON /DATAI/FREQ(100),AMP(100),PHASE(100),WEIGHT(2,100) 
      COMMON /CMPLXF/Z(100),ROOT(2) 
      COMMON /DATAI/NPOINT,ICHECK,ILOOP,IGUESS
      COMMON /DATAR/ASTAR,DT,FNYQST,PIE,F1,F2,DTR 
      DIMENSION X(1),NUSR(20),G(1),E1(100),E2(100),ANGLE(100) 
      DIMENSION COST(2,100) 
      COMPLEX TOP(100,10),BOTTOM(100,10),H(100),Z,ROOT
      DOUBLE PRECISION X,G,AUP,ADOWN,HABS,HDA,HDB,HDC,HDD 
      DOUBLE PRECISION DHDA,DHDB,DHDC,DHDD,F
      NCS=N/4 
      IUSR=0
      CONST=20./ALOG(10.) 
      DO 11 I=1,20
11    NUSR(I)=0 
      DO 1 I1=1,NPOINT
      H(I1)=CMPLX(1.0,0.0)
      ANGLE(I1)=0.
      DO 2 I2=1,NCS 
      K=4*(I2-1)+1
      TOP(I1,I2)=Z(I1)**2+X(K)*Z(I1)+X(K+1) 
      BOTTOM(I1,I2)=Z(I1)**2+X(K+2)*Z(I1)+X(K+3)
      H(I1)=H(I1)*TOP(I1,I2)/BOTTOM(I1,I2)
      CALL ROOTER(X,K,ROOT) 
      IF (I1.GT.1) GO TO 12 
      IF (CABS(ROOT(1)).LT.1. .AND. CABS(ROOT(2)).LT.1.) GO TO 12 
      NUSR(IUSR+1)=K
      IUSR=IUSR+1 
12    CALL PHASER(ANGLE2,FREQ(I1),ROOT,DT)
      CALL ROOTER(X,K+2,ROOT) 
      IF (I1.GT.1) GO TO 13 
      IF (CABS(ROOT(1)).LT.1. .AND. CABS(ROOT(2)).LT.1.) GO TO 13 
      NUSR(IUSR+1)=K+2
      IUSR=IUSR+1 
13    CALL PHASER(ANGLE3,FREQ(I1),ROOT,DT)
2     ANGLE(I1)=ANGLE(I1)+(ANGLE2-ANGLE3) 
1     CONTINUE
C** 
C** CALCULATE GAIN ESTIMATE 
C** 
      AUP=0.
      ADOWN=0.
      DO 3 I=1,NPOINT 
      HABS=CABS(H(I)) 
      AUP=AUP+WEIGHT(1,I)*(AMP(I)-20.*DLOG10(HABS)) 
3     ADOWN=ADOWN+20.*WEIGHT(1,I) 
      ASTAR=10.**(AUP/ADOWN)
C** 
C** CALCULATE ERROR AT INDIVIDUAL POINTS AND TOTAL ERROR
C** 
      F=0.
      F1=0. 
      F2=0. 
      DO 4 I1=1,NPOINT
      AMPC=ASTAR*CABS(H(I1))
      AMPC=20.*ALOG10(AMPC) 
      COST(1,I1)=WEIGHT(1,I1) 
      COST(2,I1)=WEIGHT(2,I1) 
C     IF (FREQ(I1).GT.10.) GO TO 16 
C** 
C** LARRY'S COST FUNCTION 
C** 
C     IF(ANGLE(I1).GT.(PHASE(I1)/DTR)) COST(2,I1)=0.
C     GO TO 17
C16   IF (AMPC.LT.AMPD) COST(1,I1)=0. 
C     IF(ANGLE(I1).LT.(PHASE(I1)/DTR)) COST(2,I1)=0.
17    E1(I1)=AMPC-AMP(I1) 
      E2(I1)=ANGLE(I1)*DTR-PHASE(I1)
      F1=F1+COST(1,I1)*E1(I1)**2
      F2=F2+COST(2,I1)*E2(I1)**2
4     F=F+COST(1,I1)*E1(I1)**2+COST(2,I1)*E2(I1)**2 
C** 
C** CALCULATE GRADIENT
C** 
      DO 9 I1=1,NCS 
      K=4*(I1-1)+1
      DHDA=0.D0 
      DHDB=0.D0 
      DHDC=0.D0 
      DHDD=0.D0 
      DO 10 I2=1,NPOINT 
      HABS=CABS(H(I2))
      HDA=REAL(Z(I2)/TOP(I2,I1))
      HDB=REAL(1./TOP(I2,I1)) 
      HDC=-REAL(Z(I2)/BOTTOM(I2,I1))
      HDD=-REAL(1./BOTTOM(I2,I1)) 
      ZR=REAL(Z(I2))
      ZI=AIMAG(Z(I2)) 
      DELAB=(X(K+1)-1.)**2+X(K)**2+2.*ZR*(X(K)*(1.+X(K+1))+ 
     *2.*X(K+1)*ZR) 
      DELCD=(X(K+3)-1.)**2+X(K+2)**2+2.*ZR*(X(K+2)*(1.+X(K+3))+ 
     *2.*X(K+3)*ZR) 
      HDA1=(X(K+1)-1.)*ZI/DELAB 
      HDB1=-ZI*(2.*ZR+X(K))/DELAB 
      HDC1=-(X(K+3)-1.)*ZI/DELCD
      HDD1=ZI*(2.*ZR+X(K+2))/DELCD
      CONST1=COST(1,I2)*E1(I2)*CONST
      CONST2=COST(2,I2)*E2(I2)
      DHDA=DHDA+CONST1*HDA+CONST2*HDA1
      DHDB=DHDB+CONST1*HDB+CONST2*HDB1
      DHDC=DHDC+CONST1*HDC+CONST2*HDC1
10    DHDD=DHDD+CONST1*HDD+CONST2*HDD1
      G(K)=2.*DHDA
      G(K+1)=2.*DHDB
      G(K+2)=2.*DHDC
9     G(K+3)=2.*DHDD
      IF (IGUESS.LE.ILOOP) GO TO 14 
      IF (IUSR.EQ.0) GO TO 14 
      DO 15 I=1,IUSR
      I1=NUSR(I)
      G(I1)=-G(I1)
      G(I1+1)=-G(I1+1)
15    CONTINUE
14    IF (ICHECK.EQ.0) RETURN 
      WRITE(6,5) (X(I),I=1,N) 
5     FORMAT(1H0,10X,9HFUNCT ARG/(10X,4F15.7))
      WRITE(6,6) F
6     FORMAT(1H0,10X,6HERROR=,E20.7)
      WRITE(6,7) (G(I),I=1,N) 
7     FORMAT(1H0,10X,8HGRADIENT/(10X,4E20.7)) 
      RETURN
      END 
*DECK DFMFP 
      SUBROUTINE DFMFP(FUNCT,N,X,F,G,EST,EPS,LIMIT,IER,H) 
C**   ADAPTED FROM S/360 SCIENTIFIC SUBROUTINE PACKAGE, 
C     (360A-CM-03X) VERSION III, 08/16/69 R.A. GARMOE 
C** 
C     ..................................................................
  
C 
C        SUBROUTINE DFMFP 
C 
C        PURPOSE
C           TO FIND A LOCAL MINIMUM OF A FUNCTION OF SEVERAL VARIABLES
C           BY THE METHOD OF FLETCHER AND POWELL
C 
C        USAGE
C           CALL DFMFP(FUNCT,N,X,F,G,EST,EPS,LIMIT,IER,H) 
C 
C        DESCRIPTION OF PARAMETERS
C           FUNCT  - USER-WRITTEN SUBROUTINE CONCERNING THE FUNCTION TO 
  
C                    BE MINIMIZED. IT MUST BE OF THE FORM 
C                    SUBROUTINE FUNCT(N,ARG,VAL,GRAD) 
C                    AND MUST SERVE THE FOLLOWING PURPOSE 
C                    FOR EACH N-DIMENSIONAL ARGUMENT VECTOR  ARG, 
C                    FUNCTION VALUE AND GRADIENT VECTOR MUST BE COMPUTED
  
C                    AND, ON RETURN, STORED IN VAL AND GRAD RESPECTIVELY
  
C                    ARG,VAL AND GRAD MUST BE OF DOUBLE PRECISION.
C           N      - NUMBER OF VARIABLES
C           X      - VECTOR OF DIMENSION N CONTAINING THE INITIAL 
C                    ARGUMENT WHERE THE ITERATION STARTS. ON RETURN,
C                    X HOLDS THE ARGUMENT CORRESPONDING TO THE
C                    COMPUTED MINIMUM FUNCTION VALUE
C                    DOUBLE PRECISION VECTOR. 
C           F      - SINGLE VARIABLE CONTAINING THE MINIMUM FUNCTION
C                    VALUE ON RETURN, I.E. F=F(X).
C                    DOUBLE PRECISION VARIABLE. 
C           G      - VECTOR OF DIMENSION N CONTAINING THE GRADIENT
C                    VECTOR CORRESPONDING TO THE MINIMUM ON RETURN, 
C                    I.E. G=G(X). 
C                    DOUBLE PRECISION VECTOR. 
C           EST    - IS AN ESTIMATE OF THE MINIMUM FUNCTION VALUE.
C                    SINGLE PRECISION VARIABLE. 
C           EPS    - TESTVALUE REPRESENTING THE EXPECTED ABSOLUTE ERROR.
  
C                    A REASONABLE CHOICE IS 10**(-16), I.E. 
C                    SOMEWHAT GREATER THAN 10**(-D), WHERE D IS THE 
C                    NUMBER OF SIGNIFICANT DIGITS IN FLOATING POINT 
C                    REPRESENTATION.
C                    SINGLE PRECISION VARIABLE. 
C           LIMIT  - MAXIMUM NUMBER OF ITERATIONS.
C           IER    - ERROR PARAMETER
C                    IER = 0 MEANS CONVERGENCE WAS OBTAINED 
C                    IER = 1 MEANS NO CONVERGENCE IN LIMIT ITERATIONS 
C                    IER =-1 MEANS ERRORS IN GRADIENT CALCULATION 
C                    IER = 2 MEANS LINEAR SEARCH TECHNIQUE INDICATES
C                    IT IS LIKELY THAT THERE EXISTS NO MINIMUM. 
C           H      - WORKING STORAGE OF DIMENSION N*(N+7)/2.
C                    DOUBLE PRECISION ARRAY.
C 
C        REMARKS
C            I) THE SUBROUTINE NAME REPLACING THE DUMMY ARGUMENT  FUNCT 
  
C               MUST BE DECLARED AS EXTERNAL IN THE CALLING PROGRAM.
C           II) IER IS SET TO 2 IF , STEPPING IN ONE OF THE COMPUTED
C               DIRECTIONS, THE FUNCTION WILL NEVER INCREASE WITHIN 
C               A TOLERABLE RANGE OF ARGUMENT.
C               IER = 2 MAY OCCUR ALSO IF THE INTERVAL WHERE F
C               INCREASES IS SMALL AND THE INITIAL ARGUMENT WAS 
C               RELATIVELY FAR AWAY FROM THE MINIMUM SUCH THAT THE
C               MINIMUM WAS OVERLEAPED. THIS IS DUE TO THE SEARCH 
C               TECHNIQUE WHICH DOUBLES THE STEPSIZE UNTIL A POINT
C               IS FOUND WHERE THE FUNCTION INCREASES.
C 
C        SUBROUTINES AND FUNCTION SUBPROGRAMS REQUIRED
C           FUNCT 
C 
C        METHOD 
C           THE METHOD IS DESCRIBED IN THE FOLLOWING ARTICLE
C           R. FLETCHER AND M.J.D. POWELL, A RAPID DESCENT METHOD FOR 
C           MINIMIZATION, 
C           COMPUTER JOURNAL VOL.6, ISS. 2, 1963, PP.163-168. 
C 
C     ..................................................................
  
C 
C 
C        DIMENSIONED DUMMY VARIABLES
      DIMENSION H(1),X(1),G(1)
      DOUBLE PRECISION X,F,FX,FY,OLDF,HNRM,GNRM,H,G,DX,DY,ALFA,DALFA, 
     1AMBDA,T,Z,W 
C 
C        COMPUTE FUNCTION VALUE AND GRADIENT VECTOR FOR INITIAL ARGUMENT
  
      CALL FUNCT(N,X,F,G) 
C 
C        RESET ITERATION COUNTER AND GENERATE IDENTITY MATRIX 
      IER=0 
      KOUNT=0 
      N2=N+N
      N3=N2+N 
      N31=N3+1
    1 K=N31 
      DO 4 J=1,N
      H(K)=1.D0 
      NJ=N-J
      IF(NJ)5,5,2 
    2 DO 3 L=1,NJ 
      KL=K+L
    3 H(KL)=0.D0
    4 K=KL+1
C 
C        START ITERATION LOOP 
    5 KOUNT=KOUNT +1
C 
C        SAVE FUNCTION VALUE, ARGUMENT VECTOR AND GRADIENT VECTOR 
      OLDF=F
      DO 9 J=1,N
      K=N+J 
      H(K)=G(J) 
      K=K+N 
      H(K)=X(J) 
C 
C        DETERMINE DIRECTION VECTOR H 
      K=J+N3
      T=0.D0
      DO 8 L=1,N
      T=T-G(L)*H(K) 
      IF(L-J)6,7,7
    6 K=K+N-L 
      GO TO 8 
    7 K=K+1 
    8 CONTINUE
    9 H(J)=T
C 
C        CHECK WHETHER FUNCTION WILL DECREASE STEPPING ALONG H. 
      DY=0.D0 
      HNRM=0.D0 
      GNRM=0.D0 
C 
C        CALCULATE DIRECTIONAL DERIVATIVE AND TESTVALUES FOR DIRECTION
C        VECTOR H AND GRADIENT VECTOR G.
      DO 10 J=1,N 
      HNRM=HNRM+DABS(H(J))
      GNRM=GNRM+DABS(G(J))
   10 DY=DY+H(J)*G(J) 
C 
C        REPEAT SEARCH IN DIRECTION OF STEEPEST DESCENT IF DIRECTIONAL
C        DERIVATIVE APPEARS TO BE POSITIVE OR ZERO. 
      IF(DY)11,51,51
C 
C        REPEAT SEARCH IN DIRECTION OF STEEPEST DESCENT IF DIRECTION
C        VECTOR H IS SMALL COMPARED TO GRADIENT VECTOR G. 
   11 IF(HNRM/GNRM-EPS)51,51,12 
C 
C        SEARCH MINIMUM ALONG DIRECTION H 
C 
C        SEARCH ALONG H FOR POSITIVE DIRECTIONAL DERIVATIVE 
   12 FY=F
      ALFA=2.D0*(EST-F)/DY
      AMBDA=1.D0
C 
C        USE ESTIMATE FOR STEPSIZE ONLY IF IT IS POSITIVE AND LESS THAN 
  
C        1. OTHERWISE TAKE 1. AS STEPSIZE 
      IF(ALFA)15,15,13
   13 IF(ALFA-AMBDA)14,15,15
   14 AMBDA=ALFA
   15 ALFA=0.D0 
C 
C        SAVE FUNCTION AND DERIVATIVE VALUES FOR OLD ARGUMENT 
   16 FX=FY 
      DX=DY 
C 
C        STEP ARGUMENT ALONG H
      DO 17 I=1,N 
   17 X(I)=X(I)+AMBDA*H(I)
C 
C        COMPUTE FUNCTION VALUE AND GRADIENT FOR NEW ARGUMENT 
      CALL FUNCT(N,X,F,G) 
      FY=F
C 
C        COMPUTE DIRECTIONAL DERIVATIVE DY FOR NEW ARGUMENT.  TERMINATE 
  
C        SEARCH, IF DY IS POSITIVE. IF DY IS ZERO THE MINIMUM IS FOUND
      DY=0.D0 
      DO 18 I=1,N 
   18 DY=DY+G(I)*H(I) 
      IF(DY)19,36,22
C 
C        TERMINATE SEARCH ALSO IF THE FUNCTION VALUE INDICATES THAT 
C        A MINIMUM HAS BEEN PASSED
   19 IF(FY-FX)20,22,22 
C 
C        REPEAT SEARCH AND DOUBLE STEPSIZE FOR FURTHER SEARCHES 
   20 AMBDA=AMBDA+ALFA
      ALFA=AMBDA
C        END OF SEARCH LOOP 
C 
C        TERMINATE IF THE CHANGE IN ARGUMENT GETS VERY LARGE
      IF(HNRM*AMBDA-1.D10)16,16,21
C 
C        LINEAR SEARCH TECHNIQUE INDICATES THAT NO MINIMUM EXISTS 
   21 IER=2 
      RETURN
C 
C        INTERPOLATE CUBICALLY IN THE INTERVAL DEFINED BY THE SEARCH
C        ABOVE AND COMPUTE THE ARGUMENT X FOR WHICH THE INTERPOLATION 
C        POLYNOMIAL IS MINIMIZED
   22 T=0.D0
   23 IF(AMBDA)24,36,24 
   24 Z=3.D0*(FX-FY)/AMBDA+DX+DY
      ALFA=DMAX1(DABS(Z),DABS(DX),DABS(DY)) 
      DALFA=Z/ALFA
      DALFA=DALFA*DALFA-DX/ALFA*DY/ALFA 
      IF(DALFA)51,25,25 
   25 W=ALFA*DSQRT(DALFA) 
      ALFA=DY-DX+W+W
      IF(ALFA) 250,251,250
  250 ALFA=(DY-Z+W)/ALFA
      GO TO 252 
  251 ALFA=(Z+DY-W)/(Z+DX+Z+DY) 
  252 ALFA=ALFA*AMBDA 
      DO 26 I=1,N 
   26 X(I)=X(I)+(T-ALFA)*H(I) 
C 
C        TERMINATE, IF THE VALUE OF THE ACTUAL FUNCTION AT X IS LESS
C        THAN THE FUNCTION VALUES AT THE INTERVAL ENDS. OTHERWISE REDUCE
  
C        THE INTERVAL BY CHOOSING ONE END-POINT EQUAL TO X AND REPEAT 
C        THE INTERPOLATION.  WHICH END-POINT IS CHOOSEN DEPENDS ON THE
C        VALUE OF THE FUNCTION AND ITS GRADIENT AT X
C 
      CALL FUNCT(N,X,F,G) 
      IF(F-FX)27,27,28
   27 IF(F-FY)36,36,28
   28 DALFA=0.D0
      DO 29 I=1,N 
   29 DALFA=DALFA+G(I)*H(I) 
      IF(DALFA)30,33,33 
   30 IF(F-FX)32,31,33
   31 IF(DX-DALFA)32,36,32
   32 FX=F
      DX=DALFA
      T=ALFA
      AMBDA=ALFA
      GO TO 23
   33 IF(FY-F)35,34,35
   34 IF(DY-DALFA)35,36,35
   35 FY=F
      DY=DALFA
      AMBDA=AMBDA-ALFA
      GO TO 22
C 
C        TERMINATE, IF FUNCTION HAS NOT DECREASED DURING LAST ITERATION 
  
   36 IF(OLDF-F+EPS)51,38,38
C 
C        COMPUTE DIFFERENCE VECTORS OF ARGUMENT AND GRADIENT FROM 
C        TWO CONSECUTIVE ITERATIONS 
   38 DO 37 J=1,N 
      K=N+J 
      H(K)=G(J)-H(K)
      K=N+K 
   37 H(K)=X(J)-H(K)
C 
C        TEST LENGTH OF ARGUMENT DIFFERENCE VECTOR AND DIRECTION VECTOR 
  
C        IF AT LEAST N ITERATIONS HAVE BEEN EXECUTED. TERMINATE, IF 
C        BOTH ARE LESS THAN  EPS
      IER=0 
      IF(KOUNT-N)42,39,39 
   39 T=0.D0
      Z=0.D0
      DO 40 J=1,N 
      K=N+J 
      W=H(K)
      K=K+N 
      T=T+DABS(H(K))
   40 Z=Z+W*H(K)
      IF(HNRM-EPS)41,41,42
   41 IF(T-EPS)56,56,42 
C 
C        TERMINATE, IF NUMBER OF ITERATIONS WOULD EXCEED  LIMIT 
   42 IF(KOUNT-LIMIT)43,50,50 
C 
C        PREPARE UPDATING OF MATRIX H 
   43 ALFA=0.D0 
      DO 47 J=1,N 
      K=J+N3
      W=0.D0
      DO 46 L=1,N 
      KL=N+L
      W=W+H(KL)*H(K)
      IF(L-J)44,45,45 
   44 K=K+N-L 
      GO TO 46
   45 K=K+1 
   46 CONTINUE
      K=N+J 
      ALFA=ALFA+W*H(K)
   47 H(J)=W
C 
C        REPEAT SEARCH IN DIRECTION OF STEEPEST DESCENT IF RESULTS
C        ARE NOT SATISFACTORY 
      IF(Z*ALFA)48,1,48 
C 
C        UPDATE MATRIX H
   48 K=N31 
      DO 49 L=1,N 
      KL=N2+L 
      DO 49 J=L,N 
      NJ=N2+J 
      H(K)=H(K)+H(KL)*H(NJ)/Z-H(L)*H(J)/ALFA
   49 K=K+1 
      GO TO 5 
C        END OF ITERATION LOOP
C 
C        NO CONVERGENCE AFTER  LIMIT  ITERATIONS
   50 IER=1 
      RETURN
C 
C        RESTORE OLD VALUES OF FUNCTION AND ARGUMENTS 
   51 DO 52 J=1,N 
      K=N2+J
   52 X(J)=H(K) 
      CALL FUNCT(N,X,F,G) 
C 
C        REPEAT SEARCH IN DIRECTION OF STEEPEST DESCENT IF DERIVATIVE 
C        FAILS TO BE SUFFICIENTLY SMALL 
      IF(GNRM-EPS)55,55,53
C 
C        TEST FOR REPEATED FAILURE OF ITERATION 
   53 IF(IER)56,54,54 
   54 IER=-1
      GOTO 1
   55 IER=0 
   56 RETURN
      END 
*DECK ROOTER
      SUBROUTINE ROOTER(X,K,ROOT) 
      DIMENSION X(1)
      DOUBLE PRECISION X
      COMPLEX ROOT(2) 
      TEST=X(K)**2-4.*X(K+1)
      SQRTT=SQRT(ABS(TEST)) 
      IF (TEST) 15,16,16
16    ROOT(1)=CMPLX(-SNGL(X(K))+SQRTT,0.)/2.
      ROOT(2)=CMPLX(-SNGL(X(K))-SQRTT,0.)/2.
      RETURN
15    ROOT(1)=CMPLX(-SNGL(X(K)),SQRTT)/2. 
      ROOT(2)=CONJG(ROOT(1))
      RETURN
      END 
*DECK PHASER
      SUBROUTINE PHASER(ANGLE,OMEGA,ROOT,DT)
      COMPLEX Z,ROOT(2) 
      PIE=3.141592654 
      FNYQST=PIE/DT 
      RATIO=OMEGA/FNYQST
      Z=CMPLX(0.0,RATIO*PIE)
      Z=CEXP(Z) 
      RR1=REAL(Z)-REAL(ROOT(1)) 
      RI1=AIMAG(Z)-AIMAG(ROOT(1)) 
      RR2=REAL(Z)-REAL(ROOT(2)) 
      RI2=AIMAG(Z)-AIMAG(ROOT(2)) 
      IF (RR1 .NE. 0.) ANGLE1=ATAN2(RI1,RR1)
      IF (RR1.EQ.0. .AND. RI1.NE.0.) ANGLE1=SIGN(PIE/2.,RI1)
      IF (RR1.EQ.0. .AND. RI1.EQ.0.) ANGLE1=0.
      IF (RR2 .NE. 0.) ANGLE2=ATAN2(RI2,RR2)
      IF (RR2.EQ.0. .AND. RI2.NE.0.) ANGLE2=SIGN(PIE/2.,RI2)
      IF (RR2.EQ.0. .AND. RI2.EQ.0.) ANGLE2=0.
      IF (RR1.LT.0. .AND. RI1.LT.0.) ANGLE1=2.*PIE+ANGLE1 
      IF (RR2.LT.0. .AND. RI2.LT.0.) ANGLE2=2.*PIE+ANGLE2 
      ANGLE=ANGLE1+ANGLE2 
      RETURN
      END 
*DECK FREQR 
      SUBROUTINE FREQR(NCS,X,ASTAR,DT)
      DIMENSION X(1),ANGLE(100),AMP(100),OMEGA(100),BCDNAM(7) 
      COMPLEX TOP,BOTTOM,H,Z,ROOT(2)
      DOUBLE PRECISION X
      COMMON /PLOT/ IPLOT,IFREQR(2),XMAX(7),XMIN(7),YMAX(7),YMIN(7) 
      DATA BCDNAM/10H          ,10H          ,10H          ,
     .10H          ,10H          ,10H          ,10H          /
      PIE=3.141592654 
      DTR=57.29577951 
      FNYQST=PIE/DT 
      NPT=INT(FNYQST) 
      WRITE(6,10) 
 10   FORMAT(T10,15HFREQUENCY (R/S),T30,14HAMPLITUDE (DB),T50,
     .12HPHASE  (DEG),/)
      DO 1 I1=1,NPT 
      FQ=FLOAT(I1-1)
      RATIO=FQ/FNYQST 
      Z=CMPLX(0.0,RATIO*PIE)
      Z=CEXP(Z) 
      H=CMPLX(1.0,0.0)
      ANGLE(I1)=0.
      DO 2 I2=1,NCS 
      K=4*(I2-1)+1
      TOP=Z**2+X(K)*Z+X(K+1)
      BOTTOM=Z**2+X(K+2)*Z+X(K+3) 
      H=H*TOP/BOTTOM
      CALL ROOTER(X,K,ROOT) 
      CALL PHASER(ANGLE2,FQ,ROOT,DT)
      CALL ROOTER(X,K+2,ROOT) 
      CALL PHASER(ANGLE3,FQ,ROOT,DT)
2     ANGLE(I1)=ANGLE(I1)+ANGLE2-ANGLE3 
      AMP(I1)=ASTAR*CABS(H) 
      AMP(I1)=20.*ALOG10(AMP(I1)) 
      ANGLE(I1)=ANGLE(I1)*DTR 
      WRITE(6,3) FQ,AMP(I1),ANGLE(I1) 
      OMEGA(I1)=FQ
3     FORMAT(1H0,3E20.7)
1     CONTINUE
      IF(IPLOT .EQ. 0) RETURN 
      IF(IPLOT .EQ. 2) GO TO 20 
      CALL RPLOT(OMEGA,AMP,AR,AL,AB,AT,2,3,1,BCDNAM,I1) 
      CALL RPLOT(OMEGA,ANGLE,AR,AL,AB,AT,2,4,1,BCDNAM,I1) 
 20   CONTINUE
      IF(IPLOT .EQ. 1) RETURN 
      CALL RPLOT(AMP,ANGLE,AR,AL,AB,AT,1,1,1,BCDNAM,I1) 
      RETURN
      END 
*DECK CYCLE 
       SUBROUTINE CYCLE (XL,XR,NCX,X,Y,NP)
      JL=ALOG10(XL) 
      JR=ALOG10(XR) 
      TENJR=10.**JR 
      IF(ABS(XR-TENJR)-(TENJR*10.0E-4)) 1,1,100 
  100 IF(XR-TENJR) 1,200,200
  200 JR=JR+1 
      TENJR=TENJR*10. 
    1 XR=TENJR
      TENJL=10.**JL 
      IF(ABS(XL-TENJL)-(TENJL*10.0E-4)) 2,2,300 
  300 IF(XL-TENJL) 400,400,2
  400 JL=JL-1 
      TENJL=TENJL*.1
    2 XL=TENJL
       NCX = JR-JL
       IF (NCX .LE. 5) RETURN 
       NCX = 5
      XL=10.**(JR-5)
      CALL SORTL (NP,X,Y,XL,X,0)
       RETURN 
       END
*DECK PLOT9 
      SUBROUTINE PLOT9(XMIN,XMAX,YMIN,YMAX, BNTT, TNAME,ITYPE,JHOL, 
     . NCX,JC,X1,Y1)
      DIMENSION BNTT(7),TNAME(12) 
      DIMENSION X1(1750),Y1(1750),OUT(101),X(400),Y(400),XOUT(11) 
      DATA BLANK/1H /,EYE/1HI/,DASH/1H-/,DOT/1H./,PLUS/1H+/ 
      DATA ONE/1H1/ 
 1    FORMAT(1H0,30X,7A10)
 2    FORMAT(5X,E10.3,6X,101A1) 
 3    FORMAT(31X,12A6)
 4    FORMAT(16X,11E10.3) 
      WRITE(6,22) 
 22   FORMAT(1H1) 
      JLOG=0
      IF(JHOL .EQ. 3 .OR. JHOL.EQ. 4) JLOG = 1
      IF(JLOG.LT. 1) GO TO 550
      XMAX = ALOG10(XMAX) 
      XMIN = ALOG10(XMIN) 
      DO 540 I=1,JC 
      X1(I) = ALOG10(X1(I)) 
  540 CONTINUE
  550 CONTINUE
C** 
      APL=YMAX-YMIN 
      IF(APL.EQ.0.) RETURN
      DELY=APL/54.
      APLX=XMAX-XMIN
      IF(APLX.EQ.0.) RETURN 
      DELX=APLX/100.
      DEL=APLX/10.
      IAX=(.5-XMIN/DELX)+1
      IF(JHOL.EQ.1) 
     .IAX = (.5 - (XMIN+ 180.)/DELX) + 1
      IAY=(.5+YMAX/DELY)+1
      IF(IAX.LE.0.OR.IAX.GT.101) IAX=0
      IF(IAY.LE.0.OR.IAY.GT.55) GO TO 500 
      YMAX=(IAY-1)*DELY 
 500  CONTINUE
      YMX=YMAX
      DELY2=DELY/2. 
      DELX2=DELX/2. 
      YM=YMAX+DELY2 
      N=0 
      JCC=JC
      JCD=JC/101
      JCR=JC-101*JCD
      IF(JCR.EQ.0) GO TO 505
      JCD=JCD+1 
 505  CONTINUE
      DO 9 I=1,JCC,JCD
      IF(N .EQ. 400) GO TO 9
      IF(X1(I).GT.XMAX.OR.X1(I).LT.XMIN) GO TO 9
      IF(Y1(I).GT.YM.OR.Y1(I).LT.YMIN) GO TO 9
      N=N+1 
      Y(N)=Y1(I)
      X(N)=X1(I)
      IF(400-N.LE.JC-I) GO TO 9 
      IF(I.EQ.JC) GO TO 9 
      XDIFF=X1(I+1)-X1(I) 
      YDIFF=Y1(I+1)-Y1(I) 
      J1=(ABS(YDIFF)+DELY2)/DELY-1
      J2=(ABS(XDIFF)+DELX2)/DELX-1
      IF(2*J2.GT.J1) GO TO 7
      IF(J1.LE.0) GO TO 9 
      DL=DELY 
      DX=ABS(XDIFF)/(J1+1)
 5    IF(YDIFF.LT.0.) DL=-DL
      IF(XDIFF.LT.0.) DX=-DX
      DO 6 II=1,J1
      IF (N.EQ.400) GO TO 9 
      N=N+1 
      Y(N)=Y(N-1)+DL
      X(N)=X(N-1)+DX
 6    CONTINUE
      GO TO 9 
 7    IF(J2.LE.0) GO TO 9 
      DL=ABS(YDIFF)/(J2+1)
      DX=DELX 
      J1=J2 
      GO TO 5 
 9    CONTINUE
C** 
      DO 10 I=1,11
      XOUT(I)=XMIN+(I-1)*DEL
      IF(JLOG.LT. 1) GO TO 699
      XOUT(I)= 10.**XOUT(I) 
  699 CONTINUE
 10   CONTINUE
      WRITE(6,1) (BNTT(I),I=1,7)
      WRITE(6,3) (TNAME(I),I=1,12)
C** 
      IY=0
      DO 100 J=1,55 
      DO 30 I=1,101 
 30   OUT(I)=BLANK
      YN=YM-DELY
      IF(IAX.EQ.0) GO TO 35 
      IA=IAX
      OUT(IA)=EYE 
      GO TO 36
 35   IA=1
 36   IY=IY+1 
      IF(IY.EQ.6) IY=0
      IF(IY.EQ.1) OUT(IA)=DASH
      IF(IAY.NE.J) GO TO 60 
      DO 50 I=1,101 
 50   OUT(I)=DASH 
      YMX=0.
      DO 58 I=1,N 
      IF(JLOG.LT. 1) GO TO 58 
      IF(I.EQ.1) GO TO 58 
      XLOGP = X(I-1)
      IXLP = XLOGP
      IF(IXLP .NE. -2) GO TO 58 
      XLOG= X(I)
      IXL = XLOG
      IF(IXLP .EQ.IXL) GO TO 58 
      IB = (.5+(X(I) - XMIN)/DELX) + 1
      IF(IB.LE.0 .OR. IB.GT. 101) GO TO 58
      OUT(IB) = ONE 
  58  CONTINUE
 60   CONTINUE
      IF(J.NE.55) GO TO 65
      DO 32 I=1,101,10
 32   OUT(I)=DOT
      DO 68 I=1,N 
      IF(JLOG.LT. 1) GO TO 68 
      IF(I.EQ.1) GO TO 68 
      XLOGP = X(I-1)
      IXLP = XLOGP
      XLOG= X(I)
      IXL = XLOG
      IF(XLOGP .LE. -1. .OR. XLOGP .GT. 0.0) GO TO 64 
      IF(XLOG.LT.0) GO TO 68
      GO TO 66
  64  CONTINUE
      IF(IXLP .EQ.IXL) GO TO 68 
  66  CONTINUE
      XVAL = X(I) 
      XVAL1 = IXLP
      IF(XLOGP.GT.0) XVAL1 = IXL
      XVAL2 = 10.**XLOGP
      XVAL3 = 10.**XLOG 
      XVAL4 = 10.**XVAL1
      IF( (ABS(XVAL2-XVAL4)) .LT. (ABS(XVAL3-XVAL4)) ) XVAL = X(I-1)
      IB = (.5+(XVAL - XMIN)/DELX) + 1
      IF(IB.LE.0 .OR. IB.GT. 101) GO TO 68
      OUT(IB) = ONE 
   68 CONTINUE
 65   CONTINUE
      DO 70 I=1,N 
      IF(Y(I).GT.YM.OR.Y(I).LE.YN) GO TO 70 
      IB=(.5+(X(I)-XMIN)/DELX)+1
      IF(IB.LE.0.OR.IB.GT.101) GO TO 70 
      OUT(IB)=PLUS
 70   CONTINUE
      WRITE(6,2) YMX,(OUT(I),I=1,101) 
      YMX=YMX-DELY
      YM=YM-DELY
 100  CONTINUE
      WRITE(6,4) (XOUT(I),I=1,11) 
      RETURN
      END 
*DECK PHASE 
      SUBROUTINE PHASE(V,X,NP)
      DIMENSION V(1750),X(1750) 
C** 
C**      THIS ROUTINE IS USED TO PRODUCE CONTINUOUS VALUES FOR PHASE
C** 
      IF(NP.LT.2) GO TO 100 
C** 
C**    NORMALIZE THE PHASE BETWEEN -180. AND +180. DEGREES
      DO 1 I=1,NP 
      IF(ABS(V(I)).LE. 180. ) GO TO 1 
      V(I) = PHNOM(V(I))
    1 CONTINUE
C)) 
      ICOUNT = 0
      ITRNS = 0 
      BIAS = 0.0
      DO 90 I=2,NP
C**     DTERMINE THE QUADRANT LOCATION OF THE ANGLE 
      IZERON = 0
      IZEROO = 0
      IF(ABS(V(  I)) .NE. 0.0) GO TO 5
      IQUADN = 1
      IZERON = 1
    5 CONTINUE
      IF(ABS(V(I-1)) .NE. 0.0) GO TO 10 
      IQUADO = 1
      IZEROO = 1
   10 CONTINUE
      IF(IZERON .GT. 0) GO TO 15
      IF(ABS(V(I)  ).LE.90. .AND. SIGN(1.0,V(I)  ).GT.0.) IQUADN = 1
      IF(ABS(V(I)  ).GT.90. .AND. SIGN(1.0,V(I)  ).GT.0.) IQUADN = 2
      IF(ABS(V(I)  ).GT.90. .AND. SIGN(1.0,V(I)  ).LT.0.) IQUADN = 3
      IF(ABS(V(I)  ).LE.90. .AND. SIGN(1.0,V(I)  ).LT.0.) IQUADN = 4
   15 CONTINUE
      IF(IZEROO .GT. 0) GO TO 20
      IF(ABS(V(I-1)).LE.90. .AND. SIGN(1.0,V(I-1)).GT.0.) IQUADO = 1
      IF(ABS(V(I-1)).GT.90. .AND. SIGN(1.0,V(I-1)).GT.0.) IQUADO = 2
      IF(ABS(V(I-1)).GT.90. .AND. SIGN(1.0,V(I-1)).LT.0.) IQUADO = 3
      IF(ABS(V(I-1)).LE.90. .AND. SIGN(1.0,V(I-1)).LT.0.) IQUADO = 4
   20 CONTINUE
C**    DETERMINE UPPER OR LOWER HALF PLANE
      IF(IQUADN.LT.3) IPLANE = 0
      IF(IQUADN.GT.2) IPLANE = 1
C**     CHECK FOR TRANSITIONS 
      ITRNS = 0 
      IF(IQUADO . EQ. 3 .AND. IQUADN .EQ. 2) ITRNS = 1
      IF(IQUADO . EQ. 2 .AND. IQUADN .EQ. 3) ITRNS = 2
      IF(IQUADO . EQ. 1 .AND. IQUADN .EQ. 4) ITRNS = 3
      IF(IQUADO . EQ. 4 .AND. IQUADN .EQ. 1) ITRNS = 4
C**     CALCULATE A BIAS TERM IF A TRANSITION WAS MADE
      IF(ITRNS.EQ. 0) GO TO 45
C** 
      IF(ITRNS .NE. 1) GO TO 25 
      BIAS = BIAS - 180.
      ICOUNT = ICOUNT - 1 
   25 CONTINUE
      IF(ITRNS .NE. 2) GO TO 30 
      BIAS = BIAS + 180.
      ICOUNT = ICOUNT + 1 
   30 CONTINUE
      IF(ITRNS.EQ. 3 .AND.ICOUNT .NE. 0) BIAS = BIAS - 180. 
      IF(ITRNS.EQ. 4 .AND.ICOUNT .NE. 0) BIAS = BIAS + 180. 
   45 CONTINUE
C** 
C**      CALCULATE THE DELTA VALUE
      IF(ICOUNT) 50,70,60 
   50 CONTINUE
      IF(IPLANE) 51,51,52 
   51 VAL = -(180. - V(I))
      GO TO 75
   52 VAL = V(I)
      GO TO 75
   60 CONTINUE
      IF(IPLANE) 61,61,62 
   61 VAL = V(I)
      GO TO 75
   62 VAL = 180. + V(I) 
      GO TO 75
   70 VAL = V(I)
   75 CONTINUE
C**      CALCULATE THE FINAL VALUE
      X(I) = VAL + BIAS 
   90 CONTINUE
  100 CONTINUE
      X(1)= V(1)
      RETURN
      END 
*DECK PHNOM 
      FUNCTION PHNOM(X) 
    7 IF ( X - 180.0 ) 4,4,5
    5 X = X - 360.0 
      GO TO 7 
    4 IF ( X + 180.0 ) 8,8,6
    8 X = X + 360.0 
      GO TO 4 
    6 PHNOM = X 
      RETURN
      END 
*DECK RPLOT 
      SUBROUTINE RPLOT(A,B,AR,AL,AB,AT,ITYPE,JHOL,JNDC,BCDNAM,MP) 
C 
C 
C 
C 
      DIMENSION A(1),B(1),TITLE(12,7),BCDX(12,7),BCDY(12,7),
     1            X(1750),Y(1750) 
      COMMON /PLOT/ IPLOT,IFREQR(2),XMAX(7),XMIN(7),YMAX(7),YMIN(7) 
C**   THE FOLLOWING DATA HAVE BEEN DEFINED IN THE MAIN PROGRAM    **
C**   DATA XMIN/-1000.0,-200.0,1.0,1.0,-200.0,0.0,0.0/
C**   DATA XMAX/1000.0,200.0,1.0E10,1.0E10,200.0,1.0E10,1.0E6/
C**   DATA YMIN/-200.0,-20.0,-200.0,-1000.0,-200.0,-1.0E38,-1.0E38/ 
C**   DATA YMAX/200.0,20.0,200.0,1000.0,200.0,1.0E38,1.0E38/
C**   A   THE ARRAY OF ABSCISSA POINT TO BE PLOTTED 
C**   B   THE ARRAY OF ORDINATE POINTS TO BE PLOTTED
C**   AR  THE RIGHT ABSCISSA LIMIT,IF AR=-1 THE LIMIT WILL BE THE 
C**       LARGEST VALUE IN THE A ARRAY
C**   AL  SIMILAR TO AR FOR THE LEFT ABSCISSA 
C**   AB  SIMOLAR TO AR FOR BOTTOM ORDINATE 
C**   AT  SIMILAR TO AR FOR TOP ORDINATE
C**   ITYPE    0 ABSCISSA AND ORDINATE SCALESA% IDENTICAL & LINEAR
C**              1 BOTH SCALES% LINEAR
C**            2 ABSCISSA SCALE% LOG , ORDINATE% LINEAR 
C**            3 ABSCISSA SCALE% LINEAR, ORDINATE% LOG
C**            4 BOTH SCALES% LOG 
C**   JHOL   1  GAIN-PHASE PLOT 
C**          2  NYQUIST (POLAR) PLOT
C**          3  BODE GAIN PLOT
C**          4  BODE PHASE PLOT 
C**          5  ROOT LOCUS PLOT 
C**          6  TIME RESPONSE PLOT% CONTINUOUS SYSTEM 
C**          7  TIME RESPONSE PLOT% SAMPLED DATA SYSTEM 
C**          8 GAIN-PHASE PLOT% DESCRIBING FUNCTION 
C**   JNDC       PLOT CHARACTER TO BE USED WHEN JHOL=5 0R 8,
C**              OTHERWISW AN ASTERISK (*) IS USED
C**   BCDNAME    VARIABLE NAME OF 9 WORD ARRAY, WILL BE WRIITEN 
C**              AT THE TOP OF THE FRAME
C**   MP    NUMBER OF POINT (STORED IN A  P & B) TO BE PLOTTED
C 
C 
C 
      DATA XMIN/-1000.0,-200.0,1.0,1.0,-200.0,0.0,0.0/
      DATA XMAX/1000.,20.,1.E10,1.E10,200.,1.E10,1.E6/
      DATA YMIN/-200.,-20.,-200.,-1000.,-200.,-1.E38,-1.E38/
      DATA YMAX/200.,20.,200.,1000.,200.,1.E38,1.E38/ 
      DATA (TITLE(I,1),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     1 6H      ,6H      ,6H      ,6H      ,6HGAIN -,6H PHASE,6H PLOT ,
     2 6H      /
      DATA (TITLE(I,2),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     1 6H      ,6H      ,6H      ,6H      ,6HNYQUIS,6HT (POL,6HAR) PL,
     2 6HOT    /
      DATA (TITLE(I,3),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     1 6H      ,6H      ,6H      ,6H      ,6H    BO,6HDE GAI,6HN     ,
     2 6H      /
      DATA (TITLE(I,4),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     1 6H      ,6H      ,6H      ,6H      ,6H    BO,6HDE PHA,6HSE    ,
     2 6H      /
      DATA (TITLE(I,5),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     1 6H      ,6H      ,6H      ,6H    RO,6HOT LOC,6HUS    ,6H      ,
     2 6H      /
      DATA (TITLE(I,6),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     *4*1H ,6H TIME ,6HRESPON,2HSE,1H / 
      DATA (TITLE(I,7),I=1,12)/6H      ,6H      ,6H      ,6H      , 
     *4*1H ,6H TIME ,6HRESPON,2HSE,1H / 
C 
      DATA (BCDX(I,1),I=1,12)/6HPHASE ,6H- DEG.,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDX(I,2),I=1,12)/6HX     ,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDX(I,3),I=1,12)/6HFREQUE,6HNCY, R,6HAD. / ,6HSEC.  ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDX(I,4),I=1,12)/6HFREQUE,6HNCY, R,6HAD. / ,6HSEC.  ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDX(I,5),I=1,12)/6HREAL  ,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA(BCDX(I,6),I=1,12)/5HTIME,,4HSEC.,10*1H / 
      DATA (BCDX(I,7),I=1,12)/6H     N,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
C 
      DATA (BCDY(I,1),I=1,12)/6HGAIN -,6H DBS  ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,2),I=1,12)/6HY     ,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,3),I=1,12)/6HGAIN -,6H DBS  ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,4),I=1,12)/6HPHASE ,6H- DEG.,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,5),I=1,12)/6HIMAGIN,6HARY   ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,6),I=1,12)/6HF OF T,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
      DATA (BCDY(I,7),I=1,12)/6HF OF N,6H      ,6H      ,6H      ,
     1 6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,6H      ,
     2 6H      /
C 
C** 
C 
      IF(JHOL.GE.8)GO TO 31 
      IHOL=JHOL 
      IF(IHOL.EQ.5)GO TO 33 
      INDC=1H*
      GO TO 32
   31 IHOL=1
   33 INDC=JNDC 
   32 CONTINUE
      AL = -1.
      AR = -1.
      AB = -1.
      AT = -1.
       NP = MP
       XR = AR
       XL = AL
       YB = AB
       YT = AT
      IF(NP.LT.1) GO TO 1 
      DO 13 I = 1,NP
      X(I) = A(I) 
   13  Y(I) = B(I)
      IF(JHOL.EQ.1) CALL PHASE(A,X,NP)
      IF(JHOL.EQ.4) CALL PHASE(B,Y,NP)
C 
C 
C 
  1   CONTINUE
      IN = 0
      IF(XR.EQ.-1.) GO TO 10
    5 CONTINUE
      CALL SORTL (NP,X,Y,XR,X,1)
      IF(IN .EQ. 0) GO TO 15
   10 CONTINUE
      CALL SCAL (2,NP,X,XR,XMAX(IHOL),IN) 
       IF (IN .NE. 0) GO TO 5 
C 
   15 CONTINUE
      IN = 0
      IF( XL.EQ. -1.) GO TO 25
   20 CONTINUE
      CALL SORTL (NP,X,Y,XL,X,0)
      IF( IN .EQ. 0) GO TO 30 
   25 CONTINUE
       CALL SCAL (1,NP,X,XL,XMIN(IHOL),IN)
       IF (IN .NE. 0) GO TO 20
C 
   30 CONTINUE
      IN = 0
      IF(YB .EQ. -1.) GO TO 40
   35 CONTINUE
      CALL SORTL  (NP,X,Y,YB,Y,0) 
      IF( IN .EQ. 0) GO TO 45 
   40 CONTINUE
       CALL SCAL (1,NP,Y,YB,YMIN(IHOL),IN)
      IF(IN .NE. 0) GO TO 35
C 
   45 CONTINUE
      IN = 0
      IF( YT .EQ. -1.) GO TO 55 
   50 CONTINUE
      CALL SORTL  (NP,X,Y,YT,Y,1) 
      IF( IN .EQ. 0) GO TO 60 
   55 CONTINUE
       CALL SCAL (2,NP,Y,YT,YMAX(IHOL),IN)
       IF (IN .NE. 0) GO TO 50
C 
   60 IF (ITYPE.GT.0) GO TO (110,200,300,400),ITYPE 
      IF (XR-YT) 2,7,3
    2 XR=YT 
      GO TO 7 
    3 YT=XR 
    7 IF (XL-YB) 4,110,6
    4 YB=XL 
      GO TO 110 
    6 XL=YB 
C 
C 
  110 CONTINUE
         GO TO 100
C 
  200  CALL CYCLE (XL,XR,NCX,X,Y,NP)
       CALL SCAL (1,NP,Y,YB,YMIN(IHOL),IN)
       CALL SCAL (2,NP,Y,YT,YMAX(IHOL),IN)
         GO TO 100
C 
  300  CALL CYCLE (YB,YT,NCY,X,Y,NP)
         GO TO 100
C 
  400  CALL CYCLE (XL,XR,NCX,X,Y,NP)
       CALL CYCLE (YB,YT,NCY,X,Y,NP)
C 
  100 CONTINUE
      CALL PLOT9(XL,XR,YB,YT,BCDNAM,TITLE(1,IHOL),ITYPE,JHOL,NCX, 
     . NP,X,Y)
C 
  500 CONTINUE
  600 CONTINUE
      RETURN
       END
*DECK SCAL
       SUBROUTINE SCAL (KEY,NP,X,XLIMIT,Q,IN) 
C 
C        IF KEY = 1, ROUTINE WILL FIND MINIMUM VALUE IN AN ARRAY OF 
C        NP POINTS.  IF KEY = 2, THE MAXIMUM VALUE WILL BE FOUND
C 
       DIMENSION X(1) 
       IN = 0 
         XLIMIT = X(1)
      IF(KEY .EQ. 2) GO TO 15 
      IF(NP.LT.2) GO TO 11
      DO 10 K=2,NP
      IF(XLIMIT.GT.X(K))XLIMIT=X(K) 
   10 CONTINUE
   11 CONTINUE
      IF(XLIMIT-Q .GE. 0) GO TO 400 
      GO TO 300 
C** 
   15 CONTINUE
      IF(NP.LT.2) GO TO 21
      DO 20 K=2,NP
      IF(XLIMIT.LT.X(K))XLIMIT=X(K) 
   20 CONTINUE
   21 CONTINUE
      IF(XLIMIT-Q .LE. 0) GO TO 400 
C** 
  300  XLIMIT = Q 
       IN = 1 
  400 RETURN
         END
*DECK SORTL 
       SUBROUTINE SORTL  (NP,X,Y,ALIMIT,D,INDC) 
C 
C        IF INDC = 0, SUBROUTINE WILL THROW OUT ALL VALUES IN AN
C        ARRAY LESS THAN SOME LIMIT, COMPACT THE ARRAY, AND COMPUTE 
C        THE NEW ARRAY SIZE.
C 
C        IF INDC IS NOT = 0, SUBROUTINE WILL THROW OUT ALL VALUES 
C        IN AN ARRAY GREATER THAN SOME LIMIT, COMPACT THE ARRAY, AND
C        COMPUTE THE NEW ARRAY SIZE.
C 
      DIMENSION D(1),X(1),Y(1)
         INDEX = 0
      IF(NP.LE.0)GO TO 21 
      DO 20 I=1,NP
      IF(INDC .EQ. 0) GO TO 5 
      IF(D(I) - ALIMIT  .GT. 0.0) GO TO 20
      GO TO 10
    5 CONTINUE
      IF(D(I)- ALIMIT  .LT. 0.0) GO TO 20 
   10    INDEX = INDEX + 1
      X(INDEX)=X(I) 
      Y(INDEX)=Y(I) 
   20    CONTINUE 
   21 NP=INDEX
      RETURN
      END 
