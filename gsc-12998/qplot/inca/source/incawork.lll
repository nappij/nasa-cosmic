UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                   2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:IO',
00004      0  0                'QLIBHOME:MATH',
00005      0  0                'QLIBHOME:COMPLEX',
00006      0  0                'QLIBHOME:STRING',
00007      0  0                'QLIBHOME:FIG',
00008      0  0                'QLIBHOME:PLOT',
00009      0  0                'FCN','FCNIO'),
00010      0  0   ENVIRONMENT ('UTIL')]
00011      0  0 MODULE util;
00012   C  0  0 {=============================================================================}
00013      0  0 CONST
00014      0  0    VERSION_NUMBER  = 3.10;
00015      0  0    INCAVERSION     = 'INCA Vers 3.13 -- December 2, 1988';
00016      0  0 TYPE
00017      0  0    freqplot_type   = (mag,pha,nyq,nic,pop,bod,bmp);
00018      0  0    freqformat_type = RECORD
00019      0  0                      freqplot  : freqplot_type;
00020      0  0                      db        : boolean;
00021      0  0                      hz        : boolean;
00022      0  0                      flog      : boolean;
00023      0  0                      END;
00024      0  0 VAR
00025      0  0    havehandler     : boolean  := true;
00026      0  0    startclock      : integer  := 0;
00027      0  0    curvecolormax   : integer  := 0;          { Maximum number of curve colors}
00028      0  0 
00029      0  0    searchcircle    : integer  := 4096;
00030      0  0    boundarygrid    : boolean  := true;
00031      0  0    toprightlable   : boolean  := false;
00032      0  0    showlogo        : boolean  := true;
00033      0  0    defaulteditformat: char    := 'R';
00034      0  0    defaultfreqformat: freqformat_type := (bod,true,false,true);
00035      0  0    wrapping        : real     := 0;
00036      0  0    zagging         : real     := 40;
00037   C  0  0 {=============================================================================}
00038   C  0  0 {-- INCA SPECIFIC CONVERSION FUNCTIONS ---------------------------------------}
00039   C  0  0 {=============================================================================}
00040      1  0 FUNCTION C_colorofi (i : integer) : color_type;
00041      1  1 BEGIN
00042      1  1 C_colorofi := 'C' + strofi ((i-1) MOD curvecolormax + 1,0);
00043      0  0 END;
00044   C  0  0 {-----------------------------------------------------------------------------}
00045      1  0 FUNCTION T_colorofi (i : integer) : color_type;
00046      1  1 BEGIN
00047      1  1 T_colorofi := 'T' + strofi (i,0);
00048      0  0 END;
00049   C  0  0 {-----------------------------------------------------------------------------}
00050      1  0 FUNCTION stroffreqplot (fp : freqplot_type) : anystring;
00051      1  1 BEGIN
00052      1  2 CASE fp OF
00053      1  2    mag:  stroffreqplot := 'MAGNITUDE';
00054      1  2    pha:  stroffreqplot := 'PHASE';
00055      1  2    nyq:  stroffreqplot := 'NYQUIST';

UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                   2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

-LINE-IDC-PL-SL-

00056      1  2    nic:  stroffreqplot := 'NICHOLS';
00057      1  2    pop:  stroffreqplot := 'POPOV';
00058      1  2    bod:  stroffreqplot := 'BODE';
00059      1  2    bmp:  stroffreqplot := 'STRIP_BODE';
00060      1  1    END;
00061      0  0 END;
00062   C  0  0 {-----------------------------------------------------------------------------}
00063      1  0 FUNCTION freqplotofch (ch : char) : freqplot_type;
00064      1  1 BEGIN
00065      1  2 CASE ch OF
00066      1  2    'M':  freqplotofch  := mag;
00067      1  2    'N':  freqplotofch  := nyq;
00068      1  2    'P':  freqplotofch  := pha;
00069      1  2    'C':  freqplotofch  := nic;
00070      1  2    'V':  freqplotofch  := pop;
00071      1  2    'B':  freqplotofch  := bod;
00072      1  2    'S':  freqplotofch  := bmp;
00073      1  1    END;
00074      0  0 END;
00075   C  0  0 {=============================================================================}
00076   C  0  0 {-- INCA SPECIFIC GRAPHICS PROCEDURES ----------------------------------------}
00077   C  0  0 {=============================================================================}
00078      1  0 PROCEDURE plotroot (fr : framelink;  factor : complex;  order : integer);
00079      1  0 VAR
00080      1  0    ipt : ipoint;
00081      1  1 BEGIN
00082      1  1 ipt := scale (convert (pointofr (fr,-factor.re,-factor.im)));
00083      1  1 IF inside (fr,ipt)
00084      1  1  THEN
00085      1  2   BEGIN
00086      1  2   position (ipt.ix,ipt.iy);
00087      1  2   IF order > 0
00088      1  2    THEN
00089      1  3     BEGIN
00090      1  3     setcolor ('ZERO');
00091      1  3     moveto (-256,-128);
00092      1  3     drawto (128,-128);  drawto (256,0);   
00093      1  3     drawto (128,128);   drawto (0,256);
00094      1  3     drawto (-128,128);  drawto (-256,0);  
00095      1  3     drawto (-128,-128); drawto (0,-256);
00096      1  3     END
00097      1  2    ELSE
00098      1  3     BEGIN
00099      1  3     setcolor ('POLE');
00100      1  3     moveto (-256,256);  drawto (512,-512);  
00101      1  3     moveto (-512,0);    drawto (512,512);
00102      1  2     END;
00103      1  2   position (ipt.ix,ipt.iy);
00104      1  2   moveto (300,300);
00105      1  2   IF abs(order) > 10
00106      1  2    THEN grprint (strofi(abs(order),2))
00107      1  2   ELSE IF abs(order) > 1
00108      1  2    THEN grprint (strofi(abs(order),1));
00109      1  1   END;
00110      0  0 END;

UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                   2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

-LINE-IDC-PL-SL-

00111   C  0  0 {-----------------------------------------------------------------------------}
00112      1  0 PROCEDURE writegraffcn (VAR fn : fcn);
00113      1  1 BEGIN
00114      1  1 rewrite (tempfile);
00115      1  1 writefcn (temp,fn,'G');
00116      1  1 grprinttempfile;
00117      0  0 END;
00118   C  0  0 {-----------------------------------------------------------------------------}
00119      1  0 PROCEDURE incalogo (ix,iy,scale : integer);
00120   C  1  0 {---------------------------------}
00121      2  0 PROCEDURE p (x,y : real);
00122      2  1 BEGIN
00123      2  1 position (ix + round(x*scale), iy + round((y-40)*scale));
00124      1  0 END;
00125   C  1  0 {---------------------------------}
00126      2  0 PROCEDURE d (x,y : real);
00127      2  1 BEGIN
00128      2  1 draw (ix + round(x*scale), iy + round((y-40)*scale));
00129      1  0 END;
00130   C  1  0 {---------------------------------}
00131      1  1 BEGIN
00132      1  1 IF showlogo 
00133      1  1  THEN
00134      1  2   BEGIN
00135      1  2   openpanel ('LOGOFILL','LOGOEDGE');
00136      1  2   p(0,0);   d(0,40);  d(75,40); d(75,0);  d(0,0);
00137      1  2   closepanel;
00138      1  2 
00139   C  1  2   { I }
00140      1  2   openpanel ('BLACK','LOGOEDGE');
00141      1  2   p(3,3);   d(3,37);  d(7,37);  d(7,3);   d(3,3);
00142      1  2   closepanel;
00143   C  1  2   { N }
00144      1  2   openpanel ('BLACK','LOGOEDGE');
00145      1  2   p(13,3);  d(13,37); d(16,37); d(28,13); d(28,37); d(32,37); d(32,3);
00146      1  2             d(29,3);  d(17,27); d(17,3);  d(13,3);
00147      1  2   closepanel;
00148   C  1  2   { C }
00149      1  2   openpanel ('BLACK','LOGOEDGE');
00150      1  2   p(38,3);  d(38,37); d(63,37); d(56,23); d(52,23); d(57,33); d(42,33);
00151      1  2             d(42,7);  d(44,7);  d(49,17); d(53,17); d(46,3);  d(38,3);
00152      1  2   closepanel;
00153   C  1  2   { A }
00154      1  2   openpanel ('BLACK','LOGOEDGE');
00155      1  2   p(52,3);  d(69,37); d(72,37); d(72,3);  d(68,3);  d(68,13); d(61,13);
00156      1  2             d(56,3);  d(52,3); 
00157      1  2   closepanel;
00158      1  2   openpanel ('LOGOFILL','LOGOEDGE');
00159      1  2   p(63,17); d(68,27); d(68,17); d(63,17);
00160      1  2   closepanel;
00161      1  2 
00162      1  2   setcolor ('LOGOLINE');
00163   C  1  2   { I }
00164      1  2   p(5,5);   d(5,35);
00165   C  1  2   { N }

UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                   2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

-LINE-IDC-PL-SL-

00166      1  2   p(15,5);  d(15,35); d(30,5);  d(30,35);
00167   C  1  2   { C }
00168      1  2   p(50,15); d(45,5);  d(40,5);  d(40,35); d(60,35); d(55,25);
00169   C  1  2   { A }
00170      1  2   p(55,5);  d(70,35); d(70,5);  
00171      1  2   p(60,15); d(70,15);
00172      1  2   finplot;
00173      1  1   END;
00174      0  0 END;
00175   C  0  0 {-----------------------------------------------------------------------------}
00176      1  0 PROCEDURE newlogo (ix,iy,scale : integer);
00177   C  1  0 {---------------------------------}
00178      2  0 PROCEDURE p (x,y : real);
00179      2  1 BEGIN
00180      2  1 position (ix + round(x*scale), iy + round((y-40)*scale));
00181      1  0 END;
00182   C  1  0 {---------------------------------}
00183      2  0 PROCEDURE d (x,y : real);
00184      2  1 BEGIN
00185      2  1 draw (ix + round(x*scale), iy + round((y-40)*scale));
00186      1  0 END;
00187   C  1  0 {---------------------------------}
00188      1  1 BEGIN
00189      1  1 IF showlogo AND (config.resolution < 220)
00190      1  1  THEN
00191      1  2   BEGIN
00192   C  1  2   { NEW }
00193      1  2   openpanel ('BLUE','WHITE');
00194      1  2   p (94,33);  d(104,53);  d(60,75);  d(50,55);  d(94,33);
00195      1  2   closepanel;
00196      1  2 
00197   C  1  2   {N}
00198      1  2   openpanel ('BLINK RED','WHITE');
00199      1  2   p (56,57);   d(62,69);  d(64,68);  d(64,58);  d(68,66);
00200      1  2                d(70,65);  d(64,53);  d(62,54);  d(62,64);
00201      1  2                d(58,56);  d(56,57);
00202      1  2   closepanel;
00203      1  2 
00204   C  1  2   {E}
00205      1  2   openpanel ('BLINK RED','WHITE');
00206      1  2   p (68,51);   d(74,63);   d(82,59);   d(81,57);   d(75,60);
00207      1  2                d(73.5,57); d(77.5,55); d(76.5,53); d(72.5,55);
00208      1  2                d(71,52);   d(77,49);   d(76,47);   d(68,51);
00209      1  2   closepanel;
00210      1  2 
00211   C  1  2   {W}
00212      1  2   openpanel ('BLINK RED','WHITE');
00213      1  2   p (82,44);   d(86,57);  d(88,56);  d(85,47);  d(92,54);
00214      1  2                d(91,45);  d(96,52);  d(98,51);  d(90,40);
00215      1  2                d(88,41);  d(89,48);  d(84,43);  d(82,44);
00216      1  2   closepanel;
00217      1  2   finplot;
00218      1  1   END;
00219      0  0 END;
00220   C  0  0 {-----------------------------------------------------------------------------}

UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                   2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

-LINE-IDC-PL-SL-

00221      1  0 PROCEDURE tagplot;
00222      1  0 VAR
00223      1  0    scale : integer;
00224      1  1 BEGIN
00225      1  1 position (imax (0,65535-config.ch.width*40),49152);
00226      1  1 newline;
00227      1  1 setcolor ('TIME');
00228      1  1 timeprint;
00229      1  1 newline;
00230      1  1 setcolor ('PROJECT');
00231      1  1 grprint ('Project: ' + project);
00232      1  1 scale := imax(config.resolution,64);
00233      1  1 IF config.resolution < 200 THEN incalogo (1000, 760*64, scale);
00234      0  0 END;
00235   C  0  0 {=============================================================================}
00236   C  0  0 {-- MISCELLANEOUS PROCEDURES -------------------------------------------------}
00237   C  0  0 {=============================================================================}
00238      1  0 PROCEDURE fcncalclimits (VAR lim : plotlimits;  VAR fn : fcn;  window : real);
00239      1  0 VAR
00240      1  0    i : integer;
00241      1  1 BEGIN
00242      1  1 IF fn.ro.deg = 0
00243      1  1  THEN lim := plotlimits ((-1,-1),(1,1))
00244      1  1  ELSE lim := plotlimits ((0,0),(0,0));
00245      1  1 FOR i := 1 TO fn.ro.deg DO
00246      1  1    WITH fn.ro.f[i] DO
00247      1  2       BEGIN
00248      1  2       broadenxy (lim, -v.re, -v.im);
00249      1  2       broadenxy (lim, -v.re, +v.im);
00250      1  1       END;
00251      1  1 samescale (lim);
00252      1  1 expandlimits (lim,window);
00253      0  0 END;
00254   C  0  0 {-----------------------------------------------------------------------------}
00255      1  0 PROCEDURE revfcn (prompt : VARYING [l1] OF char;  VAR fn : fcn;
00256      1  0    VAR str : VARYING [l3] OF char;  planes : anystring;  
00257      1  0        def : VARYING [l5] OF char);
00258      1  1 BEGIN
00259      1  2 REPEAT
00260      1  2    readvary (prompt,str,def);
00261      1  2    fn := evalfcn (str);
00262      1  2    IF index (planes,fn.plane) = 0
00263      1  2     THEN writeline (out,'Function must be in "' + planes + '".');
00264      1  1    UNTIL index (planes,fn.plane) <> 0;
00265      0  0 END;
00266   C  0  0 {=============================================================================}
00267      0  0 END.

UTIL                                                            23-Dec-1988 10:53:39    VAX Pascal V3.7-254                Page    6
INCA                            Pascal Compilation Statistics    2-Dec-1988 15:16:22    DUA1:[QPLOT.INCA.SOURCE]UTIL.PAS;311 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                7066  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                                 40  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        35        28
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        57        28
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         3         5
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         4         6
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72         8        11
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213       116        54
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292       106        36
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        80        32
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        67        36



CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    1
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('CONVERT'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:STRING',
00004      0  0                'QLIBHOME:DIRECTORY',
00005      0  0                'QLIBHOME:HANDLER',
00006      0  0                'QLIBHOME:IO',
00007      0  0                'QLIBHOME:MATH',
00008      0  0                'QLIBHOME:IOBASE',
00009      0  0                'POLYMATH','OLDFCN','UTIL','FCN'),
00010      0  0   ENVIRONMENT ('CONVERT') ]
00011      0  0 MODULE convert;
00012      0  0 CONST
00013      0  0    DASHS    = 
00014      0  0 '------------------------------------------------------------------------------';
00015      0  0    BLANK    = '  ';
00016      0  0    CTABLEN  = 18;
00017      0  0    NAMESIZE = 30;
00018      0  0 TYPE
00019      0  0    var80    = VARYING[80] OF char;
00020      0  0    var4     = VARYING[4]  OF char;
00021      0  0 VAR
00022      0  0    i                    : integer;
00023      0  0    ch                   : char;
00024      0  0    tempext              : var4;
00025      0  0    newfile              : TEXT;
00026      0  0    newname,namestr,line : anystring;
00027      0  0    storstr,commstr,str  : anystring;
00028      0  0    datestr,filename     : anystring;
00029      0  0    nomoredata,noconvert : boolean;
00030      0  0    doall,all            : boolean;
00031   C  0  0 {------------------------------------------------------------------------------}
00032      1  0 FUNCTION striphead(st : anystring) : anystring;
00033      1  0 VAR                    { look at this proc }  
00034      1  0    i   : integer;      { should be better  }
00035      1  1 BEGIN
00036      1  1 i := 1;
00037      1  1 IF st <> ''
00038      1  1   THEN
00039      1  1     WHILE (st[i] = ' ') AND (i <= length(st)) DO
00040      1  1       i := succ(i);
00041      1  1 striphead := substr(st,i-1,length(st));
00042      0  0 END;
00043   C  0  0 {------------------------------------------------------------------------------}
00044      1  0 PROCEDURE alldo(VAR tempext : var4);
00045      1  1 BEGIN
00046      1  1 doall := false;
00047      1  1 IF all THEN doall := true;
00048      1  1   IF NOT all 
00049      1  1     THEN 
00050      1  2       BEGIN
00051      1  2       writeline(out, '');
00052      1  2       writeline(out, 'Do you wish to convert all of the '+ tempext +' files (Y/N)?');
00053      1  2       readch('ENTER : ',ch,'YyNn',' ');
00054      1  2       writeline(out, '');
00055      1  2       IF (ch = 'Y') OR (ch = 'y') THEN doall := true;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    2
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00056      1  1       END;
00057      0  0 END;
00058   C  0  0 {------------------------------------------------------------------------------}
00059      1  0 PROCEDURE convertno(VAR tempext : var4);
00060      1  1 BEGIN
00061      1  1 noconvert := false;
00062      1  1 IF not doall
00063      1  1  THEN 
00064      1  2   BEGIN
00065      1  2   clearscreen;
00066      1  2   writeline(out, '');
00067      1  2   writeline(out, 'CONVERT ' + tempext + ' FILES');
00068      1  2   writeline(out, '');
00069      1  2   writeline(out,'');
00070      1  2   writeline(out, 'Do you want ' + fs.name + tempext + ' converted?');
00071      1  2   readch('ENTER : ',ch,'YyNn',' ');
00072      1  2   writeline(out, '');
00073      1  2   IF (ch = 'N') OR (ch = 'n') THEN noconvert := true;
00074      1  1   END;
00075      0  0 END;
00076   C  0  0 {------------------------------------------------------------------------------}
00077      1  0 PROCEDURE Convert_WOR_To_PRO;
00078      1  0 TYPE
00079      1  0    patype = PACKED ARRAY [1..size(fcn)] OF char;
00080      1  0    v_type = VARYING [size(fcn)] OF char;
00081      1  0 VAR
00082      1  0    old    : oldfcn;
00083      1  0    fn     : fcn;
00084      1  0    v      : v_type;
00085      1  0    fun    : fcn;
00086   C  1  0 {------------------------------------------}
00087      2  0 PROCEDURE movefcn (VAR fn1,fn2 : fcn);
00088      2  0 TYPE
00089      2  0    byteblock = ARRAY [1..size(fcn)] OF char;
00090      2  0 VAR
00091      2  0    i         : integer;
00092      2  1 BEGIN
00093      2  1 FOR i := 1 TO fn1.storage DO
00094      2  1    fn2::byteblock[i] := fn1::byteblock[i];
00095      1  0 END;
00096   C  1  0 {------------------------------------------}
00097      1  1 BEGIN
00098      1  1 clearscreen;
00099      1  1 tempext := '.WOR';
00100      1  1 startfilesearch('*.WOR');
00101      1  1 IF NOT endoffilesearch 
00102      1  1    THEN
00103      1  2       BEGIN
00104      1  2       writeline(both, '');
00105      1  2       writeline(both, 'CONVERT .WOR FILES TO .PRO FILES');
00106      1  2       writeline(both, '');
00107      1  2       alldo(tempext);
00108      1  2       END
00109      1  1    ELSE
00110      1  2        BEGIN

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    3
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00111      1  2        writeline(out, 'No .WOR files found.');
00112      1  2        IF NOT all THEN pause;
00113      1  1        END;
00114      1  1  WHILE NOT endoffilesearch DO
00115      1  2    BEGIN
00116      1  2    filesearch (line);
00117      1  2    convertno(tempext);
00118      1  2    IF NOT noconvert 
00119      1  2      THEN
00120      1  3        BEGIN
00121      1  3        filename := fs.name + '.WOR';
00122      1  3        close (fcnfile,ERROR:=CONTINUE);
00123      1  3        open (fcnfile,filename,OLD);
00124      1  3        reset (fcnfile);
00125      1  3        close (textfile,ERROR:=CONTINUE);
00126      1  3        filename := fs.name + '.PRO';
00127      1  3        open (textfile,filename,NEW,size(fcn));
00128      1  3        rewrite (textfile);
00129      1  3        WHILE NOT eof (fcnfile) DO
00130      1  4          BEGIN
00131      1  4          read (fcnfile,old);
00132      1  4          fn := fcnofoldfcn (old);
00133      1  4          v.length := fn.storage;
00134      1  4          movefcn (fn,v.body::fcn);
00135      1  4          writeln (textfile,v);
00136      1  3          END;
00137      1  3       close (fcnfile);
00138      1  3       close (textfile);
00139      1  3       writeline (both, '');
00140      1  3       writeline (both, 'The file ' + fs.name + ' has been converted to a .PRO file.');
00141      1  3       writeline (both, '');
00142      1  3       END
00143      1  1   END;
00144      0  0 END;
00145   C  0  0 {-----------------------------------------------------------------------------}
00146      1  0 PROCEDURE getstr(VAR str : anystring);
00147      1  1 BEGIN
00148      1  1 nomoredata := false;
00149      1  1 IF NOT eof(textfile)
00150      1  1    THEN readln(textfile,str)
00151      1  1    ELSE nomoredata := true;
00152      0  0 END;
00153   C  0  0 {------------------------------------------------------------------------------}
00154      1  0 PROCEDURE checkinfinity(VAR str : anystring);
00155      1  0 VAR
00156      1  0    y        : integer;
00157      1  0    epos     : integer;
00158      1  0    checkstr : VARYING[3] OF char;
00159      1  0    threestr : VARYING[3] OF char;
00160      1  1 BEGIN
00161      1  1 IF NOT nomoredata
00162      1  1   THEN
00163      1  2     BEGIN
00164      1  2     checkstr := '+05';
00165      1  2     y := 1;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    4
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00166      1  2     epos := 0;
00167      1  2     IF index(str,'E+05') <> 0
00168      1  2      THEN
00169      1  3        BEGIN
00170      1  3        WHILE epos < 2 DO
00171      1  3          IF str[y] <> 'E'
00172      1  3            THEN y := y + 1
00173      1  4            ELSE BEGIN
00174      1  4                 y := y + 1;
00175      1  4                 epos := epos + 1;
00176      1  3                 END;       
00177      1  3        threestr := substr(str,y,3);
00178      1  3        IF checkstr = threestr
00179      1  3          THEN str[y+2] := '7';
00180      1  2        END;
00181      1  1     END;
00182      0  0 END;
00183   C  0  0 {------------------------------------------------------------------------------}
00184      1  0 PROCEDURE GETSTORAGE;
00185      1  0 VAR
00186      1  0    count    : integer;
00187      1  0    norepeat : integer;
00188      1  1 BEGIN
00189      1  1 count := 0;
00190      1  1 FOR i := 1 TO 2 DO
00191      1  2    BEGIN
00192      1  2    WHILE str <> '' DO
00193      1  3       BEGIN
00194      1  3       norepeat := index (str,'- j');
00195      1  3       IF norepeat = 0 THEN count := succ(count);
00196      1  3       getstr(str);
00197      1  2       END;
00198      1  2    getstr(str);
00199      1  2    getstr(str);
00200      1  1    END;
00201      1  1 count   := size(fcn,FCT) - (MAXDEG - count) * size(cspolyfactor);
00202      1  1 storstr := 'Storage requirement            ' + strofi(count,6);
00203      0  0 END; 
00204   C  0  0 {------------------------------------------------------------------------------}
00205      1  0 PROCEDURE stripdate(VAR datestr : anystring);
00206      1  0 VAR
00207      1  0    tempstr : VARYING[255] OF char;
00208      1  1 BEGIN
00209      1  1 tempstr := '';
00210      1  1 tempstr := substr (datestr,32,24);
00211      1  1 datestr := 'Function last modified on      ' + tempstr;
00212      0  0 END;
00213   C  0  0 {------------------------------------------------------------------------------}
00214      1  0 PROCEDURE Setstrs;
00215      1  1 BEGIN
00216      1  1 namestr := str;
00217      1  1 FOR i:= 1 TO 3 DO
00218      1  1    getstr(datestr);
00219      1  1 stripdate(datestr);
00220      1  1 FOR i := 1 TO 4 DO

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    5
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00221      1  1    getstr(commstr);
00222      1  1 FOR i := 1 TO 7 DO
00223      1  1   getstr(str);
00224      1  1 getstorage;
00225      0  0 END;
00226   C  0  0 {------------------------------------------------------------------------------}
00227      1  0 PROCEDURE Writestrs;
00228      1  1 BEGIN
00229      1  1 writeln(newfile,namestr);
00230      1  1 writeln(newfile,storstr);
00231      1  1 writeln(newfile,datestr);
00232      1  1 writeln(newfile,commstr);
00233      1  1 writeln(newfile,BLANK);
00234      0  0 END;
00235   C  0  0 {------------------------------------------------------------------------------}
00236      1  0 PROCEDURE Writefactors;
00237      1  1 BEGIN
00238      1  1 WHILE (str <> DASHS) AND NOT eof(textfile) DO
00239      1  2    BEGIN
00240      1  2    writeln(newfile,str);
00241      1  2    getstr(str);
00242      1  1    END;
00243      0  0 END;
00244   C  0  0 {------------------------------------------------------------------------------}
00245      1  0 PROCEDURE Writeread(VAR endloop : integer);
00246      1  0 VAR
00247      1  0    loop : integer;
00248      1  1 BEGIN
00249      1  1 FOR loop := 1 TO endloop DO
00250      1  2    BEGIN
00251      1  2    writeln(newfile,str);
00252      1  2    getstr(str);
00253      1  1    END;
00254      0  0 END;
00255   C  0  0 {------------------------------------------------------------------------------}
00256      1  0 PROCEDURE Convert_LOC_To_RL;
00257      1  0 VAR
00258      1  0    phstr    : anystring;
00259      1  1 BEGIN
00260      1  1 clearscreen;
00261      1  1 tempext := '.LOC';
00262      1  1 startfilesearch ('*.LOC');
00263      1  1 IF NOT endoffilesearch 
00264      1  1   THEN
00265      1  2     BEGIN
00266      1  2     writeline(both,'');
00267      1  2     writeline(both,'CONVERTING .LOC FILES TO .RL FILES ');
00268      1  2     writeline(both,'');
00269      1  2     alldo(tempext);
00270      1  2     END
00271      1  1   ELSE
00272      1  2      BEGIN 
00273      1  2      writeline(out, 'No .LOC files found.');
00274      1  2      IF NOT all THEN pause;
00275      1  1      END;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    6
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00276      1  1 WHILE NOT endoffilesearch DO 
00277      1  2    BEGIN
00278      1  2    filesearch (line);
00279      1  2    convertno(tempext);
00280      1  2    IF NOT noconvert
00281      1  2      THEN
00282      1  3        BEGIN
00283      1  3        close(textfile,ERROR:=CONTINUE);
00284      1  3        close(newfile,ERROR:=CONTINUE);
00285      1  3        filename := fs.name + '.LOC';
00286      1  3        newname  := fs.name + '.RL';
00287      1  3        open (textfile,filename,old,ERROR:=CONTINUE);
00288      1  3        open (newfile,newname,NEW,ERROR:=CONTINUE);   
00289      1  3        reset(textfile);
00290      1  3        rewrite(newfile);
00291      1  3        FOR i := 1 TO 4 DO	
00292      1  3          getstr(namestr);
00293      1  3        FOR i := 1 TO 3 DO
00294      1  3          getstr(datestr);
00295      1  3        stripdate(datestr);
00296      1  3        FOR i := 1 TO 4 DO
00297      1  3          getstr(commstr);
00298      1  3        getstr(str);
00299      1  3        WHILE (str <> DASHS) AND NOT eof(textfile) DO
00300      1  3          getstr(str);
00301      1  3    getstr(str);
00302      1  3    getstr(phstr);
00303      1  3    reset(textfile);
00304      1  3    FOR i := 1 TO 18 DO
00305      1  3       getstr(str);
00306      1  3    getstorage;
00307      1  3    reset(textfile);
00308      1  3    FOR i := 1 TO 12 DO
00309      1  3       getstr(str);
00310      1  3    writeln(newfile,'ROOT LOCUS CURVE, INCA 3.00');
00311      1  3    writeln(newfile,fs.name);
00312      1  3    writeln(newfile,'STANDARD LOCUS');
00313      1  3    writeln(newfile,phstr);
00314      1  3    writeln(newfile,'5');
00315      1  3    writeln(newfile,'5');
00316      1  3    writeln(newfile,'5');
00317      1  3    writeln(newfile,DASHS);
00318      1  3    writeln(newfile,BLANK);
00319      1  3    writeln(newfile,namestr);
00320      1  3    writeln(newfile,storstr);
00321      1  3    writeln(newfile,datestr);
00322      1  3    writeln(newfile,commstr);
00323      1  3    writeln(newfile,BLANK);
00324      1  3    getstr(str);
00325      1  3    writeln(newfile,str);
00326      1  3    WHILE (str <> DASHS) AND (NOT eof(textfile)) DO
00327      1  4       BEGIN
00328      1  4       getstr(str);
00329      1  4       writeln(newfile,str);
00330      1  3       END;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    7
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00331      1  3    getstr(str);
00332      1  3    getstr(str);
00333      1  3    writeln(newfile,'PLANE AND LIMITS');
00334      1  3    writeln(newfile,'S');
00335      1  3    WHILE NOT eof(textfile) DO
00336      1  4       BEGIN
00337      1  4       getstr(str);
00338      1  4       writeln(newfile,str);
00339      1  3       END;
00340      1  3    writeline(both,'');
00341      1  3    writeline(both,'The file ' + fs.name + ' has been converted to a .RL file.');
00342      1  3    writeline(both,'');
00343      1  3    close(textfile,ERROR:=CONTINUE);
00344      1  3    close(newfile,ERROR:=CONTINUE);
00345      1  2    END;
00346      1  1    END;
00347      0  0 END;                            
00348   C  0  0 {------------------------------------------------------------------------------}
00349      1  0 PROCEDURE Convert_FRE_To_FR;
00350      1  1 BEGIN
00351      1  1 clearscreen;
00352      1  1 tempext := '.FRE';
00353      1  1 startfilesearch ('*.FRE');
00354      1  1 IF NOT endoffilesearch THEN
00355      1  2   BEGIN
00356      1  2   writeline(both,'');
00357      1  2   writeline(both,'CONVERTING .FRE FILES TO .FR FILES ');
00358      1  2   writeline(both,'');
00359      1  2   alldo(tempext);
00360      1  2   END
00361      1  1   ELSE 
00362      1  2      BEGIN
00363      1  2      writeline(out, 'No .FRE files found.');
00364      1  2      IF NOT all THEN pause;
00365      1  1      END;
00366      1  1 WHILE NOT endoffilesearch DO
00367      1  2    BEGIN
00368      1  2    filesearch(line);
00369      1  2    convertno(tempext);
00370      1  2    IF NOT noconvert
00371      1  2     THEN
00372      1  3      BEGIN
00373      1  3    close(textfile,ERROR:=CONTINUE);
00374      1  3    close(newfile,ERROR:=CONTINUE);
00375      1  3    filename := fs.name + '.FRE';
00376      1  3    newname  := fs.name + '.FR';
00377      1  3    open(textfile,filename,OLD,ERROR:=CONTINUE);
00378      1  3    open(newfile,newname,NEW,ERROR:=CONTINUE);
00379      1  3    reset(textfile);
00380      1  3    rewrite(newfile);
00381      1  3    writeln(newfile,'FREQUENCY RESPONSE CURVE, INCA 3.00');
00382      1  3    writeln(newfile,fs.name);
00383      1  3    getstr(str);
00384      1  3    i := 3;
00385      1  3    writeread(i);

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    8
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00386      1  3    setstrs;
00387      1  3    writestrs;
00388      1  3    reset(textfile);
00389      1  3    FOR i:=1 TO 13 DO
00390      1  3       getstr(str);
00391      1  3    writefactors;
00392      1  3    i := 4;
00393      1  3    writeread(i);
00394      1  3    setstrs;
00395      1  3    writestrs;
00396      1  3    reset(textfile);
00397      1  3    getstr(str);
00398      1  3    WHILE (index(str,'ROOTED FORM') = 0) AND NOT eof(textfile) DO
00399      1  3       getstr(str);
00400      1  3    getstr(str);
00401      1  3    WHILE (index(str,'ROOTED FORM') = 0) AND NOT eof(textfile) DO
00402      1  3       getstr(str);
00403      1  3    getstr(str);
00404      1  3    writeln(newfile,'ROOTED FORM');
00405      1  3    writefactors;
00406      1  3    FOR i := 1 to 6 DO
00407      1  4      BEGIN
00408      1  4      writeln(newfile,str);
00409      1  4      IF index(str,'COMP DATA') > 0
00410      1  4       THEN BEGIN writeln(newfile,'DEFAULT'); writeln(newfile,'DEFAULT'); END;
00411      1  4      getstr(str);
00412      1  3      END;
00413      1  3    getstr(str);
00414      1  3    checkinfinity(str);
00415      1  3    WHILE NOT eof(textfile) DO
00416      1  4       BEGIN
00417      1  4       writeln(newfile,str);
00418      1  4       getstr(str);
00419      1  4       checkinfinity(str);
00420      1  3       END;
00421      1  3    writeline(both,'');
00422      1  3    writeline(both,'The file ' + fs.name + ' has been converted to a .FR file.');
00423      1  3    writeline(both,'');
00424      1  3    close(textfile,ERROR:=CONTINUE);
00425      1  3    close(newfile,ERROR:=CONTINUE);
00426      1  2    END;
00427      1  1    END;
00428      0  0 END;
00429   C  0  0 {------------------------------------------------------------------------------}
00430      1  0 PROCEDURE Convert_TIR_To_TR;
00431      1  0 VAR
00432      1  0    tempstr : anystring;
00433      1  1 BEGIN
00434      1  1 clearscreen;
00435      1  1 tempext := '.TIR';
00436      1  1 startfilesearch ('*.TIR');
00437      1  1 IF NOT endoffilesearch THEN
00438      1  2    BEGIN
00439      1  2    writeline(both,'');
00440      1  2    writeline(both,'CONVERTING .TIR FILES TO .TR FILES');

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page    9
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00441      1  2    writeline(both,'');
00442      1  2    alldo(tempext);
00443      1  2    END
00444      1  1    ELSE 
00445      1  2      BEGIN
00446      1  2      writeline(out, 'No .TIR files found.');
00447      1  2      IF NOT all THEN pause;
00448      1  1      END;
00449      1  1 WHILE NOT endoffilesearch DO
00450      1  2    BEGIN
00451      1  2    filesearch (line);
00452      1  2    convertno(tempext);
00453      1  2    IF NOT noconvert
00454      1  2     THEN
00455      1  3      BEGIN
00456      1  3    close(textfile,ERROR:=CONTINUE);
00457      1  3    close(newfile,ERROR:=CONTINUE);
00458      1  3    filename := fs.name + '.TIR';
00459      1  3    newname := fs.name + '.TR';
00460      1  3    open(textfile,filename,OLD,ERROR:=CONTINUE);
00461      1  3    open(newfile,newname,NEW,ERROR:=CONTINUE);
00462      1  3    reset(textfile);
00463      1  3    rewrite(newfile);
00464      1  3    writeln(newfile,'TIME RESPONSE CURVE, INCA 3.00');
00465      1  3    writeln(newfile,fs.name);
00466      1  3    getstr(str);
00467      1  3    i := 3;
00468      1  3    writeread(i);
00469      1  3    setstrs;
00470      1  3    writestrs;
00471      1  3    reset(textfile);
00472      1  3    FOR i := 1 TO 13 DO
00473      1  3       getstr(str);
00474      1  3    writefactors;
00475      1  3    i := 4;
00476      1  3    writeread(i);
00477      1  3    setstrs;
00478      1  3    writestrs;
00479      1  3    reset(textfile);
00480      1  3    getstr(str);
00481      1  3    WHILE (index(str,'FEEDBACK FUNCTION') = 0) AND NOT eof(textfile) DO
00482      1  3       getstr(str);
00483      1  3    FOR i := 1 TO 12 DO
00484      1  3       getstr(str);
00485      1  3    writefactors;
00486      1  3    i := 4;
00487      1  3    writeread(i);
00488      1  3    setstrs;
00489      1  3    writestrs;
00490      1  3    reset(textfile);
00491      1  3    getstr(str);
00492      1  3    WHILE (index(str,'ROOTED FORM') = 0) AND NOT eof(textfile) DO
00493      1  3       getstr(str);
00494      1  3    getstr(str);
00495      1  3    WHILE (index(str,'ROOTED FORM') = 0) AND NOT eof(textfile) DO

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   10
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00496      1  3       getstr(str);
00497      1  3    getstr(str);
00498      1  3    WHILE (index(str,'ROOTED FORM') = 0) AND NOT eof(textfile) DO
00499      1  3       getstr(str);
00500      1  3    getstr(str);
00501      1  3    writeln(newfile,'ROOTED FORM');
00502      1  3    writefactors;
00503      1  3    i := 4;
00504      1  3    writeread(i);
00505      1  3    setstrs;
00506      1  3    writestrs;
00507      1  3    reset(textfile);
00508      1  3    getstr(str);
00509      1  3    WHILE (index(str,'INPUT FUNCTION')=0) AND NOT eof(textfile) DO
00510      1  3       getstr(str);
00511      1  3    FOR i := 1 TO 12 DO
00512      1  3       getstr(str);
00513      1  3    writefactors;
00514      1  3    i := 8;
00515      1  3    writeread(i);
00516      1  3    tempstr := str;
00517      1  3    getstr(str);
00518      1  3    i := 2;
00519      1  3    writeread(i);
00520      1  3    writeln(newfile,'COMP GAIN');
00521      1  3    writeln(newfile,'         1');
00522      1  3    writeln(newfile,tempstr);
00523      1  3    WHILE NOT eof(textfile) DO
00524      1  4       BEGIN
00525      1  4       writeln(newfile,str);
00526      1  4       getstr(str);
00527      1  3       END;
00528      1  3    writeline(both,'');
00529      1  3    writeline(both,'The file ' + fs.name + ' has been converted to a .TR file.');
00530      1  3    writeline(both,'');
00531      1  3    close(textfile,ERROR:=CONTINUE);
00532      1  3    close(newfile,ERROR:=CONTINUE);
00533      1  2    END;
00534      1  1    END;
00535      0  0 END;
00536   C  0  0 {------------------------------------------------------------------------------}
00537      1  0 PROCEDURE Convert_SOU_To_SOU;
00538      1  0 TYPE
00539      1  0    charset            = SET OF char;
00540      1  0    comname            = VARYING[20] OF char;
00541      1  0 VAR
00542      1  0    convertlower       : [STATIC]  boolean              := true;
00543      1  0    tempfile           : text;
00544      1  0    helpcommand        : [STATIC]  VARYING [80] OF char := '$HELP';
00545      1  0    auditfilename      : [STATIC]  VARYING [30] OF char := '';
00546      1  0    source             : [STATIC]  (TERM,COMFILE)       := TERM;
00547      1  0    symbol             : [STATIC]  RECORD
00548      1  0                         number  : integer;
00549      1  0                         log     : ARRAY [1..50] OF VARYING [30] OF char;
00550      1  0                         equiv   : ARRAY [1..50] OF VARYING [80] OF char;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   11
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00551      1  0                         END
00552      1  0                         := (0,(50 OF ''),(50 OF ''));
00553      1  0    editqual           : [STATIC] ARRAY [1..7] OF comname := ('/ROOTS',
00554      1  0                                                              '/FACTORED',
00555      1  0                                                              '/BODEGAIN_FACTORED',
00556      1  0                                                              '/ZETA_OMEGA',
00557      1  0                                                              '/POLAR',
00558      1  0                                                              '/DEGREE_POLAR',
00559      1  0                                                              '/UNFACTORED');
00560      1  0    delqual            : [STATIC] ARRAY [1..1] OF comname := ('/ALL');
00561      1  0    savequal           : [STATIC] ARRAY [1..1] OF comname := ('/WORKSPACE');
00562      1  0    unsavequal         : [STATIC] ARRAY [1..1] OF comname := ('/WORKSPACE');
00563      1  0    showqual           : [STATIC] ARRAY [1..5] OF comname := ('/COMMANDS',
00564      1  0                                                              '/QUALIFIERS',
00565      1  0                                                              '/CLOCK',
00566      1  0                                                              '/PROJECT',
00567      1  0                                                              '/NEWS');
00568      1  0    setqual            : [STATIC] ARRAY [1..9] OF comname := ('/ERROR_HANDLER',
00569      1  0                                                              '/LOGO_SHOW',
00570      1  0                                                              '/MENU_SHOW',
00571      1  0                                                              '/EDIT_FORMAT',
00572      1  0                              				     '/SEARCH_CIRCLE',
00573      1  0 							     '/FREQUENCY_RESPONSE',
00574      1  0 							     '/WRAP',
00575      1  0 							     '/ZAGGING',
00576      1  0                                                              '/LABEL_FULL');
00577      1  0    printqual          : [STATIC] ARRAY [1..7] OF comname := ('/GRAPHICS_FORMAT',
00578      1  0                                                              '/HEADER_FACTORED',
00579      1  0                                                              '/EXPAND_PART_FRACT', 
00580      1  0                                                              '/SUMMARY',
00581      1  0                                                              '/ABBR_LIST_NAMES',
00582      1  0                                                              '/LIST_NAMES',
00583      1  0                                                              '/COUNT');
00584      1  0    exitqual           : [STATIC] ARRAY [1..5] OF comname := ('/SAVE',
00585      1  0                                                              '/PRINT',
00586      1  0                                                              '/DELETE',
00587      1  0                                                              '/BOTH_PRINT_DELETE',
00588      1  0                                                              '/REMOVE_OLD_VERSIONS');
00589      1  0    timerqual          : [STATIC] ARRAY [1..5] OF comname := ('/CLOSED_LOOP',
00590      1  0                                                              '/PLANT_SAMPLER',
00591      1  0                                                              '/FEEDBACK_SAMPLER',
00592      1  0                                                              '/EXTERNAL',
00593      1  0                                                              '/OLD');
00594      1  0    freqrqual          : [STATIC] ARRAY [1..13] OF comname := ('/BODE',
00595      1  0                                                               '/MAGNITUDE',
00596      1  0 							      '/PHASE',
00597      1  0 							      '/NYQUIST',
00598      1  0 							      '/C-NICHOLS',
00599      1  0 							      '/V-POPOV',
00600      1  0 							      '/HERTZ',
00601      1  0 							      '/RADIANS_PER_SECOND',
00602      1  0                          				      '/DB',
00603      1  0      							      '/AMPLITUDE',
00604      1  0 							      '/STAR',
00605      1  0     							      '/EXTERNAL',

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   12
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00606      1  0 							      '/OLD');
00607      1  0    locusqual          : [STATIC] ARRAY [1..4] OF comname := ('/ROOTS',
00608      1  0                                                              '/PHASE_ANGLE_SET',
00609      1  0                                              		     '/EXTERNAL',
00610      1  0                                                              '/OLD');
00611      1  0    comqual            : [STATIC] ARRAY [1..1] OF comname   := ('/REPLACE');
00612      1  0    termqual           : [STATIC] ARRAY [1..22] OF comname  := ('/AUTO',
00613      1  0                                                                '/NONE',
00614      1  0             						       '/DUMB',
00615      1  0 							       '/VT100',
00616      1  0 							       '/VT102',
00617      1  0 							       '/VT220',
00618      1  0 							       '/VT100',
00619      1  0 							       '/VT125',
00620      1  0 							       '/VT240',
00621      1  0 							       '/TEK4010',
00622      1  0 							       '/TEK4014',
00623      1  0 							       '/TEK4016',
00624      1  0 							       '/TEK4105',
00625      1  0 							       '/TEK4106',
00626      1  0 							       '/TEK4109',
00627      1  0 							       '/TEK4107',
00628      1  0 							       '/TEK4114',							       '/TEK4115',
00629      1  0 							       '/VS550',
00630      1  0 							       '/HP9845',
00631      1  0 							       '/ERGO301',
00632      1  0 							       '/VT241');
00633      1  0    qshowqual          : [STATIC] ARRAY [1..4] OF comname := ('/STATUS',
00634      1  0 							     '/SOURCE',
00635      1  0 							     '/TIME',
00636      1  0 							     '/MAP_OF_TERMINALS');
00637      1  0    qsetqual           : [STATIC] ARRAY [1..29] OF comname := ('/NEARNESS',
00638      1  0 							      '/NEARZERO',
00639      1  0 							      '/FIELD_WIDTH',
00640      1  0 							      '/ROOT_MAXIMUM',
00641      1  0 							      '/SYMBOL',
00642      1  0 							      '/COLOR',
00643      1  0 							      '/XROUNDING',
00644      1  0                                                               '/XGRIDDING',
00645      1  0 							      '/XSUBGRIDDING',
00646      1  0 							      '/XMINIMUM',
00647      1  0 							      '/XMAXIMUM',
00648      1  0 						  	      '/YROUNDING',
00649      1  0 							      '/YGRIDDING',
00650      1  0 							      '/YSUBGRIDDING',
00651      1  0 							      '/YMINIMUM',
00652      1  0             						      '/YMAXIMUM',
00653      1  0 							      '/AZIMUTH_PERCENT',
00654      1  0 							      '/RADIAL_PERCENT',
00655      1  0 							      '/TICKSIZE',
00656      1  0 							      '/SUBTICKSIZE',
00657      1  0 							      '/MAXTICKS',
00658      1  0 							      '/RESOLUTION',
00659      1  0 							      '/DOTSIZE',
00660      1  0 							      '/SLOW_PRINT',

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   13
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00661      1  0 							      '/OVERLAY_KILL',
00662      1  0 							      '/WIDTH',
00663      1  0 							      '/HEIGHT',
00664      1  0 							      '/TOP_MARGIN',
00665      1  0 							      '/RIGHT_MARGIN');
00666      1  0    comtable           : [STATIC] ARRAY [0..CTABLEN] OF comname := (19 OF '');
00667      1  0    firstqual          : [STATIC] ARRAY [0..CTABLEN] OF integer := (19 OF 0);
00668      1  0    lastqual           : [STATIC] ARRAY [0..CTABLEN] OF integer := (19 OF 0);
00669      1  0    qualtable          : [STATIC] ARRAY [0..400]     OF comname := (401 OF '');
00670      1  0    blankqual          : [STATIC] ARRAY [1..1]       OF comname := ('  ');
00671      1  0    termmapfile        : text;
00672      1  0    streq1,streq2      : boolean;
00673      1  0    hzs,rad,amp,dbs    : boolean;
00674   C  1  0 {-------------------------------}
00675      1  0 [ EXTERNAL (LIB$SPAWN) ]
00676      2  0 PROCEDURE spawn (%STDESCR str : PACKED ARRAY [l1..u1:integer] OF char);
00677      1  0 EXTERNAL;
00678   C  1  0 {-------------------------------}
00679      1  0 [ ASYNCHRONOUS, EXTERNAL (LIB$SIGNAL) ]
00680      2  0 PROCEDURE signal (%IMMED cond : integer);
00681      1  0 EXTERNAL;
00682   C  1  0 {-------------------------------}
00683      2  0 PROCEDURE readstr;  
00684   C  2  0 { Purpose -- Read character string from textfile. Plus         }
00685   C  2  0 {            check for Commands 'HELP' ,'VAX', and             }
00686   C  2  0 {            'ABORT' and comments (';').                       }
00687      2  0 VAR
00688      2  0    gone      : boolean;
00689      2  1 BEGIN
00690      2  2 REPEAT 
00691      2  2    gone := true;
00692      2  2    IF NOT eof(textfile) THEN readln(textfile,str);
00693      2  2    IF str <> ''
00694      2  2       THEN  FOR i := 1 TO length(str) DO
00695      2  2               IF (str[i] IN ['a'..'z'])
00696      2  2                  THEN str[i] := chr(ord(str[i])-32); 
00697      2  2    IF index(str,'ABORT')=1
00698      2  2      THEN
00699      2  3        BEGIN
00700      2  3        gone := false;
00701      2  3        writeln(newfile,str);
00702      2  2        END;
00703      2  2    IF index(str,'HELP')=1 
00704      2  2      THEN
00705      2  3        BEGIN
00706      2  3        gone := false;
00707      2  3        writeln(newfile,str);
00708      2  2        END;
00709      2  2    IF index(str,'VAX')=1
00710      2  2      THEN
00711      2  3        BEGIN
00712      2  3        writeln(newfile,str);
00713      2  3        gone := false;
00714      2  2        END;
00715      2  2    IF index(STR,';')=1

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   14
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00716      2  2      THEN
00717      2  3        BEGIN
00718      2  3        gone := false;
00719      2  3        writeln(newfile,str);
00720      2  2        END;
00721      2  2    IF index(str,'@')=1
00722      2  2      THEN
00723      2  3        BEGIN
00724      2  3        writeln(newfile,str);
00725      2  3        gone := false;
00726      2  3        END
00727      2  1    UNTIL gone OR eof(textfile);
00728      1  0 END;
00729   C  1  0 {--------------------------------}
00730      2  0 PROCEDURE write_til_x;
00731      2  1 BEGIN
00732      2  1 readstr;
00733      2  1 WHILE ((str[1] <> 'E') AND (str[1] <> 'X'))  AND NOT eof(textfile) DO
00734      2  2    BEGIN
00735      2  2    writeln(newfile,str);
00736      2  2    readstr;
00737      2  1    END;
00738      2  1 writeln(newfile, 'X');
00739      1  0 END;
00740   C  1  0 {---------------------------------}
00741      2  0 PROCEDURE read_five;
00742      2  0 VAR
00743      2  0    i : integer;
00744      2  1 BEGIN
00745      2  1 FOR i := 1 TO 5 DO
00746      2  2    BEGIN
00747      2  2    readstr;
00748      2  2    writeln(newfile, str);
00749      2  1    END;
00750      1  0 END;
00751   C  1  0 {---------------------------------}
00752      2  0 PROCEDURE write_four(VAR comm : comname);
00753      2  0 VAR
00754      2  0    tempqual   :  comname;
00755      2  1 BEGIN
00756      2  1 tempqual := '';
00757      2  1 IF length(comm) > 1 THEN tempqual := substr(comm,2,length(comm)-1);
00758      2  1 writeln(newfile, tempqual);
00759      2  1 IF amp THEN writeln(newfile, 'YES')
00760      2  1        ELSE IF dbs THEN writeln(newfile, 'NO')
00761      2  1                    ELSE writeln(newfile, 'DEFAULT');
00762      2  1 IF hzs THEN writeln(newfile, 'YES')
00763      2  1        ELSE IF rad THEN writeln(newfile, 'NO')
00764      2  1                    ELSE writeln(newfile, 'DEFAULT'); 
00765      2  1 writeln(newfile, 'DEFAULT');
00766      1  0 END;
00767   C  1  0 {-------------------------------}
00768      2  0 PROCEDURE fr_readwrite(VAR comm : comname);
00769      2  1 BEGIN
00770      2  1 read_five;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   15
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00771      2  1 writeln(newfile, 'DEFAULT');
00772      2  1 writeln(newfile, 'DEFAULT');
00773      2  1 writeln(newfile, 'DEFAULT');
00774      2  1 write_four(comm);
00775      2  1 write_til_x;
00776      1  0 END;
00777   C  1  0 {-------------------------------}
00778      2  0 PROCEDURE write_tail;
00779      2  0 VAR
00780      2  0    i : integer;
00781      2  1 BEGIN
00782      2  1 FOR i := 1 TO 3 DO
00783      2  2    BEGIN
00784      2  2    readstr;
00785      2  2    writeln(newfile, str);
00786      2  1    END;
00787      2  1 writeln(newfile, 'DEFAULT');
00788      2  1 writeln(newfile, 'DEFAULT');
00789      2  1 writeln(newfile, 'DEFAULT');
00790      1  0 END;
00791   C  1  0 {-------------------------------}
00792      2  0 PROCEDURE write_arg(VAR arg : var80);
00793      2  1 BEGIN
00794      2  1 IF arg = ''
00795      2  1    THEN
00796      2  2      BEGIN
00797      2  2      readstr;
00798      2  2      writeln(newfile, str);
00799      2  2      arg := str;
00800      2  1      END;
00801      1  0 END;
00802   C  1  0 {--------------------------------}
00803      2  0 PROCEDURE Cedit(VAR comm : comname; VAR argname : name_type);
00804      2  1 BEGIN
00805      2  1 readstr;
00806      2  1 writeln(newfile,'; The EDIT command is not converted.'); 
00807      2  1 WHILE ((str[1] <> 'E') AND (str[1] <> 'X')) AND NOT eof(textfile) DO
00808      2  2    BEGIN
00809      2  2    readstr;
00810      2  2    writeln(newfile,'; ' + str);
00811      2  1    END; 
00812      1  0 END;
00813   C  1  0 {--------------------------------}
00814      2  0 PROCEDURE write_argname(VAR argname : name_type);
00815      2  1 BEGIN
00816      2  1 IF argname = '' 
00817      2  1    THEN
00818      2  2      BEGIN
00819      2  2      readstr;
00820      2  2      writeln(newfile, str);
00821      2  2      argname := str;
00822      2  1      END;
00823      1  0 END;
00824   C  1  0 {--------------------------------}
00825      2  0 PROCEDURE Cotherwise;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   16
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00826      2  1 BEGIN
00827      2  1 IF (index(str,'=') <> 0)
00828      2  1    THEN
00829      2  2       BEGIN
00830      2  2       writeln(newfile, 'F G S ' + str);
00831      2  2       writeln(newfile, '');
00832      2  2       END
00833      2  1    ELSE IF str<> ''
00834      2  1           THEN
00835      2  1             IF str[1]<> ';'
00836      2  1                THEN
00837      2  2                  BEGIN
00838      2  2                  writeln(newfile, ';Not able to convert the following command');
00839      2  2                  str := ';' + str;
00840      2  2                  writeln(newfile, str);
00841      2  1                  END;
00842      1  0 END;
00843   C  1  0 {-----------------------------}
00844      2  0 PROCEDURE Cprint(VAR comm : comname; VAR argname : name_type);
00845      2  0 VAR 
00846      2  0    noarg     : boolean;
00847      2  1 BEGIN
00848      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
00849      2  1 noarg := false;
00850      2  2 CASE comm[2] OF
00851      2  2    'R'       :   writeln(newfile, 'FUNCTION AUDIT ROOTS ' + argname);
00852      2  2    'B'	     :   writeln(newfile, 'FUNCTION AUDIT BODEGAIN_FACTORED ' + argname);
00853      2  2    'F'       :   writeln(newfile, 'FUNCTION AUDIT FACTORED ' + argname);
00854      2  2    'Z'       :   writeln(newfile, 'FUNCTION AUDIT ZETA_OMEGA ' + argname);
00855      2  2    'P'       :   writeln(newfile, 'FUNCTION AUDIT POLAR ' + argname);
00856      2  2    'D'       :   writeln(newfile, 'FUNCTION AUDIT DEGREE_POLAR ' + argname);
00857      2  2    'U'       :   writeln(newfile, 'FUNCTION AUDIT UNFACTORED ' + argname);
00858      2  2    'G'       :   noarg := true;
00859      2  2    'H'       :   writeln(newfile, 'FUNCTION AUDIT NO_EVALUATION ' + argname);
00860      2  2    'E'       :   writeln(newfile, 'FUNCTION AUDIT EXPAND_PART_FRACT ' + argname);
00861      2  3    'S'       :   BEGIN
00862      2  3                  writeln(newfile, 'PROJECT AUDIT SUMMARY');
00863      2  3                  noarg := true;
00864      2  2                  end;
00865      2  3    'A'       :   BEGIN
00866      2  3                  writeln(newfile, 'PROJECT AUDIT ABBR_LIST_NAMES');
00867      2  3                  noarg := true;
00868      2  2                  END;
00869      2  3    'L'       :   BEGIN
00870      2  3                  writeln(newfile, 'PROJECT AUDIT LIST_NAMES');
00871      2  3                  noarg := true;
00872      2  2                  END;
00873      2  3    'C'       :   BEGIN
00874      2  3                  writeln(newfile, 'PROJECT AUDIT COUNT');      
00875      2  3 		 noarg := true;
00876      2  2 		 END;
00877      2  2    OTHERWISE     noarg := true;
00878      2  2 IF NOT noarg
00879      2  2    THEN write_argname(argname);
00880      2  1 END;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   17
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00881      1  0 END;                                                                            
00882   C  1  0 {-----------------------------}
00883      2  0 PROCEDURE Ctype(VAR comm : comname; VAR argname : name_type);
00884      2  0 VAR
00885      2  0    noarg        :   boolean; 
00886      2  1 BEGIN
00887      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
00888      2  1 noarg := false;
00889      2  2 CASE comm[2] OF
00890      2  2    'R'       :   writeln(newfile, 'FUNCTION VIEW ROOTS ' + argname);
00891      2  2    'F'       :   writeln(newfile, 'FUNCTION VIEW FACTORED ' +  argname);
00892      2  2    'B'       :   writeln(newfile, 'FUNCTION VIEW BODEGAIN_FACTORED ' + argname);
00893      2  2    'P'       :   writeln(newfile, 'FUNCTION VIEW POLAR ' + argname);
00894      2  2    'Z'       :   writeln(newfile, 'FUNCTION VIEW ZETA_OMEGA ' + argname);
00895      2  2    'D'       :   writeln(newfile, 'FUNCTION VIEW DEGREE_POLAR ' + argname);
00896      2  2    'U'       :   writeln(newfile, 'FUNCTION VIEW UNFACTORED ' + argname);
00897      2  2    'G'       :   writeln(newfile, 'FUNCTION VIEW GRAPHICS_FORMAT ' + argname);
00898      2  2    'H'       :   writeln(newfile, 'FUNCTION VIEW HEADER_FACTORED ' + argname);
00899      2  2    'E'       :   writeln(newfile, 'FUNCTION VIEW EXPAND_PART_FRACT ' + argname);
00900      2  3    'S'       :   BEGIN
00901      2  3                  writeln(newfile, 'PROJECT VIEW SUMMARY');
00902      2  3 		 noarg := true;
00903      2  2 		 END;
00904      2  3    'A'       :   BEGIN
00905      2  3 		 writeln(newfile, 'PROJECT VIEW ABBR_LIST_NAMES');
00906      2  3 		 noarg := true;
00907      2  2 		 END;
00908      2  3    'L'       :   BEGIN
00909      2  3 		 writeln(newfile, 'PROJECT VIEW LIST_NAMES');
00910      2  3 		 noarg := true;
00911      2  2 		 END;
00912      2  3    'C'       :   BEGIN
00913      2  3 		 writeln(newfile, 'PROJECT VIEW COUNT');
00914      2  3                  noarg := true;
00915      2  2                  END;
00916      2  2    OTHERWISE     noarg := true;
00917      2  2 IF NOT noarg
00918      2  2    THEN write_argname(argname);
00919      2  1 END;
00920      1  0 END;
00921   C  1  0 {------------------------------}
00922      2  0 PROCEDURE Cdelete(VAR comm : comname; VAR argname : name_type);
00923      2  1 BEGIN
00924      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
00925      2  2 CASE comm[2] OF
00926      2  3    'A'          :   BEGIN
00927      2  3                     writeln(newfile, 'FUNCTION DELETE ALL');
00928      2  3                     readstr;
00929      2  3 		    writeln(newfile, 'Y');
00930      2  2                     END;
00931      2  3    OTHERWISE        BEGIN
00932      2  3                     writeln(newfile, 'FUNCTION DELETE ' + argname);
00933      2  3 		    IF argname = 'ALL' 
00934      2  4                        THEN  BEGIN
00935      2  4                              readstr;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   18
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00936      2  4 			     writeln(newfile, 'Y');
00937      2  4                              END
00938      2  3                        ELSE
00939      2  3                          IF argname = ''
00940      2  3                            THEN
00941      2  4                               BEGIN
00942      2  4                               readstr;
00943      2  4                               writeln(newfile,str);
00944      2  3                               END;
00945      2  2                     END;
00946      2  1 END;
00947      1  0 END;
00948   C  1  0 {----------------------------}
00949      2  0 PROCEDURE Cshow(VAR comm : comname; VAR arg : var80);
00950      2  0 VAR
00951      2  0    tempqual  :   comname;
00952      2  1 BEGIN
00953      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
00954      2  1 tempqual := '';
00955      2  2 CASE comm[2] OF
00956      2  2    'S'       :   IF comm[3] = 'T'
00957      2  2                    THEN writeln(newfile,'UTILITIES VIEW')
00958      2  2                    ELSE IF comm[3] = 'O' THEN  writeln(newfile,'UTILITIES VIEW SOURCE')
00959      2  2                           ELSE IF comm[3] = 'E'
00960      2  2                                  THEN 
00961      2  3 				   BEGIN
00962      2  3 				   writeln(newfile,'SET SEARCH_CIRCLE');
00963      2  3 				   writeln(newfile,'DEFAULT');
00964      2  3 				   END
00965      2  2                                  ELSE
00966      2  3                                     BEGIN
00967      2  3 				    tempqual := substr(comm,2,length(comm)-1);
00968      2  3 				    writeln(newfile,'UTILITIES SET '+ tempqual);
00969      2  2 				    END;
00970      2  2    'T'       :   IF comm[4] = 'M' 
00971      2  2                     THEN  writeln(newfile,'UTILITIES VIEW TIME')
00972      2  3 		    ELSE BEGIN
00973      2  3 			 tempqual := substr(comm,2,length(comm)-1);
00974      2  3 			 writeln(newfile,'UTILITIES SET ' + tempqual);
00975      2  2 			 END;
00976      2  2    'M'       :   IF comm[4] = 'P'
00977      2  2                     THEN  writeln(newfile,'UTILITIES VIEW MAP')
00978      2  2 		    ELSE IF comm[4] = 'X'
00979      2  2 			    THEN writeln(newfile,'UTILITIES SET MAXTICKS')
00980      2  3 			    ELSE BEGIN
00981      2  3 				 writeln(newfile,'SET MENU_SHOW');
00982      2  3 				 writeln(newfile,'DEFAULT');
00983      2  2 				 END;
00984      2  2    'C'       :   IF comm[3] = 'L'
00985      2  2                     THEN writeln(newfile,'VIEW USED_CPU_TIME')
00986      2  2                     ELSE IF comm[4] = 'L'
00987      2  2                             THEN writeln(newfile,'UTILITIES SET COLOR');
00988      2  2    'Q'       :   ;
00989      2  2    'P'       :   ;
00990      2  2    'N'       :   IF comm[4] = 'W'

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   19
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

00991      2  2 		    THEN  writeln(newfile,'VIEW NEWS')
00992      2  3                     ELSE BEGIN
00993      2  3 			 tempqual := substr(comm,2,length(comm)-1);
00994      2  3 			 writeln(newfile,'UTILITIES SET ' + tempqual);
00995      2  2 			 END;
00996      2  3    'E'       :   BEGIN
00997      2  3 		 IF comm[3] = 'R'
00998      2  3                     THEN writeln(newfile,'SET ERROR_HANDLER')
00999      2  3 		    ELSE writeln(newfile,'SET EDIT_FORMAT');
01000      2  3 		 writeln(newfile,'DEFAULT');
01001      2  2 		 END;
01002      2  3    'L'       :   BEGIN
01003      2  3 		 IF comm[3] = 'O'
01004      2  3 		    THEN writeln(newfile,'SET LOGO_SHOW')
01005      2  3 		    ELSE writeln(newfile,'SET LABEL_FULL');
01006      2  3 		 writeln(newfile,'DEFAULT');
01007      2  2 		 END;
01008      2  3    'Z'       :   BEGIN
01009      2  3 		 writeln(newfile,'SET ZAGGING');
01010      2  3 		 writeln(newfile,'DEFAULT');
01011      2  2 		 END;
01012      2  2    'F'       :   IF comm[3] = 'I'
01013      2  2 		    THEN writeln(newfile,'UTILITIES SET FIELD_WIDTH')
01014      2  3 		    ELSE BEGIN
01015      2  3 		         writeln(newfile,'SET FREQUENCY_RESPONSE');
01016      2  3 			 writeln(newfile,'DEFAULT');
01017      2  2 			 END;
01018      2  2    'W'       :   IF comm[3] = 'I'
01019      2  2 		    THEN writeln(newfile,'UTILITIES SET WIDTH')
01020      2  3 		    ELSE BEGIN
01021      2  3 		         writeln(newfile,'SET WRAP');
01022      2  3 			 writeln(newfile,'DEFAULT');
01023      2  2 			 END;
01024      2  3    OTHERWISE     BEGIN
01025      2  3 		 tempqual := substr(comm,2,length(comm)-1);
01026      2  3 		 writeln(newfile,'UTILITIES SET ' + tempqual);
01027      2  2 		 END;
01028      2  1 END;
01029      1  0 END;
01030   C  1  0 {------------------------------}
01031      2  0 PROCEDURE Csetter(VAR comm : comname; VAR arg : var80);
01032      2  1 BEGIN
01033      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01034      2  2 CASE comm[2] OF
01035      2  2    'E'       :   IF comm[3] = 'D' THEN 
01036      2  3                                      BEGIN
01037      2  3                                      writeln(newfile, 'SET EDIT_FORMAT ' + arg);
01038      2  3 		                     write_arg(arg);
01039      2  2 		 		     END;
01040      2  2    'L'       :   IF comm[3] = 'O' THEN
01041      2  3 		                     BEGIN
01042      2  3 				     writeln(newfile, 'SET LOGO_SHOW ');
01043      2  3 				     readstr;
01044      2  3 				     writeln(newfile,str);
01045      2  3 				     END

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   20
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01046      2  2 				  ELSE
01047      2  3 				     BEGIN
01048      2  3 				     writeln(newfile, 'SET DOUBLE_LABEL ');
01049      2  3 				     readstr;
01050      2  3                                      writeln(newfile,str);
01051      2  2 				     END;
01052      2  2    'M'       :   IF comm[3] = 'A' THEN
01053      2  3 		 		    BEGIN
01054      2  3 		 		    writeln(newfile, 'UTILITIES FRAME SET MAXTICKS ' + arg);
01055      2  3 				    write_arg(arg);
01056      2  2 				    END;
01057      2  2    'S'       :   IF comm[3] = 'E' THEN
01058      2  3                                      BEGIN
01059      2  3 		                     writeln(newfile, 'SET SEARCH_CIRCLE ' + arg);
01060      2  3 		                     write_arg(arg);
01061      2  3 		                     END
01062      2  2 				  ELSE
01063      2  2 				     IF comm[3] = 'U' 
01064      2  2                                         THEN
01065      2  3 					   BEGIN
01066      2  3 					   writeln(newfile,
01067      2  3                                      'UTILITIES FRAME SET SUBTICKSIZE ' + arg);
01068      2  3 					   write_arg(arg);
01069      2  2 					   END;
01070      2  2    'F'       :  IF comm[3] = 'R' THEN
01071      2  3                                     BEGIN
01072      2  4    				    IF arg = '' THEN BEGIN
01073      2  4                                                      readstr;
01074      2  4 						     arg := str;
01075      2  3                                                      END;
01076      2  3 				    IF arg[1] = 'R'
01077      2  3                                       THEN  rad := true
01078      2  3                                       ELSE IF arg[1] = 'H'
01079      2  3                                              THEN  hzs := true
01080      2  3 				             ELSE IF arg[1] = 'D'
01081      2  3                                                     THEN  dbs := true
01082      2  3 	   			                    ELSE IF arg[1] = 'A'
01083      2  3                                                            THEN amp := true
01084      2  3 				    ELSE  
01085      2  3 		                      writeln(newfile, 'SET FREQUENCY_PLOT_TYPE '+ arg);
01086      2  3                                       write_arg(arg);
01087      2  3          	                    END
01088      2  2 				 ELSE
01089      2  3                                     BEGIN
01090      2  3 				    writeln(newfile,'UTILITIES SET FIELD_WIDTH ' + arg);
01091      2  3                                     write_arg(arg);
01092      2  2                                     END;     
01093      2  2    'W'       :   IF comm[3] = 'R' 
01094      2  2 	            THEN
01095      2  3                       BEGIN
01096      2  3 		      writeln(newfile, 'SET WRAP ' + arg);
01097      2  3 		      write_arg(arg);
01098      2  3 		      END
01099      2  2                     ELSE
01100      2  3                       BEGIN

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   21
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01101      2  3 		      writeln(newfile,'UTILITIES SET WIDTH ' + arg);
01102      2  3                       write_arg(arg);
01103      2  2 		      END; 
01104      2  3    'Z'       :   BEGIN
01105      2  3 		 writeln(newfile, 'SET ZAGGING ' + arg);
01106      2  3 		 write_arg(arg);
01107      2  2 		 END;
01108      2  2    'N'       :   IF comm[6] = 'N' 
01109      2  2                     THEN
01110      2  3 		       BEGIN
01111      2  3 		       writeln(newfile,'SET NEARNESS ' + arg);
01112      2  3 		       write_arg(arg);
01113      2  3 		       END
01114      2  2 		    ELSE
01115      2  3 		       BEGIN
01116      2  3                        writeln(newfile,'SET CLOSENESS_TO_ZERO ' + arg);
01117      2  3 		       write_arg(arg);
01118      2  2 		       END;
01119      2  3    'A'       :   BEGIN
01120      2  3 		 writeln(newfile,'UTILITIES FRAME SET AZIMUTH_PERCENT ' + arg);
01121      2  3                  write_arg(arg);
01122      2  2                  END;
01123      2  3    'D'       :   BEGIN
01124      2  3 		 writeln(newfile,'UTILITIES SET DOTSIZE ' + arg);
01125      2  3                  write_arg(arg);
01126      2  2                  END;
01127      2  3    'O'       :   BEGIN
01128      2  3 		 writeln(newfile,'UTILITIES SET OVERLAY_KILL ' + arg);
01129      2  3 		 write_arg(arg);
01130      2  2 		 END;
01131      2  3    'H'       :   BEGIN
01132      2  3 		 writeln(newfile,'UTILITIES SET HEIGHT ' + arg);
01133      2  3 		 write_arg(arg);
01134      2  2 		 END;
01135      2  2    'T'       :   IF comm[3] = 'I'
01136      2  2                     THEN
01137      2  3 		       BEGIN
01138      2  3                        writeln(newfile,'UTILITIES FRAME SET TICKSIZE ' + arg);
01139      2  3 		       write_arg(arg);
01140      2  3                        END
01141      2  2 		    ELSE
01142      2  3 		       BEGIN
01143      2  3 		       writeln(newfile,'UTILITIES SET LINE_SPACING ' + arg);
01144      2  3 		       write_arg(arg);
01145      2  2 		       END;
01146      2  2    'C'       :   ;
01147      2  2    'R'       :   IF comm[3] = 'O' 
01148      2  2 		    THEN
01149      2  3 		       BEGIN
01150      2  3 		       writeln(newfile,'SET ROOT_MAXIMUM ' + arg);
01151      2  3 		       write_arg(arg);
01152      2  3                        END
01153      2  2 		    ELSE IF comm[3] = 'A' 
01154      2  2                            THEN
01155      2  3                              BEGIN

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   22
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01156      2  3 		 	     writeln(newfile,
01157      2  3                                  'UTILITIES FRAME SET RADIAL_PERCENT'+arg);
01158      2  3                              write_arg(arg);
01159      2  3                              END
01160      2  2                            ELSE IF comm[3] = 'E'
01161      2  2                                   THEN
01162      2  3 		 		    BEGIN
01163      2  3 		 		    writeln(newfile,
01164      2  3                                      'UTILITIES FRAME SET RESOLUTION ' + arg);
01165      2  3                                     write_arg(arg);
01166      2  3                                     END
01167      2  2 		 		   ELSE
01168      2  3                                      BEGIN
01169      2  3                                      writeln(newfile,
01170      2  3 		 		      'UTILITIES SET CHAR_SPACING ' + arg);
01171      2  3 		 		     write_arg(arg);
01172      2  2                                      END;
01173      2  3    'X'       :   BEGIN
01174      2  3 		 write(newfile,'UTILITIES FRAME X_AXIS ');
01175      2  3 		 IF comm[3] = 'R' 
01176      2  3 		    THEN writeln(newfile,'ROUNDING ' + arg)
01177      2  3                     ELSE IF comm[3] = 'G'
01178      2  3                            THEN writeln(newfile,'GRIDDING ' + arg)
01179      2  3 		           ELSE IF comm[3] = 'S'
01180      2  3 		 		  THEN writeln(newfile,'SUBGRIDDING ' + arg)
01181      2  3 		 		  ELSE IF comm[4] = 'I'
01182      2  3 		 			THEN writeln(newfile,'LOWER_LIMIT'+arg)
01183      2  3 		 		        ELSE writeln(newfile,'UPPER_LIMIT'+arg);
01184      2  3 		 write_arg(arg);
01185      2  2 		 END;
01186      2  3    'Y'        :  BEGIN
01187      2  3 		 write(newfile,'UTILITIES FRAME Y_AXIS ');
01188      2  3 		 IF comm[3] = 'R'
01189      2  3 		   THEN writeln(newfile,'ROUNDING ' +arg)
01190      2  3 		   ELSE IF comm[3] = 'G'
01191      2  3 		          THEN writeln(newfile,'GRIDDING ' + arg)
01192      2  3 		 	  ELSE IF comm[3] = 'S'
01193      2  3 		 	         THEN writeln(newfile,'SUBGRIDDING ' + arg)
01194      2  3 		 	         ELSE IF comm[4] = 'I'
01195      2  3 		 		        THEN writeln(newfile,'LOWER_LIMIT'+arg)
01196      2  3                                         ELSE writeln(newfile,'UPPER_LIMIT'+arg);
01197      2  3                  write_arg(arg); 
01198      2  2                  END;
01199      2  2    OTHERWISE     Cotherwise;
01200      2  1 END;
01201      1  0 END;
01202   C  1  0 {-----------------------------}
01203      2  0 PROCEDURE Csave(VAR comm : comname; VAR argfile : name_type);
01204      2  1 BEGIN
01205      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01206      2  2 CASE comm[2] OF 
01207      2  2    'W'          :   writeln(newfile, 'PROJECT SAVE');
01208      2  3    OTHERWISE        BEGIN
01209      2  3                     writeln(newfile,'FUNCTION SAVE ' + argfile);
01210      2  3 		    IF argfile = '' THEN write_argname(argfile);

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   23
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01211      2  2                     END;
01212      2  1 END;     
01213      1  0 END;
01214   C  1  0 {-----------------------------}
01215      2  0 PROCEDURE Cunsave(VAR comm : comname; VAR argfile : name_type);
01216      2  1 BEGIN
01217      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01218      2  2 CASE comm[2] OF
01219      2  3    'W'          :   BEGIN
01220      2  3 		    writeln(newfile, 'PROJECT LOAD ' + argfile);
01221      2  3 		    IF argfile = '' THEN write_argname(argfile);
01222      2  2 		    END;
01223      2  3    OTHERWISE	    BEGIN
01224      2  3 		    writeln(newfile, 'FUNCTION LOAD ' + argfile);
01225      2  3 		    IF argfile = '' THEN write_argname(argfile);
01226      2  2 		    END;
01227      2  1 END;
01228      1  0 END;
01229   C  1  0 {------------------------------}
01230      2  0 PROCEDURE Ccompute(VAR comm : comname; VAR arg : var80);
01231      2  1 BEGIN
01232      2  1 writeln(newfile,'FUNCTION COMPUTE ' + arg);
01233      2  1 WHILE (str <> '') AND (NOT eof(textfile)) DO
01234      2  2    BEGIN
01235      2  2    readstr;
01236      2  2    writeln(newfile,str);
01237      2  1    END;
01238      2  1 writeln(newfile,'');
01239      1  0 END;
01240   C  1  0 {------------------------------}
01241      2  0 PROCEDURE Cqsetterm(VAR comm : comname; VAR arg : var80);
01242      2  0 VAR
01243      2  0    tempqual :   comname;
01244      2  1 BEGIN
01245      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01246      2  1 tempqual := '';
01247      2  1 IF length(comm) > 1
01248      2  1    THEN 
01249      2  2      BEGIN
01250      2  2      tempqual := substr(comm,2,length(comm)-1);
01251      2  2      writeln(newfile, 'UTILITIES TERMINAL SELECT ' + tempqual);
01252      2  1      END;
01253      1  0 END;
01254   C  1  0 {------------------------------}
01255      2  0 PROCEDURE Clocus(VAR comm : comname; VAR arg : var80);
01256      2  1 BEGIN
01257      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01258      2  2 CASE comm[2] OF
01259      2  3    'P'      :     BEGIN
01260      2  3 		  writeln(newfile, 'ANALYZE ROOT_LOCUS ' + arg);
01261      2  3 		  write_arg(arg);
01262      2  3                   readstr;
01263      2  3                   writeln(newfile,str);
01264      2  3 		  write_tail;
01265      2  3 		  write_til_x;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   24
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01266      2  2 		  END;
01267      2  3    'O'      :	  BEGIN
01268      2  3  		  writeln(newfile, 'PLOT NEW RL');
01269      2  3                   writeln(newfile, 'DEFAULT');
01270      2  3 		  write_til_x;
01271      2  2 		  END;
01272      2  3    'E'      :	  BEGIN
01273      2  3 		  writeln(newfile, 'CURVE LOAD ' + arg);
01274      2  3 		  write_arg(arg);
01275      2  3 		  writeln(newfile, 'PLOT NEW ' + arg);
01276      2  3           	  writeln(newfile, 'DEFAULT');
01277      2  3                   write_til_x;
01278      2  2                   END;
01279      2  3    'R'      :	  BEGIN
01280      2  3 		  writeln(newfile, 'ANALYZE ROOT_LOCUS ROOTS ' + arg);
01281      2  3 		  write_arg(arg);
01282      2  3 		  writeln(newfile, 'DEFAULT');
01283      2  3 		  write_til_x;
01284      2  2 		  END;
01285      2  3    OTHERWISE      BEGIN
01286      2  3 		  writeln(newfile, 'ANALYZE ROOT EXPRESSION ' + arg);
01287      2  3 		  write_arg(arg);
01288      2  3 		  writeln(newfile,'180');
01289      2  3 		  write_tail;
01290      2  3                   write_til_x;
01291      2  2 		  END;
01292      2  1 END;
01293      1  0 END;
01294   C  1  0 {-----------------------------}
01295      2  0 PROCEDURE Cfreqr(VAR comm  : comname; VAR arg : var80);
01296      2  0 VAR
01297      2  0    i : integer;
01298      2  1 BEGIN
01299      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01300      2  2 CASE comm[2] OF
01301      2  3    'O'       :   BEGIN
01302      2  3 		 writeln(newfile, 'PLOT NEW FR');
01303      2  3 		 writeln(newfile, 'DEFAULT');
01304      2  3 		 writeln(newfile, 'DEFAULT');
01305      2  3 		 writeln(newfile, 'DEFAULT');
01306      2  3 		 writeln(newfile, 'DEFAULT');
01307      2  3 		 writeln(newfile, 'DEFAULT');
01308      2  3 		 write_til_x;
01309      2  2 		 END;
01310      2  3    'E'       :   BEGIN
01311      2  3 		 writeln(newfile, 'CURVE LOAD ' + arg);
01312      2  3 		 write_arg(arg);
01313      2  3 		 writeln(newfile, 'PLOT NEW ' + arg);
01314      2  3 		 writeln(newfile, 'DEFAULT');
01315      2  3 		 writeln(newfile, 'DEFAULT');
01316      2  3 		 writeln(newfile, 'DEFAULT');
01317      2  3 		 writeln(newfile, 'DEFAULT');
01318      2  3 		 writeln(newfile, 'DEFAULT');
01319      2  3 		 write_til_x;
01320      2  2 		 END;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   25
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01321      2  3    'S'       :   BEGIN
01322      2  3 		 writeln(newfile,'ANALYZE FREQUENCY_RESPONSE STAR');
01323      2  3 		 FOR i := 1 TO 12 DO
01324      2  4 		    BEGIN
01325      2  4 		    readstr;
01326      2  4 		    writeln(newfile,str);
01327      2  3 		    END;
01328      2  3                  writeln(newfile, 'X 0 0');
01329      2  3 		 writeln(newfile, 'DEFAULT');
01330      2  3 		 writeln(newfile, 'DEFAULT');
01331      2  3 		 writeln(newfile, 'DEFAULT');
01332      2  3 		 writeln(newfile, 'DEFAULT');
01333      2  3 	         writeln(newfile, 'DEFAULT');
01334      2  3 		 write_til_x;
01335      2  2 		 END;
01336      2  3    'B'        :  BEGIN
01337      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE BODE ');
01338      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01339      2  3 		 write_arg(arg);
01340      2  3 		 fr_readwrite(comm);
01341      2  2 		 END;
01342      2  3    'M'        :  BEGIN
01343      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE MAGNITUDE ');
01344      2  3                  writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01345      2  3 		 write_arg(arg);
01346      2  3 		 fr_readwrite(comm);
01347      2  2 		 END;
01348      2  3    'P'        :  BEGIN
01349      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE PHASE ');
01350      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01351      2  3 		 write_arg(arg);
01352      2  3 		 fr_readwrite(comm);
01353      2  2 		 END;
01354      2  3    'N'        :  BEGIN
01355      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE NYQUIST ');
01356      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01357      2  3 		 write_arg(arg);
01358      2  3 		 fr_readwrite(comm);
01359      2  2 		 END;
01360      2  3    'C'        :  BEGIN
01361      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE C-NICHOLS ');
01362      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01363      2  3 		 write_arg(arg);
01364      2  3 		 fr_readwrite(comm);
01365      2  2 		 END;
01366      2  3    'V'        :  BEGIN
01367      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE V-POPOV ');
01368      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01369      2  3 		 write_arg(arg);
01370      2  3 		 fr_readwrite(comm);
01371      2  2 		 END;
01372      2  3    'H'        :  BEGIN
01373      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE HERTZ ');
01374      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01375      2  3 		 write_arg(arg);

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   26
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01376      2  3 		 fr_readwrite(comm);
01377      2  2 		 END;
01378      2  3    'R'        :  BEGIN
01379      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE RADIANS_PER_SECOND ');
01380      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01381      2  3 		 write_arg(arg);
01382      2  3                  comm := '/DEFAULT';
01383      2  3 		 fr_readwrite(comm);
01384      2  2 		 END;
01385      2  3    'D'        :  BEGIN
01386      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE DB ');
01387      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01388      2  3 		 write_arg(arg);
01389      2  3                  comm := '/DEFAULT';
01390      2  3 		 fr_readwrite(comm);
01391      2  2 		 END;
01392      2  3    'A'        :  BEGIN
01393      2  3 		 writeln(newfile, 'SET FREQUENCY_RESPONSE AMPLITUDE ');
01394      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION '+arg);
01395      2  3 		 write_arg(arg);
01396      2  3                  comm := '/DEFAULT';
01397      2  3 		 fr_readwrite(comm);
01398      2  2 		 END;
01399      2  3    OTHERWISE     BEGIN
01400      2  3 		 writeln(newfile, 'ANALYZE FREQUENCY_RESPONSE EXPRESSION ' + arg);
01401      2  3 		 write_arg(arg);
01402      2  3                  comm := '/DEFAULT';
01403      2  3 		 fr_readwrite(comm);
01404      2  2 		 END;
01405      2  1 END;
01406      1  0 END;
01407   C  1  0 {-------------------------}
01408      2  0 PROCEDURE tr_write;
01409      2  1 BEGIN
01410      2  1 readstr;
01411      2  1 WHILE ((str <> 'W') AND (str <> 'E') AND (str <> 'X')) AND NOT eof(textfile) DO
01412      2  2    BEGIN
01413      2  2    writeln(newfile, str);
01414      2  2    readstr;
01415      2  1    END;
01416      2  1 writeln(newfile, 'X 0 0');
01417      2  1 writeln(newfile, 'DEFAULT');
01418      2  1 writeln(newfile, 'DEFAULT');
01419      2  1 writeln(newfile, 'DEFAULT');
01420      2  1 writeln(newfile, 'DEFAULT');
01421      2  1 writeln(newfile, str);
01422      2  1 write_til_x;
01423      1  0 END;
01424   C  1  0 {----------------------------}
01425      2  0 PROCEDURE Ctimer(VAR comm : comname; VAR arg : var80);
01426      2  1 BEGIN
01427      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;
01428      2  2 CASE comm[2] OF
01429      2  3    'O'       :   BEGIN
01430      2  3 		 writeln(newfile, 'PLOT NEW TR');

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   27
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01431      2  3                  writeln(newfile, 'DEFAULT');
01432      2  3 		 writeln(newfile, 'DEFAULT');
01433      2  3 		 write_til_x;
01434      2  2 		 END;
01435      2  3    'E'       :   BEGIN
01436      2  3 		 writeln(newfile, 'CURVE LOAD ' + arg);
01437      2  3 		 write_arg(arg);
01438      2  3 		 writeln(newfile, 'PLOT NEW ' + arg);
01439      2  3 		 writeln(newfile, 'DEFAULT');
01440      2  3 		 writeln(newfile, 'DEFAULT');
01441      2  3 		 write_til_x;
01442      2  2 		 END;
01443      2  3    'C'       :   BEGIN
01444      2  3 		 writeln(newfile, 'ANALYZE TIME_RESPONSE CLOSED_LOOP ' + arg);
01445      2  3 		 write_arg(arg);
01446      2  3 		 tr_write;
01447      2  2 		 END;
01448      2  3    'P'       :   BEGIN
01449      2  3 		 writeln(newfile, 'ANALYZE TIME_RESPONSE PLANT_SAMPLER ' + arg);
01450      2  3 		 write_arg(arg);
01451      2  3 		 tr_write;
01452      2  2 		 END;
01453      2  3    'F'       :   BEGIN
01454      2  3 		 writeln(newfile, 'ANALYZE TIME_RESPONSE FEEDBACK_SAMPLER ' + arg);
01455      2  3 		 write_arg(arg);
01456      2  3 		 tr_write; 
01457      2  2 		 END;
01458      2  3    OTHERWISE     BEGIN
01459      2  3 		 writeln(newfile, 'ANALYZE TIME_RESPONSE SIMPLE_SYSTEM ' + arg);
01460      2  3 		 write_arg(arg);
01461      2  3 		 tr_write;
01462      2  2 		 END;
01463      2  1 END;
01464      1  0 END;
01465   C  1  0 {----------------------------}
01466      2  0 PROCEDURE Cgredit(VAR comm : comname; VAR arg : var80);
01467      2  1 BEGIN
01468      2  1 readstr;
01469      2  1 writeln(newfile,'; The CGREDIT command is not converted. ');
01470      2  1 WHILE ((str[1] <> 'E') AND (str[1] <> 'X')) AND NOT eof(textfile) DO
01471      2  2    BEGIN
01472      2  2    readstr;
01473      2  2    writeln(newfile,'; ' + str);
01474      2  1    END;
01475      1  0 END;
01476   C  1  0 {----------------------------}
01477      2  0 PROCEDURE Clook(VAR comm : comname; VAR arg : var80);
01478      2  1 BEGIN
01479      2  1 writeln(newfile, 'VIEW AUDIT ' + arg);
01480      2  1 write_arg(arg);
01481      1  0 END;
01482   C  1  0 {----------------------------}
01483      2  0 PROCEDURE Cexit(VAR comm : comname; VAR arg : var80);
01484      2  1 BEGIN
01485      2  1 IF comm[1] <> '/' THEN comm := '/' + comm;

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   28
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01486      2  2 CASE comm[2] OF
01487      2  2    'S'       :   writeln(newfile, 'XIT SAVE_AUDIT_FILE');
01488      2  2    'P'       :   writeln(newfile, 'XIT PRINT_AUDIT_FILE');
01489      2  2    'D'       :   writeln(newfile, 'XIT DELETE_AUDIT_FILE');
01490      2  2    'B'       :   writeln(newfile, 'XIT BOTH_PRINT_DELETE');
01491      2  2    'R'       :   writeln(newfile, 'XIT REMOVE_OLD_VERSIONS');
01492      2  2    OTHERWISE     writeln(newfile, 'XIT');
01493      2  1 END; 
01494      1  0 END;
01495   C  1  0 {-----------------------------}
01496      2  0 FUNCTION namefromstr (VAR fname : name_type;  string : VARYING [l1] OF CHAR)
01497      2  0    : var80;
01498   C  2  0 { Purpose -- Convert character string into name.                   }
01499   C  2  0 {            Function result is "" if conversion is successful.    }
01500      2  0 VAR
01501      2  0    i         : integer;
01502      2  1 BEGIN
01503      2  1 namefromstr := '';
01504      2  1 fname := '';
01505      2  1 IF length(string) = 0
01506      2  1  THEN namefromstr := 'All blank field not allowed'
01507      2  1  ELSE 
01508      2  2   BEGIN
01509      2  2   WHILE index(string,' ') = 1 DO string := substr (string,2,length(string)-1);
01510      2  2   IF index (string,' ') <> 0
01511      2  2    THEN namefromstr := 'Blanks not allowed within name';
01512      2  2   IF NOT (string[1] IN ['A'..'Z']) 
01513      2  2    THEN namefromstr := 'Illegal character at start of name';
01514      2  2   FOR i := 1 TO length(string) DO
01515      2  2      IF NOT (string[i] IN ['A'..'Z','0'..'9','_'])
01516      2  2       THEN namefromstr := 'Illegal character "' + string[i] + '"'
01517      2  2       ELSE IF length(fname) < NAMESIZE 
01518      2  2        THEN fname := fname + string[i];
01519      2  1   END;
01520      1  0 END;
01521   C  1  0 {-------------------------------}
01522      2  0 PROCEDURE command ( VAR comnum,qualnum : integer;  line : VARYING [l3] OF char;
01523      2  0                     VAR arg : VARYING [l4] OF CHAR);
01524      2  0 VAR
01525      2  0    i,ic,ichold : integer;
01526      2  0    com,qual    : comname;
01527   C  2  0 {--------------------------------}
01528      3  0 PROCEDURE parse (VAR string : VARYING [l1] OF CHAR;  stop : charset);
01529      3  1 BEGIN
01530      3  1 IF length(line) >= ic
01531      3  1  THEN
01532      3  1   WHILE (line[imin(ic,length(line))] = ' ') AND (ic <=length(line)) DO 
01533      3  1      ic := ic+1;
01534      3  1 string := '';
01535      3  2 IF ic <= length(line) THEN REPEAT
01536      3  2    IF length(string) < l1 THEN string := string + line[ic];
01537      3  2    ic := ic + 1;
01538      3  1    UNTIL (ic > length(line)) OR (line[imin(ic,length(line))] IN stop);
01539      2  0 END;
01540   C  2  0 {--------------------------------------}

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   29
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01541      3  0 FUNCTION identify (cq : comname;  table : ARRAY [l2..u2:integer] OF comname;
01542      3  0    lo,hi : integer) : integer;
01543      3  0 VAR
01544      3  0    i,numok,perfect : integer;
01545      3  1 BEGIN
01546      3  1 numok := 0;
01547      3  1 perfect := 0;
01548      3  1 FOR i := lo TO hi DO
01549      3  2    BEGIN
01550      3  2    IF (index(table[i],cq) = 1) AND (index(cq,table[i]) = 1) 
01551      3  2     THEN perfect := i;
01552      3  2    IF (index(table[i],cq) = 1) AND (length(cq) > 0) 
01553      3  2     THEN BEGIN identify := i;  numok := numok+1;  END;
01554      3  1    END;
01555      3  1 IF numok <> 1 THEN identify := 0;
01556      3  1 IF perfect <> 0 THEN identify := perfect;
01557      2  0 END;
01558   C  2  0 {--------------------------------------}
01559      2  1 BEGIN  { COMMAND }
01560   C  2  1 { PARSE LINE }
01561      2  1 ic := 1;
01562      2  1 parse (com,[' ','/']);
01563      2  1 ichold := ic;
01564      2  1 parse (qual,[' ']);
01565      2  1 IF index (qual,'/') <> 1 THEN BEGIN  ic := ichold;  qual := '';  END;
01566      2  1 parse (arg,['}']);
01567   C  2  1 { IDENTIFY COMMAND AND QUALIFIER }
01568      2  1 comnum := identify (com,comtable,1,CTABLEN);
01569      2  1 qualnum := identify (qual,qualtable,firstqual[comnum],lastqual[comnum]);
01570      2  1 IF length(qual) = 0
01571      2  1  THEN qual := qualtable[0]
01572      2  1 ELSE IF qualnum = 0
01573      2  1  THEN comnum := 0;
01574   C  2  1 { PRINT FULL COMMAND } 
01575      2  1 IF length(com)<>length(comtable[comnum])
01576      2  1    THEN streq1 := false
01577      2  1    ELSE streq1 := com=comtable[comnum];
01578      2  1 IF length(qual)<>length(qualtable[qualnum])
01579      2  1    THEN streq2 := false
01580      2  1    ELSE streq2 := qual=qualtable[qualnum];
01581      1  0 END;
01582   C  1  0 {--------------------------------------}
01583      2  0 PROCEDURE loadtables;
01584      2  0 VAR
01585      2  0    comno,iqual   :  integer;
01586   C  2  0 {--------------------------------------}
01587      3  0 PROCEDURE setcom ( icom : integer;  ccom : comname);
01588      3  1 BEGIN
01589      3  1 comno := icom;
01590      3  1 comtable[comno] := ccom;
01591      3  1 firstqual[comno] := iqual+1;
01592      3  1 lastqual[comno] := iqual;
01593      2  0 END;
01594   C  2  0 {--------------------------------------}
01595      3  0 PROCEDURE loadqual (lqual : ARRAY [l1..u1:integer] OF comname);

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   30
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01596      3  0 VAR
01597      3  0    i : integer;
01598      3  1 BEGIN
01599      3  1 FOR i := l1 TO u1 DO 
01600      3  1    IF length(lqual[i]) >= 2
01601      3  1     THEN
01602      3  2      BEGIN
01603      3  2      iqual := iqual+1;
01604      3  2      qualtable[iqual] := lqual[i];
01605      3  1      END;
01606      3  1 lastqual[comno] := iqual;
01607      2  0 END;
01608   C  2  0 {--------------------------------------}
01609      2  1 BEGIN
01610      2  1 iqual := -1;
01611      2  1 setcom ( 0 , '____________________');
01612      2  1    loadqual (blankqual);
01613      2  1 setcom ( 1 , 'EDIT_FUNCTION');
01614      2  1    loadqual (editqual);
01615      2  1 setcom ( 2 , 'PRINT_FUNCTION');
01616      2  1    loadqual (editqual);
01617      2  1    loadqual (printqual);
01618      2  1 setcom ( 3 , 'TYPE_FUNCTION');
01619      2  1    loadqual (editqual);
01620      2  1    loadqual (printqual);
01621      2  1 setcom ( 4 , 'DELETE_FUNCTION');
01622      2  1    loadqual (delqual);
01623      2  1 setcom ( 5 , 'SHOW');
01624      2  1    loadqual (setqual);
01625      2  1    loadqual (qsetqual);
01626      2  1    loadqual (showqual);
01627      2  1    loadqual (qshowqual);
01628      2  1 setcom ( 6 , 'SET');
01629      2  1    loadqual (setqual);
01630      2  1    loadqual (qsetqual);
01631      2  1 setcom ( 7 , 'SAVE');
01632      2  1    loadqual (savequal);
01633      2  1 setcom ( 8 , 'UNSAVE');
01634      2  1    loadqual (unsavequal);
01635      2  1 setcom ( 9 , 'COMPUTE');
01636      2  1    loadqual (comqual);
01637      2  1 setcom (10 , 'TERMINAL');
01638      2  1    loadqual (termqual);
01639      2  1 setcom (11 , 'ROOT_LOCUS');
01640      2  1    loadqual (locusqual);
01641      2  1 setcom (12 , 'FREQUENCY_RESPONSE');
01642      2  1    loadqual (freqrqual);
01643      2  1 setcom (13 , 'TIME_RESPONSE');
01644      2  1    loadqual (timerqual);
01645      2  1 setcom (14 , 'GRAPHICS_EDIT');
01646      2  1 setcom (15 , 'LOOK_AT_AUDIT_FILE');
01647      2  1 setcom (16 , 'ERASE_SCREEN');
01648      2  1 setcom (17 , 'EXIT');
01649      2  1    loadqual (exitqual);
01650      2  1 setcom (18 , 'XIT');

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   31
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01651      2  1    loadqual (exitqual);
01652      1  0 END;
01653   C  1  0 {------------------------------------}
01654      2  0 PROCEDURE initial;
01655      2  0 TYPE
01656      2  0    str9              = VARYING [9] OF char;
01657      2  0 VAR
01658      2  0    comno,qualno,i,n  : integer;
01659      2  0    ix,iy             : integer;
01660      2  0    qual              : comname;
01661      2  0    found,displayed   : boolean;
01662      2  0    projects          : ARRAY [1..100] OF str9;
01663      2  0    string,commstring : var80;
01664      2  0    filename          : var80;
01665   C  2  0 {------------------------------------}
01666      2  1 BEGIN
01667   C  2  1 { INITIALIZE GLOBAL VARIABLES }
01668      2  1 loadtables;
01669      2  1 helpcommand := 'HELP/LIBRARY=INCAHOME:INCA.HLB';
01670      2  1 startclock  := clock; 
01671      2  1 hzs         := false;
01672      2  1 rad         := false;
01673      2  1 amp         := false;
01674      2  1 dbs         := false;
01675      1  0 END;
01676   C  1  0 {-----------------------------------}
01677      2  0 PROCEDURE principal;
01678      2  0 VAR
01679      2  0    comno,qualno       : integer;
01680      2  0    argname,argfile    : name_type;
01681      2  0    str8               : VARYING [8] OF char;
01682      2  0    arg,line           : var80;
01683      2  1 BEGIN   
01684      2  1 initial;
01685      2  1 WHILE NOT eof(textfile) DO
01686      2  2  BEGIN
01687      2  3   REPEAT
01688      2  3    readstr;
01689      2  3    line := str;
01690      2  3    command (comno,qualno,line,arg);
01691      2  3    IF (comno IN [5]) AND (qualno = 0) 
01692      2  3     THEN command (comno,qualno,comtable[comno] + ' /' + arg,arg);
01693      2  3    IF (comno = 0) AND (index (line,'=') <> 0) 
01694      2  3     THEN 
01695      2  3       IF length(line) < 76
01696      2  3         THEN
01697      2  4           BEGIN 
01698      2  4           line := 'COMP ' + line;
01699      2  4           command (comno,qualno,line,arg);
01700      2  3           END;
01701      2  3    namefromstr(argname,arg);
01702      2  3    argfile := substr(arg,1,imin(NAMESIZE,length(arg)));
01703   C  2  3 { THE CALLS TO THE PROCEDURES THAT WRITE OUT THE COMMANDS }
01704      2  4    CASE comno OF
01705      2  4       0:        Cotherwise;    

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   32
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01706      2  4       1:        Cedit      (qualtable[qualno], argname);
01707      2  4       2:        Cprint     (qualtable[qualno], argname); 
01708      2  4       3:        Ctype      (qualtable[qualno], argname); 
01709      2  4       4:        Cdelete    (qualtable[qualno], argname);
01710      2  4       5:        Cshow      (qualtable[qualno], arg);
01711      2  4       6:        Csetter    (qualtable[qualno], arg);
01712      2  4       7:        Csave      (qualtable[qualno], argfile);
01713      2  4       8:        Cunsave    (qualtable[qualno], argfile);
01714      2  4       9:        Ccompute   (qualtable[qualno], arg);
01715      2  4       10:       Cqsetterm   (qualtable[qualno], arg);
01716      2  4       11:       Clocus      (qualtable[qualno], arg);
01717      2  4       12:       Cfreqr      (qualtable[qualno], arg);
01718      2  4       13:       Ctimer      (qualtable[qualno], arg);
01719      2  4       14:       Cgredit     (qualtable[qualno], arg);
01720      2  4       15:       Clook       (qualtable[qualno], arg);
01721      2  4       16:       writeln     (newfile, 'ZAP_SCREEN');
01722      2  4       17:       Cexit       (qualtable[qualno], arg);
01723      2  4       18:       Cexit       (qualtable[qualno], arg);       
01724      2  4       OTHERWISE Cotherwise;
01725      2  3       END; 
01726      2  3 
01727      2  2    UNTIL (comno > CTABLEN-2) OR eof(textfile);
01728      2  1  END;
01729      1  0 END;
01730   C  1  0 {------------------------------------}
01731   C  1  0 { main begin for subroutine Convert_SOU_To_SOU  }
01732      1  1 BEGIN
01733      1  1 clearscreen;
01734      1  1 tempext := '.SOU';
01735      1  1 startfilesearch ('*.SOU');
01736      1  1 IF NOT endoffilesearch THEN
01737      1  2    BEGIN
01738      1  2    writeline(both,BLANK);
01739      1  2    writeline(both,' CONVERTING OLD .SOU FILES TO NEW .SOU FILES.');
01740      1  2    writeline(both,BLANK);
01741      1  2    alldo(tempext);
01742      1  2    END
01743      1  1    ELSE 
01744      1  2      BEGIN
01745      1  2      writeline(out, 'No .SOU files found.');
01746      1  2      IF NOT all THEN pause;
01747      1  1      END;
01748      1  1 WHILE NOT endoffilesearch DO
01749      1  2    BEGIN
01750      1  2    filesearch(line);
01751      1  2    IF upcasestr(fs.name) <> 'JOURNAL'
01752      1  2      THEN 
01753      1  3        BEGIN
01754      1  3        convertno(tempext);
01755      1  3        IF NOT noconvert 
01756      1  3          THEN
01757      1  4            BEGIN
01758      1  4            close(textfile,ERROR:=CONTINUE);
01759      1  4            close(newfile,ERROR:=CONTINUE);
01760      1  4            filename := fs.name + '.SOU';

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   33
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01761      1  4            open(textfile,filename,OLD,ERROR := CONTINUE);
01762      1  4            reset(textfile);
01763      1  4            IF NOT eof(textfile) 
01764      1  4              THEN
01765      1  5                BEGIN
01766      1  5                readln(textfile,str);
01767      1  5                IF str = ';This file has been converted to INCA 3.0 standards.'
01768      1  5                  THEN close(textfile,ERROR:=CONTINUE)
01769      1  5                  ELSE 
01770      1  6                    BEGIN
01771      1  6                    close(textfile,ERROR:=CONTINUE);
01772      1  6                    RENAME_FILE(filename,filename + 'OLD');
01773      1  6                    filename := filename + 'OLD';
01774      1  6                    newname  := fs.name + '.SOU';
01775      1  6                    open(textfile,filename,OLD,ERROR:=CONTINUE);
01776      1  6                    open(newfile,newname,NEW,ERROR:=CONTINUE);
01777      1  6                    reset(textfile);
01778      1  6                    rewrite(newfile);
01779      1  6                    writeln(newfile, ';This file has been converted to INCA 3.0 standards.');
01780      1  6                    IF NOT eof(textfile)
01781      1  6                      THEN principal;    { call to main procedure }
01782      1  6                    writeline(both,BLANK);
01783      1  6                    writeline(both,'The file ' + fs.name + ' has been converted to a new .SOU file.');
01784      1  6                    writeline(both,BLANK);
01785      1  6                    close(textfile,ERROR := CONTINUE);
01786      1  6                    close(newfile,ERROR  := CONTINUE);
01787      1  5                    END;
01788      1  4                END;
01789      1  3            END;          { end of noconvert }
01790      1  2        END;              { end of not journal file }
01791      1  1    END;                  { end of while loop }
01792      0  0 END;                     { end of procedure Convert_Sou_To_Sou }
01793   C  0  0 {-----------------------------------------------------------------------------}
01794      1  0 PROCEDURE Convertall;
01795      1  1 BEGIN
01796      1  1 all := true;
01797      1  1 Convert_WOR_To_PRO;
01798      1  1 Convert_LOC_To_RL;
01799      1  1 Convert_FRE_To_FR;
01800      1  1 Convert_TIR_To_TR;
01801      1  1 Convert_SOU_To_SOU;   
01802      0  0 END;
01803   C  0  0 {------------------------------------------------------------------------------}
01804      1  0 PROCEDURE convert;
01805   C  1  0 { This procedure calls five procedures that convert }
01806   C  1  0 { the old INCA files to new INCA files.             }
01807      1  0 VAR
01808      1  0    line,arg : anystring;
01809      1  0    com      : command_type;
01810      1  1 BEGIN
01811      1  1 all := false;
01812      1  1 startcommand ('CONVERT_INCA_200',true);
01813      1  1 setcommand ('All_INCA_files');
01814      1  1 setcommand ('FRE_files');
01815      1  1 setcommand ('LOC_files');

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   34
CONVERT                         Source Listing                  13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

-LINE-IDC-PL-SL-

01816      1  1 setcommand ('SOU_files');
01817      1  1 setcommand ('TIR_files');
01818      1  1 setcommand ('WOR_files');
01819      1  1 readcommand (com,ESC,false,'MISC CONVERT_INCA_200');
01820      1  2 CASE com[1] OF
01821      1  2    'A'       : Convertall;
01822      1  2    'F'       : Convert_FRE_To_FR;
01823      1  2    'L'       : Convert_LOC_To_RL;
01824      1  2    'S'       : Convert_SOU_To_SOU;
01825      1  2    'T'       : Convert_TIR_To_TR;
01826      1  2    'W'       : Convert_WOR_To_PRO;
01827      1  1    END; 
01828      0  0 END;
01829   C  0  0 {------------------------------------------------------------------------------}
01830      0  0 END.

CONVERT                                                         23-Dec-1988 10:54:41    VAX Pascal V3.7-254                Page   35
CONVERT                         Pascal Compilation Statistics   13-Jun-1988 11:08:15    DUA1:[QPLOT.INCA.SOURCE]CONVERT.PAS;44 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               44065  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                              19894  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        33        27
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        11        15
DUA1:[QPLOT.QPLOT.SOURCE]DIRECTORY.PEN;1                  45        34        76
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39        10        26
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        35        17
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         3         5
DUA1:[QPLOT.QPLOT.SOURCE]IOBASE.PEN;1                    104         8         8
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         9         6
DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PEN;1                     167       127        76
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289         1         0
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        64        26



SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:STRING',
00005      0  0                'QLIBHOME:COMPLEX',
00006      0  0                'QLIBHOME:IO',
00007      0  0                'POLYMATH','LONGREAL','FCNIO','FCN'), 
00008      0  0 ENVIRONMENT ('SCREENEDIT')]
00009      0  0 
00010      0  0 MODULE screenedit;
00011      0  0 
00012      0  0 CONST
00013      0  0    DASHS = 
00014      0  0 '------------------------------------------------------------------------------';
00015      0  0 TYPE 
00016      0  0    var132    = VARYING[132] OF char;
00017      0  0    var80     = VARYING[80]  OF char;
00018      0  0    var15     = VARYING[15]  OF char;
00019      0  0    name_type = VARYING[30]  OF char;
00020   C  0  0 {------------------------------------------------------------------------------}
00021      0  0 
00022      1  0 PROCEDURE copyfcn(VAR infn : FCN);
00023      1  0 VAR
00024      1  0    string : VARYING[132] OF char;
00025      1  1 BEGIN
00026      1  1 rewrite(tempfile);
00027      1  1 writefcn(temp,infn,'R');
00028      1  1 close(textfile,ERROR:=CONTINUE);
00029      1  1 open(textfile,'INCAFCN.TXT',NEW);
00030      1  1 rewrite(textfile);
00031      1  1 reset(tempfile);
00032      1  1 WHILE NOT eof(tempfile) DO
00033      1  2   BEGIN
00034      1  2   readln(tempfile,string);
00035      1  2   writeln(textfile,string);
00036      1  1   END;
00037      1  1 close(textfile);
00038      0  0 END;
00039   C  0  0 {------------------------------------------------------------------------------}
00040      1  0 PROCEDURE compilefcn(filename : VARYING[l1] OF char; VAR good : boolean);
00041      1  0 VAR
00042      1  0    tempfile : text;
00043      1  0    string   : var132;
00044      1  0    partstr  : var132;
00045      1  0    fn       : fcn;
00046      1  0    fname    : logicalname;
00047      1  0    scan     : parse_type;
00048      1  0    fatalerr : boolean;
00049      1  0 
00050   C  1  0 {-------------------------------------}
00051      2  0 FUNCTION indexerr(string : var132) : integer;
00052      2  1 BEGIN
00053      2  1 indexerr := index(string,'<Error>') + index(string,'<Warning>');
00054      1  0 END;
00055   C  1  0 {-------------------------------------}

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00056      2  0 PROCEDURE readline(VAR string : var132);
00057      2  1 BEGIN
00058      2  1 IF NOT eof(textfile)
00059      2  1   THEN
00060      2  2     BEGIN
00061      2  2     readln(textfile, string);
00062      2  2     WHILE (indexerr(string) > 0) AND NOT eof(textfile) DO
00063      2  2       readln(textfile, string);
00064      2  2     IF indexerr(string) > 0 
00065      2  2       THEN string := '';
00066      2  1     END;
00067      1  0 END; 
00068   C  1  0 {-------------------------------------}
00069      2  0 PROCEDURE writeline(string : var132);
00070      2  1 BEGIN
00071      2  1 writeln(tempfile,string);
00072      1  0 END;
00073   C  1  0 {-------------------------------------}
00074      2  0 PROCEDURE checkend;
00075      2  1 BEGIN
00076      2  1 WHILE NOT eof(textfile) DO
00077      2  2   BEGIN 
00078      2  2   readline(string);
00079      2  2   writeln(tempfile,string);
00080      2  1   END;
00081      1  0 END;
00082   C  1  0 {-------------------------------------}
00083      2  0 PROCEDURE pullerrors;
00084      2  1 BEGIN
00085      2  1 rewrite(textfile);
00086      2  1 reset(tempfile);
00087      2  1 WHILE NOT eof(tempfile) DO
00088      2  2    BEGIN
00089      2  2    readln(tempfile,string);
00090      2  2    IF NOT good 
00091      2  2      THEN writeln(textfile,string)
00092      2  2      ELSE IF indexerr(string) = 0
00093      2  2             THEN writeln(textfile,string);
00094      2  1    END;
00095      2  1 close(tempfile,DISPOSITION:=DELETE,ERROR:=CONTINUE);
00096      2  1 close(textfile,ERROR:=CONTINUE);
00097      1  0 END;
00098   C  1  0 {-------------------------------------}
00099      2  0 PROCEDURE writerr(errx : integer);
00100      2  0 VAR 
00101      2  0    noprint : boolean;
00102      2  0    errstr  : var80;
00103      2  0 
00104   C  2  0 {--------------------}
00105      3  0 PROCEDURE printerr(errstr : var80);
00106      3  1 BEGIN
00107      3  1 writeln(tempfile,'<<Error>> ' + errstr);
00108      3  1 writeln(tempfile,'');
00109      2  0 END;
00110   C  2  0 {--------------------}

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00111      2  0 
00112      2  1 BEGIN
00113      2  1 noprint := false;
00114      2  2 CASE errx OF 
00115      2  2   1 : errstr := 'Illegal name. Characters must be alpha-numeric or _.';
00116      2  2   2 : errstr := 'Function must be named.';
00117      2  2   3 : errstr := 'Illegal function name field. ex:  Function name  = EXAMPLE';
00118      2  2   4 : errstr := 'Illegal Comment field. ex: Comment: This part is not necessary.';
00119      2  2   5 : errstr := 'Improper plane.  INCA supports S, Z, W, and K planes only.'; 
00120      2  2   6 : errstr := 'Improper plane format.  ex:  Function plane = S';
00121      2  2   7 : errstr := 'Gain must be a real number.';
00122      2  2   8 : errstr := 'Improper Gain format.  ex:  Gain =  1.00000000000000';
00123      2  2   9 : errstr := 'Sample Period must be a real number.';
00124      2  2  10 : errstr := 'Improper Sample Period format.  ex:  Sample Period =  0.10000';
00125      2  2  11 : errstr := 'Improper root format. ';
00126      2  2  12 : errstr := 'Number of distinct factors must be an integer.';
00127      2  2  13 : errstr := 'Number of distinct roots exceeds specified amount.';
00128      2  2  14 : errstr := 'Number of distinct roots less than specified amount.';
00129      2  2  15 : errstr := 'Order of polynomial must be less than or equal to 100. ';
00130      2  2  16 : errstr := 'Root must be a complex number. ';
00131      2  2  17 : errstr := 'Complex conjugate not found.';
00132      2  2  18 : errstr := 'Improper factor format.  ex:  S= - 1.00  -j* 1.00  Order =  1';
00133      2  2  19 : errstr := 'Order of polynomial must be an integer.';
00134      2  2  20 : errstr := 'DENOMINATOR expected.';
00135      2  1  END;
00136      2  1 IF NOT noprint
00137      2  1   THEN printerr(errstr); 
00138      2  1 errx := 0;
00139      2  1 good := false;
00140      1  0 END;
00141   C  1  0 {-------------------------------------}
00142      2  0 PROCEDURE compilecspoly (VAR c : cspoly;  numerator : boolean);
00143      2  0 VAR
00144      2  0    counter,j,orde,cnt  : integer;
00145      2  0    nextkey,minus,first : boolean;
00146      2  0    compneg1,compneg2   : boolean;
00147      2  0    tempstr             : var132;
00148      2  0    prevorde            : integer;
00149      2  0    z,y                 : complex;
00150      2  0 
00151   C  2  0 {---------------------}
00152      3  0 PROCEDURE getnum(VAR i : integer; VAR minus : boolean);
00153      3  0 VAR
00154      3  0    looking : boolean;
00155      3  1 BEGIN
00156      3  1 partstr := '';
00157      3  1 minus   := false;
00158      3  1 looking := true;
00159      3  1 WHILE (looking) AND (i <= length(string)) DO 
00160      3  2   BEGIN
00161      3  2   IF string[i] = '-'
00162      3  2     THEN minus := true;
00163      3  2   IF string[i] IN ['0'..'9','.']
00164      3  2     THEN looking := false
00165      3  2     ELSE i := succ(i);

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00166      3  1   END;
00167      3  1 WHILE NOT looking DO
00168      3  2   BEGIN
00169      3  2   partstr := partstr + string[i];
00170      3  2   IF (string[i] = ' ') OR (i = length(string))
00171      3  2     THEN looking := true
00172      3  2     ELSE i := succ(i);
00173      3  1   END;
00174      2  0 END;
00175   C  2  0 {---------------------}
00176      3  0 PROCEDURE getreal;
00177      3  0 VAR
00178      3  0    i       : integer;
00179      3  0    flagnum : boolean;
00180      3  1 BEGIN
00181      3  1 j := 1;
00182      3  1 z.re := 0;
00183      3  1 flagnum := false;
00184      3  1 j := index(string,'J');
00185      3  1 IF j <> 0
00186      3  1   THEN
00187      3  2     BEGIN
00188      3  2     FOR i := 1 TO j DO
00189      3  2       IF string[i] IN ['0'..'9'] 
00190      3  2         THEN flagnum := true;
00191      3  2     IF NOT flagnum
00192      3  2       THEN counter := succ(counter);
00193      3  2     END
00194      3  1   ELSE flagnum := true;
00195      3  1 j := 1;
00196      3  1 IF flagnum
00197      3  1   THEN
00198      3  2     BEGIN
00199      3  2     getnum(j,minus);
00200      3  2     IF partstr <> ''
00201      3  2       THEN
00202      3  3         BEGIN
00203      3  3         z.re := rofstr(partstr);
00204      3  3         IF NOT goodconvert
00205      3  3           THEN writerr(18)
00206      3  3           ELSE
00207      3  4             BEGIN
00208      3  4             counter := counter + 1;
00209      3  4             IF minus
00210      3  4               THEN z.re := -z.re;
00211      3  3             END;
00212      3  3         END
00213      3  2       ELSE writerr(11);
00214      3  1     END;
00215      2  0 END;
00216   C  2  0 {---------------------}
00217      3  0 PROCEDURE getimag;
00218      3  1 BEGIN
00219      3  1 z.im := 0;
00220      3  1 compneg1 := false;

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00221      3  1 IF index(string,'J') > j
00222      3  1   THEN
00223      3  2     BEGIN
00224      3  2     WHILE string[j] <> 'J' DO
00225      3  3       BEGIN
00226      3  3       IF string[j] = '-'
00227      3  3         THEN compneg1 := true;
00228      3  3       j  := j + 1;
00229      3  2       END;
00230      3  2     getnum(j,minus);
00231      3  2     IF partstr <> ''
00232      3  2       THEN
00233      3  3         BEGIN
00234      3  3         z.im := rofstr(partstr);
00235      3  3         IF NOT goodconvert
00236      3  3           THEN writerr(18)
00237      3  3           ELSE
00238      3  4             BEGIN
00239      3  4             IF minus
00240      3  4               THEN z.im := -z.im;
00241      3  4             IF compneg1
00242      3  4               THEN z.im := -z.im;
00243      3  3             END;
00244      3  3         END
00245      3  2       ELSE writerr(16);
00246      3  1     END;
00247      2  0 END;
00248   C  2  0 {---------------------}
00249      3  0 PROCEDURE getorde;
00250      3  1 BEGIN
00251      3  1 orde := 1;
00252      3  1 IF index(string,'ORDER') <> 0
00253      3  1   THEN
00254      3  2     BEGIN
00255      3  2     getnum(j,minus);
00256      3  2     IF partstr <> ''
00257      3  2       THEN
00258      3  3         BEGIN
00259      3  3         orde := iofstr(partstr);
00260      3  3         IF NOT goodconvert
00261      3  3           THEN writerr(19)
00262      3  3           ELSE IF orde > 100
00263      3  3              THEN writerr(15);
00264      3  3         END     
00265      3  2         ELSE writerr(19);
00266      3  1     END;  
00267      2  0 END;
00268   C  2  0 {---------------------}
00269      3  0 PROCEDURE setrest(VAR z : complex);
00270      3  1 BEGIN
00271      3  1 z := cneg(z);
00272      3  1 IF z.im >= 0
00273      3  1   THEN
00274      3  2     BEGIN
00275      3  2     c.deg := c.deg + 1;

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00276      3  2     WITH c.f[c.deg] DO
00277      3  3       BEGIN
00278      3  3       v := z;
00279      3  3       IF numerator
00280      3  3         THEN p := orde
00281      3  3         ELSE p := -orde;
00282      3  2       END;
00283      3  1     END;
00284      2  0 END;
00285   C  2  0 {---------------------}
00286      3  0 PROCEDURE writeconjugate;
00287      3  1 BEGIN
00288      3  1 counter := succ(counter);
00289      3  1 partstr := strofi(prevorde,3);
00290      3  1 IF compneg2
00291      3  1   THEN  write(tempfile,'  ',fn.plane,'=    ',y.re,'      j* ',y.im)
00292      3  1   ELSE  write(tempfile,'  ',fn.plane,'=    ',y.re,'    - j* ',y.im);
00293      3  1 writeln(tempfile,'        Order =',partstr);
00294      3  1 writeln(tempfile,'<<Warning>>  Complex conjugate added.');
00295      3  1 writeln(tempfile,'');
00296      3  1 good := false;
00297      2  0 END;
00298   C  2  0 {---------------------}
00299      2  1 BEGIN
00300      2  1 counter := 0;
00301      2  1 y.re    := 0;
00302      2  1 y.im    := 0;
00303      2  1 nextkey := false;
00304      2  1 first   := false;
00305      2  1 partstr := '';
00306      2  1 FOR j := 1 TO length(string) DO
00307      2  1    IF string[j] IN ['0'..'9']
00308      2  1      THEN partstr := partstr + string[j];
00309      2  1 IF partstr = ''
00310      2  1   THEN writerr(12)
00311      2  1   ELSE cnt := iofstr(partstr);
00312      2  1      IF NOT goodconvert
00313      2  1        THEN writerr(12);
00314      2  1 
00315      2  1 WHILE (NOT nextkey) AND  (NOT eof(textfile))  DO 
00316      2  2   BEGIN
00317      2  2   readline(string);
00318      2  2   tempstr := string;
00319      2  2   string := upcasestr(string);
00320      2  2   IF index(string,'DENOMINATOR') <> 0
00321      2  2     THEN
00322      2  3       BEGIN
00323      2  3       nextkey := true;
00324      2  3       string  := tempstr;
00325      2  3       END
00326      2  2     ELSE
00327      2  3       BEGIN
00328      2  3       IF NOT first
00329      2  3         THEN writeline(tempstr);
00330      2  3       IF (string <> '') AND (string <> DASHS)

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00331      2  3         THEN
00332      2  4           BEGIN
00333      2  4           getreal;
00334      2  4           getimag;
00335      2  4           getorde;
00336      2  4           IF first
00337      2  4             THEN
00338      2  5               BEGIN
00339      2  5               IF (z.re = y.re) AND (z.im = y.im)
00340      2  5                 THEN first := false
00341      2  5                 ELSE
00342      2  6                   BEGIN
00343      2  6                   IF NOT compneg2
00344      2  6                     THEN 
00345      2  6                       IF (z.re = y.re) AND (z.im = -y.im)
00346      2  6                        THEN first := false
00347      2  6                        ELSE { need to write conjugate }
00348      2  7                          BEGIN
00349      2  7                          writeconjugate;
00350      2  7                          y.im := -y.im;
00351      2  7                          setrest(y);
00352      2  7                          first := false;
00353      2  7                          IF index(string,'J') <> 0
00354      2  7                            THEN first := true;
00355      2  7                          END
00356      2  6                     ELSE
00357      2  7                       BEGIN
00358      2  7                       writeconjugate;
00359      2  7                       setrest(y);
00360      2  7                       first := false;
00361      2  7                       IF index(string,'J') <> 0
00362      2  7                         THEN first := true;
00363      2  6                       END;
00364      2  5                   END; 
00365      2  5               writeline(tempstr);
00366      2  5               END
00367      2  4             ELSE
00368      2  5               BEGIN
00369      2  5               IF index(string,'J') <> 0 
00370      2  5                 THEN first := true;
00371      2  4               END;
00372      2  4           y.re := z.re;
00373      2  4           IF z.im < 0
00374      2  4             THEN  y.im := -z.im
00375      2  4             ELSE  y.im := z.im;
00376      2  4           compneg2 := compneg1;
00377      2  4           prevorde := orde;
00378      2  4           IF goodconvert AND good
00379      2  4             THEN setrest(z);
00380      2  3           END;   { end of non nil string }
00381      2  2       END;          
00382      2  1   END;    { end of while loop }
00383      2  1 IF first
00384      2  1   THEN writeconjugate;
00385      2  1 IF counter <> cnt 

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00386      2  1   THEN
00387      2  2     BEGIN
00388      2  2     partstr := strofi(counter,2);
00389      2  2     write(tempfile,'<<Error>>  Number of distinct roots,' + partstr);
00390      2  2     partstr := strofi(cnt,2);
00391      2  2     IF counter > cnt
00392      2  2       THEN writeln(tempfile,', exceeds specified amount,' + partstr + '.')
00393      2  2       ELSE writeln(tempfile,', less than specified amount,' + partstr + '.');
00394      2  2     writeln(tempfile,'');
00395      2  2     good := false;
00396      2  1     END;     
00397      2  1 first := false;
00398      1  0 END;
00399   C  1  0 {-------------------------------------}
00400      2  0 PROCEDURE startup;
00401      2  1 BEGIN
00402      2  1 fatalerr := false;
00403      2  1 good := true;
00404      2  1 close(tempfile,ERROR:=CONTINUE);
00405      2  1 open(textfile,filename,OLD,ERROR:=CONTINUE);
00406      2  1 open(tempfile,'INCATEMP.TXT',NEW);
00407      2  1 rewrite(tempfile);
00408      2  1 reset(textfile);
00409      1  0 END;
00410   C  1  0 {-------------------------------------}
00411      2  0 PROCEDURE trimstr(key : var15);
00412      2  0 VAR
00413      2  0   i       : integer;
00414      2  0   ind     : integer;
00415      2  1 BEGIN
00416      2  1 partstr := '';
00417      2  1 IF index(string,'=') <> 0
00418      2  1   THEN key := '=';
00419      2  1 ind := index(string,key) + length(key);
00420      2  1 IF length(string) > ind 
00421      2  1   THEN 
00422      2  1     FOR i := ind  TO  length(string)   DO
00423      2  1       IF string[i] <> ' '
00424      2  1         THEN partstr := partstr + string[i];
00425      1  0 END;
00426   C  1  0 {-------------------------------------}
00427      2  0 PROCEDURE evalstr(key : var15; keyno : integer);
00428      2  1 BEGIN
00429      2  1 IF keyno <> 2
00430      2  1   THEN 
00431      2  1     string := upcasestr(string);
00432      2  1 startparse(scan,string);
00433      2  2 CASE keyno OF
00434      2  3   1  : BEGIN
00435      2  3        trimstr(key);
00436      2  3        IF partstr = '' 
00437      2  3          THEN writerr(2)
00438      2  3           ELSE 
00439      2  4             BEGIN
00440      2  4             namefromstr(fname,partstr);

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00441      2  4             IF (NOT goodconvert) OR (fname = '')
00442      2  4               THEN writerr(1)
00443      2  4               ELSE fn.name := fname;
00444      2  4             fn.storage := 0;
00445      2  4             fn.time := strtime;
00446      2  3             END; 
00447      2  2        END;
00448      2  3   2  : BEGIN
00449      2  3        partstr := parse(scan,' ');
00450      2  3        fn.comment := parse(scan,'');
00451      2  2        END;
00452      2  3   3  : BEGIN
00453      2  3        IF key = 'ROOTED'
00454      2  3          THEN fn.fcntype := FCT
00455      2  3          ELSE fn.fcntype := DYN;
00456      2  2        END;  
00457      2  3   4  : BEGIN
00458      2  3        trimstr(key);
00459      2  3        IF partstr = ''
00460      2  3          THEN writerr(5)
00461      2  3          ELSE
00462      2  4            BEGIN
00463      2  4            IF partstr[1] in ['Z','S','W','K']
00464      2  4              THEN
00465      2  4                fn.plane := partstr[1]           
00466      2  4              ELSE
00467      2  4                writerr(5);
00468      2  3             END;   
00469      2  2        END;
00470      2  3   5  : BEGIN
00471      2  3        trimstr(key);
00472      2  3        IF partstr = ''
00473      2  3          THEN writerr(7)
00474      2  3          ELSE
00475      2  4            BEGIN
00476      2  4            fn.gain := lofstr(partstr);
00477      2  4            IF NOT goodconvert
00478      2  4              THEN writerr(7);
00479      2  3            END;
00480      2  2        END;
00481      2  3   6  : BEGIN
00482      2  3        trimstr(key);
00483      2  3        IF partstr = ''
00484      2  3          THEN writerr(9)
00485      2  3          ELSE
00486      2  4            BEGIN
00487      2  4            fn.tau := rofstr(partstr);
00488      2  4            IF NOT goodconvert
00489      2  4              THEN writerr(9);
00490      2  3            END;
00491      2  2        END;
00492      2  3   7  : BEGIN
00493      2  3        fn.ro.deg := 0;
00494      2  3        compilecspoly(fn.ro,true); {return if eof or denom found}
00495      2  3        IF eof(textfile)

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00496      2  3          THEN 
00497      2  4            BEGIN
00498      2  4            good     := false;
00499      2  4            fatalerr := true;
00500      2  4            writerr(20);
00501      2  4            END
00502      2  3          ELSE
00503      2  4            BEGIN
00504      2  4            writeline(string);
00505      2  4            compilecspoly(fn.ro,false);
00506      2  3            END;
00507      2  2        END;
00508      2  1 END;
00509      1  0 END;
00510   C  1  0 {-------------------------------------}
00511      2  0 PROCEDURE checkstr(VAR key1, key2 : var15; VAR foundkey : boolean);
00512      2  1 BEGIN
00513      2  1 IF index(upcasestr(string),key1) <> 0
00514      2  1   THEN foundkey := true
00515      2  1   ELSE IF key2 <> ''
00516      2  1          THEN IF index(string,key2) <> 0
00517      2  1                THEN
00518      2  2                  BEGIN
00519      2  2                  key1 := key2;
00520      2  2                  foundkey := true;
00521      2  1                  END;
00522      1  0 END;
00523   C  1  0 {-------------------------------------}
00524      2  0 PROCEDURE keyword(key1 : var15; key2 : var15; keyno : integer);
00525      2  0 VAR
00526      2  0   twokeys : boolean;
00527      2  0   foundkey : boolean;
00528      2  1 BEGIN
00529      2  1 IF NOT fatalerr
00530      2  1   THEN 
00531      2  2     BEGIN
00532      2  2     foundkey := false;
00533      2  2     WHILE NOT eof(textfile) AND NOT foundkey DO
00534      2  3       BEGIN
00535      2  3       readline(string);
00536      2  3       writeline(string);
00537      2  3       checkstr(key1,key2,foundkey);
00538      2  2       END;
00539      2  2     IF foundkey
00540      2  2       THEN evalstr(key1,keyno)
00541      2  2       ELSE
00542      2  3         BEGIN
00543      2  3         fatalerr := true;
00544      2  3         good     := false;
00545      2  3         IF key2 = ''
00546      2  3           THEN writeln(tempfile,'<<Error>>  ' + key1 +  '  expected.')
00547      2  3           ELSE writeln(tempfile,'<<Error>>  '+ key1+' or '+ key2+'  expected.');
00548      2  3         writeln(tempfile,'');
00549      2  2         END; 
00550      2  1     END;

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

-LINE-IDC-PL-SL-

00551      1  0 END;
00552   C  1  0 {-------------------------------------}
00553      1  1 BEGIN { begin for proc compilefcn }
00554      1  1 startup;
00555      1  1 keyword('NAME','',1);
00556      1  1 keyword('COMMENT','',2);
00557      1  1 keyword('ROOTED','DYNAMIC',3);
00558      1  2 CASE fn.fcntype OF 
00559      1  3    FCT :  BEGIN
00560      1  3           keyword('PLANE','',4);
00561      1  3           keyword('GAIN','',5);
00562      1  3           IF fn.plane IN ['Z','W']
00563      1  3             THEN keyword('PERIOD','',6);
00564      1  3           keyword('NUMERATOR','',7);
00565      1  2           END;
00566      1  3    DYN :  BEGIN
00567      1  3           fn.val := '';
00568      1  4           REPEAT
00569      1  4             readline(string);
00570      1  4             writeline(string);
00571      1  4             IF (string <> '') AND (string <> DASHS)
00572      1  4               THEN fn.val := fn.val + string;
00573      1  4             UNTIL eof(textfile)
00574      1  2           END;
00575      1  1   END; 
00576      1  1 checkend;
00577      1  1 pullerrors;
00578      1  1 IF good
00579      1  1   THEN 
00580      1  1     copyfcn(fn);
00581      0  0 END;
00582   C  0  0 {---------------------------------------------------------------------------}
00583      1  0 PROCEDURE screeneditfcn (VAR infn : fcn);
00584      1  0 VAR
00585      1  0    good : boolean;
00586      1  0    line : anystring;
00587      1  0 
00588      1  1 BEGIN     {main begin for screeneditfcn}
00589      1  1 copyfcn(infn);
00590      1  1 good := true;
00591      1  2 REPEAT
00592      1  2    editfile ('INCAFCN.TXT');
00593      1  2    compilefcn('INCAFCN.TXT',good);
00594      1  1    UNTIL good;
00595      1  1 open (textfile,'INCAFCN.TXT',OLD,DISPOSITION:=DELETE);
00596      1  1 reset (textfile);
00597      1  1 readfcn (textfile,infn);
00598      1  1 close (textfile);
00599      1  1 LIB$SPAWN ('DELETE INCAFCN.*;*');
00600      0  0 END;
00601   C  0  0 {============================================================================}
00602      0  0 END.

SCREENEDIT                                                      23-Dec-1988 10:58:06    VAX Pascal V3.7-254                Page   12
INCA                            Pascal Compilation Statistics   23-Oct-1987 15:12:55    [QPLOT.INCA.SOURCE]SCREENEDIT.PAS;1 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               11145  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260         4         2
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        32        26
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        41        57
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         7        11
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        17         8
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        12         7
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         7        10
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        78        42
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        64        26



EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:STRING',
00005      0  0                'QLIBHOME:MATH',
00006      0  0                'QLIBHOME:COMPLEX',
00007      0  0                'QLIBHOME:FIG',
00008      0  0                'QLIBHOME:UTILITIES',
00009      0  0                'QLIBHOME:IO',
00010      0  0                'QLIBHOME:PLOT',
00011      0  0                'POLYMATH','LONGREAL','FCNIO','FCN','UTIL','SCREENEDIT'), 
00012      0  0   ENVIRONMENT ('EDIT')]
00013      0  0 MODULE edit;
00014      0  0 [ HIDDEN ] VAR
00015      0  0    format     : char;
00016      0  0    width      : real := 0.01d0;
00017      0  0 [ HIDDEN ] VAR
00018      0  0    editframe  : [ VOLATILE ] frame_type
00019      0  0                   := ((false,1,'REAL','',true,false,0,65535,0,0,0,0,
00020      0  0                          false,'XTICK','XSUBTICK',
00021      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00022      0  0                       (false,1,'IMAG','',true,false,2000,46000,0,0,0,0,
00023      0  0                          false,'YTICK','YSUBTICK',
00024      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00025      0  0                       'EDIT',
00026      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00027      0  0                       false,false,NIL,0,true,false,false,1024,640,7,65,65,
00028      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00029   C  0  0 {-----------------------------------------------------------------------------}
00030      0  0 [ HIDDEN, INITIALIZE ]
00031      1  0 PROCEDURE addeditframe;
00032      1  1 BEGIN
00033      1  1 addtemplate (address (editframe));
00034      0  0 END;
00035   C  0  0 {=============================================================================}
00036   C  0  0 {-- GREDIT COMMAND -----------------------------------------------------------}
00037   C  0  0 {=============================================================================}
00038      0  0 [ HIDDEN ] 
00039      1  0 PROCEDURE greditmenu;
00040      1  1 BEGIN
00041      1  1 newline;  grprint('GRAPHICS MODE COMMANDS (GRAPHIC EDITOR)');
00042      1  1 newline;  
00043      1  1 newline;  grprint('Use first letter of command to select');
00044      1  1 newline;  
00045      1  1 newline;  grprint('Add      -- Add zero or pole');
00046      1  1 newline;  grprint('     Pole     -- Add pole');
00047      1  1 newline;  grprint('     Zero     -- Add zero');
00048      1  1 newline;  grprint('BackZoom -- Return to previous zoom view');
00049      1  1 newline;  grprint('Comment  -- Change comment');
00050      1  1 newline;  grprint('DeZoom   -- Replot function in original scale');
00051      1  1 newline;  grprint('Exit     -- Return to main commands');
00052      1  1 newline;  grprint('Fix fcn  -- Fix function roots to grid');
00053      1  1 newline;  grprint('Gain     -- Change gain');
00054      1  1 newline;  grprint('Help     -- Display this menu');
00055      1  1 newline;  grprint('Keyboard -- Enter zoom coordinates from keyboard');

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00056      1  1 newline;  grprint('Lower    -- Cursor at lower left coords. for zoom');
00057      1  1 newline;  grprint('Name     -- Change name of function');
00058      1  1 newline;  grprint('Plane    -- Change plane (domain)');
00059      1  1 newline;  grprint('Q-square -- Square zoom area');
00060      1  1 newline;  grprint('Redraw   -- Redraw plot with current scale');
00061      1  1 newline;  grprint('Samp. Per-- Change sample period');
00062      1  1 newline;  grprint('Type Fcn -- Type function description at cursor');
00063      1  1 newline;  grprint('Upper    -- Cursor at upper right coord. for zoom');
00064      1  1 newline;  grprint('Width    -- Set width of rounding grid');
00065      1  1 newline;  grprint('X-it     -- Return to main commands');
00066      1  1 newline;  grprint('Zoom     -- Zoom to coords. given by U, L, K');
00067      1  1 newline;  grprint('2-9      -- Widen window by factor indicated');
00068      1  1 newline;  grprint('$-options-- Allows access to UTILITIES commands');
00069      1  1 newline;  grprint('%        -- Hardcopy');
00070      1  1 newline;  
00071      1  1 newline;  grprint('            3 BEEPS means command not executed');
00072      0  0 END;
00073   C  0  0 {-----------------------------------------------------------------------------}
00074      0  0 [ HIDDEN ] 
00075      1  0 PROCEDURE cspolyfix (VAR v : cspoly);
00076      1  0 VAR
00077      1  0    i,j         : integer;
00078      1  1 BEGIN
00079      1  1 FOR i := 1 TO v.deg DO 
00080      1  1    v.f[i].v.re := round (v.f[i].v.re / width) * width;
00081      1  1 
00082      1  1 FOR i := 1 TO v.deg DO
00083      1  1    FOR j := i+1 TO v.deg DO
00084      1  1       IF cabsdif (v.f[i].v,v.f[j].v) <= width / 2
00085      1  1        THEN BEGIN  v.f[i].p := v.f[i].p + v.f[j].p;  v.f[j].p := 0;  END;
00086      0  0 END;
00087   C  0  0 {-----------------------------------------------------------------------------}
00088      0  0 [ HIDDEN ]
00089      1  0 PROCEDURE readcomment (VAR comment : VARYING [l1] OF char;
00090      1  0    def : VARYING [l2] OF char);
00091      1  1 BEGIN
00092      1  1 IF index (def,chr(0)) <> 1 
00093      1  1  THEN 
00094      1  2   BEGIN
00095      1  2   writeline (out,'Current comment is     : ' + def);
00096      1  2   def := '';  
00097      1  1   END;
00098      1  1 readvary ('ENTER COMMENT          : ',comment,def);
00099      0  0 END;
00100   C  0  0 {-----------------------------------------------------------------------------}
00101      0  0 [ HIDDEN ]
00102      1  0 PROCEDURE readgain (VAR gain : longreal;  def : longreal);
00103      1  1 BEGIN
00104      1  2 CASE format OF
00105      1  2    'R','F','Z','P',
00106      1  3    'D':  BEGIN
00107      1  3          IF def <> UNDEFINED_LONGREAL
00108      1  3           THEN writeline (out,'Current gain is        : ' + strofl(def,0))
00109      1  3           ELSE def := 1;  
00110      1  3          readlongreal ('ENTER GAIN             : ',gain,-LONGBIG,LONGBIG,def);

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00111      1  2          END;
00112      1  2    'B',
00113      1  3    'G':  BEGIN
00114      1  3          IF def <> UNDEFINED_LONGREAL
00115      1  3           THEN writeline (out,'Current bode gain is   : ' + strofl(def,0))
00116      1  3           ELSE def := 1;  
00117      1  3          readlongreal ('ENTER BODE GAIN        : ',gain,-LONGBIG,LONGBIG,def);
00118      1  2          END;
00119      1  2    'U':  IF def <> UNDEFINED_LONGREAL
00120      1  2           THEN 
00121      1  3            BEGIN
00122      1  3            writeline (out,'Current gain is        : ' + strofl(def,0));
00123      1  3            readlongreal ('ENTER GAIN             : ',gain,-LONGBIG,LONGBIG,def);
00124      1  3            END
00125      1  2           ELSE gain := 1;  
00126      1  1    END;
00127      0  0 END;
00128   C  0  0 {-----------------------------------------------------------------------------}
00129      0  0 [ HIDDEN ]
00130      1  0 PROCEDURE readtau (VAR tau : real;  def : real);
00131      1  1 BEGIN
00132      1  1 IF def <> 0 
00133      1  1  THEN writeline (out,'Current sample period  = ' + strofr(def,0))
00134      1  1  ELSE def := UNDEFINED_REAL;
00135      1  1 readreal ('ENTER SAMPLE PERIOD    : ',tau,0,BIG,def);
00136      0  0 END;
00137   C  0  0 {-----------------------------------------------------------------------------}
00138      0  0 [ HIDDEN ]
00139      1  0 PROCEDURE greditfcn (VAR infn : fcn);
00140      1  0 VAR
00141      1  0    fr          : framelink;
00142      1  0    go,plotagain: boolean;
00143      1  0    notcomplex  : boolean;
00144      1  0    ipt         : ipoint;
00145      1  0    pt          : point;
00146      1  0    key         : char;
00147      1  0    edlim       : plotlimits;
00148      1  0    fn          : fcn;
00149   C  1  0 {------------------------------}
00150      2  0 PROCEDURE plotfunction;
00151      2  0 VAR
00152      2  0    i             : integer;
00153      2  1 BEGIN
00154      2  1 clearscreen;
00155      2  1 clearframe;
00156      2  1 xymapit (fr);
00157      2  1 
00158      2  1 FOR i := 1 TO fn.ro.deg DO
00159      2  1    WITH fn.ro.f[i] DO
00160      2  2       BEGIN
00161      2  2       plotroot (fr,v,p);
00162      2  2       IF v.im <> 0 THEN plotroot (fr,ccnj(v),p);
00163      2  1       END;
00164      2  1 tagplot;
00165      1  0 END;

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00166   C  1  0 {------------------------------}
00167      1  1 BEGIN
00168      1  1 fn := bodefcnofnumfcn (infn);
00169      1  1 fcncalclimits (edlim,fn,1.5);
00170      1  1 
00171      1  1 makeframe (fr, address (editframe), edlim);
00172      1  1 fr^.title       := strtrunc ('Editing function ' + fn.name,80);
00173      1  1 fr^.x.lablehigh := toprightlable;
00174      1  1 fr^.y.lablehigh := toprightlable;
00175      1  1 
00176      1  1 plotfunction;
00177      1  2 REPEAT
00178      1  2    readcursor  (key,ipt,'GIN_NORMAL');
00179      1  2    checkcursor (key,ipt,go,plotagain);
00180      1  3    CASE key OF
00181      1  3       NUL:  ;
00182      1  4       'A':  BEGIN
00183      1  4             readcursor (key,ipt,'BLUE');
00184      1  4             notcomplex := key <> 'C';
00185      1  4             IF NOT notcomplex THEN readcursor (key,ipt,'GREEN');
00186      1  4             getcursorpoint (pt,ipt);
00187      1  4             pt.x := round (pt.x / width) * width;
00188      1  4             IF notcomplex
00189      1  4              THEN pt.y := 0
00190      1  4              ELSE pt.y := round (pt.y / width) * width;
00191      1  4             fn.ro.deg := fn.ro.deg + 1;
00192      1  4             WITH fn.ro.f[fn.ro.deg] DO
00193      1  5                BEGIN
00194      1  5                v.re := -pt.x;
00195      1  5                v.im := abs(pt.y);
00196      1  6                CASE key OF
00197      1  6                   'Z':  p := 1;
00198      1  6                   'P':  p := -1;
00199      1  5                   END;
00200      1  5                plotroot (fr,v,p);
00201      1  5                IF v.im <> 0 THEN plotroot (fr,ccnj(v),p);
00202      1  4                END;
00203      1  3             END;
00204      1  3       'C':  readcomment (fn.comment,fn.comment);
00205      1  4       'F':  BEGIN  
00206      1  4             cspolyfix (fn.ro);
00207      1  4             fcnnorm (fn);  
00208      1  4             plotfunction;  
00209      1  3             END;
00210      1  3       'G':  readgain (fn.gain,fn.gain);
00211      1  4       'H':  BEGIN  
00212      1  4             setcolor ('HELP');  
00213      1  4             scaleposition (pt);  
00214      1  4             grprint ('');  
00215      1  4             greditmenu;  
00216      1  3             END;
00217      1  4       'N':  BEGIN
00218      1  4             writeline (out,'Current name is        : ' + fn.name);
00219      1  4             readlogicalname  ('ENTER NAME             : ',fn.name,fn.name);
00220      1  3             END;

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00221      1  3       'O':  fn := infn;
00222      1  3       'P':  readch ('ENTER FUNCTION PLANE   : ',fn.plane,goodplanes,fn.plane);
00223      1  3       'S':  readtau (fn.tau,fn.tau);
00224      1  4       'T':  BEGIN 
00225      1  4             scaleposition (pt);
00226      1  4             setcolor ('FIND');
00227      1  4             writegraffcn (fn);
00228      1  3             END;
00229      1  3       'W':  readreal ('ENTER WIDTH OF ROUNDING GRID : ',width,1d-5,1d5,width);
00230      1  3       '2','3','4','5','6','7','8',
00231      1  3       '9':  expandlimits (edlim,ord(key)-ord('0'));
00232      1  3       OTHERWISE bell;
00233      1  2       END;  
00234      1  2    fcnnorm (fn);
00235      1  2    IF plotagain THEN plotfunction;
00236      1  1    UNTIL NOT go;
00237      1  1 clearframe;
00238      1  1 clearscreen;
00239      1  1 infn := numfcnofbodefcn (fn);
00240      0  0 END;
00241   C  0  0 {=============================================================================}
00242   C  0  0 {-- EDIT COMMAND -------------------------------------------------------------}
00243   C  0  0 {=============================================================================}
00244      0  0 [ HIDDEN ]
00245      1  0 FUNCTION twin (v : cpoly;  i : integer) : integer;
00246      1  0 VAR
00247      1  0    j,k  : integer;
00248      1  1 BEGIN
00249      1  1 j := 0;
00250      1  1 IF (i < 1) OR (i > v.deg) THEN raise ('Polynomial index out of range');
00251      1  1 FOR k := imax(i-1,1) TO imin(i+1,v.deg) DO
00252      1  1    IF ceq (v.f[i],ccnj(v.f[k])) THEN j := k;
00253      1  1 IF j = 0 
00254      1  1  THEN raise ('Complex conjugate not found')
00255      1  1  ELSE twin := j;
00256      0  0 END;
00257   C  0  0 {-----------------------------------------------------------------------------}
00258      0  0 [ HIDDEN ]
00259      1  0 PROCEDURE readcpolyfactor (prompt : VARYING [len] OF char;  plane : char;
00260      1  0    VAR v : cpoly;  i : integer);
00261      1  0 VAR
00262      1  0    j                  : integer;
00263      1  0    zeta,omega,lambda  : real;
00264      1  0    mag,theta          : real;
00265      1  0    z                  : complex;
00266      1  0    ch                 : char;
00267      1  1 BEGIN
00268      1  1 IF i > v.deg 
00269      1  1  THEN 
00270      1  2   BEGIN
00271      1  2   z := complex(0,0);
00272      1  2   v.p[i] := 0;
00273      1  2   END
00274      1  1  ELSE 
00275      1  2   BEGIN

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00276      1  2   z := v.f[i];
00277      1  2   j := twin (v,i);
00278      1  1   END;
00279      1  2 CASE format OF
00280      1  3    'R':  BEGIN
00281      1  3          writeline (out,prompt + ' ROOT ' + strofi(i,2));
00282      1  3          IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00283      1  3          z := cneg(z);
00284      1  3          readreal ('RE: ',z.re,-BIG,BIG,z.re);
00285      1  3          readreal ('IM: ',z.im,-BIG,BIG,z.im);
00286      1  3          z := cneg(z);
00287      1  2          END;
00288      1  3    'F':  BEGIN
00289      1  3          writeline (out,prompt + ' FACTOR ' + strofi(i,2));
00290      1  3          IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00291      1  3          readreal ('RE: ',z.re,-BIG,BIG,z.re);
00292      1  3          readreal ('IM: ',z.im,-BIG,BIG,z.im);
00293      1  2          END;
00294      1  3    'B':  BEGIN
00295      1  3          writeline (out,prompt + ' BODE_FACTOR ' + strofi(i,2));
00296      1  3          IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00297      1  3          readreal ('RE: ',z.re,-BIG,BIG,z.re);
00298      1  3          readreal ('IM: ',z.im,-BIG,BIG,z.im);
00299      1  2          END;
00300      1  3    'Z':  BEGIN
00301      1  3          IF i > v.deg
00302      1  3           THEN readch (prompt + ' FACTOR ' + strofi(i,2) 
00303      1  3                        + '-- REAL or COMPLEX term ? ',ch,'RC',' ')
00304      1  3          ELSE IF z.im = 0
00305      1  3           THEN ch := 'R'
00306      1  3           ELSE ch := 'C';
00307      1  4          CASE ch OF
00308      1  5             'C':  BEGIN
00309      1  5                   writeline (out,prompt + ' ZETA_OMEGA FACTOR ' + strofi(i,2));
00310      1  5                   IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00311      1  5                   omega := cabs(z);
00312      1  5                   IF omega = 0 THEN zeta := 0 ELSE zeta := z.re/omega;
00313      1  5                   readreal  ('ZETA  : ',zeta,-BIG,BIG,zeta);
00314      1  5                   readreal  ('OMEGA : ',omega,0,BIG,omega);
00315      1  5                   z.re := zeta * omega;
00316      1  5                   z.im := 0;
00317      1  5                   IF zeta**2 < 1d0
00318      1  5                    THEN z.im := z.im + omega * sqrt(1d0-zeta**2)
00319      1  5                    ELSE z.re := z.re + omega * sqrt(zeta**2-1d0);
00320      1  4                   END;
00321      1  5             'R':  BEGIN
00322      1  5                   lambda := z.re;
00323      1  5                   writeline (out,prompt + ' LAMBDA FACTOR ' + strofi(i,2));
00324      1  5                   IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00325      1  5                   readreal  ('LAMBDA: ',lambda,-BIG,BIG,lambda);
00326      1  5                   z := cofr(lambda);
00327      1  4                   END;
00328      1  3             END;
00329      1  2          END;
00330      1  3    'P':  BEGIN

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00331      1  3          writeline (out,prompt + ' POLAR FACTOR ' + strofi(i,2));
00332      1  3          IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00333      1  3          z := cneg(z);
00334      1  3          mag   := cabs(z);
00335      1  3          theta := angle(z);
00336      1  3          readreal ('MAG   : ',mag,0,BIG,mag);
00337      1  3          readreal ('RAD   : ',theta,-PI,2*PI,theta);
00338      1  3          z.re := mag * cos(theta);
00339      1  3          z.im := mag * sin(theta);
00340      1  3          z := cneg(z);
00341      1  2          END; 
00342      1  3    'D':  BEGIN
00343      1  3          writeline (out,prompt + ' DEGREE_POLAR FACTOR ' + strofi(i,2));
00344      1  3          IF i <= v.deg THEN writecpolyfactor (out,plane,v,i,format);
00345      1  3          z := cneg(z);
00346      1  3          mag   := cabs(z);
00347      1  3          theta := angle(z)*180/PI;
00348      1  3          readreal ('MAG   : ',mag,0,BIG,mag);
00349      1  3          readreal ('DEG   : ',theta,-180,360,theta);
00350      1  3          z.re := mag * cos(theta*PI/180);
00351      1  3          z.im := mag * sin(theta*PI/180);
00352      1  3          z := cneg(z);
00353      1  2          END;
00354      1  1    END;
00355      1  1 readint ('ORDER : ',v.p[i],0,MAXDEG,v.p[i]);
00356      1  1 IF abs(z.im) < abs(z.re) * nearness THEN z.im := 0;
00357      1  1 IF (i = j) AND (z.im <> 0)
00358      1  1  THEN
00359      1  2   BEGIN
00360      1  2   writeline (out,'Illegal to change real root to complex.');
00361      1  2   writeline (out,'Imaginary part changed to zero');
00362      1  2   z.im := 0;
00363      1  1   END;
00364      1  1 v.f[i] := z;
00365      1  1 IF (i < v.deg) AND (i <> j)
00366      1  1  THEN 
00367      1  2   BEGIN
00368      1  2   v.f[j] := ccnj(z);
00369      1  2   writeline (out,'Conjugate root/factor also changed');
00370      1  1   END;
00371      0  0 END;
00372   C  0  0 {-----------------------------------------------------------------------------}
00373      0  0 [ HIDDEN ]
00374      1  0 PROCEDURE readaddcpoly (prompt : VARYING [len] OF char;  plane : char;
00375      1  0    VAR v : cpoly);
00376      1  0 VAR
00377      1  0    i,order   : integer;
00378      1  0    go        : boolean;
00379      1  1 BEGIN
00380      1  1 writeline (out,'Enter '+prompt+'.  (Use ORDER: 0 to exit)');
00381      1  1 go := true;
00382      1  1 WHILE go AND (v.deg < MAXDEG-1) DO
00383      1  2    BEGIN
00384      1  2    readcpolyfactor (prompt,plane,v,v.deg+1);
00385      1  2    IF v.p[v.deg+1] = 0

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00386      1  2     THEN go := false
00387      1  2     ELSE
00388      1  3      BEGIN
00389      1  3      v.deg := v.deg+1;
00390      1  3      IF v.f[v.deg].im <> 0
00391      1  3       THEN
00392      1  4        BEGIN
00393      1  4        v.deg      := v.deg+1;
00394      1  4        v.f[v.deg] := ccnj(v.f[v.deg-1]);
00395      1  4        v.p[v.deg] := v.p[v.deg-1];
00396      1  4        writeline (out,'Complex conjugate factor also entered');
00397      1  3        END;
00398      1  2      END;
00399      1  1    END;
00400      1  1 order := 0;
00401      1  1 FOR i := 1 TO v.deg DO order := order + v.p[i];
00402      1  1 writeline (out,'Polynomial degree = ' + strofi(order,2));
00403      0  0 END;
00404   C  0  0 {-----------------------------------------------------------------------------}
00405      0  0 [ HIDDEN ]
00406      1  0 PROCEDURE readupolycoef (prompt : VARYING [len] OF char;  plane : char;
00407      1  0    VAR u : upoly;  i : integer);
00408      1  1 BEGIN
00409      1  1 IF i > u.deg 
00410      1  1  THEN u.c[i] := UNDEFINED_REAL
00411      1  1  ELSE writeupolycoef (out,plane,u,i);
00412      1  1 readreal (prompt + strofi(i,2) + ': ',u.c[i],-BIG,BIG,u.c[i]);
00413      0  0 END;
00414   C  0  0 {-----------------------------------------------------------------------------}
00415      0  0 [ HIDDEN ]
00416      1  0 PROCEDURE readaddupoly (prompt : VARYING [len] OF char;  plane : char;
00417      1  0    VAR u : upoly);
00418      1  0 VAR
00419      1  0    go   : boolean;
00420      1  1 BEGIN
00421      1  1 writeline (out,'Enter ' + prompt + ' COEFS.  (Use <RETURN> to exit)');
00422      1  1 go := true;
00423      1  1 WHILE go AND (u.deg < rootmax) DO
00424      1  2    BEGIN
00425      1  2    readupolycoef (prompt,plane,u,u.deg+1);
00426      1  2    IF u.c[u.deg+1] <> UNDEFINED_REAL
00427      1  2     THEN u.deg := u.deg+1
00428      1  2    ELSE IF u.deg >= 0
00429      1  2     THEN go := false;
00430      1  1    END;
00431      1  1 writeline (out,'Polynomial is of degree ' + strofi(u.deg,2));
00432      0  0 END;
00433   C  0  0 {-----------------------------------------------------------------------------}
00434      0  0 [ HIDDEN ]
00435      1  0 PROCEDURE editpoly (prompt : anystring;  plane : char;  
00436      1  0    VAR v : cpoly;  VAR vgain : longreal;  query : boolean);
00437      1  0 VAR
00438      1  0    i   : integer;
00439      1  0    u   : upoly;
00440      1  0    com : command_type;

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00441      1  1 BEGIN
00442      1  1 startcommand (prompt,true);
00443      1  1 setcommand ('Add');
00444      1  1 setcommand ('Change');
00445      1  1 setcommand ('Degree');
00446      1  1 setcommand ('View');
00447      1  1 readcommand (com,'V',false,'FUNCTION EDIT LINE commands ' + prompt);
00448      1  2 CASE chofcom(com) OF
00449      1  3    'A':  CASE format OF
00450      1  3             'R','F','B','Z','P',
00451      1  3             'D':  readaddcpoly (prompt,plane,v);
00452      1  4             'U':  BEGIN
00453      1  4                   upolyfromcpoly (u,v,vgain);
00454      1  4                   readaddupoly (prompt,plane,u);
00455      1  4                   cpolyfromupoly (v,vgain,u);
00456      1  3                   END;
00457      1  2             END;
00458      1  3    'C':  BEGIN
00459      1  3          startcommand (prompt + ' ITEM',false);
00460      1  4          CASE format OF
00461      1  4             'R','F','B','Z','P',
00462      1  4             'D':  FOR i := 1 TO v.deg DO
00463      1  4                      setcommand (stripblank(strofi(i,3)));
00464      1  5             'U':  BEGIN
00465      1  5                   upolyfromcpoly (u,v,vgain);
00466      1  5                   FOR i := 0 TO u.deg DO
00467      1  5                      setcommand (stripblank(strofi(i,3)));
00468      1  4                   END;
00469      1  3             END;
00470      1  3          readcommand (com,ESC,false,
00471      1  3                        'FUNCTION EDIT LINE commands ' + prompt + ' CHANGE');
00472      1  3          i := iofstr (com);
00473      1  4          CASE format OF
00474      1  4             'R','F','B','Z','P',
00475      1  4             'D':  IF query
00476      1  4                    THEN readcpolyfactor (prompt,plane,v,i)
00477      1  4                    ELSE writecpolyfactor (out,plane,v,i,format);
00478      1  5             'U':  BEGIN
00479      1  5                   upolyfromcpoly (u,v,vgain);
00480      1  5                   IF query
00481      1  5                    THEN
00482      1  6                     BEGIN
00483      1  6                     readupolycoef (prompt,plane,u,i);
00484      1  6                     cpolyfromupoly (v,vgain,u);
00485      1  6                     END
00486      1  5                    ELSE writeupolycoef (out,plane,u,i);
00487      1  4                   END;
00488      1  3             END;
00489      1  2          END;
00490      1  3    'D':  CASE format OF
00491      1  3             'R','F','B','Z','P',
00492      1  4             'D':  BEGIN
00493      1  4                   writeline (out,'Current root count is  : ' + strofi(v.deg,2));
00494      1  4                   IF query 
00495      1  4                    THEN readint 

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00496      1  4                               ('ENTER NEW ROOT COUNT   : ',v.deg,0,v.deg,v.deg);
00497      1  3                   END;
00498      1  4             'U':  BEGIN
00499      1  4                   upolyfromcpoly (u,v,vgain);
00500      1  4                   writeline (out,'Current degree is      : ' + strofi(u.deg,2));
00501      1  4                   IF query
00502      1  4                    THEN
00503      1  5                     BEGIN
00504      1  5                     readint       ('ENTER NEW DEGREE       : ',u.deg,0,u.deg,u.deg);
00505      1  5                     cpolyfromupoly (v,vgain,u);
00506      1  4                     END;
00507      1  3                   END;
00508      1  2             END;
00509      1  3    'V':  CASE format OF
00510      1  3             'R','F','B','Z','P',
00511      1  4             'D':  BEGIN
00512      1  4                   writecpoly (out,prompt,plane,v,format);
00513      1  4                   pause;
00514      1  3                   END;
00515      1  4             'U':  BEGIN
00516      1  4                   upolyfromcpoly (u,v,vgain);
00517      1  4                   writeupoly (out,prompt,plane,u);
00518      1  4                   pause;
00519      1  3                   END;
00520      1  2             END;
00521      1  2    ESC:  ;
00522      1  1    END;
00523      0  0 END;
00524   C  0  0 {-----------------------------------------------------------------------------}
00525      1  0 PROCEDURE editfcn (VAR fn : fcn;  new : boolean);
00526      1  0 VAR
00527      1  0    i        : integer;
00528      1  0    k1       : longreal;
00529      1  0    str      : logicalname;
00530      1  0    u        : upoly;
00531      1  0    nu,de    : cpoly;
00532      1  0    com      : command_type;
00533      1  1 BEGIN
00534      1  1 IF format = 'B' THEN fn := bodefcnofnumfcn (fn);
00535      1  1 cpolysfromcspoly (nu,de,fn.ro);
00536      1  2 REPEAT
00537   C  1  2    { PRINT WARNINGS }
00538      1  2    IF (format = 'Z') AND (fn.plane IN ['Z','W'])
00539      1  2     THEN writeline (out,'WARNING -- You are editing a non-S function in '
00540      1  2            + 'ZETA_OMEGA format');
00541      1  2    IF (format = 'U') AND (numord(fn) > rootmax)
00542      1  2     THEN writeline (out,'WARNING -- Numerator order is greater than '
00543      1  2            + strofi(rootmax,6));
00544      1  2    IF (format = 'U') AND (denord(fn) > rootmax)
00545      1  2     THEN writeline (out,'WARNING -- Denominator order is greater than '
00546      1  2            + strofi(rootmax,6));
00547      1  2    IF new
00548      1  2     THEN 
00549      1  3      BEGIN
00550      1  4      CASE format OF

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00551      1  4         'R','F','B','Z','P',
00552      1  5         'D':  BEGIN
00553      1  5               readaddcpoly    ('NUMERATOR',fn.plane,nu);
00554      1  5               readaddcpoly    ('DENOMINATOR',fn.plane,de);
00555      1  4               END;
00556      1  5         'U':  BEGIN
00557      1  5               u.deg := -1;
00558      1  5               readaddupoly ('NUMERATOR',fn.plane,u);
00559      1  5               cpolyfromupoly (nu,fn.gain,u);
00560      1  5               u.deg := -1;
00561      1  5               readaddupoly ('DENOMINATOR',fn.plane,u);
00562      1  5               cpolyfromupoly (de,k1,u);
00563      1  5               fn.gain := fn.gain / k1;
00564      1  4               END;
00565      1  3         END;
00566      1  3      new := false;
00567      1  2      END;
00568      1  2 
00569      1  2    cspolyfromcpolys (fn.ro,nu,de);
00570      1  2    startcommand ('EDITOR',true);
00571      1  2    setcommand ('Check');
00572      1  2    setcommand ('Denominator');
00573      1  2    setcommand ('Heading');
00574      1  2    setcommand ('Numerator');
00575      1  2    setcommand ('View');
00576      1  2    setcommand ('Xit');
00577      1  2    readcommand (com,ESC,true,'FUNCTION EDIT LINE commands');
00578      1  2 
00579      1  3    CASE chofcom(com) OF
00580      1  4       'C':  BEGIN
00581      1  4             fcnnorm (fn);
00582      1  4             writeline (out,'Function check completed');
00583      1  4             pause;
00584      1  3             END;
00585      1  4       'D':  BEGIN
00586      1  4             k1 := 1;
00587      1  4             editpoly ('DENOMINATOR',fn.plane,de,k1,true);
00588      1  4             fn.gain := fn.gain / k1;
00589      1  3             END;
00590      1  4       'H':  BEGIN
00591      1  4             startcommand ('HEADING',true);
00592      1  4             setcommand ('Comment');
00593      1  4             setcommand ('Gain');
00594      1  4             setcommand ('Name');
00595      1  4             setcommand ('Plane');
00596      1  4             setcommand ('Sampling_period');
00597      1  4             setcommand ('View');
00598      1  4             readcommand (com,'V',false,'FUNCTION EDIT LINE commands HEADING');
00599      1  5             CASE chofcom(com) OF
00600      1  5                'C':  readcomment (fn.comment,fn.comment);
00601      1  5                'G':  IF format <> 'U'
00602      1  5                       THEN readgain (fn.gain,fn.gain);
00603      1  5                'N':  readlogicalname ('ENTER NAME : ',fn.name,fn.name);
00604      1  5                'P':  readch ('ENTER FUNCTION PLANE : ',
00605      1  5                                                fn.plane,goodplanes,fn.plane);

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00606      1  5                'S':  IF fn.plane IN ['Z','W']
00607      1  5                       THEN readtau     (fn.tau,fn.tau)
00608      1  5                       ELSE bell;
00609      1  6                'V':  BEGIN
00610      1  6                      writeline (out,'NAME      = ' + fn.name);
00611      1  6                      writeline (out,'COMMENT   = ' + fn.comment);
00612      1  6                      writeline (out,'PLANE     = "' + fn.plane + '"');
00613      1  6                      writeline (out,'GAIN      = ' + strofl(fn.gain,0));
00614      1  6                      writeline (out,'SAMPLING  = ' + strofr(fn.tau,0));
00615      1  6                      pause;
00616      1  5                      END;
00617      1  5                ESC:  ;
00618      1  4                END;
00619      1  3             END;
00620      1  3       'N':  editpoly ('NUMERATOR',fn.plane,nu,fn.gain,true);
00621      1  4       'V':  BEGIN
00622      1  4             writefcn (out,fn,format);
00623      1  4             pause;
00624      1  3             END;
00625      1  3       'X':  ;
00626      1  3       ESC:  ;
00627      1  2       END;
00628      1  2    cspolyfromcpolys (fn.ro,nu,de);
00629      1  1    UNTIL chofcom(com) = 'X';
00630      1  1 IF format = 'B' THEN fn := numfcnofbodefcn (fn);
00631      0  0 END;
00632   C  0  0 {-----------------------------------------------------------------------------}
00633      1  0 PROCEDURE edit;
00634      1  0 VAR
00635      1  0    mode,form : command_type;
00636      1  0    sel       : command_type;
00637      1  0    fn        : fcn;
00638   C  1  0 {------------------------------}
00639      2  0 PROCEDURE getfcn;
00640      2  0 VAR
00641      2  0    arg : anystring;
00642      2  1 BEGIN
00643      2  1 selectfunction (sel,false,true);
00644      2  1 readargument (arg);
00645      2  1 IF sel = 'New' 
00646      2  1  THEN 
00647      2  2   BEGIN
00648      2  2   readlogicalname ('ENTER NEW FUNCTION NAME : ',fn.name,'NEWFCN');
00649      2  2   readch          ('ENTER FUNCTION PLANE    : ',fn.plane,goodplanes,'S');
00650      2  2   readvary        ('ENTER COMMENT           : ',fn.comment,'');
00651      2  2   readlongreal    ('ENTER GAIN              : ',fn.gain,-LONGBIG,LONGBIG,1);
00652      2  2   fn.tau := UNDEFINED_REAL;
00653      2  2   IF fn.plane IN ['Z','W'] 
00654      2  2    THEN readreal  ('ENTER SAMPLE PERIOD     : ',fn.tau,0,BIG,fn.tau);
00655      2  2   fn.time       := strtime;
00656      2  2   fn.fcntype    := FCT;
00657      2  2   fn.ro.deg     := 0;
00658      2  2   END
00659      2  1  ELSE fcnsearch (fn,sel);
00660      1  0 END;

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                  11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

-LINE-IDC-PL-SL-

00661   C  1  0 {------------------------------}
00662      2  0 PROCEDURE putfcn;
00663      2  1 BEGIN
00664      2  1 fcnnorm (fn);
00665      2  1 writefcn (aud,fn,'R');
00666      2  1 fcninsert (fn);
00667      2  1 writeproject (project);
00668      1  0 END;
00669   C  1  0 {------------------------------}
00670      1  1 BEGIN
00671      1  1 startcommand ('FUNCTION EDIT',true);
00672      1  1 setcommand ('Graphic');
00673      1  1 setcommand ('Line');
00674      1  1 setcommand ('Screen');
00675      1  1 readcommand (mode,'S',false,'FUNCTION EDIT');
00676      1  1 
00677      1  2 CASE chofcom(mode) OF
00678      1  3    'G':  BEGIN
00679      1  3          getfcn;
00680      1  3          IF fn.fcntype = DYN 
00681      1  3           THEN raise ('You cannot graphicly edit a dynamic function');
00682      1  3          IF fn.name <> ''  THEN BEGIN  greditfcn (fn);  putfcn;  END;
00683      1  2          END;
00684      1  3    'L':  BEGIN
00685      1  3          startcommand ('EDIT format',true);
00686      1  3          setcommand ('Bodegain_Factored');
00687      1  3          setcommand ('Degree_Polar');
00688      1  3          setcommand ('Factored');
00689      1  3          setcommand ('Polar');
00690      1  3          setcommand ('Roots');
00691      1  3          setcommand ('Unfactored');
00692      1  3          setcommand ('Zeta_Omega');
00693      1  3          readcommand (form,' ',false,'FUNCTION EDIT LINE');
00694      1  3          IF chofcom(form) = ' ' 
00695      1  3           THEN format := defaulteditformat 
00696      1  3           ELSE format := chofcom(form);
00697      1  3          IF format IN ['A'..'Z']
00698      1  3           THEN
00699      1  4            BEGIN
00700      1  4            getfcn;
00701      1  4            IF fn.fcntype = DYN 
00702      1  4             THEN raise ('You cannot line edit a dynamic function');
00703      1  4            IF fn.name <> ''  
00704      1  4             THEN BEGIN  editfcn (fn,sel = 'New');  putfcn;  END;
00705      1  3            END;
00706      1  2          END;
00707      1  3    'S':  BEGIN
00708      1  3          getfcn;
00709      1  3          IF fn.name <> ''  THEN BEGIN  screeneditfcn (fn);  putfcn;  END;
00710      1  2          END;
00711      1  2    ESC:  ;
00712      1  1    END;
00713      0  0 END;
00714   C  0  0 {=============================================================================}
00715      0  0 END.

EDIT                                                            23-Dec-1988 10:59:30    VAX Pascal V3.7-254                Page   14
INCA                            Pascal Compilation Statistics   11-Oct-1988 14:58:02    DUA1:[QPLOT.INCA.SOURCE]EDIT.PAS;290 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               20583  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               1243  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
LIB$INITIALIZE                          4  NOVEC,NOWRT,  RD,NOEXE,NOSHR,  GBL,  REL,  CON,NOPIC,ALIGN(0)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260         0         0
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        54        44
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        31        43
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         6        10
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        27        44
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        95        45
DUA1:[QPLOT.QPLOT.SOURCE]UTILITIES.PEN;1                 105        18        17
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        86        42
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292       109        37
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        47        29
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67        23        34
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184       128        70
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        95        38
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289       151        52
DUA1:[QPLOT.INCA.SOURCE]SCREENEDIT.PEN;1                 136        65        48



MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:DIRECTORY',
00005      0  0                'QLIBHOME:GENERAL',
00006      0  0                'QLIBHOME:STRING',
00007      0  0                'QLIBHOME:MATH',
00008      0  0                'QLIBHOME:FIG',
00009      0  0                'QLIBHOME:IOBASE',
00010      0  0                'QLIBHOME:IO',
00011      0  0                'QLIBHOME:PLOT',
00012      0  0                'QLIBHOME:UTILITIES',
00013      0  0                'EDIT','CURVE',
00014      0  0                'FCNIO','FCNOPER','FCN','OLDFCN','POLYMATH','UTIL'),
00015      0  0   ENVIRONMENT ('MISC')]
00016      0  0 MODULE misc;
00017   C  0  0 {=============================================================================}
00018   C  0  0 {-- CURVE, FUNCTION, PROJECT, SET, VIEW, XIT, ZAP ----------------------------}
00019   C  0  0 {=============================================================================}
00020   C  0  0 {-- ROUTINE TO DO CURVE COMMAND ----------------------------------------------}
00021   C  0  0 {=============================================================================}
00022      1  0 PROCEDURE curvecommand;
00023      1  0 VAR
00024      1  0    found  : boolean;
00025      1  0    modi   : command_type;
00026      1  0    subcom : command_type;
00027      1  0    arg    : anystring;
00028      1  0    sel    : command_type;
00029      1  1 BEGIN
00030      1  1 startcommand ('CURVE modifier',true);
00031      1  1 setcommand ('Audit');
00032      1  1 setcommand ('Delete');
00033      1  1 setcommand ('Load');
00034      1  1 setcommand ('Rename');
00035      1  1 setcommand ('Save');
00036      1  1 setcommand ('Table');
00037      1  1 setcommand ('View');
00038      1  1 setcommand ('WormFormat');
00039      1  1 readcommand (modi,'V',false,'CURVE');
00040      1  1 
00041      1  2 CASE chofcom(modi) OF
00042      1  3    'A':  BEGIN
00043      1  3          listcurves (aud);
00044      1  3          writeline (out,'List of curves placed in audit file');
00045      1  3          wait (0.5);
00046      1  2          END;
00047      1  3    'D':  BEGIN
00048      1  3          selectcurve (sel,true,false);
00049      1  3          IF (sel = ' ') OR (sel = ESC)
00050      1  3           THEN
00051      1  3          ELSE IF sel = 'All'
00052      1  3           THEN
00053      1  4            BEGIN
00054      1  4            WHILE curve.count > 0 DO deletecurve (curve.data[1].name);
00055      1  4            writeline (both,'All curves deleted');

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00056      1  4            pause;
00057      1  4            END
00058      1  3           ELSE 
00059      1  4            BEGIN
00060      1  4            deletecurve (sel);
00061      1  4            writeline (out,'Curve ' + sel + ' deleted');
00062      1  4            pause;
00063      1  3            END;
00064      1  2          END;
00065      1  3    'L':  BEGIN
00066      1  3          found := false;
00067      1  3          startcommand ('Curve file selection',false);
00068      1  3          startfilesearch ('*.RL');
00069      1  3          WHILE NOT endoffilesearch DO
00070      1  4             BEGIN
00071      1  4             filesearch (arg);
00072      1  4             setcommand (fs.name + fs.typ);
00073      1  4             found := true;
00074      1  3             END;
00075      1  3          startfilesearch ('*.FR');
00076      1  3          WHILE NOT endoffilesearch DO
00077      1  4             BEGIN
00078      1  4             filesearch (arg);
00079      1  4             setcommand (fs.name + fs.typ);
00080      1  4             found := true;
00081      1  3             END;
00082      1  3          startfilesearch ('*.TR');
00083      1  3          WHILE NOT endoffilesearch DO
00084      1  4             BEGIN
00085      1  4             filesearch (arg);
00086      1  4             setcommand (fs.name + fs.typ);
00087      1  4             found := true;
00088      1  3             END;
00089      1  3          IF found
00090      1  3           THEN
00091      1  4            BEGIN
00092      1  4            readcommand (sel,' ',false,'CURVE LOAD');
00093      1  4            IF sel = ' ' THEN readvary ('ENTER CURVE FILE NAME : ',sel,'');
00094      1  4            loadcurve (sel,VERSION_NUMBER);
00095      1  4            END
00096      1  3           ELSE
00097      1  4            BEGIN
00098      1  4            writeline (out,'No curve files found');
00099      1  4            pause;
00100      1  3            END;
00101      1  2          END;
00102      1  3    'R':  BEGIN
00103      1  3          selectcurve (sel,false,false);
00104      1  3          IF curveexist (sel)
00105      1  3           THEN readlogicalname ('ENTER NEW NAME :  ',
00106      1  3                               curve.data[getcurveindex(sel)].name,sel);
00107      1  2          END;
00108      1  3    'S':  BEGIN
00109      1  3          selectcurve (sel,false,false);
00110      1  3          IF sel <> ESC

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00111      1  3           THEN
00112      1  4            BEGIN
00113      1  4            readvary ('ENTER FILE NAME (no extension) : ',arg,sel);
00114      1  4            IF goodfilename (arg + '.XXX') AND (arg <> '')
00115      1  4             THEN writecurve (sel,arg,VERSION_NUMBER)
00116      1  4             ELSE 
00117      1  5              BEGIN
00118      1  5              writeline (out,'Bad filename, no file written');
00119      1  5              pause;
00120      1  4              END;
00121      1  3            END;
00122      1  2          END;
00123      1  3    'T':  BEGIN
00124      1  3          startcommand ('CURVE TABLE destination',true);
00125      1  3          setcommand ('Audit');
00126      1  3          setcommand ('File');
00127      1  3          setcommand ('View');
00128      1  3          readcommand (subcom,'V',false,'CURVE TABLE');
00129      1  4          CASE subcom[1] OF
00130      1  5             'A':  BEGIN
00131      1  5                   showcurvetable (aud);
00132      1  5                   writeline (out,'Curve table placed in audit file');
00133      1  5                   wait (0.5);
00134      1  4                   END;
00135      1  5             'F':  BEGIN
00136      1  5                   readvary ('ENTER FILENAME : ',arg,'');
00137      1  5                   rewrite (tempfile);
00138      1  5                   showcurvetable (temp);
00139      1  5                   reset (tempfile);
00140      1  5                   open (textfile,arg,NEW);
00141      1  5                   rewrite (textfile);
00142      1  5                   WHILE NOT eof (tempfile) DO
00143      1  6                      BEGIN
00144      1  6                      readln (tempfile,arg);
00145      1  6                      writeln (textfile,arg);
00146      1  5                      END;
00147      1  5                   close (textfile);
00148      1  4                   END;
00149      1  5             'V':  BEGIN
00150      1  5                   showcurvetable (out);
00151      1  5                   pause;
00152      1  4                   END;
00153      1  4             ESC:  ;
00154      1  3             END;
00155      1  2          END;
00156      1  3    'V':  BEGIN
00157      1  3          listcurves (out);
00158      1  3          pause;
00159      1  2          END;
00160      1  3    'W':  BEGIN
00161      1  3          readvary ('ENTER FILENAME : ',arg,'');
00162      1  3          open (textfile,arg,NEW);
00163      1  3          rewrite (textfile);
00164      1  3          wormcurvestotext;
00165      1  3          close (textfile);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00166      1  2          END;
00167      1  2    ESC:  ;
00168      1  1    END;
00169      1  1 readargument (arg);
00170      0  0 END;
00171   C  0  0 {=============================================================================}
00172   C  0  0 {-- USEREVAL ROUTINE ---------------------------------------------------------}
00173   C  0  0 {=============================================================================}
00174      0  0 [ GLOBAL ]
00175      1  0 FUNCTION usereval (st : anystring) : boolean;
00176      1  0 VAR
00177      1  0    s1,se,s2 : anystring;
00178      1  0    f1,f2    : fcn;
00179      1  0    p        : parse_type;
00180      1  1 BEGIN
00181      1  1 startparse (p,st);
00182      1  1 s1 := parse (p,'=');
00183      1  1 se := parse (p,'=');
00184      1  1 s2 := parse (p,'=');
00185      1  1 f1 := evalfcn (s1);
00186      1  1 f2 := evalfcn (s2);
00187      1  1 usereval := f1.gain = f2.gain;
00188      0  0 END;
00189   C  0  0 {=============================================================================}
00190   C  0  0 {-- ROUTINE TO DO FUNCTION COMMAND -------------------------------------------}
00191   C  0  0 {=============================================================================}
00192      1  0 PROCEDURE expression (VAR fn : fcn);
00193      1  0 VAR
00194      1  0    token   : logicalname;
00195      1  0    p       : parse_type;
00196      1  0    arg     : anystring;
00197      1  1 BEGIN
00198      1  1 readvary ('ENTER EQUATION : ',arg,'');
00199      1  1 IF arg <> ''
00200      1  1  THEN
00201      1  2   BEGIN
00202      1  2   writeline (aud,'EQUATION : ' + arg);
00203      1  2   startparse (p,arg);
00204      1  2   fn.name := parse (p,' :=');
00205      1  2   token   := parse (p,' :=');
00206      1  2   IF token  = ':' THEN token := parse (p,' :=');
00207      1  2   IF token <> '=' THEN raise ('Equals sign not found where expected');
00208      1  2   fn.val := parse (p,'');
00209      1  2   IF fn.val = '' THEN fn.val := ' ';
00210      1  2   WHILE fn.val[fn.val.length] = '\' DO
00211      1  3      BEGIN
00212      1  3      fn.val.length := fn.val.length - 1;
00213      1  3      readvary ('ENTER CONTINUATION: ',arg,'');
00214      1  3      writeline (aud,'CONTINUATION: ' + arg);
00215      1  3      fn.val := fn.val + arg;
00216      1  2      END;
00217      1  2   fn.fcntype := DYN;
00218      1  2   fn.time := strtime;
00219      1  2   fn.comment := '';
00220      1  2   fcnnorm (fn);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00221      1  2   END
00222      1  1  ELSE
00223      1  2   BEGIN
00224      1  2   fn := fcnofr (0);
00225      1  2   fn.name := '';
00226      1  1   END;
00227      0  0 END;
00228   C  0  0 {-----------------------------------------------------------------------------}
00229      1  0 PROCEDURE functiongenerate;
00230      1  0 VAR
00231      1  0    n           : integer;
00232      1  0    r1,r2,r3,r4 : real;
00233      1  0    ch          : char;
00234      1  0    name        : logicalname;
00235      1  0    modi,sel    : command_type;
00236      1  0    arg,st      : anystring;
00237      1  0    ptr         : fcnlink;
00238      1  0    fn          : fcn;
00239      1  0    c,p,f       : fcn;
00240   C  1  0 {------------------------------}
00241      1  1 BEGIN
00242      1  1 startcommand ('FUNCTION GENERATE modifier',true);
00243      1  1 setcommand ('Algebraic_Operator');
00244      1  1 setcommand ('Conversion');
00245      1  1 setcommand ('Dynamic_Equation');
00246      1  1 setcommand ('Filter');
00247      1  1 setcommand ('Miscellaneous');
00248      1  1 setcommand ('Input');
00249      1  1 setcommand ('Static_Equation');
00250      1  1 readcommand (modi,ESC,false,'FUNCTION GENERATE');
00251      1  2 CASE chofcom (modi) OF
00252      1  3    'A':  BEGIN
00253      1  3          startcommand ('ALGEBRAIC OPERATOR',false);
00254      1  3          setcommand ('COS');
00255      1  3          setcommand ('COSD');
00256      1  3          setcommand ('EXP');
00257      1  3          setcommand ('EXP10');
00258      1  3          setcommand ('LOG');
00259      1  3          setcommand ('LOG10');
00260      1  3          setcommand ('SIN');
00261      1  3          setcommand ('SIND');
00262      1  3          setcommand ('SQRT');
00263      1  3          readcommand (modi,ESC,false,'FUNCTION GENERATE ALGEBRAIC_OPERATOR');
00264      1  3          IF modi <> ESC
00265      1  3           THEN
00266      1  4            BEGIN
00267      1  4            writeline (out,'Compute ' + modi + ' of...');
00268      1  4            writeline (out,'');
00269      1  4            readlogicalname ('ENTER NAME        : ',name,modi);
00270      1  4            readreal ('ENTER OPERAND     : ',r1,0,BIG,1);
00271      1  4            oper_$eval (ptr,ptroffcns (fcnofr (r1)),upcasestr(modi));
00272      1  4            fn := ptr^;
00273      1  4            dispose (ptr);
00274      1  4            fn.comment := modi + ' of ' + strofr(r1,13);
00275      1  4            fn.name    := name;

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00276      1  4            checkandinsertfunction (fn);
00277      1  3            END;
00278      1  2          END;
00279      1  3    'C':  BEGIN
00280      1  3          selectfunction (sel,false,false);
00281      1  3          IF sel <> ''
00282      1  3           THEN
00283      1  4            BEGIN
00284      1  4            writeline (out,'Convert function ' + sel);
00285      1  4            writeline (out,'');
00286      1  4            readch ('ENTER TARGET PLANE          : ',ch,'ZW',' ');
00287      1  4            readlogicalname ('ENTER TARGET FUNCTION NAME  : ',name,sel + ch);
00288      1  4            modi := ch;
00289      1  4            new (ptr);
00290      1  4            fcnsearch (ptr^,sel);
00291      1  4            ptr^ := fcnFCTofANY (ptr^);
00292      1  4            IF ptr^.plane IN ['Z','W']
00293      1  4             THEN
00294      1  4            ELSE IF readyes ('DO YOU WISH ZERO-ORDER HOLD ? ')
00295      1  4             THEN modi := modi + 'H';
00296      1  4            IF ptr^.tau = UNDEFINED_REAL
00297      1  4             THEN 
00298      1  5              BEGIN
00299      1  5              readreal ('ENTER SAMPLE PERIOD         : ',
00300      1  5                                                       r1,0,BIG,UNDEFINED_REAL);
00301      1  5              new (ptr^.nextfcn);
00302      1  5              ptr^.nextfcn^ := fcnofr(r1);
00303      1  5              END
00304      1  4             ELSE ptr^.nextfcn := NIL;
00305      1  4            IF ptr^.plane = 'S'
00306      1  4             THEN
00307      1  5              BEGIN
00308      1  5              readreal ('ENTER ADVANCE FACTOR        : ',r2,0,1,0);
00309      1  5              IF r2 <> 0
00310      1  5               THEN
00311      1  6                BEGIN
00312      1  6                new (ptr^.nextfcn^.nextfcn);
00313      1  6                ptr^.nextfcn^.nextfcn^ := fcnofr(r2);
00314      1  5                END;
00315      1  4              END;
00316      1  4            oper_$eval (ptr,ptr,modi);
00317      1  4            fn := ptr^;
00318      1  4            dispose (ptr);
00319      1  4            fn.name    := name;
00320      1  4            fn.comment := modi + '-plane Conversion of ' + sel;
00321      1  4            checkandinsertfunction (fn);
00322      1  3            END;
00323      1  2          END;
00324      1  2    'D':  expression (fn);
00325      1  3    'F':  BEGIN
00326      1  3          startcommand ('FILTER',true);
00327      1  3          setcommand ('Bessel');
00328      1  3          setcommand ('Chebyshev');
00329      1  3          setcommand ('ITAE');
00330      1  3          setcommand ('butterWorth');

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00331      1  3          readcommand (modi,ESC,false,'FUNCTION GENERATE FILTER');
00332      1  3          IF chofcom(modi) IN ['A'..'Z']
00333      1  3           THEN
00334      1  4            BEGIN
00335      1  4            writeline (out,'Compute ' + modi + ' filter');
00336      1  4            writeline (out,'');
00337      1  4            readlogicalname ('ENTER FUNCTION NAME   : ',name,modi);
00338      1  4            readreal        ('ENTER BANDWIDTH (rps) : ',r1,0,BIG,1);
00339      1  4            IF chofcom(modi) = 'C'
00340      1  4             THEN readreal  ('ENTER RIPPLE (db)     : ',r2,0,BIG,0.5);
00341      1  4            readint         ('ENTER ORDER           : ',n,1,20,2);
00342      1  4            IF chofcom(modi) = 'C'
00343      1  4             THEN oper_$eval (ptr,ptroffcns (fcnofr(r1),fcnofr(r2),fcnofr(n)),
00344      1  4                                              strtrunc(upcasestr(modi),6))
00345      1  4             ELSE oper_$eval (ptr,ptroffcns (fcnofr(r1),fcnofr(n)),
00346      1  4                                              strtrunc(upcasestr(modi),6));
00347      1  4            fn := ptr^;
00348      1  4            dispose (ptr);
00349      1  4            fn.name    := name;
00350      1  4            fn.comment := modi + ' Filter, Order=' + strofi(n,2) 
00351      1  4                                  + '  Bandwidth=' + strofr(r1,13);
00352      1  4            checkandinsertfunction (fn);
00353      1  3            END;
00354      1  2          END;
00355      1  3    'I':  BEGIN
00356      1  3          startcommand ('INPUT',true);
00357      1  3          setcommand ('Acceleration');
00358      1  3          setcommand ('Combination');
00359      1  3          setcommand ('Damped_Oscillator');
00360      1  3          setcommand ('Impulse');
00361      1  3          setcommand ('Ramp');
00362      1  3          setcommand ('Step');
00363      1  3          readcommand (modi,ESC,false,'FUNCTION GENERATE INPUT');
00364      1  4          CASE chofcom(modi) OF
00365      1  4             'A',
00366      1  4             'R',
00367      1  5             'S':  BEGIN
00368      1  5                   writeline (out,'Compute ' + modi + ' Input function');
00369      1  5                   writeline (out,'');
00370      1  5                   readlogicalname ('ENTER NAME        : ',name,modi);
00371      1  5                   readreal ('ENTER VALUE       : ',r1,-BIG,BIG,1);
00372      1  5                   oper_$eval (ptr,ptroffcns (fcnofr (r1)),upcasestr(modi));
00373      1  5                   fn := ptr^;
00374      1  5                   dispose (ptr);
00375      1  5                   fn.name    := name;
00376      1  5                   fn.comment := modi + ' Input, Value=' + strofr(r1,13);
00377      1  5                   checkandinsertfunction (fn);
00378      1  4                   END;
00379      1  5             'C':  BEGIN
00380      1  5                   writeline (out,'Compute Combination Input function');
00381      1  5                   writeline (out,'');
00382      1  5                   readlogicalname ('ENTER NAME        : ',name,modi);
00383      1  5                   readreal ('ENTER STEP        : ',r1,-BIG,BIG,0);
00384      1  5                   readreal ('ENTER RAMP        : ',r2,-BIG,BIG,0);
00385      1  5                   readreal ('ENTER ACCELERATION: ',r3,-BIG,BIG,0);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00386      1  5                   oper_$eval (ptr,
00387      1  5                         ptroffcns (fcnofr (r1),fcnofr(r2),fcnofr(r3)),'SRA');
00388      1  5                   fn := ptr^;
00389      1  5                   dispose (ptr);
00390      1  5                   fn.name    := name;
00391      1  5                   fn.comment := 'Combination Input, Step=' + strofr(r1,13)
00392      1  5                       + '  Ramp=' + strofr(r2,13) + '  Acc=' + strofr(r3,13);
00393      1  5                   checkandinsertfunction (fn);
00394      1  4                   END;
00395      1  5             'D':  BEGIN
00396      1  5                   writeline (out,'Compute Damped Oscilator Input function');
00397      1  5                   writeline (out,'');
00398      1  5                   readlogicalname ('ENTER NAME        : ',name,modi);
00399      1  5                   readreal ('ENTER FREQUENCY   : ',r1,0,BIG,1);
00400      1  5                   readreal ('ENTER PHASE       : ',r2,-180,360,0);
00401      1  5                   readreal ('ENTER DAMPING     : ',r3,0,BIG,0);
00402      1  5                   IF readyes ('PHASE IN DEGREES  ? ')
00403      1  5                    THEN oper_$eval (ptr,
00404      1  5                         ptroffcns (fcnofr (r1),fcnofr(r2),fcnofr(r3)),'DOSCD')
00405      1  5                    ELSE oper_$eval (ptr,
00406      1  5                         ptroffcns (fcnofr (r1),fcnofr(r2),fcnofr(r3)),'DOSC');
00407      1  5                   fn := ptr^;
00408      1  5                   dispose (ptr);
00409      1  5                   fn.name    := name;
00410      1  5                   fn.comment := 'Damped Oscillator Input, Freq=' + strofr(r1,13)
00411      1  5                      + '  Phase=' + strofr(r2,13) + '  Damp=' + strofr(r3,13);
00412      1  5                   checkandinsertfunction (fn);
00413      1  4                   END;
00414      1  5             'I':  BEGIN
00415      1  5                   readlogicalname ('ENTER NAME        : ',name,modi);
00416      1  5                   fn := fcnofr(1);
00417      1  5                   fn.name    := name;
00418      1  5                   fn.comment := 'Impulse function';
00419      1  5                   checkandinsertfunction (fn);
00420      1  4                   END;
00421      1  4             ESC:  ;
00422      1  3             END;
00423      1  2          END;
00424      1  3    'M':  BEGIN
00425      1  3          startcommand ('MISCELLANEOUS',true);
00426      1  3          setcommand ('Closed_Loop');
00427      1  3          setcommand ('pID_Control_Law');
00428      1  3          setcommand ('PD_Control_Law');
00429      1  3          readcommand (modi,ESC,false,'FUNCTION GENERATE MISCELLANEOUS');
00430      1  4          CASE chofcom(modi) OF
00431      1  5             'C':  BEGIN
00432      1  5                   writeline (out,'Compute Closed Loop Transfer Function');
00433      1  5                   writeline (out,'');
00434      1  5                   readlogicalname ('ENTER NAME                  : ',name,
00435      1  5                                                                     'CLOOP');
00436      1  5                   revfcn ('ENTER COMPENSATION FUNCTION : ',c,arg,'KSZW','1');
00437      1  5                   revfcn ('ENTER PLANT FUNCTION        : ',p,arg,'KSZW','1');
00438      1  5                   revfcn ('ENTER FEEDACK FUNCTION      : ',f,arg,'KSZW','1');
00439      1  5                   oper_$eval (ptr,ptroffcns (c,p,f),'CLOOP');
00440      1  5                   fn := ptr^;

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00441      1  5                   dispose (ptr);
00442      1  5                   fn.name    := name;
00443      1  5                   fn.comment := 'Closed Loop Transfer Function';
00444      1  5                   checkandinsertfunction (fn);
00445      1  4                   END;
00446      1  5             'I':  BEGIN
00447      1  5                   writeline (out,'Compute PID Control Law');
00448      1  5                   writeline (out,'');
00449      1  5                   readlogicalname ('ENTER NAME            : ',name,'PID');
00450      1  5                   readreal ('ENTER BANDWIDTH (rps) : ',r1,0,BIG,1);
00451      1  5                   readreal ('ENTER ZETA            : ',r2,0,BIG,sqrt(2)/2);
00452      1  5                   readreal ('ENTER LOOP GAIN       : ',r3,0,BIG,1);
00453      1  5                   readreal ('ENTER INT LOOP WEIGHT : ',r4,0,BIG,1);
00454      1  5                   oper_$eval (ptr,ptroffcns (fcnofr (r1),fcnofr (r2),
00455      1  5                                              fcnofr (r3),fcnofr (r4)),'PID');
00456      1  5                   fn := ptr^;
00457      1  5                   dispose (ptr);
00458      1  5                   fn.name    := name;
00459      1  5                   fn.comment := strfix ('PID Controller'
00460      1  5                         + ', Bandwidth=' + strofr(r1,13)
00461      1  5                         + '  Zeta=' + strofr(r2,13) 
00462      1  5                         + '  Loop Gain=' + strofr(r3,13) 
00463      1  5                         + '  Int Gain Dom=' + strofr(r4,13),80);
00464      1  5                   checkandinsertfunction (fn);
00465      1  4                   END;
00466      1  5             'P':  BEGIN
00467      1  5                   writeline (out,'Compute PD Control Law');
00468      1  5                   writeline (out,'');
00469      1  5                   readlogicalname ('ENTER NAME            : ',name,'PD');
00470      1  5                   readreal ('ENTER BANDWIDTH (rps) : ',r1,0,BIG,1);
00471      1  5                   readreal ('ENTER ZETA            : ',r2,0,BIG,sqrt(2)/2);
00472      1  5                   readreal ('ENTER LOOP GAIN       : ',r3,0,BIG,1);
00473      1  5                   oper_$eval (ptr,ptroffcns (fcnofr (r1),fcnofr (r2),
00474      1  5                                              fcnofr (r3)),'PD');
00475      1  5                   fn := ptr^;
00476      1  5                   dispose (ptr);
00477      1  5                   fn.name    := name;
00478      1  5                   fn.comment := strfix ('PD Controller'
00479      1  5                         + ', Bandwidth=' + strofr(r1,13)
00480      1  5                         + '  Zeta=' + strofr(r2,13) 
00481      1  5                         + '  Loop Gain=' + strofr(r3,13),80);
00482      1  5                   checkandinsertfunction (fn);
00483      1  4                   END;
00484      1  4             ESC:  ;
00485      1  3             END;
00486      1  2          END;
00487      1  3    'S':  BEGIN
00488      1  3          expression (fn);
00489      1  3          IF fn.name <> ''
00490      1  3           THEN
00491      1  4            BEGIN
00492      1  4            fn.comment := strtrunc (fn.val,80);
00493      1  4            fn := fcnFCTofDYN (fn);
00494      1  4            checkandinsertfunction (fn);
00495      1  3            END;

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00496      1  2          END;
00497      1  2    ESC:  ;
00498      1  1    END;
00499      0  0 END;
00500   C  0  0 {-----------------------------------------------------------------------------}
00501      1  0 PROCEDURE functioncommand;
00502      1  0 VAR
00503      1  0    modi,sel    : command_type;
00504      1  0    arg,st      : anystring;
00505      1  0    fn          : fcn;
00506      1  1 BEGIN
00507      1  1 startcommand ('FUNCTION modifier',true);
00508      1  1 setcommand ('Audit');
00509      1  1 setcommand ('Compute');
00510      1  1 setcommand ('Delete');
00511      1  1 setcommand ('Edit');
00512      1  1 setcommand ('Generate');
00513      1  1 setcommand ('Load');
00514      1  1 setcommand ('Save');
00515      1  1 setcommand ('Undelete');
00516      1  1 setcommand ('View');
00517      1  1 readcommand (modi,'C',false,'FUNCTION');
00518      1  1 
00519      1  2 CASE chofcom(modi) OF
00520      1  3    'A':  BEGIN
00521      1  3          showfunction (aud);
00522      1  3          writeline (out,'Function printed in audit file');
00523      1  3          wait (0.5);
00524      1  2          END;
00525      1  3    'C':  BEGIN
00526      1  3          writeline (out,'Enter equations to generate dynamic functions');
00527      1  3          writeline (out,'Enter empty line to exit');
00528      1  3          writeline (out,'');
00529      1  4          REPEAT
00530      1  4             expression (fn);
00531      1  4             IF fn.name <> '' THEN checkandinsertfunction (fn);
00532      1  3             UNTIL fn.name = '';
00533      1  2          END;
00534      1  3    'D':  BEGIN
00535      1  3          selectfunction (sel,true,false);
00536      1  3          IF (sel = ' ') OR (sel = ESC)
00537      1  3           THEN
00538      1  3          ELSE IF sel = 'All'
00539      1  3           THEN
00540      1  4            BEGIN
00541      1  4            clearfcns;
00542      1  4            writeline (both,'All functions deleted');
00543      1  4            pause;
00544      1  4            END
00545      1  3           ELSE 
00546      1  4            BEGIN
00547      1  4            deletefcn (sel);
00548      1  4            writeline (out,'Function ' + sel + ' deleted');
00549      1  4            pause;
00550      1  3            END;

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00551      1  2          END;
00552      1  2    'E':  edit;
00553      1  2    'G':  functiongenerate;
00554      1  3    'L':  BEGIN
00555      1  3          readvary ('ENTER NAME OF TEXT FILE: ',arg,'');
00556      1  3          IF exist (arg) 
00557      1  3           THEN 
00558      1  4            BEGIN
00559      1  4            close (textfile,ERROR:=CONTINUE);
00560      1  4            open (textfile,arg,OLD);
00561      1  4            clearfcns;
00562      1  4            reset (textfile);
00563      1  4            WHILE NOT eof(textfile) DO
00564      1  5               BEGIN
00565      1  5               readfcn (textfile,fn);
00566      1  5               fcnnorm (fn);
00567      1  5               fcninsert (fn);  
00568      1  5               writefcn (aud,fn,'R');
00569      1  4               END;
00570      1  4            close (textfile);
00571      1  4            writeline (both,'Functions loaded from file ' + arg);
00572      1  4            writeproject (project);
00573      1  4            END
00574      1  3           ELSE 
00575      1  4            BEGIN
00576      1  4            writeline (out,'Cannot find data file');
00577      1  4            pause;
00578      1  3            END;
00579      1  2          END;
00580      1  3    'S':  BEGIN
00581      1  3          readvary ('ENTER NAME OF FILE: ',arg,'');
00582      1  3          IF goodfilename (arg)
00583      1  3           THEN
00584      1  4            BEGIN
00585      1  4            rewrite (tempfile);
00586      1  4            startfcnget;
00587      1  4            WHILE NOT endoffcnget DO
00588      1  5               BEGIN
00589      1  5               fcnget (fn);
00590      1  5               writefcn (temp,fn,'R');
00591      1  4               END;
00592      1  4            open (textfile,arg,NEW);
00593      1  4            rewrite (textfile);
00594      1  4            reset (tempfile);
00595      1  4            WHILE NOT eof(tempfile) DO
00596      1  5               BEGIN
00597      1  5               readln (tempfile,st);
00598      1  5               writeln (textfile,st);
00599      1  4               END;
00600      1  4            close (textfile);
00601      1  4            writeline (both,'Functions written to file ' + arg);
00602      1  4            END
00603      1  3           ELSE
00604      1  4            BEGIN
00605      1  4            writeline (out,'Illegal file name "' + arg + '"');

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00606      1  4            pause;
00607      1  3            END;
00608      1  2          END;
00609      1  3    'U':  BEGIN
00610      1  3          starttrashget;
00611      1  3          IF endoftrashget 
00612      1  3           THEN 
00613      1  4            BEGIN
00614      1  4            writeline (out,'No functions in trash');
00615      1  4            pause;
00616      1  4            END
00617      1  3           ELSE 
00618      1  3            WHILE NOT endoftrashget DO
00619      1  4               BEGIN
00620      1  4               trashget (fn);
00621      1  4               writefcn (out,fn,'R');
00622      1  4               IF readyes ('DO YOU WISH TO UNTRASH THIS FUNCTION ? ')
00623      1  4                THEN 
00624      1  5                 BEGIN
00625      1  5                 readlogicalname ('ENTER NAME : ',fn.name,fn.name);
00626      1  5                 endoftrashget := true;
00627      1  5                 checkandinsertfunction (fn);
00628      1  4                 END;
00629      1  3               END;
00630      1  2          END;
00631      1  2    'V':  showfunction (out);
00632      1  2    ESC:  ;
00633      1  1    END;
00634      1  1 readargument (arg);
00635      0  0 END;
00636   C  0  0 {=============================================================================}
00637   C  0  0 {-- ROUTINE TO DO PROJECT COMMAND --------------------------------------------}
00638   C  0  0 {=============================================================================}
00639      1  0 PROCEDURE projectcommand;
00640      1  0 VAR
00641      1  0    modi,sel : command_type;
00642      1  0    fn       : fcn;
00643      1  0    arg      : anystring;
00644      1  1 BEGIN
00645      1  1 startcommand ('PROJECT',true);
00646      1  1 setcommand ('Audit');
00647      1  1 setcommand ('Change');
00648      1  1 setcommand ('Load');
00649      1  1 setcommand ('Old_inca_load');
00650      1  1 setcommand ('Save');
00651      1  1 setcommand ('View');
00652      1  1 readcommand (modi,'V',false,'PROJECT');
00653      1  2 CASE chofcom(modi) OF
00654      1  3    'A':  BEGIN
00655      1  3          showproject (aud);
00656      1  3          writeline (out,'Project summary placed in audit file');
00657      1  3          wait (0.5);
00658      1  2          END;
00659      1  3    'C':  BEGIN
00660      1  3          selectproject (sel,true);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00661      1  3          IF sel <> ''
00662      1  3           THEN 
00663      1  4            BEGIN
00664      1  4            writeproject (project);
00665      1  4            unread ('YES');
00666      1  4            clearfcns;
00667      1  4            IF sel = 'New'
00668      1  4             THEN readlogicalname ('ENTER NEW PROJECT NAME : ',project,project)
00669      1  4             ELSE project := sel;
00670      1  4            loadproject (project);
00671      1  3            END;
00672      1  2          END;
00673      1  3    'L':  BEGIN
00674      1  3          selectproject (sel,false);
00675      1  3          IF sel <> ''
00676      1  3           THEN 
00677      1  4            BEGIN
00678      1  4            loadproject (sel);
00679      1  4            writeproject (project);
00680      1  3            END;
00681      1  2          END;
00682      1  3    'O':  BEGIN
00683      1  3          startcommand ('Workspace Selection',false);
00684      1  3          startfilesearch ('*.WOR');
00685      1  3          WHILE NOT endoffilesearch DO
00686      1  4             BEGIN
00687      1  4             filesearch (arg);
00688      1  4             setcommand (fs.name);
00689      1  3             END;
00690      1  3          readcommand (sel,ESC,false,'PROJECT OLD_INCA_LOAD');
00691      1  3          IF exist (sel + '.WOR') 
00692      1  3           THEN 
00693      1  4            BEGIN
00694      1  4            workspaceload (sel);
00695      1  4            writeproject (project);
00696      1  4            END
00697      1  3           ELSE 
00698      1  4            BEGIN
00699      1  4            writeline (out,'Cannot find OLD INCA workspace file');
00700      1  4            pause;
00701      1  3            END;
00702      1  2          END;
00703      1  3    'S':  BEGIN
00704      1  3          readargument (arg);
00705      1  3          IF arg = ''
00706      1  3           THEN writeproject (project)
00707      1  3           ELSE writeproject (arg);
00708      1  2          END;
00709      1  3    'V':  BEGIN
00710      1  3          showproject (out);
00711      1  3          pause;
00712      1  2          END;
00713      1  2    ESC:  ;
00714      1  1    END;
00715      1  1 readargument (arg);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   14
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00716      0  0 END;
00717   C  0  0 {=============================================================================}
00718   C  0  0 {-- ROUTINE TO DO SET COMMAND ------------------------------------------------}
00719   C  0  0 {=============================================================================}
00720      1  0 PROCEDURE setdefaulteditformat (arg : anystring);
00721   C  1  0 {------------------------------}
00722      2  0 PROCEDURE showdefaulteditformat;
00723      2  1 BEGIN
00724      2  2 CASE defaulteditformat OF
00725      2  2    'B':  writeline (out,'The edit format is BODEGAIN_FACTORED');
00726      2  2    'D':  writeline (out,'The edit format is DEGREE_POLAR');
00727      2  2    'F':  writeline (out,'The edit format is FACTORED');
00728      2  2    'P':  writeline (out,'The edit format is POLAR');
00729      2  2    'R':  writeline (out,'The edit format is ROOTS');
00730      2  2    'U':  writeline (out,'The edit format is UNFACTORED');
00731      2  2    'Z':  writeline (out,'The edit format is ZETA_OMEGA');
00732      2  1    END;
00733      1  0 END;
00734   C  1  0 {------------------------------}
00735      1  1 BEGIN
00736      1  1 IF arg = '' THEN showdefaulteditformat;
00737      1  1 IF arg <> NUL
00738      1  1  THEN 
00739      1  2   BEGIN
00740      1  2   unread (arg);
00741      1  2   readch ('ENTER EDIT FORMAT : ',defaulteditformat,'BDFPRUZ',defaulteditformat);
00742      1  1   END;
00743      1  1 showdefaulteditformat;
00744      0  0 END;
00745   C  0  0 {-----------------------------------------------------------------------------}
00746      1  0 PROCEDURE setfreqplot (arg : anystring);
00747      1  0 VAR
00748      1  0    ch : char;
00749   C  1  0 {------------------------------}
00750      2  0 PROCEDURE showfreqplot;
00751      2  1 BEGIN
00752      2  1 writeline (out,'The default frequency response plot type is ' 
00753      2  1               + stroffreqplot (defaultfreqformat.freqplot));
00754      1  0 END;
00755   C  1  0 {------------------------------}
00756      1  1 BEGIN
00757      1  1 IF arg = '' THEN showfreqplot;
00758      1  1 IF arg <> NUL
00759      1  1  THEN 
00760      1  2   BEGIN
00761      1  2   unread (arg);
00762      1  2   readch ('ENTER FREQUENCY RESPONSE FORMAT : ',ch,'MPNCVBS ',' ');
00763      1  2   defaultfreqformat.freqplot := freqplotofch (ch);
00764      1  1   END;
00765      1  1 showfreqplot;
00766      0  0 END;
00767   C  0  0 {-----------------------------------------------------------------------------}
00768      1  0 PROCEDURE setter;
00769      1  0 VAR
00770      1  0    modi : command_type;

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   15
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00771      1  0    arg  : anystring;
00772   C  1  0 {------------------------------}
00773      2  0 PROCEDURE doset (modi : command_type;  arg : anystring);
00774      2  0 VAR
00775      2  0    i    : integer;
00776      2  1 BEGIN
00777      2  2 CASE chofcom(modi) OF
00778      2  2    'B':  setflag (boundarygrid,             modi,arg);
00779      2  2    'C':  setreal (closezero,                modi,arg,1d-18,BIG);
00780      2  2    'D':  setflag (defaultfreqformat.db,     modi,arg);
00781      2  2    'E':  setdefaulteditformat                   (arg);
00782      2  2    'F':  setfreqplot                            (arg);
00783      2  2    'G':  setflag (defaultfreqformat.flog,   modi,arg);
00784      2  2    'H':  setflag (defaultfreqformat.hz,     modi,arg);
00785      2  2    'L':  setflag (showlogo,                 modi,arg);
00786      2  2    'N':  setreal (nearness,                 modi,arg,1d-18,1);
00787      2  2    'Q':  setint  (QZaddcutoff,              modi,arg,0,50);
00788      2  2    'R':  setint  (rootmax,                  modi,arg,0,100);
00789      2  2    'S':  setint  (searchcircle,             modi,arg,0,65536);
00790      2  2    'T':  setflag (toprightlable,            modi,arg);
00791      2  2    'W':  setreal (wrapping,                 modi,arg,-BIG,BIG);
00792      2  2    'Z':  setreal (zagging,                  modi,arg,-100,100);
00793      2  2    ESC:  ;
00794      2  2    OTHERWISE 
00795      2  3          BEGIN
00796      2  3          FOR i := 1 TO commandcount DO doset (commandcreate(i),NUL);
00797      2  3          pause;
00798      2  2          END;
00799      2  1    END;
00800      1  0 END;
00801   C  1  0 {------------------------------}
00802      1  1 BEGIN
00803      1  1 startcommand ('SET modifier',true);
00804      1  1 setcommand ('Boundary_Grid');
00805      1  1 setcommand ('Closeness_to_Zero');
00806      1  1 setcommand ('DB');
00807      1  1 setcommand ('Edit_Format');
00808      1  1 setcommand ('Frequency_Plot');
00809      1  1 setcommand ('loGarithmic_Freq');
00810      1  1 setcommand ('Hertz');
00811      1  1 setcommand ('Logo_Show');
00812      1  1 setcommand ('Nearness');
00813      1  1 setcommand ('QZ_Add_Cutoff');
00814      1  1 setcommand ('Root_Maximum');
00815      1  1 setcommand ('Search_Circle');
00816      1  1 setcommand ('Top_Right_Label');
00817      1  1 setcommand ('Wrap');
00818      1  1 setcommand ('Zagging');
00819      1  1 readcommand (modi,' ',false,'SET');
00820      1  1 readargument (arg);
00821      1  1 doset (modi,arg);
00822      0  0 END;
00823   C  0  0 {=============================================================================}
00824   C  0  0 {-- ROUTINE TO DO VIEW COMMAND -----------------------------------------------}
00825   C  0  0 {=============================================================================}

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   16
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00826      1  0 PROCEDURE viewnews (dest : destination);
00827      1  0 VAR
00828      1  0    string : VARYING [79] OF char;
00829      1  1 BEGIN
00830      1  1 writeline (dest,pad('','=',79));
00831      1  1 writeline (dest,INCAVERSION + '        ' + strtime);
00832      1  1 open (textfile,'QPLOTHOME:INCANEWS.DAT',old,ERROR:=CONTINUE);
00833      1  1 IF status(textfile) <> 0
00834      1  1  THEN writeline (dest,'NO NEWS TODAY')
00835      1  1  ELSE
00836      1  2   BEGIN
00837      1  2   reset (textfile);
00838      1  2   WHILE NOT eof(textfile) DO
00839      1  3      BEGIN
00840      1  3      readln (textfile,string);
00841      1  3      writeline (dest,string);
00842      1  2      END;
00843      1  2   close (textfile);  
00844      1  1   END;
00845      1  1 writeline (out,pad('','=',79));
00846      0  0 END;
00847   C  0  0 {-----------------------------------------------------------------------------}
00848      1  0 PROCEDURE view;
00849      1  0 VAR
00850      1  0    modi : command_type;
00851      1  0    arg  : anystring;
00852      1  1 BEGIN
00853      1  1 startcommand ('VIEW modifier',true);
00854      1  1 setcommand ('Audit_File');
00855      1  1 setcommand ('Composite');
00856      1  1 setcommand ('Logo');
00857      1  1 setcommand ('News');
00858      1  1 setcommand ('Used_CPU_Time');
00859      1  1 setcommand ('Version');
00860      1  1 readcommand (modi,'C',false,'VIEW');
00861      1  1 
00862      1  2 CASE chofcom(modi) OF
00863      1  3    'A':  BEGIN
00864      1  3          readvary ('ENTER NAME OF EDITOR : ',arg,'EDT');
00865      1  3          closeaudit ('SAVE');
00866      1  3          IF arg <> 'EDT'
00867      1  3           THEN LIB$SPAWN (arg + ' ' + auditfilename)
00868      1  3          ELSE IF config.ansi364
00869      1  3           THEN EDT$EDIT ((auditfilename),,'QPLOTHOME:EDTINI.EDT')
00870      1  3           ELSE EDT$EDIT ((auditfilename),,);
00871      1  3          reopenaudit;
00872      1  2          END;
00873      1  3    'C':  BEGIN
00874      1  3          writeline (out,'Time used = ' 
00875      1  3                       + strofr2 ((clock-startclock) / 100,8,2) + ' seconds');
00876      1  3          writeline (out,INCAVERSION);
00877      1  3          viewnews (out);
00878      1  2          END;
00879      1  3    'L':  BEGIN
00880      1  3          readargument (arg);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   17
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00881      1  3          clearscreen;
00882      1  3          incalogo (10000,40000,600);
00883   C  1  3          { newlogo (6400,32000,500); }
00884      1  3          graphicpause;
00885      1  3          clearscreen;
00886      1  2          END;
00887      1  2    'N':  viewnews (out);
00888      1  2    'U':  writeline (out,'Time used = ' 
00889      1  2                       + strofr2 ((clock-startclock) / 100,8,2) + ' seconds');
00890      1  2    'V':  writeline (out,INCAVERSION);
00891      1  2    ESC:  ;
00892      1  1    END;
00893      1  1 readargument (arg);
00894      1  1 IF NOT (chofcom(modi) IN [ESC,'L']) THEN pause;
00895      0  0 END;
00896   C  0  0 {=============================================================================}
00897   C  0  0 {-- ROUTINE TO DO XIT COMMAND ------------------------------------------------}
00898   C  0  0 {=============================================================================}
00899      1  0 PROCEDURE xit (VAR go : boolean);
00900      1  0 VAR
00901      1  0    modi    : command_type;
00902      1  0    arg     : anystring;
00903      1  0    cputime : VARYING [10] OF char;
00904      1  1 BEGIN
00905      1  1 startcommand ('XIT',true);
00906      1  1 setcommand ('Save_Audit_File');
00907      1  1 setcommand ('Print_Audit_File');
00908      1  1 setcommand ('Delete_Audit_File');
00909      1  1 setcommand ('Both_Print_Delete');
00910      1  1 setcommand ('Remove_Old_Versions');
00911      1  1 readcommand (modi,'S',false,'XIT');
00912      1  1 readargument (arg);
00913      1  1 
00914      1  1 IF modi <> ESC
00915      1  1  THEN
00916      1  2   BEGIN
00917      1  2   go := false;
00918      1  2   writeline (aud,pad('','=',128));
00919      1  2   cputime := strofi ((clock-startclock) DIV 1000,7)
00920      1  2      + '.' + strofi ((clock-startclock) MOD 1000 DIV 10,2);
00921      1  2   IF cputime[9] = ' ' THEN cputime[9] := '0';
00922      1  2   writeline (both,'CPU time used is ' + cputime + ' seconds.');
00923      1  2   writeline (aud,strtime);
00924      1  2   writeline (aud,pad('','=',128));
00925      1  3   CASE chofcom(modi) OF
00926      1  3      'S':  closeaudit ('SAVE');
00927      1  4      'R':  BEGIN
00928      1  4            closeaudit ('SAVE');
00929      1  4            LIB$SPAWN ('PURGE ' + auditfilename);
00930      1  3            END;
00931      1  3      'D':  closeaudit ('DELETE');
00932      1  3      'P':  closeaudit ('PRINT');
00933      1  3      'B':  closeaudit ('PRINT_DELETE');
00934      1  2      END;
00935      1  2   writeproject (project);

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   18
INCA                            Source Listing                  30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

-LINE-IDC-PL-SL-

00936      1  2   clearscreen;
00937      1  1   END;
00938      0  0 END;
00939   C  0  0 {=============================================================================}
00940   C  0  0 {-- ROUTINE TO DO ZAP COMMAND ------------------------------------------------}
00941   C  0  0 {=============================================================================}
00942      1  0 PROCEDURE zap;
00943      1  0 VAR
00944      1  0    arg     : anystring;
00945      1  1 BEGIN
00946      1  1 readargument (arg);
00947      1  1 writeline (out,' ');
00948      1  1 clearscreen;
00949      0  0 END;
00950   C  0  0 {=============================================================================}
00951      0  0 END.

MISC                                                            23-Dec-1988 11:01:37    VAX Pascal V3.7-254                Page   19
INCA                            Pascal Compilation Statistics   30-Nov-1988 09:59:16    DUA1:[QPLOT.INCA.SOURCE]MISC.PAS;340 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               31190  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260        19         7
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        49        40
DUA1:[QPLOT.QPLOT.SOURCE]DIRECTORY.PEN;1                  45        34        76
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20        15        75
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        52        72
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         0         0
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        42        20
DUA1:[QPLOT.QPLOT.SOURCE]IOBASE.PEN;1                    104        30        29
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        95        47
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292         1         0
DUA1:[QPLOT.QPLOT.SOURCE]UTILITIES.PEN;1                 105        20        19
DUA1:[QPLOT.INCA.SOURCE]EDIT.PEN;1                       131         9         7
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       310        82
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        87        47
DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PEN;1                    114        74        65
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248       109        44
DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PEN;1                     167         6         4
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         3         2
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289       129        45



PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:IO',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:MATH',
00007      0  0                'QLIBHOME:COMPLEX',
00008      0  0                'QLIBHOME:COLOR',
00009      0  0                'QLIBHOME:FIG',
00010      0  0                'QLIBHOME:HANDLER',
00011      0  0                'QLIBHOME:UTILITIES',
00012      0  0                'QLIBHOME:PLOT',
00013      0  0                'CURVE','FCN','FCNEVAL','FCNIO','UTIL'),
00014      0  0   ENVIRONMENT ('PLOT')]
00015      0  0 MODULE plotinca;
00016      0  0 [ HIDDEN ] CONST
00017      0  0    WINLINELIM       = 10;
00018      0  0    WINITEMLIM       = 10;
00019      0  0 [ HIDDEN ] TYPE
00020      0  0    winlineitem_type = RECORD
00021      0  0                       curveix    : integer;
00022      0  0                       color      : color_type;
00023      0  0                       END;
00024      0  0    winline_type     = RECORD
00025      0  0                       count      : integer;
00026      0  0                       lable      : anystring;
00027      0  0                       data       : ARRAY [1..WINLINELIM] OF winlineitem_type;
00028      0  0                       END;
00029      0  0    winbox_type      = RECORD
00030      0  0                       xmin,xmax,ymin,ymax : integer;
00031      0  0                       END;
00032      0  0 
00033      0  0    winitem_type     = RECORD
00034      0  0                       box        : winbox_type;
00035      0  0                       line       : winline_type;
00036      0  0                       usertitle  : anystring;
00037      0  0                       CASE curveclass : curveclass_type OF
00038      0  0                           C_EMP:  ();
00039      0  0                           C_LOC:  (loc        : RECORD
00040      0  0                                                 fr         : framelink;
00041      0  0                                                 plane      : char;
00042      0  0                                                 END);
00043      0  0                           C_FRE:  (fre        : RECORD
00044      0  0                                                 freqformat : freqformat_type;
00045      0  0                                                 ori        : real;
00046      0  0                                                 fr1        : framelink;
00047      0  0                                                 fr2        : framelink;
00048      0  0                                                 END);
00049      0  0                           C_TIR:  (tir        : RECORD
00050      0  0                                                 fr         : framelink;
00051      0  0                                                 END);
00052      0  0                       END;
00053      0  0    winlink          = ^winitem_type;
00054      0  0 [ HIDDEN ] VAR
00055      0  0    gcount           : integer    := 0;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00056      0  0    infinity         : real       := 200d0;
00057      0  0    win              : RECORD
00058      0  0                       count      : integer;
00059      0  0                       data       : ARRAY [1..WINITEMLIM] OF winlink;
00060      0  0                       END
00061      0  0                     := (0,(WINITEMLIM OF NIL));
00062      0  0 
00063      0  0 [ HIDDEN ] VAR
00064      0  0    locusframe     : [ VOLATILE ] frame_type
00065      0  0                   := ((false,1,'REAL','',true,false,0,0,0,0,0,0,
00066      0  0                          false,'XTICK','XSUBTICK',
00067      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00068      0  0                       (false,1,'IMAG','',true,false,0,0,0,0,0,0,
00069      0  0                          false,'YTICK','YSUBTICK',
00070      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00071      0  0                       'LOCUS',
00072      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00073      0  0                       false,false,NIL,0,true,false,false,1024,640,7,65,65,
00074      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00075      0  0 
00076      0  0    frmagframe     : [ VOLATILE ] frame_type
00077      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00078      0  0                          false,'XTICK','XSUBTICK',
00079      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00080      0  0                       (false,1,'','',true,false,0,0,0,0,0,0,
00081      0  0                          false,'YTICK','YSUBTICK',
00082      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00083      0  0                       'MAGNITUDE',
00084      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00085      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00086      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00087      0  0 
00088      0  0    frbodmagframe  : [ VOLATILE ] frame_type
00089      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00090      0  0                          false,'XTICK','XSUBTICK',
00091      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00092      0  0                       (false,1,'','',true,false,0,0,0,0,0,0,
00093      0  0                          false,'MAGNITUDE','MAGNITUDE',
00094      0  0                                'YGRID','YSUBGRID','MAGNITUDE','MAGNITUDE'),
00095      0  0                       'BODE_MAGNITUDE',
00096      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00097      0  0                       false,false,NIL,0,false,true,false,1024,640,7,65,65,
00098      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00099      0  0 
00100      0  0    frbmpmagframe  : [ VOLATILE ] frame_type
00101      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00102      0  0                          false,'CLEAR','CLEAR',
00103      0  0                                'XGRID','XSUBGRID','CLEAR','CLEAR'),
00104      0  0                       (false,1,'','',true,false,0,0,0,0,0,0,
00105      0  0                          false,'YTICK','YSUBTICK',
00106      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00107      0  0                       'BODE_STRIP_MAGNITUDE',
00108      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00109      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00110      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00111      0  0 
00112      0  0    frphaframe     : [ VOLATILE ] frame_type
00113      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00114      0  0                          false,'XTICK','XSUBTICK',
00115      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00116      0  0                       (false,1,'PHASE','o',true,false,0,0,0,0,0,0,
00117      0  0                          false,'YTICK','YSUBTICK',
00118      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00119      0  0                       'PHASE',
00120      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00121      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00122      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00123      0  0 
00124      0  0    frbodphaframe  : [ VOLATILE ] frame_type
00125      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00126      0  0                          false,'CLEAR','CLEAR',
00127      0  0                                'CLEAR','CLEAR','CLEAR','CLEAR'),
00128      0  0                       (false,1,'PHASE','o',false,true,0,0,0,0,0,0,
00129      0  0                          false,'PHASE','PHASE',
00130      0  0                                'YGRID','YSUBGRID','PHASE','PHASE'),
00131      0  0                       'BODE_PHASE',
00132      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00133      0  0                       false,false,NIL,0,false,true,true,1024,640,7,65,65,
00134      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00135      0  0 
00136      0  0    frbmpphaframe  : [ VOLATILE ] frame_type
00137      0  0                   := ((false,1,'','',true,false,0,0,0,0,0,0,
00138      0  0                          false,'XTICK','XSUBTICK',
00139      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00140      0  0                       (false,1,'PHASE','o',true,false,0,0,0,0,0,0,
00141      0  0                          false,'YTICK','YSUBTICK',
00142      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00143      0  0                       'BODE_STRIP_PHASE',
00144      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00145      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00146      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00147      0  0 
00148      0  0    frnyqframe     : [ VOLATILE ] frame_type
00149      0  0                   := ((false,1,'MAGNITUDE','',true,false,0,0,0,0,0,0,
00150      0  0                          false,'XTICK','XSUBTICK',
00151      0  0                                'POLARGRID','POLARGRID','XLABEL','XNUMBER'),
00152      0  0                       (false,1,'PHASE','o',true,true,0,0,0,0,0,0,
00153      0  0                          false,'YTICK','YSUBTICK',
00154      0  0                                'POLARGRID','POLARGRID','YLABEL','YNUMBER'),
00155      0  0                       'NYQUIST',
00156      0  0                       POLAR,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00157      0  0                       false,false,NIL,0,true,false,false,1024,640,7,65,65,
00158      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00159      0  0 
00160      0  0    frnicframe     : [ VOLATILE ] frame_type
00161      0  0                   := ((false,1,'PHASE','o',true,false,0,0,0,0,0,0,
00162      0  0                          false,'XTICK','XSUBTICK',
00163      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00164      0  0                       (false,1,'MAGNITUDE','',true,true,0,0,0,0,0,0,
00165      0  0                          false,'YTICK','YSUBTICK',

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00166      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00167      0  0                       'NICHOLS',
00168      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00169      0  0                       false,false,NIL,0,true,false,false,1024,640,7,65,65,
00170      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00171      0  0 
00172      0  0    frpopframe     : [ VOLATILE ] frame_type
00173      0  0                   := ((false,1,'REAL PART','',true,false,0,0,0,0,0,0,
00174      0  0                          false,'XTICK','XSUBTICK',
00175      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00176      0  0                       (false,1,'IMAG * FREQ','',true,true,0,0,0,0,0,0,
00177      0  0                          false,'YTICK','YSUBTICK',
00178      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00179      0  0                       'POPOV',
00180      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00181      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00182      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00183      0  0 
00184      0  0    timerframe     : [ VOLATILE ] frame_type
00185      0  0                   := ((false,1,'TIME (seconds)','',true,false,0,0,0,0,0,0,
00186      0  0                          false,'XTICK','XSUBTICK',
00187      0  0                                'XGRID','XSUBGRID','XLABEL','XNUMBER'),
00188      0  0                       (false,1,'','',true,false,0,0,0,0,0,0,
00189      0  0                          false,'YTICK','YSUBTICK',
00190      0  0                                'YGRID','YSUBGRID','YLABEL','YNUMBER'),
00191      0  0                       'TIME_RESPONSE',
00192      0  0                       XYTICK,((0,0),(1,1)),((0,0),(0,1)),((0,0),(1,1)),
00193      0  0                       false,false,NIL,0,false,false,false,1024,640,7,65,65,
00194      0  0                       'WINDOW','PANE','BOX','FILL','HEADING');
00195   C  0  0 {-----------------------------------------------------------------------------}
00196      0  0 [ HIDDEN, INITIALIZE ]
00197      1  0 PROCEDURE addplotframe;
00198      1  1 BEGIN
00199      1  1 addtemplate (address (locusframe));
00200      1  1 addtemplate (address (frmagframe));
00201      1  1 addtemplate (address (frbodmagframe));
00202      1  1 addtemplate (address (frbmpmagframe));
00203      1  1 addtemplate (address (frphaframe));
00204      1  1 addtemplate (address (frbodphaframe));
00205      1  1 addtemplate (address (frbmpphaframe));
00206      1  1 addtemplate (address (frnyqframe));
00207      1  1 addtemplate (address (frnicframe));
00208      1  1 addtemplate (address (frpopframe));
00209      1  1 addtemplate (address (timerframe));
00210      0  0 END;
00211   C  0  0 {=============================================================================}
00212   C  0  0 {-- UTILITIY ROUTINES FOR PLOTTING FREQUENCY RESPONSE ------------------------}
00213   C  0  0 {=============================================================================}
00214      1  0 PROCEDURE checkforpwpf (VAR selstr : anystring);
00215      1  0 VAR
00216      1  0    j,ind,indexlength           : integer;
00217      1  0    pwpfindex,nameofpwpfcurves  : anystring;
00218      1  0    thiscurve                   : command_type;
00219      1  1 BEGIN
00220      1  1 IF curveexist (selstr)

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00221      1  1  THEN
00222      1  2   BEGIN
00223      1  2   ind := getcurveindex(selstr);
00224      1  2   IF curve.data[ind].lable = 'MULTI_PWPF'
00225      1  2    THEN
00226      1  3     BEGIN
00227      1  3     selstr := ' ';
00228      1  3     FOR j := 1 to (curve.data[ind].fcptr^.f.numname + 1) DO
00229      1  4        BEGIN
00230      1  4        indexlength := trunc(log10(j)) + 1;
00231      1  4        pwpfindex := strofi(j,indexlength);
00232      1  4        thiscurve:= curve.data[ind].name + pwpfindex;
00233      1  4        IF j = 1
00234      1  4         THEN selstr := selstr + thiscurve
00235      1  4         ELSE selstr := selstr + ', ' + thiscurve;
00236      1  3        END;
00237      1  2     END;
00238      1  1   END;
00239      0  0 END;
00240   C  0  0 {-----------------------------------------------------------------------------}
00241      1  0 PROCEDURE pwsqueeze (VAR string : anystring);
00242      1  0 VAR
00243      1  0    lablesofar, restoflable, str, cv  : anystring;
00244      1  0    i, j, strstart, strlength         : integer;
00245      1  0    cvlength, startofrest             : integer;
00246      1  0    p                                 : parse_type;
00247      1  1 BEGIN
00248      1  1 startparse(p,string);
00249      1  1 lablesofar := '';
00250      1  1 strstart := 1;
00251      1  2 REPEAT
00252      1  2    str := parse(p,', ');
00253      1  2    IF (str <> ', ') AND (str <> '')
00254      1  2     THEN
00255      1  3      BEGIN
00256      1  3      strlength := length(str);
00257      1  3      cv := str;
00258      1  3      checkforpwpf(cv);
00259      1  3      cvlength := length(cv);
00260      1  3      IF strlength <> cvlength
00261      1  3       THEN
00262      1  4        BEGIN
00263      1  4        i := 0;
00264      1  4        restoflable := '';
00265      1  4        WHILE p.line[p.ic + i] <> NUL DO
00266      1  5           BEGIN
00267      1  5           restoflable := restoflable + p.line[p.ic + i];
00268      1  5           i := i + 1;
00269      1  4           END;
00270      1  4        p.line := lablesofar + cv + restoflable + NUL;
00271      1  4        p.ic := strstart + cvlength;
00272      1  3        END;
00273      1  3      strstart := p.ic;
00274      1  2      END;
00275      1  2    lablesofar := lablesofar + str;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00276      1  1    UNTIL p.line[p.ic] = NUL;
00277      1  1 string := p.line;
00278      0  0 END;
00279   C  0  0 {-----------------------------------------------------------------------------}
00280      1  0 FUNCTION winlinkofframelink (fr : framelink) : winlink;
00281      1  0 VAR
00282      1  0    i,j : integer;
00283      1  1 BEGIN
00284      1  1 j := 0;
00285      1  1 FOR i := 1 TO win.count DO
00286      1  1    WITH win.data[i]^ DO
00287      1  2       CASE curveclass OF
00288      1  2          C_EMP:  ;
00289      1  2          C_LOC:  IF fr = loc.fr THEN j := i;
00290      1  2          C_FRE:  IF (fr = fre.fr1) OR (fr = fre.fr2) THEN j := i;
00291      1  2          C_TIR:  IF fr = tir.fr THEN j := i;
00292      1  1          END;
00293      1  1 IF j = 0
00294      1  1  THEN winlinkofframelink := NIL
00295      1  1  ELSE winlinkofframelink := win.data[j];
00296      0  0 END;
00297   C  0  0 {-----------------------------------------------------------------------------}
00298      1  0 FUNCTION phnorm (phase : real) : real;
00299      1  1 BEGIN
00300      1  1 phnorm := rmod (phase-wrapping+360d0, 360d0) + wrapping;
00301      0  0 END;
00302   C  0  0 {-----------------------------------------------------------------------------}
00303      1  0 FUNCTION pseudodb (VAR fc : frecurve_type;  i : integer) : real;
00304      1  1 BEGIN
00305      1  1 IF abs (fc.dat[i].db) < 10 * LOGINFINITY
00306      1  1  THEN pseudodb := fc.dat[i].db
00307      1  1 ELSE IF i = 1
00308      1  1  THEN pseudodb := fc.dat[i+1].db
00309      1  1         + imin (1,imax(-1,round (fc.dat[i].db/20/LOGINFINITY))) * infinity
00310      1  1 ELSE IF i = fc.steps
00311      1  1  THEN pseudodb := fc.dat[i-1].db
00312      1  1         + imin (1,imax(-1,round (fc.dat[i].db/20/LOGINFINITY))) * infinity
00313      1  1  ELSE pseudodb := (fc.dat[i-1].db + fc.dat[i-1].db) / 2
00314      1  1         + imin (1,imax(-1,round (fc.dat[i].db/20/LOGINFINITY))) * infinity;
00315      0  0 END;
00316   C  0  0 {-----------------------------------------------------------------------------}
00317      1  0 FUNCTION mul (db : boolean) : double;
00318      1  1 BEGIN
00319      1  1 IF db THEN mul := 1d0 ELSE mul := 0.05d0;
00320      0  0 END;
00321   C  0  0 {-----------------------------------------------------------------------------}
00322      1  0 PROCEDURE strfromfredattype (VAR strw,strmag,strpha : anystring;
00323      1  0    fr : fredat_type;  freqformat : freqformat_type;  width : integer;
00324      1  0    ft : ftype_type);
00325      1  1 BEGIN
00326      1  2 CASE ft OF
00327      1  2    SFR: IF freqformat.hz
00328      1  2          THEN
00329      1  3           BEGIN
00330      1  3           strw := 'W=' + strofr (fr.omega/2d0/PI,width);

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00331      1  3           IF strw[width-1] = ' '
00332      1  3            THEN strw := substr (strw,1,width-2) + ' Hz'
00333      1  3            ELSE strw := strw + ' Hz';
00334      1  3           END
00335      1  2          ELSE
00336      1  3           BEGIN
00337      1  3           strw := 'W=' + strofr (fr.omega,width);
00338      1  3           IF strw[width-1] = ' '
00339      1  3            THEN strw := substr (strw,1,width-2) + ' rps'
00340      1  3            ELSE strw := strw + ' rps';
00341      1  2           END; { if }
00342      1  2    DES: strw := 'X=' + strofr (fr.amp,width);
00343      1  2    NRA: ;
00344      1  1    END;
00345      1  1 
00346      1  1 IF freqformat.db
00347      1  1  THEN
00348      1  2   BEGIN
00349      1  2   strmag := 'M=' + strofr (fr.db,width);
00350      1  2   IF strmag[width-1] = ' '
00351      1  2    THEN strmag := substr (strmag,1,width-2) + ' dB'
00352      1  2    ELSE strmag := strmag + ' dB';
00353      1  2   END
00354      1  1  ELSE strmag := 'M=' + strofr (exp10(fr.db/20d0),width);
00355      1  1 
00356      1  1 strpha := 'P=' + strofr (phnorm(fr.phase),width);
00357      0  0 END;
00358   C  0  0 {=============================================================================}
00359   C  0  0 {-- ROUTINES TO CALCULATE LIMITS ---------------------------------------------}
00360   C  0  0 {=============================================================================}
00361      1  0 FUNCTION calclim (VAR line : winline_type;  cc : curveclass_type;
00362      1  0    db : boolean;  fp : freqplot_type;  VAR ori : real) : plotlimits;
00363      1  0 VAR
00364      1  0    lim : plotlimits;
00365   C  1  0 {------------------------------}
00366      2  0 PROCEDURE checklim (VAR min,max : real;  factor : real);
00367      2  0 VAR
00368      2  0    dif   : real;
00369      2  1 BEGIN
00370      2  1 dif := max - min;
00371      2  1 IF dif = 0
00372      2  1  THEN factor := 0.1
00373      2  1  ELSE dif := rmax (dif,1d-6 * (abs(max) + abs(min)));
00374      2  1 
00375      2  1 IF dif <> 0
00376      2  2  THEN BEGIN  max := max + dif * factor;  min := min - dif * factor;  END
00377      2  1 ELSE IF max > 0
00378      2  2  THEN BEGIN  max := max + max * factor;  min := -max * factor;       END
00379      2  1 ELSE IF max < 0
00380      2  2  THEN BEGIN  min := min + min * factor;  max := -min * factor;       END
00381      2  1  ELSE BEGIN  max := 1;                   min := -1;                  END;
00382      1  0 END;
00383   C  1  0 {------------------------------}
00384      2  0 PROCEDURE calcmaglim;
00385      2  0 VAR

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00386      2  0    i,j   : integer;
00387      2  1 BEGIN
00388      2  1 lim  := plotlimits ((BIG,BIG),(-BIG,-BIG));
00389      2  1 FOR j := 1 TO line.count DO
00390      2  1    WITH curve.data[line.data[j].curveix] DO
00391      2  1       FOR i := 1 TO fcptr^.steps DO
00392      2  2          BEGIN
00393      2  2          broadenx (lim, fcptr^.dat[i].omega);
00394      2  2          IF db
00395      2  2           THEN broadeny (lim, pseudodb (fcptr^,i))
00396      2  2           ELSE broadeny (lim, exp10 (fcptr^.dat[i].db/20d0));
00397      2  1          END;
00398      2  1 IF db THEN checklim (lim.min.y,lim.max.y,0.1);
00399      1  0 END;
00400   C  1  0 {------------------------------}
00401      2  0 PROCEDURE calcphalim;
00402      2  0 VAR
00403      2  0    i,j   : integer;
00404      2  1 BEGIN
00405      2  1 lim  := plotlimits ((BIG,-180d0),(-BIG,180d0));
00406      2  1 lim.min.y := wrapping;
00407      2  1 lim.max.y := wrapping + 360d0;
00408      2  1 FOR j := 1 TO line.count DO
00409      2  1    WITH curve.data[line.data[j].curveix].fcptr^ DO
00410      2  1       FOR i := 1 TO steps DO
00411      2  1          broadenx (lim,dat[i].omega);
00412      1  0 END;
00413   C  1  0 {------------------------------}
00414      2  0 PROCEDURE calcnyqlim;
00415      2  0 VAR
00416      2  0    i,j   : integer;
00417      2  0    temp  : real;
00418      2  1 BEGIN
00419      2  1 lim := calclim (line,C_FRE,true,mag,ori);
00420      2  1 IF ori = UNDEFINED_REAL THEN ori := mul(db) * (lim.min.y - 10);
00421      2  1 lim := plotlimits ((0,0),(0,0));
00422      2  1 FOR j := 1 TO line.count DO
00423      2  1    WITH curve.data[line.data[j].curveix] DO
00424      2  1       FOR i := 1 TO fcptr^.steps DO
00425      2  1          IF abs (fcptr^.dat[i].db) > 10 * LOGINFINITY
00426      2  1           THEN
00427      2  2            BEGIN
00428      2  2            temp := 1.1 * mul(db) * (pseudodb (fcptr^,i) - ori);
00429      2  2            broadenxy (lim,temp,temp);
00430      2  2            broadenxy (lim,-temp,-temp);
00431      2  2            END
00432      2  1          ELSE IF mul(db) * fcptr^.dat[i].db > ori
00433      2  1           THEN broadenxy (lim,mul(db) * (fcptr^.dat[i].db - ori)
00434      2  1                             * cos (fcptr^.dat[i].phase * PI / 180),
00435      2  1                               mul(db) * (fcptr^.dat[i].db - ori)
00436      2  1                             * sin (fcptr^.dat[i].phase * PI / 180));
00437      2  1 checklim (lim.min.x,lim.max.x,0.1);
00438      2  1 checklim (lim.min.y,lim.max.y,0.1);
00439      2  1 samescale (lim);
00440      1  0 END;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00441   C  1  0 {------------------------------}
00442      2  0 PROCEDURE calcniclim;
00443      2  0 VAR
00444      2  0    i,j   : integer;
00445      2  1 BEGIN
00446      2  1 lim  := plotlimits ((-180d0,BIG),(180d0,-BIG));
00447      2  1 lim.min.x := wrapping;
00448      2  1 lim.max.x := wrapping + 360d0;
00449      2  1 FOR j := 1 TO line.count DO
00450      2  1    WITH curve.data[line.data[j].curveix] DO
00451      2  1       FOR i := 1 TO fcptr^.steps DO
00452      2  1          IF db
00453      2  1           THEN broadeny (lim,pseudodb (fcptr^,i))
00454      2  1           ELSE broadeny (lim, exp10 (fcptr^.dat[i].db/20d0));
00455      2  1 IF db THEN checklim (lim.min.y,lim.max.y,0.1);
00456      1  0 END;
00457   C  1  0 {------------------------------}
00458      2  0 PROCEDURE calcpoplim;
00459      2  0 VAR
00460      2  0    i,j   : integer;
00461      2  1 BEGIN
00462      2  1 lim := plotlimits ((0,0),(0,0));
00463      2  1 FOR j := 1 TO line.count DO
00464      2  1    WITH curve.data[line.data[j].curveix].fcptr^ DO
00465      2  1       FOR i := 1 TO steps DO
00466      2  1          broadenxy (lim, (exp10 (dat[i].db/20d0))
00467      2  1                           * cos (dat[i].phase * PI/180),
00468      2  1                          (exp10 (dat[i].db/20d0))
00469      2  1                           * sin (dat[i].phase * PI/180) * dat[i].omega);
00470      2  1 checklim (lim.min.x,lim.max.x,0.1);
00471      2  1 checklim (lim.min.y,lim.max.y,0.1);
00472      1  0 END;
00473   C  1  0 {------------------------------}
00474      2  0 PROCEDURE calcloclim;
00475      2  0 VAR
00476      2  0    i,j   : integer;
00477      2  1 BEGIN
00478      2  1 lim := plotlimits ((0,0),(0,0));
00479      2  1 FOR j := 1 TO line.count DO
00480      2  1    WITH curve.data[line.data[j].curveix] DO
00481      2  2       BEGIN
00482      2  2       broadenxy (lim, lcptr^.l.lim.min.x, lcptr^.l.lim.min.y);
00483      2  2       broadenxy (lim, lcptr^.l.lim.max.x, lcptr^.l.lim.max.y);
00484      2  1       END;
00485      2  1 samescale (lim);
00486      1  0 END;
00487   C  1  0 {------------------------------}
00488      2  0 PROCEDURE calctirlim;
00489      2  0 VAR
00490      2  0    i,j,k : integer;
00491      2  1 BEGIN
00492      2  1 lim  := plotlimits ((BIG,BIG),(-BIG,-BIG));
00493      2  1 FOR j := 1 TO line.count DO
00494      2  1    WITH curve.data[line.data[j].curveix].tcptr^ DO
00495      2  1       FOR i := 1 TO steps DO

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00496      2  2          BEGIN
00497      2  2          broadenx (lim,dat[i].time);
00498      2  2          IF NOT continuous
00499      2  2           THEN broadenx (lim,dat[i].time + dt);
00500      2  2          FOR k := 1 TO count DO
00501      2  2             broadeny (lim,dat[i].value[k]);
00502      2  1          END;
00503      2  1 checklim (lim.min.y,lim.max.y,0.1);
00504      1  0 END;
00505   C  1  0 {------------------------------}
00506      1  1 BEGIN
00507      1  2 CASE cc OF
00508      1  2    C_EMP:  ;
00509      1  2    C_LOC:  calcloclim;
00510      1  3    C_FRE:  CASE fp OF
00511      1  3               mag:  calcmaglim;
00512      1  3               pha:  calcphalim;
00513      1  3               nyq:  calcnyqlim;
00514      1  3               nic:  calcniclim;
00515      1  3               pop:  calcpoplim;
00516      1  2               END;
00517      1  2    C_TIR:  calctirlim;
00518      1  1    END;
00519      1  1 calclim := lim;
00520      0  0 END;
00521   C  0  0 {=============================================================================}
00522   C  0  0 {-- ROUTINE TO MAKE FRAMES ---------------------------------------------------}
00523   C  0  0 {=============================================================================}
00524      1  0 PROCEDURE makefreqrframes (ww : winlink);
00525      1  1 BEGIN
00526      1  1 WITH ww^,fre DO
00527      1  2    BEGIN
00528      1  2    fr1 := NIL;
00529      1  2    fr2 := NIL;
00530      1  3    CASE freqformat.freqplot OF
00531      1  4       bod:  BEGIN
00532      1  4             makeframe (fr2,address (frbodphaframe),
00533      1  4                          calclim (line,C_FRE,freqformat.db,pha,ori));
00534      1  4             makeframe (fr1,address (frbodmagframe),
00535      1  4                          calclim (line,C_FRE,freqformat.db,mag,ori));
00536      1  3             END;
00537      1  4       bmp:  BEGIN
00538      1  4             makeframe (fr2,address (frbmpphaframe),
00539      1  4                          calclim (line,C_FRE,freqformat.db,pha,ori));
00540      1  4             makeframe (fr1,address (frbmpmagframe),
00541      1  4                          calclim (line,C_FRE,freqformat.db,mag,ori));
00542      1  3             END;
00543      1  3       mag:  makeframe (fr1,address (frmagframe),
00544      1  3                          calclim (line,C_FRE,freqformat.db,mag,ori));
00545      1  3       pha:  makeframe (fr1,address (frphaframe),
00546      1  3                          calclim (line,C_FRE,freqformat.db,pha,ori));
00547      1  3       nyq:  makeframe (fr1,address (frnyqframe),
00548      1  3                          calclim (line,C_FRE,freqformat.db,nyq,ori));
00549      1  3       nic:  makeframe (fr1,address (frnicframe),
00550      1  3                          calclim (line,C_FRE,freqformat.db,nic,ori));

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00551      1  3       pop:  makeframe (fr1,address (frpopframe),
00552      1  3                          calclim (line,C_FRE,freqformat.db,pop,ori));
00553      1  2       END;
00554      1  1    END;
00555      0  0 END;
00556   C  0  0 {=============================================================================}
00557   C  0  0 {-- ROUTINES TO PLOT INCA GRAPHS ---------------------------------------------}
00558   C  0  0 {=============================================================================}
00559      1  0 PROCEDURE plotinca;
00560      1  0 TYPE
00561      1  0    itemtype  = (item_omega,item_amp,item_db,item_phase,item_popx,item_popy);
00562      1  0 VAR
00563      1  0    k     : integer;
00564   C  1  0 {------------------------------}
00565      2  0 PROCEDURE setbminbmax (fr : framelink;  box : winbox_type);
00566      2  1 BEGIN
00567      2  1 fr^.lset   := false;
00568      2  1 fr^.uset   := false;
00569      2  1 fr^.x.bmin := box.xmin;
00570      2  1 fr^.x.bmax := box.xmax;
00571      2  1 fr^.y.bmin := box.ymin;
00572      2  1 fr^.y.bmax := box.ymax;
00573      1  0 END;
00574   C  1  0 {------------------------------}
00575      2  0 PROCEDURE tracefreqcurve (ww : winlink;  frx : framelink;
00576      2  0    xval,yval : itemtype;  color : color_type);
00577      2  0 CONST
00578      2  0    NYQLOOP   = 34;
00579      2  0 VAR
00580      2  0    i,ii,j,kk  : integer;
00581      2  0    oldphase   : real;
00582      2  0    fr         : fredat_type;
00583      2  0    xpts,ypts  : ARRAY [1..FREARRSIZE] OF real;
00584   C  2  0 {--------------------}
00585      3  0 PROCEDURE addpoint (f : fredat_type);
00586      3  1 BEGIN
00587      3  1 f.phase := phnorm (f.phase);
00588      3  1 IF (ii <> 0) AND ((xval = item_phase) OR (yval = item_phase)) AND
00589      3  1    (ww^.fre.freqformat.freqplot <> nyq) AND
00590      3  1    (abs (f.phase - oldphase) > 300)
00591      3  1  THEN
00592      3  2   BEGIN
00593      3  2   trace (frx,xpts,ypts,1,ii,true,j-1);
00594      3  2   ii := 0;
00595      3  1   END;
00596      3  1 oldphase := f.phase;
00597      3  1 ii := ii+1;
00598      3  2 CASE xval OF
00599      3  2    item_omega:  xpts[ii] := f.omega;
00600      3  2    item_db:     xpts[ii] := f.db;
00601      3  2    item_amp:    xpts[ii] := exp10 (f.db/20d0);
00602      3  2    item_phase:  xpts[ii] := f.phase;
00603      3  2    item_popx:   xpts[ii] := exp10(f.db/20d0) * cos (f.phase *PI/180d0);
00604      3  1    END;
00605      3  2 CASE yval OF

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00606      3  2    item_omega:  ypts[ii] := f.omega;
00607      3  2    item_db:     ypts[ii] := f.db;
00608      3  2    item_amp:    ypts[ii] := exp10 (f.db/20d0);
00609      3  2    item_phase:  ypts[ii] := f.phase;
00610      3  2    item_popy:   ypts[ii] := exp10(f.db/20d0 + log10 (f.omega))
00611      3  2                           * sin (f.phase *PI/180d0);
00612      3  1    END;
00613      2  0 END;
00614   C  2  0 {--------------------}
00615      2  1 BEGIN
00616      2  1 WITH ww^ DO
00617      2  1    FOR j := 1 TO line.count DO
00618      2  1       WITH curve.data[line.data[j].curveix],fcptr^ DO
00619      2  2          BEGIN
00620      2  2          IF color = ''
00621      2  2           THEN setcolor (C_colorofi (j))
00622      2  2           ELSE setcolor (color);
00623      2  2          ii := 0;
00624      2  2          FOR i := 1 TO steps DO
00625      2  2             IF (abs (dat[i].db) < 10 * LOGINFINITY)
00626      2  2              THEN addpoint (dat[i])
00627      2  2              ELSE
00628      2  3               BEGIN
00629      2  3               IF i <> 1
00630      2  3                THEN FOR kk := 0 TO NYQLOOP-1 DO
00631      2  4                 BEGIN
00632      2  4                 fr := dat[i];
00633      2  4                 IF fre.freqformat.freqplot = nyq
00634      2  4                  THEN fr.db := pseudodb (fcptr^,i)
00635      2  4                  ELSE fr.db := dat[i].db;
00636      2  4                 fr.phase := dat[i-1].phase
00637      2  4                   - round (dat[i].db/20/LOGINFINITY) * 90d0 / NYQLOOP * kk;
00638      2  4                 addpoint (fr);
00639      2  3                 END;
00640      2  3               IF i <> steps
00641      2  3                THEN FOR kk := NYQLOOP-1 DOWNTO 0 DO
00642      2  4                 BEGIN
00643      2  4                 fr := dat[i];
00644      2  4                 IF fre.freqformat.freqplot = nyq
00645      2  4                  THEN fr.db := pseudodb (fcptr^,i) + kk MOD 2 * zagging
00646      2  4                  ELSE fr.db := dat[i].db;
00647      2  4                 fr.phase := dat[i+1].phase
00648      2  4                   + round (dat[i].db/20/LOGINFINITY) * 90d0 / NYQLOOP * kk;
00649      2  4                 addpoint (fr);
00650      2  3                 END;
00651      2  2              END;
00652      2  2          IF color = 'MAGNITUDE'
00653      2  2           THEN trace (frx,xpts,ypts,1,ii,true,0)
00654      2  2          ELSE IF color = 'PHASE'
00655      2  2           THEN trace (frx,xpts,ypts,1,ii,true,1)
00656      2  2           ELSE trace (frx,xpts,ypts,1,ii,true,j-1);
00657      2  1          END;
00658      1  0 END;
00659   C  1  0 {------------------------------}
00660      2  0 FUNCTION convertofhz (hz : boolean) : real;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00661      2  1 BEGIN
00662      2  1 IF hz
00663      2  1  THEN convertofhz := 2*PI
00664      2  1  ELSE convertofhz := 1;
00665      1  0 END;
00666   C  1  0 {------------------------------}
00667      2  0 FUNCTION convertofdb (db : boolean) : real;
00668      2  1 BEGIN
00669      2  1 IF db
00670      2  1  THEN convertofdb := 1
00671      2  1  ELSE convertofdb := 1/20;
00672      1  0 END;
00673   C  1  0 {------------------------------}
00674      2  0 FUNCTION lableofhz (hz : boolean) : anystring;
00675      2  1 BEGIN
00676      2  1 IF hz
00677      2  1  THEN lableofhz := 'frequency (Hz)'
00678      2  1  ELSE lableofhz := 'frequency (rad/sec)';
00679      1  0 END;
00680   C  1  0 {------------------------------}
00681      2  0 FUNCTION lableofdb (db : boolean) : anystring;
00682      2  1 BEGIN
00683      2  1 IF db
00684      2  1  THEN lableofdb := 'dB'
00685      2  1  ELSE lableofdb := 'amplitude';
00686      1  0 END;
00687   C  1  0 {------------------------------}
00688      2  0 FUNCTION suffixofdb (db : boolean) : anystring;
00689      2  1 BEGIN
00690      2  1 IF db
00691      2  1  THEN suffixofdb := 'dB'
00692      2  1  ELSE suffixofdb := '';
00693      1  0 END;
00694   C  1  0 {------------------------------}
00695      2  0 PROCEDURE plotloc (ww : winlink);
00696      2  0 VAR
00697      2  0    i,j,br     : integer;
00698      2  0    xpts,ypts  : ARRAY [1..2000] OF real;
00699      2  1 BEGIN
00700      2  1 WITH ww^,loc.fr^ DO
00701      2  2    BEGIN
00702      2  2    setbminbmax (loc.fr,ww^.box);
00703      2  2    IF usertitle = ''
00704      2  2     THEN title := 'ROOT LOCUS of ' + line.lable
00705      2  2     ELSE title := usertitle;
00706      2  2 
00707      2  2    xymapit (loc.fr);
00708      2  2    IF boundarygrid
00709      2  2     THEN
00710      2  3      CASE loc.plane OF
00711      2  3         'S',
00712      2  4         'W':  BEGIN
00713      2  4               setcolor ('BOUNDARY');
00714      2  4               xpts[1] := 0;  ypts[1] := currlim.min.y;
00715      2  4               xpts[2] := 0;  ypts[2] := currlim.max.y;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   14
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00716      2  4               trace (loc.fr,xpts,ypts,1,2,true,0);
00717      2  3               END;
00718      2  4         'Z':  BEGIN
00719      2  4               setcolor ('BOUNDARY');
00720      2  4               FOR i := 0 TO 360 DO
00721      2  5                  BEGIN
00722      2  5                  xpts[i+1] := cos(PI*i/180);
00723      2  5                  ypts[i+1] := sin(PI*i/180);
00724      2  4                  END;
00725      2  4               trace (loc.fr,xpts,ypts,1,361,true,0);
00726      2  3               END;
00727      2  2         END;
00728      2  2    FOR j := 1 TO line.count DO
00729      2  2       WITH curve.data[line.data[j].curveix].lcptr^,l DO
00730      2  3          BEGIN
00731   C  2  3          { DRAW ZEROES AND POLES }
00732      2  3          FOR i := 1 TO locfcn.ro.deg DO
00733      2  3             WITH locfcn.ro.f[i] DO
00734      2  4                BEGIN
00735      2  4                plotroot (loc.fr,v,imin (imax (p,-1),1));
00736      2  4                IF v.im <> 0
00737      2  4                 THEN plotroot (loc.fr,ccnj(v),imin (imax (p,-1),1));
00738      2  3                END;
00739      2  3 
00740   C  2  3          { NOW PLOT THE POINTS }
00741      2  3          setcolor (C_colorofi(j));
00742      2  3          FOR br := 1 TO brmax DO  WITH branch[br] DO
00743      2  4             BEGIN
00744      2  4             FOR i := locmin TO locmax DO
00745      2  5                BEGIN
00746      2  5                xpts[i-locmin+1] := dat[i].pt.re;
00747      2  5                ypts[i-locmin+1] := dat[i].pt.im;
00748      2  4                END;
00749      2  4             trace (loc.fr,xpts,ypts,1,locmax-locmin+1,true,j-1);
00750      2  3             END;
00751      2  2          END;
00752      2  1    END;
00753      1  0 END;
00754   C  1  0 {------------------------------}
00755      2  0 PROCEDURE plotmag (ww : winlink);
00756      2  1 BEGIN
00757      2  1 WITH ww^,fre.fr1^ DO
00758      2  2    BEGIN
00759      2  2    setbminbmax (fre.fr1,ww^.box);
00760      2  2    x.lablehigh := toprightlable;
00761      2  2    x.log       := fre.freqformat.flog;
00762      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00763      2  2    x.labletext := lableofhz (fre.freqformat.hz);
00764      2  2    y.lablehigh := toprightlable;
00765      2  2    y.log       := NOT fre.freqformat.db;
00766      2  2    y.labletext := lableofdb (fre.freqformat.db);
00767      2  2    IF usertitle = ''
00768      2  2     THEN title := 'BODE MAGNITUDE PLOT of ' + line.lable
00769      2  2     ELSE title := usertitle;
00770      2  2 

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   15
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00771      2  2    xymapit (fre.fr1);
00772      2  2    IF fre.freqformat.db
00773      2  2     THEN tracefreqcurve (ww,fre.fr1,item_omega,item_db,'')
00774      2  2     ELSE tracefreqcurve (ww,fre.fr1,item_omega,item_amp,'');
00775      2  1    END;
00776      1  0 END;
00777   C  1  0 {------------------------------}
00778      2  0 PROCEDURE plotbodmag (ww : winlink);
00779      2  1 BEGIN
00780      2  1 WITH ww^,fre.fr1^ DO
00781      2  2    BEGIN
00782      2  2    setbminbmax (fre.fr1,ww^.box);
00783      2  2    x.lablehigh := toprightlable;
00784      2  2    x.log       := fre.freqformat.flog;
00785      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00786      2  2    x.labletext := lableofhz (fre.freqformat.hz);
00787      2  2    y.log       := NOT fre.freqformat.db;
00788      2  2    y.labletext := lableofdb (fre.freqformat.db);
00789      2  2    IF usertitle = ''
00790      2  2     THEN title := 'BODE PLOT of ' + line.lable
00791      2  2     ELSE title := usertitle;
00792      2  2 
00793      2  2    xymapit (fre.fr1);
00794      2  2    IF fre.freqformat.db
00795      2  2     THEN tracefreqcurve (ww,fre.fr1,item_omega,item_db,'MAGNITUDE')
00796      2  2     ELSE tracefreqcurve (ww,fre.fr1,item_omega,item_amp,'MAGNITUDE');
00797      2  1    END;
00798      1  0 END;
00799   C  1  0 {------------------------------}
00800      2  0 PROCEDURE plotbmpmag (ww : winlink);
00801      2  1 BEGIN
00802      2  1 WITH ww^,fre.fr1^ DO
00803      2  2    BEGIN
00804      2  2    setbminbmax (fre.fr1,ww^.box);
00805      2  2    y.bmin := (y.bmin + y.bmax) DIV 2;
00806      2  2    x.lablehigh := toprightlable;
00807      2  2    x.log       := fre.freqformat.flog;
00808      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00809      2  2    y.lablehigh := toprightlable;
00810      2  2    y.log       := NOT fre.freqformat.db;
00811      2  2    y.labletext := lableofdb (fre.freqformat.db);
00812      2  2    IF usertitle = ''
00813      2  2     THEN title := 'BODE PLOT of ' + line.lable
00814      2  2     ELSE title := usertitle;
00815      2  2 
00816      2  2    xymapit (fre.fr1);
00817      2  2    IF fre.freqformat.db
00818      2  2     THEN tracefreqcurve (ww,fre.fr1,item_omega,item_db,'')
00819      2  2     ELSE tracefreqcurve (ww,fre.fr1,item_omega,item_amp,'');
00820      2  1    END;
00821      1  0 END;
00822   C  1  0 {------------------------------}
00823      2  0 PROCEDURE plotpha (ww : winlink);
00824      2  1 BEGIN
00825      2  1 WITH ww^,fre.fr1^ DO

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   16
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00826      2  2    BEGIN
00827      2  2    setbminbmax (fre.fr1,ww^.box);
00828      2  2    x.lablehigh := toprightlable;
00829      2  2    x.log       := fre.freqformat.flog;
00830      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00831      2  2    x.labletext := lableofhz (fre.freqformat.hz);
00832      2  2    y.lablehigh := toprightlable;
00833      2  2    IF usertitle = ''
00834      2  2     THEN title := 'PHASE PLOT of ' + line.lable
00835      2  2     ELSE title := usertitle;
00836      2  2 
00837      2  2    xymapit (fre.fr1);
00838      2  2    tracefreqcurve (ww,fre.fr1,item_omega,item_phase,'');
00839      2  1    END;
00840      1  0 END;
00841   C  1  0 {------------------------------}
00842      2  0 PROCEDURE plotbodpha (ww : winlink);
00843      2  1 BEGIN
00844      2  1 WITH ww^,fre.fr2^ DO
00845      2  2    BEGIN
00846      2  2    setbminbmax (fre.fr2,ww^.box);
00847      2  2    x.lablehigh := toprightlable;
00848      2  2    x.log       := fre.freqformat.flog;
00849      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00850      2  2    x.labletext := lableofhz (fre.freqformat.hz);
00851      2  2    title       := '';
00852      2  2 
00853      2  2    xymapit (fre.fr2);
00854      2  2    tracefreqcurve (ww,fre.fr2,item_omega,item_phase,'PHASE');
00855      2  1    END;
00856      1  0 END;
00857   C  1  0 {------------------------------}
00858      2  0 PROCEDURE plotbmppha (ww : winlink);
00859      2  1 BEGIN
00860      2  1 WITH ww^,fre.fr2^ DO
00861      2  2    BEGIN
00862      2  2    setbminbmax (fre.fr2,ww^.box);
00863      2  2    y.bmax      := (y.bmin + y.bmax) DIV 2;
00864      2  2    x.lablehigh := toprightlable;
00865      2  2    x.log       := fre.freqformat.flog;
00866      2  2    x.convert   := convertofhz (fre.freqformat.hz);
00867      2  2    x.labletext := lableofhz (fre.freqformat.hz);
00868      2  2    y.lablehigh := toprightlable;
00869      2  2    title       := '';
00870      2  2 
00871      2  2    xymapit (fre.fr2);
00872      2  2    tracefreqcurve (ww,fre.fr2,item_omega,item_phase,'');
00873      2  1    END;
00874      1  0 END;
00875   C  1  0 {------------------------------}
00876      2  0 PROCEDURE plotnyq (ww : winlink);
00877      2  0 VAR
00878      2  0    ix,iy : integer;
00879      2  1 BEGIN
00880      2  1 WITH ww^,fre.fr1^ DO

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   17
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00881      2  2    BEGIN
00882      2  2    setbminbmax (fre.fr1,ww^.box);
00883      2  2    x.lablehigh := toprightlable;
00884      2  2    x.log       := NOT fre.freqformat.db;
00885      2  2    x.convert   := convertofdb (fre.freqformat.db);
00886      2  2    x.suffix    := suffixofdb (fre.freqformat.db);
00887      2  2    origin      := mul (fre.freqformat.db) * fre.ori;
00888      2  2    IF usertitle = ''
00889      2  2     THEN title := 'NYQUIST PLOT of ' + line.lable
00890      2  2     ELSE title := usertitle;
00891      2  2 
00892      2  2    ramapit (fre.fr1);
00893      2  2    IF boundarygrid
00894      2  2            AND inside (fre.fr1, scale (convert (pointofr (fre.fr1,0,180))))
00895      2  2     THEN
00896      2  3      BEGIN
00897      2  3      scaleposition (pointofr (fre.fr1,0,180));
00898      2  3      getposition (ix,iy);
00899      2  3      setcolor ('BOUNDARY');
00900      2  3      moveto (0,-256);     drawto (0,512);
00901      2  3      moveto (-256,-256);  drawto (512,0);
00902      2  3      finplot;
00903      2  3      circle (ix,iy,config.dotsize * 4);
00904      2  2      END;
00905      2  2    tracefreqcurve (ww,fre.fr1,item_db,item_phase,'');
00906      2  1    END;
00907      1  0 END;
00908   C  1  0 {------------------------------}
00909      2  0 PROCEDURE plotnic (ww : winlink);
00910      2  0 VAR
00911      2  0    xpts,ypts  : ARRAY [1..2] OF real;
00912      2  1 BEGIN
00913      2  1 WITH ww^,fre.fr1^ DO
00914      2  2    BEGIN
00915      2  2    setbminbmax (fre.fr1,ww^.box);
00916      2  2    x.lablehigh := toprightlable;
00917      2  2    y.lablehigh := toprightlable;
00918      2  2    y.suffix    := suffixofdb (fre.freqformat.db);
00919      2  2    y.log       := NOT fre.freqformat.db;
00920      2  2    IF usertitle = ''
00921      2  2     THEN title := 'NICHOLS PLOT of ' + line.lable
00922      2  2     ELSE title := usertitle;
00923      2  2 
00924      2  2    xymapit (fre.fr1);
00925      2  2    IF boundarygrid
00926      2  2     THEN
00927      2  3      BEGIN
00928      2  3      setcolor ('BOUNDARY');
00929      2  3      xpts[1] := currlim.min.x;  ypts[1] := 0;
00930      2  3      xpts[2] := currlim.max.x;  ypts[2] := 0;
00931      2  3      trace (fre.fr1,xpts,ypts,1,2,true,0);
00932      2  3      xpts[1] := phnorm (180d0);  ypts[1] := currlim.min.y;
00933      2  3      xpts[2] := phnorm (180d0);  ypts[2] := currlim.max.y;
00934      2  3      trace (fre.fr1,xpts,ypts,1,2,true,0);
00935      2  2      END;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   18
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00936      2  2    IF fre.freqformat.db
00937      2  2     THEN tracefreqcurve (ww,fre.fr1,item_phase,item_db,'')
00938      2  2     ELSE tracefreqcurve (ww,fre.fr1,item_phase,item_amp,'');
00939      2  1    END;
00940      1  0 END;
00941   C  1  0 {------------------------------}
00942      2  0 PROCEDURE plotpop (ww : winlink);
00943      2  0 VAR
00944      2  0    i,j            : integer;
00945      2  0    xx,dx          : real;
00946      2  0    th,thmax,thmin : real;
00947      2  0    cpt            : complex;
00948      2  0    xpts,ypts      : ARRAY [1..3] OF real;
00949      2  1 BEGIN
00950      2  1 WITH ww^,fre.fr1^ DO
00951      2  2    BEGIN
00952      2  2    setbminbmax (fre.fr1,ww^.box);
00953      2  2    x.lablehigh := toprightlable;
00954      2  2    y.lablehigh := toprightlable;
00955      2  2    IF usertitle = ''
00956      2  2     THEN title := 'POPOV PLOT of ' + line.lable
00957      2  2     ELSE title := usertitle;
00958      2  2 
00959      2  2    xymapit (fre.fr1);
00960      2  2    tracefreqcurve (ww,fre.fr1,item_popx,item_popy,'');
00961      2  2    IF boundarygrid
00962      2  2     THEN
00963      2  2      FOR j := 1 TO line.count DO
00964      2  2         WITH curve.data[line.data[j].curveix].fcptr^ DO
00965      2  3            BEGIN
00966      2  3            xx := (lim.min.x + lim.max.x) / 2;
00967      2  3            dx := (lim.max.x - lim.min.x) / 1.9;
00968      2  4            REPEAT
00969      2  4               thmax := 0;
00970      2  4               thmin := 0;
00971      2  4               FOR i := 1 TO steps DO
00972      2  5                  BEGIN
00973      2  5                  cpt.re := exp10(dat[i].db/20d0)
00974      2  5                          * cos (dat[i].phase *PI/180d0) - xx;
00975      2  5                  cpt.im := exp10(dat[i].db/20d0 + log10 (dat[i].omega))
00976      2  5                                  * sin (dat[i].phase *PI/180d0);
00977      2  5                  th := angle (cpt) * 180d0 / PI;
00978      2  5                  IF th > 180d0 THEN th := th - 360d0;
00979      2  5                  thmin := rmin (thmin,th);
00980      2  5                  thmax := rmax (thmax,th);
00981      2  4                  END;
00982      2  4               dx := dx / 2;
00983      2  4               IF thmax - thmin > 180d0
00984      2  4                THEN xx := xx - dx
00985      2  4                ELSE xx := xx + dx;
00986      2  3               UNTIL dx < 1d-6 * (lim.max.x - lim.min.x);
00987      2  3            xx := xx - dx;
00988      2  3            th := (thmax + thmin + 180d0) / 2;
00989      2  3            xpts[1] := lim.max.y * 2 * cos (th*PI/180d0) + xx;
00990      2  3            ypts[1] := lim.max.y * 2 * sin (th*PI/180d0);

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   19
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

00991      2  3            xpts[2] := xx;
00992      2  3            ypts[2] := 0;
00993      2  3            xpts[3] := lim.min.y * 2 * cos (th*PI/180d0) + xx;
00994      2  3            ypts[3] := lim.min.y * 2 * sin (th*PI/180d0);
00995      2  3            IF line.count = 1
00996      2  3             THEN setcolor ('BOUNDARY')
00997      2  3             ELSE setcolor (C_colorofi (j));
00998      2  3            trace (fre.fr1,xpts,ypts,1,3,true,j-1);
00999      2  2            END;
01000      2  1       END;
01001      1  0 END;
01002   C  1  0 {------------------------------}
01003      2  0 PROCEDURE plottir (ww : winlink);
01004      2  0 VAR
01005      2  0    i,j,k      : integer;
01006      2  0    xpts,ypts  : ARRAY [1..TIRARRSIZE*2] OF real;
01007      2  1 BEGIN
01008      2  1 WITH ww^,tir.fr^ DO
01009      2  2    BEGIN
01010      2  2    setbminbmax (tir.fr,ww^.box);
01011      2  2    x.lablehigh := toprightlable;
01012      2  2    y.lablehigh := toprightlable;
01013      2  2    IF usertitle = ''
01014      2  2     THEN title := 'TIME RESPONSE of ' + line.lable
01015      2  2     ELSE title := usertitle;
01016      2  2 
01017      2  2    xymapit (tir.fr);
01018      2  2    FOR j := 1 TO line.count DO
01019      2  2       WITH curve.data[line.data[j].curveix].tcptr^ DO
01020      2  2          FOR k := 1 TO count DO
01021      2  3             BEGIN
01022      2  3             setcolor (T_colorofi(k));
01023      2  3             IF continuous
01024      2  3              THEN
01025      2  4               BEGIN
01026      2  4               FOR i := 1 TO steps DO
01027      2  5                  BEGIN
01028      2  5                  xpts[i] := dat[i].time;
01029      2  5                  ypts[i] := dat[i].value[k];
01030      2  4                  END;
01031      2  4               trace (tir.fr,xpts,ypts,1,steps,true,j-1);
01032      2  4               END
01033      2  3              ELSE
01034      2  4               BEGIN
01035      2  4               FOR i := 1 TO steps DO
01036      2  5                  BEGIN
01037      2  5                  xpts[i*2-1] := dat[i].time;
01038      2  5                  ypts[i*2-1] := dat[i].value[k];
01039      2  5                  xpts[i*2  ] := dat[i].time + dt;
01040      2  5                  ypts[i*2  ] := dat[i].value[k];
01041      2  4                  END;
01042      2  4               trace (tir.fr,xpts,ypts,1,steps*2,true,j-1);
01043      2  3               END;
01044      2  2             END;
01045      2  1    END;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   20
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01046      1  0 END;
01047   C  1  0 {------------------------------}
01048      1  1 BEGIN
01049      1  1 clearscreen;
01050      1  1 clearframe;
01051      1  1 gcount := 0;
01052      1  1 FOR k := 1 TO win.count DO WITH win.data[k]^ DO
01053      1  2    BEGIN
01054      1  3    CASE curveclass OF
01055      1  3       C_EMP:  ;
01056      1  3       C_LOC:  plotloc (win.data[k]);
01057      1  4       C_FRE:  CASE fre.freqformat.freqplot OF
01058      1  4                  mag:  plotmag (win.data[k]);
01059      1  4                  pha:  plotpha (win.data[k]);
01060      1  5                  bod:  BEGIN
01061      1  5                        plotbodmag (win.data[k]);
01062      1  5                        plotbodpha (win.data[k]);
01063      1  4                        END;
01064      1  5                  bmp:  BEGIN
01065      1  5                        plotbmpmag (win.data[k]);
01066      1  5                        plotbmppha (win.data[k]);
01067      1  4                        END;
01068      1  4                  nyq:  plotnyq (win.data[k]);
01069      1  4                  nic:  plotnic (win.data[k]);
01070      1  4                  pop:  plotpop (win.data[k]);
01071      1  3                  END;
01072      1  3       C_TIR:  plottir (win.data[k]);
01073      1  2       END;
01074      1  1    END;
01075      1  1 tagplot;
01076      0  0 END;
01077   C  0  0 {=============================================================================}
01078   C  0  0 {-- ROUTINE TO ADD A FRAME AND FILL IT ---------------------------------------}
01079   C  0  0 {=============================================================================}
01080      1  0 PROCEDURE addwin (xmin,xmax,ymin,ymax : integer);
01081      1  0 VAR
01082      1  0    ix   : integer;
01083      1  0    fake : real;
01084      1  0    ch   : char;
01085      1  0    sel  : command_type;
01086      1  0    arg  : anystring;
01087      1  0    st   : anystring;
01088      1  0    p    : parse_type;
01089      1  0    anysel : anystring;
01090      1  1 BEGIN
01091      1  1 win.count := win.count + 1;
01092      1  1 new (win.data[win.count]);
01093      1  1 WITH win.data[win.count]^ DO
01094      1  2    BEGIN
01095   C  1  2    { FIRST SELECT CURVES, AND DETERMINE CURVECLASS AND LINES }
01096      1  2    box.xmin := xmin;
01097      1  2    box.xmax := xmax;
01098      1  2    box.ymin := ymin;
01099      1  2    box.ymax := ymax;
01100      1  2    curveclass := C_EMP;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   21
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01101      1  2 
01102      1  2    readargument (arg);
01103      1  2    IF (index (arg,' ') <> 0) OR (index (arg,',') <> 0)
01104      1  2     THEN line.lable := arg
01105      1  2     ELSE
01106      1  3      BEGIN
01107      1  3      unread (arg);
01108      1  3      selectcurve (sel,false,true);
01109      1  3      line.lable := '';
01110      1  3      IF sel = 'Many'
01111      1  3       THEN
01112      1  4        BEGIN
01113      1  5        REPEAT
01114      1  5           selectcurve (sel,false,false);
01115      1  5           IF sel = ''
01116      1  5 	   THEN
01117      1  5             IF sel = ESC
01118      1  5              THEN sel := ''
01119      1  5             ELSE IF line.lable <> ''
01120      1  5              THEN line.lable := line.lable + ', ';
01121      1  5           line.lable := line.lable + ',' + sel;
01122      1  4           UNTIL sel = '';
01123      1  4        pwsqueeze(line.lable);
01124      1  4        END
01125      1  3       ELSE
01126      1  4        BEGIN
01127      1  4        anysel := sel;
01128      1  4        checkforpwpf(anysel);
01129      1  4        line.lable := anysel;
01130      1  3        END;
01131      1  2      END;
01132      1  2    line.count := 0;
01133      1  2 
01134      1  2    startparse (p,line.lable);
01135      1  2    line.lable := '';
01136      1  2    loc.plane := 'K';
01137      1  3    REPEAT
01138      1  3       st := parse (p,', ');
01139      1  3       IF (st <> ',') AND (st <> '')
01140      1  3        THEN
01141      1  4         BEGIN
01142      1  4         IF line.count = WINLINELIM
01143      1  4          THEN raise ('Too many curves, maximum =' + strofi(WINLINELIM,0));
01144      1  4         ix := getcurveindex (st);
01145      1  4         IF ix = 0 
01146      1  4          THEN writeline (both,'Curve "' + st + '" not found')
01147      1  4          ELSE
01148      1  5           BEGIN
01149      1  5           IF curveclass = C_EMP THEN curveclass := curve.data[ix].curveclass;
01150      1  5           IF curveclass = curve.data[ix].curveclass
01151      1  5            THEN
01152      1  6             BEGIN
01153      1  6             line.count := line.count + 1;
01154      1  6             line.data[line.count].curveix := ix;
01155      1  6             line.data[line.count].color   := C_colorofi(line.count);

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   22
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01156      1  6             IF line.lable <> '' THEN line.lable := line.lable + ', ';
01157      1  6             line.lable := line.lable
01158      1  6                             + curve.data[line.data[line.count].curveix].lable;
01159      1  6             END
01160      1  5            ELSE writeline (out,'Curve "' + st + '" is not of proper class');
01161      1  5           IF curveclass = C_LOC
01162      1  5            THEN loc.plane := addplane (loc.plane,curve.data[ix].lcptr^.l.plane);
01163      1  4           END;
01164      1  3         END;
01165      1  2       UNTIL st = '';
01166      1  2 
01167   C  1  2    { CREATE FRAMES, AND FILL }
01168      1  2    IF line.count = 0
01169      1  2     THEN
01170      1  3      BEGIN
01171      1  3      dispose (win.data[win.count]);
01172      1  3      win.count := win.count - 1;
01173      1  3      END
01174      1  2     ELSE
01175      1  3      BEGIN
01176      1  3      readlowervary ('ENTER TITLE   : ',usertitle,'');
01177      1  4      CASE curveclass OF
01178      1  4         C_EMP:  ;
01179      1  4         C_LOC:  makeframe (loc.fr,address (locusframe),
01180      1  4                    calclim (line,C_LOC,true,mag,fake));
01181      1  5         C_FRE:  BEGIN
01182      1  5                 fre.freqformat := defaultfreqformat;
01183      1  5                 fre.ori := UNDEFINED_REAL;
01184      1  5                 writeline (out,'Plot Type is '
01185      1  5                                       + stroffreqplot(fre.freqformat.freqplot));
01186      1  5                 If fre.freqformat.db
01187      1  5                  THEN writeline (out,'dB scale')
01188      1  5                  ELSE writeline (out,'Amplitude scale');
01189      1  5                 If fre.freqformat.hz
01190      1  5                  THEN writeline (out,'Hertz scale')
01191      1  5                  ELSE writeline (out,'Radians per second scale');
01192      1  5                 If fre.freqformat.flog
01193      1  5                  THEN writeline (out,'Logarithmic frequency scale')
01194      1  5                  ELSE writeline (out,'Linear frequency scale');
01195      1  5                 writeline (out,'');
01196      1  5                 writeline (out,'press RETURN for default values...');
01197      1  5                 readch  ('ENTER PLOT TYPE (MPNCVBS) : ',ch,'MPNCVBS ',' ');
01198      1  5                 IF ch <> ' ' THEN fre.freqformat.freqplot := freqplotofch (ch);
01199      1  5                 readboo ('dB SCALE                  ? ',fre.freqformat.db,
01200      1  5                                                         fre.freqformat.db);
01201      1  5                 readboo ('Hertz SCALE               ? ',fre.freqformat.hz,
01202      1  5                                                         fre.freqformat.hz);
01203      1  5                 readboo ('LOG frequency SCALE       ? ',fre.freqformat.flog,
01204      1  5                                                         fre.freqformat.flog);
01205      1  5                 IF fre.freqformat.freqplot = nyq
01206      1  5                  THEN readreal('Nyquist Origin            : ',fre.ori,
01207      1  5                                     -BIG,BIG,fre.ori);
01208      1  5                 makefreqrframes (win.data[win.count]);
01209      1  4                 END;
01210      1  5         C_TIR:  BEGIN

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   23
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01211      1  5                 makeframe (tir.fr,address (timerframe),
01212      1  5                    calclim (line,C_TIR,true,mag,fake));
01213      1  5                 readlowervary ('ENTER Y-LABEL : ',tir.fr^.y.labletext,'');
01214      1  4                 END;
01215      1  3         END;
01216      1  2       END;
01217      1  1    END;
01218      0  0 END;
01219   C  0  0 {-----------------------------------------------------------------------------}
01220      1  0 PROCEDURE deletewin (w : winlink);
01221      1  0 VAR
01222      1  0    i,j : integer;
01223      1  1 BEGIN
01224      1  1 j := 0;
01225      1  1 FOR i := 1 TO win.count DO
01226      1  1    IF w = win.data[i] THEN j := i;
01227      1  1 IF j <> 0
01228      1  1  THEN WITH win.data[j]^ DO
01229      1  2   BEGIN
01230      1  3   CASE curveclass OF
01231      1  4      C_LOC:  BEGIN
01232      1  4              purgezoom (loc.fr);
01233      1  4              dispose (loc.fr);
01234      1  3              END;
01235      1  4      C_FRE:  BEGIN
01236      1  4              purgezoom (fre.fr1);
01237      1  4              dispose (fre.fr1);
01238      1  4              IF fre.fr2 <> NIL
01239      1  4               THEN
01240      1  5                BEGIN
01241      1  5                purgezoom (fre.fr2);
01242      1  5                dispose (fre.fr2);
01243      1  4                END;
01244      1  3              END;
01245      1  4      C_TIR:  BEGIN
01246      1  4              purgezoom (tir.fr);
01247      1  4              dispose (tir.fr);
01248      1  3              END;
01249      1  2      END;
01250      1  2   dispose (win.data[j]);
01251      1  2   FOR i := j+1 TO win.count DO win.data[i-1] := win.data[i];
01252      1  2   win.count := win.count - 1;
01253      1  1   END;
01254      0  0 END;
01255   C  0  0 {-----------------------------------------------------------------------------}
01256      1  0 PROCEDURE purgewins;
01257      1  1 BEGIN
01258      1  1 WHILE win.count > 0 DO
01259      1  1    deletewin (win.data[1]);
01260      0  0 END;
01261   C  0  0 {=============================================================================}
01262   C  0  0 {-- ROUTINES TO IMPLEMENT GRAPHICS MODE COMMANDS -----------------------------}
01263   C  0  0 {=============================================================================}
01264      1  0 PROCEDURE C_command (ipt : ipoint);
01265      1  0 VAR

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   24
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01266      1  0    j      : integer;
01267      1  0    pt     : point;
01268      1  0    ww     : winlink;
01269      1  0    xv,yv  : ARRAY [1..2] OF real;
01270      1  1 BEGIN
01271      1  1 getcursorpoint (pt,ipt);
01272      1  1 ww := winlinkofframelink (pt.f);
01273      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
01274      1  1 xv[1] := ipt.ix;
01275      1  1 yv[1] := ipt.iy;
01276      1  1 xv[2] := ipt.ix + 6000;
01277      1  1 yv[2] := ipt.iy;
01278      1  1 
01279      1  1 IF ww <> NIL
01280      1  1  THEN
01281      1  1   WITH ww^ DO
01282      1  2      BEGIN
01283      1  2      IF (line.count = 1) AND (curveclass = C_TIR)
01284      1  2       THEN WITH curve.data[line.data[1].curveix].tcptr^ DO
01285      1  2        FOR j := 1 TO count DO
01286      1  3           BEGIN
01287      1  3           yv[1] := yv[1] - config.ch.height;
01288      1  3           yv[2] := yv[2] - config.ch.height;
01289      1  3           setcolor (T_colorofi(j));
01290      1  3           trace (frame.data[0],xv,yv,1,2,false,j-1);
01291      1  3           moveto (400,0);
01292      1  3           grprint ('GAIN=' + strofr (compgain[j],14));
01293      1  3           END
01294      1  2      ELSE IF (line.count = 1) AND (curveclass = C_FRE) AND
01295      1  2              (fre.freqformat.freqplot = bod)
01296      1  2       THEN
01297      1  3        BEGIN
01298      1  3        setcolor ('MAGNITUDE');
01299      1  3        trace (frame.data[0],xv,yv,1,2,false,0);
01300      1  3        moveto (400,0);
01301      1  3        grprint ('Magnitude');
01302      1  3        yv[1] := yv[1] - config.ch.height;
01303      1  3        yv[2] := yv[2] - config.ch.height;
01304      1  3        setcolor ('PHASE');
01305      1  3        trace (frame.data[0],xv,yv,1,2,false,1);
01306      1  3        moveto (400,0);
01307      1  3        grprint ('Phase');
01308      1  3        END
01309      1  2       ELSE
01310      1  2        FOR j := 1 TO line.count DO
01311      1  3           BEGIN
01312      1  3           yv[1] := yv[1] - config.ch.height;
01313      1  3           yv[2] := yv[2] - config.ch.height;
01314      1  3           setcolor (line.data[j].color);
01315      1  3           trace (frame.data[0],xv,yv,1,2,false,j-1);
01316      1  3           moveto (400,0);
01317      1  3           grprint (curve.data[line.data[j].curveix].lable);
01318      1  2           END;
01319      1  2      END
01320      1  1  ELSE bell;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   25
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01321      0  0 END;
01322   C  0  0 {-----------------------------------------------------------------------------}
01323      1  0 PROCEDURE F_command (ipt : ipoint;  key : char);
01324      1  0 VAR
01325      1  0    pt  : point;
01326      1  0    ww  : winlink;
01327   C  1  0 {------------------------------}
01328      2  0 PROCEDURE findg;
01329      2  0 VAR
01330      2  0    i,j,br       : integer;
01331      2  0    search,found : RECORD
01332      2  0                   i,j,dist : integer;
01333      2  0                   END;
01334      2  0    ind,lg,phase : real;
01335      2  1 BEGIN
01336      2  1 found.dist := MAXINT;
01337      2  1 WITH ww^ DO
01338      2  1  FOR j := 1 TO line.count DO
01339      2  1   WITH curve.data[line.data[j].curveix].lcptr^ DO
01340      2  1    FOR br := 1 TO brmax DO WITH branch[br] DO
01341      2  1       FOR i := locmin TO locmax DO
01342      2  2          BEGIN
01343      2  2          search.i := i;
01344      2  2          search.j := j;
01345      2  2          search.dist := hit (pt.f, dat[i].pt.re, dat[i].pt.im, pt.x, pt.y);
01346      2  2          IF search.dist < found.dist THEN found := search;
01347      2  1          END;
01348      2  1 IF (found.dist < searchcircle)
01349      2  1  THEN WITH curve.data[ww^.line.data[found.j].curveix].lcptr^,l DO
01350      2  2   BEGIN
01351      2  2   scaleposition (pointofr (pt.f, dat[found.i].pt.re, dat[found.i].pt.im));
01352      2  2   setcolor ('FIND');
01353      2  2   encircle (imax (config.resolution*2,128));
01354      2  2   writeline (aud,'');
01355      2  3   CASE ltype OF
01356      2  3      EVA:  writeline (aud,'FIND G: Gain is '
01357      2  3                         + strofr (exp10(dat[found.i].lg),13)
01358      2  3                         + ' at Point (' + strofc (dat[found.i].pt,13) + ')');
01359      2  3      RCO:  writeline (aud,'FIND G: Independent variable is '
01360      2  3                         + strofr (dat[found.i].ind,13) + ' at Point ('
01361      2  3                         + strofc (dat[found.i].pt,13) + ')');
01362      2  2      END;
01363      2  2   moveto (768,-384);
01364      2  3   CASE ltype OF
01365      2  3      EVA:  grprint('G=' + strofr (exp10(dat[found.i].lg),11));
01366      2  3      RCO:  grprint('i=' + strofr (dat[found.i].ind,11));
01367      2  2      END;
01368      2  2   IF key = 'F'
01369      2  2    THEN
01370      2  3     BEGIN
01371      2  3     newline;  grprint('R=' + strofr (dat[found.i].pt.re,11));
01372      2  3     newline;  grprint('I=' + strofr (dat[found.i].pt.im,11));
01373      2  2     END;
01374      2  2   END
01375      2  1  ELSE bell;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   26
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01376      1  0 END;
01377   C  1  0 {------------------------------}
01378      2  0 PROCEDURE findw;
01379      2  0 VAR
01380      2  0    i,j          : integer;
01381      2  0    search,found : RECORD
01382      2  0                   i,j,dist : integer;
01383      2  0                   END;
01384      2  0    popx,popy    : real;
01385      2  0    dbamp        : real;
01386      2  0    fr           : fredat_type;
01387      2  0    strw,strmag  : anystring;
01388      2  0    strpha       : anystring;
01389      2  1 BEGIN
01390   C  2  1 {  SEARCH THE DATA TO FIND A POINT ON THE CURVES NEAR THE CURSOR POSITION }
01391      2  1 found.dist := MAXINT;
01392      2  1 WITH ww^ DO
01393      2  1  FOR j := 1 TO line.count DO
01394      2  1   WITH curve.data[line.data[j].curveix].fcptr^ DO
01395      2  1    FOR i := 1 TO steps DO
01396      2  2       BEGIN
01397      2  2       search.j := j;
01398      2  2       search.i := i;
01399      2  2       fr := dat[search.i];
01400      2  2       fr.phase := phnorm (fr.phase);
01401      2  2       popx := exp10(fr.db/20d0) * cos (fr.phase *PI/180d0);
01402      2  2       popy := exp10(fr.db/20d0 + log10 (fr.omega)) * sin (fr.phase *PI/180d0);
01403      2  2       IF fre.freqformat.db
01404      2  2        THEN dbamp := fr.db
01405      2  2        ELSE dbamp := exp10 (fr.db / 20d0);
01406      2  3       CASE fre.freqformat.freqplot OF
01407      2  3          bod,
01408      2  3          bmp:  IF pt.f = fre.fr1
01409      2  3                 THEN search.dist := hit  (pt.f, fr.omega, dbamp,    pt.x, pt.y)
01410      2  3                 ELSE search.dist := hit  (pt.f, fr.omega, fr.phase, pt.x, pt.y);
01411      2  3          mag:  search.dist := hit  (pt.f, fr.omega, dbamp,    pt.x, pt.y);
01412      2  3          pha:  search.dist := hit  (pt.f, fr.omega, fr.phase, pt.x, pt.y);
01413      2  3          nyq:  search.dist := hit  (pt.f, dbamp,    fr.phase, pt.x, pt.y);
01414      2  3          nic:  search.dist := hit  (pt.f, fr.phase, dbamp,    pt.x, pt.y);
01415      2  3          pop:  search.dist := hit  (pt.f, popx,     popy,     pt.x, pt.y);
01416      2  2          END;
01417      2  2       IF search.dist < found.dist THEN found := search;
01418      2  1       END;
01419      2  1 IF (found.dist < searchcircle)
01420      2  1  THEN
01421      2  1   WITH ww^,curve.data[line.data[found.j].curveix].fcptr^ DO
01422      2  2      BEGIN
01423      2  2      fr := dat[found.i];
01424      2  2      fr.phase := phnorm (fr.phase);
01425      2  2      popx := exp10(fr.db/20d0) * cos (fr.phase *PI/180d0);
01426      2  2      popy := exp10(fr.db/20d0 + log10 (fr.omega)) * sin (fr.phase *PI/180d0);
01427      2  2      IF fre.freqformat.db
01428      2  2       THEN dbamp := fr.db
01429      2  2       ELSE dbamp := exp10 (fr.db / 20d0);
01430      2  3      CASE fre.freqformat.freqplot OF

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   27
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01431      2  3         bod,
01432      2  3         bmp:  IF pt.f = fre.fr1
01433      2  3                THEN scaleposition (pointofr (pt.f, fr.omega, dbamp))
01434      2  3                ELSE scaleposition (pointofr (pt.f, fr.omega, fr.phase));
01435      2  3         mag:  scaleposition (pointofr (pt.f, fr.omega, dbamp));
01436      2  3         pha:  scaleposition (pointofr (pt.f, fr.omega, fr.phase));
01437      2  3         nyq:  scaleposition (pointofr (pt.f, dbamp,    fr.phase));
01438      2  3         nic:  scaleposition (pointofr (pt.f, fr.phase, dbamp));
01439      2  3         pop:  scaleposition (pointofr (pt.f, popx,     popy));
01440      2  2         END;
01441      2  2      setcolor ('FIND');
01442      2  2      encircle (imax (config.resolution*2,128));
01443      2  2      IF key = 'Y'
01444      2  2       THEN
01445      2  2        IF (f.ftype=DES) and (f.ispwpf)
01446      2  2         THEN
01447      2  3          BEGIN
01448      2  3          strw := 'W = ' + strofr(f.pwpf_omega,10);
01449      2  3          writeline(aud,'FIND W: ' + strw);
01450      2  3          END
01451      2  3         ELSE  BEGIN strw := ''; bell; END
01452      2  2       ELSE
01453      2  3        BEGIN
01454      2  3        strfromfredattype (strw,strmag,strpha,fr,fre.freqformat,13,f.ftype);
01455      2  3        writeline (aud,'FIND W: The frequency at point ('
01456      2  3                       + strmag + ', ' + strpha + ') is ' + strw);
01457      2  2        END;
01458      2  2      IF strw <> ''
01459      2  2       THEN
01460      2  3        BEGIN
01461      2  3        moveto (768,-384);
01462      2  3        grprint (strw);
01463      2  2        END;
01464      2  2      IF key = 'F'
01465      2  2       THEN BEGIN  newline;  grprint(strmag);  newline;  grprint(strpha);  END;
01466      2  2      END
01467      2  1     ELSE bell;
01468      1  0 END;
01469   C  1  0 {------------------------------}
01470      2  0 PROCEDURE findt;
01471      2  0 VAR
01472      2  0    i,j,k        : integer;
01473      2  0    search,found : RECORD
01474      2  0                   i,j,k,dist : integer;
01475      2  0                   END;
01476      2  0    strt,strv    : anystring;
01477      2  1 BEGIN
01478   C  2  1 {  SEARCH THE DATA TO FIND A POINT ON CURVES WITHIN DELTA OF CURSOR POSITION  }
01479      2  1 found.dist := MAXINT;
01480      2  1 WITH ww^ DO
01481      2  1  FOR j := 1 TO line.count DO
01482      2  1   WITH curve.data[line.data[j].curveix].tcptr^ DO
01483      2  1    FOR k := 1 TO count DO
01484      2  1       FOR i := 1 TO steps DO
01485      2  2          BEGIN

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   28
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01486      2  2          search.i := i;
01487      2  2          search.j := j;
01488      2  2          search.k := k;
01489      2  2          search.dist := hit (pt.f, dat[i].time, dat[i].value[k], pt.x, pt.y);
01490      2  2          IF search.dist < found.dist THEN found := search;
01491      2  1          END;
01492      2  1 IF found.dist < searchcircle
01493      2  1  THEN
01494      2  1   WITH ww^,curve.data[line.data[found.j].curveix].tcptr^ DO
01495      2  2      BEGIN
01496      2  2      scaleposition (pointofr (pt.f, dat[found.i].time,
01497      2  2                                     dat[found.i].value[found.k]));
01498      2  2      setcolor ('FIND');
01499      2  2      encircle (imax(config.resolution*2,128));
01500      2  2 
01501      2  2      strt := 'T=' + strofr (dat[found.i].time,13);
01502      2  2      strv := 'V=' + strofr (dat[found.i].value[found.k],13);
01503      2  2      writeline (aud,'FIND T: The value at point ' + strt + ' is ' + strv);
01504      2  2      moveto (768,-384);
01505      2  2      grprint (strt);
01506      2  2      newline;
01507      2  2      grprint (strv);
01508      2  2      END
01509      2  1  ELSE bell;
01510      1  0 END;
01511   C  1  0 {------------------------------}
01512      1  1 BEGIN
01513      1  1 getcursorpoint (pt,ipt);
01514      1  1 ww := winlinkofframelink (pt.f);
01515      1  1 IF ww <> NIL
01516      1  1  THEN
01517      1  2   CASE ww^.curveclass OF
01518      1  2      C_EMP:  ;
01519      1  2      C_LOC:  findg;
01520      1  2      C_FRE:  findw;
01521      1  2      C_TIR:  findt;
01522      1  2      END
01523      1  1  ELSE bell;
01524      0  0 END;
01525   C  0  0 {-----------------------------------------------------------------------------}
01526      1  0 PROCEDURE H_command (ipt : ipoint);
01527      1  0 VAR
01528      1  0    i : integer;
01529      1  1 BEGIN
01530      1  1 position (ipt.ix, ipt.iy);
01531      1  1 setcolor ('HELP');
01532      1  1 ngp ('GRAPHICS MODE COMMANDS');
01533      1  1 ngp ('');
01534      1  1 ngp ('Use first letter of command to select');
01535      1  1 ngp ('');
01536      1  2 FOR i := 1 TO 26 DO CASE chr (i+64) OF
01537      1  2    'C':  ngp ('Curve Lab-- Write labels for the various curves');
01538      1  2    'F':  ngp ('Find     -- Show coordinates and value at cursor point');
01539      1  2    'G':  ngp ('G-Find   -- Show hidden value at cursor point');
01540      1  2    'H':  ngp ('Help     -- Display this menu');

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   29
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01541      1  2    'I':  ngp ('Ident Lab-- Create labels for the various curves');
01542      1  2    'M':  ngp ('Margins  -- (FREQR) Display Gain and Phase margins');
01543      1  2    'O':  ngp ('Open     -- Open window');
01544      1  3    'S':  BEGIN
01545      1  3          ngp ('Select   -- (FREQR) Select plot type or curve');
01546      1  3          ngp ('     Bode Plot           Magnitude Plot');
01547      1  3          ngp ('     Nyquist Plot        Phase Plot');
01548      1  3          ngp ('     C-Nichols Plot      V-Popov Plot');
01549      1  3          ngp ('     S-Bode Strip Plot');
01550      1  3          ngp ('     Hz Scale            dB Scale');
01551      1  3          ngp ('     RPS Scale           Amp Scale');
01552      1  3          ngp ('     Frequency Scale     Log Frequency Scale');
01553      1  3          ngp ('     Infinity   -- Reset infinity circle of Nyquist Plot');
01554      1  3          ngp ('     Origin     -- Reset origin of Nyquist Plot');
01555      1  3          ngp ('     Wrapping   -- Set phase angle start');
01556      1  3          ngp ('Select   -- (TIMER) Select plot type or curve');
01557      1  3          ngp ('     Value label-- Enter value for Y-Axis label');
01558      1  2          END;
01559      1  2    'T':  ngp ('Type     -- Type information on data read');
01560      1  2    'V':  ngp ('Value    -- Show points with a given hidden value');
01561      1  3    'W':  BEGIN
01562      1  3          ngp ('Window   -- Manipulate Windows');
01563      1  3          ngp ('     Back       -- Send window to Back');
01564      1  3          ngp ('     Delete     -- Delete window');
01565      1  3          ngp ('     Front      -- Send window to Front');
01566      1  3          ngp ('     Inset      -- Create inset window');
01567      1  3          ngp ('     Zoom       -- Change borders of window');
01568      1  2          END;
01569      1  2    OTHERWISE checkmenu (chr (i+64));
01570      1  1    END;
01571      1  1 checkmenu (' ');
01572      0  0 END;
01573   C  0  0 {-----------------------------------------------------------------------------}
01574      1  0 PROCEDURE I_command (ipt : ipoint);
01575      1  0 VAR
01576      1  0    j   : integer;
01577      1  0    pt  : point;
01578      1  0    ww  : winlink;
01579      1  1 BEGIN
01580      1  1 getcursorpoint (pt,ipt);
01581      1  1 ww := winlinkofframelink (pt.f);
01582      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
01583      1  1 IF ww <> NIL
01584      1  1  THEN
01585      1  2   BEGIN
01586      1  2   WITH ww^ DO
01587      1  2      IF line.count > 1
01588      1  2       THEN readint ('ENTER NUMBER OF CURVE : ',j,1,line.count,1)
01589      1  2       ELSE j := 1;
01590      1  2   WITH curve.data[ww^.line.data[j].curveix] DO
01591      1  2      readvary ('ENTER LABEL           : ',lable,lable);
01592      1  2   END
01593      1  1  ELSE bell;
01594      0  0 END;
01595   C  0  0 {-----------------------------------------------------------------------------}

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   30
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01596      1  0 PROCEDURE M_command (ipt : ipoint);
01597      1  0 VAR
01598      1  0    pt  : point;
01599      1  0    ww  : winlink;
01600   C  1  0 {------------------------------}
01601      2  0 PROCEDURE displaylocusmargins;
01602      2  0 VAR
01603      2  0    br,i,j  : integer;
01604      2  0    found   : boolean;
01605      2  0    g,v     : real;
01606      2  0    st      : anystring;
01607      2  1 BEGIN
01608      2  1 found := false;
01609      2  1 WITH ww^ DO
01610      2  1  FOR j := 1 TO line.count DO
01611      2  1   WITH curve.data[line.data[j].curveix],lcptr^,l DO
01612      2  2    BEGIN
01613      2  2    setcolor (line.data[j].color);
01614      2  2    newline;  grprint (lable);
01615      2  2    setcolor ('BOUNDARY');
01616      2  2    newline;  grprint ('Boundary Crossings');
01617      2  2    newline;
01618      2  2    setcolor ('FIND');
01619      2  2    FOR br := 1 TO brmax DO
01620      2  2       WITH branch[br] DO
01621      2  2          FOR i := locmin TO locmax-1 DO
01622      2  3             BEGIN
01623      2  3             st := '';
01624      2  4             CASE plane OF
01625      2  4                'S',
01626      2  4                'W':  IF (dat[i].pt.re > 0) <> (dat[i+1].pt.re > 0)
01627      2  4                       THEN
01628      2  5                        BEGIN
01629      2  5                        g := interpolate (0,dat[i].pt.re,dat[i+1].pt.re,
01630      2  5                                            dat[i].lg,dat[i+1].lg);
01631      2  5                        v := interpolate (0,dat[i].pt.re,dat[i+1].pt.re,
01632      2  5                                            dat[i].pt.im,dat[i+1].pt.im);
01633      2  5                        st := 'IM=' + strofr (v,13);
01634      2  4                        END;
01635      2  4                'Z':  IF (cabs (dat[i].pt) > 1) <> (cabs (dat[i+1].pt) > 1)
01636      2  4                       THEN
01637      2  5                        BEGIN
01638      2  5                        g := interpolate (0,cabs (dat[i].pt),cabs (dat[i+1].pt),
01639      2  5                                            dat[i].lg,dat[i+1].lg);
01640      2  5                        v := interpolate (0,cabs (dat[i].pt),cabs (dat[i+1].pt),
01641      2  5                                            angle(dat[i].pt),angle(dat[i+1].pt));
01642      2  5                        st := 'PH=' + strofr2(v,9,4) + ' deg';
01643      2  4                        END;
01644      2  3                END;
01645      2  3             IF st <> ''
01646      2  3              THEN
01647      2  4               BEGIN
01648      2  5               CASE ltype OF
01649      2  5                  EVA:  st := 'G=' + strofr (exp10(g),13) + '  ' + st;
01650      2  5                  RCO:  st := 'I=' + strofr (g,13) + '  ' + st;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   31
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01651      2  4                  END;
01652      2  4               newline;  grprint (st);
01653      2  4               found := true;
01654      2  3               END;
01655      2  2             END;
01656      2  1    END;
01657      2  1 IF NOT found
01658      2  1  THEN BEGIN  newline;  setcolor ('BOUNDARY');  grprint ('None found');  END;
01659      1  0 END;
01660   C  1  0 {------------------------------}
01661      2  0 PROCEDURE displayfreqrmargins;
01662      2  0 VAR
01663      2  0    i,j         : integer;
01664      2  0    strw,strmag : anystring;
01665      2  0    strpha      : anystring;
01666      2  0    fr,fr1,fr2  : fredat_type;
01667      2  1 BEGIN
01668      2  1 WITH ww^ DO
01669      2  1  FOR j := 1 TO line.count DO
01670      2  1   WITH curve.data[line.data[j].curveix],fcptr^ DO
01671      2  2    BEGIN
01672      2  2    setcolor (line.data[j].color);
01673      2  2    newline;  grprint (lable);
01674      2  2    setcolor ('BOUNDARY');
01675      2  2    newline;  grprint ('Gain margins (P= 180)');
01676      2  2    newline;
01677      2  2    setcolor ('FIND');
01678      2  2    FOR i := 1 TO steps-1 DO
01679      2  2       IF (sin(dat[i].phase*PI/180d0) * sin(dat[i+1].phase*PI/180d0) <= 0)
01680      2  2          AND (cos(dat[i].phase*PI/180d0) < 0)
01681      2  2        THEN
01682      2  3         BEGIN
01683      2  3         fr1 := dat[i];
01684      2  3         fr2 := dat[i+1];
01685      2  3         IF fr1.phase < 0 THEN fr1.phase := fr1.phase + 360d0;
01686      2  3         IF fr2.phase < 0 THEN fr2.phase := fr2.phase + 360d0;
01687      2  3         fr.phase := 180d0;
01688      2  3         fr.omega := interpolate (180d0,fr1.phase,fr2.phase,
01689      2  3                                        fr1.omega,fr2.omega);
01690      2  3         fr.db    := interpolate (180d0,fr1.phase,fr2.phase,
01691      2  3                                        fr1.db   ,fr2.db);
01692      2  3         strfromfredattype (strw,strmag,strpha,fr,fre.freqformat,11,f.ftype);
01693      2  3         newline;  grprint (strw + '  ' + strmag);
01694      2  2         END;
01695      2  2    newline;
01696      2  2    newline;
01697      2  2    setcolor ('BOUNDARY');
01698      2  2    newline;  grprint ('Phase crossings (M= 0dB)');
01699      2  2    newline;
01700      2  2    setcolor ('FIND');
01701      2  2    FOR i := 1 TO steps-1 DO
01702      2  2       IF dat[i].db * dat[i+1].db <= 0
01703      2  2        THEN
01704      2  3         BEGIN
01705      2  3         fr1 := dat[i];

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   32
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01706      2  3         fr2 := dat[i+1];
01707      2  3         IF fr1.phase < fr2.phase-180 THEN fr1.phase := fr1.phase + 360d0;
01708      2  3         IF fr2.phase < fr1.phase-180 THEN fr2.phase := fr2.phase + 360d0;
01709      2  3         fr.db    := 0;
01710      2  3         fr.omega := interpolate (0,fr1.db,   fr2.db,
01711      2  3                                    fr1.omega,fr2.omega);
01712      2  3         fr.phase := interpolate (0,fr1.db,   fr2.db,
01713      2  3                                    fr1.phase,fr2.phase);
01714      2  3         strfromfredattype (strw,strmag,strpha,fr,fre.freqformat,11,f.ftype);
01715      2  3         newline;  grprint (strw + '  ' + strpha);
01716      2  2         END;
01717      2  2    newline;
01718      2  2    newline;
01719      2  1    END;
01720      1  0 END;
01721   C  1  0 {------------------------------}
01722      1  1 BEGIN
01723      1  1 getcursorpoint (pt,ipt);
01724      1  1 ww := winlinkofframelink (pt.f);
01725      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
01726      1  1 IF ww <> NIL
01727      1  1  THEN
01728      1  2   BEGIN
01729      1  2   position (ipt.ix, ipt.iy);
01730      1  3   CASE ww^.curveclass OF
01731      1  3      C_EMP:  ;
01732      1  3      C_LOC:  displaylocusmargins;
01733      1  3      C_FRE:  displayfreqrmargins;
01734      1  3      C_TIR:  ;
01735      1  2      END;
01736      1  2   END
01737      1  1  ELSE bell;
01738      0  0 END;
01739   C  0  0 {-----------------------------------------------------------------------------}
01740      1  0 PROCEDURE O_command (ipt : ipoint);
01741      1  1 BEGIN
01742      1  1 WITH frame.data[0]^ DO
01743      1  1    IF uset AND lset AND (win.count < WINITEMLIM)
01744      1  1     THEN
01745      1  2      BEGIN
01746      1  2      clearscreen;
01747      1  2      addwin (round (rmin (templim.min.x,templim.max.x)),
01748      1  2              round (rmax (templim.min.x,templim.max.x)),
01749      1  2              round (rmin (templim.min.y,templim.max.y)),
01750      1  2              round (rmax (templim.min.y,templim.max.y)));
01751      1  2      plotinca;
01752      1  2      END
01753      1  1     ELSE bell;
01754      0  0 END;
01755   C  0  0 {-----------------------------------------------------------------------------}
01756      1  0 PROCEDURE S_command (ipt : ipoint);
01757      1  0 VAR
01758      1  0    pt  : point;
01759      1  0    ww  : winlink;
01760   C  1  0 {------------------------------}

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   33
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01761      2  0 PROCEDURE selectfreqr;
01762      2  0 VAR
01763      2  0    key  : char;
01764      2  0    ipt  : ipoint;
01765      2  0    good : boolean;
01766      2  1 BEGIN
01767      2  1 setcolor ('GIN_SELECT');
01768      2  1 WITH ww^.box DO drawbox (xmin,xmax,ymin,ymax);
01769      2  1 readcursor (key,ipt,'GIN_SELECT');
01770      2  1 good := true;
01771      2  1 WITH ww^,fre DO
01772      2  2    CASE key OF
01773      2  2       'M','P','N','C','V','B',
01774      2  2       'S':  freqformat.freqplot := freqplotofch (key);
01775      2  2       'A':  freqformat.db := false;
01776      2  2       'D':  freqformat.db := true;
01777      2  2       'F':  freqformat.flog := false;
01778      2  2       'H':  freqformat.hz := true;
01779      2  3       'I':  BEGIN
01780      2  3             readreal('ENTER INFINITY (db) ',infinity,0,1000,infinity);
01781      2  3             ori := UNDEFINED_REAL;
01782      2  2             END;
01783      2  2       'L':  freqformat.flog := true;
01784      2  2       'O':  IF freqformat.db
01785      2  2              THEN readreal('ENTER ORIGIN: ',ori,-BIG,BIG,ori)
01786      2  2              ELSE
01787      2  3               BEGIN
01788      2  3               readreal('ENTER ORIGIN: ',ori,0,BIG,exp10(ori));
01789      2  3               ori := log10(ori);
01790      2  2               END;
01791      2  2       'R':  freqformat.hz := false;
01792      2  2       'W':  readreal ('ENTER WRAPPING : ',wrapping,-360,360,wrapping);
01793      2  2       OTHERWISE BEGIN  bell;  good := false;  END;
01794      2  1       END;
01795      2  1 IF good
01796      2  1  THEN WITH ww^,fre DO
01797      2  2   BEGIN
01798      2  2   openpanel ('GIN_SELECT','ZOOMBOX');
01799      2  2   WITH ww^.box DO drawbox (xmin,xmax,ymin,ymax);
01800      2  2   closepanel;
01801      2  2   purgezoom (fre.fr1);
01802      2  2   dispose (fr1);
01803      2  2   IF fr2 <> NIL
01804      2  2    THEN
01805      2  3     BEGIN
01806      2  3     purgezoom (fre.fr2);
01807      2  3     dispose (fr2);
01808      2  2     END;
01809      2  2   makefreqrframes (ww);
01810      2  1   END;
01811      1  0 END;
01812   C  1  0 {------------------------------}
01813      2  0 PROCEDURE selecttimer;
01814      2  0 VAR
01815      2  0    key : char;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   34
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01816      2  0    ipt : ipoint;
01817      2  1 BEGIN
01818      2  1 readcursor (key,ipt,'GIN_SELECT');
01819      2  1 WITH ww^,tir DO
01820      2  2    CASE key OF
01821      2  2       'V':  readvary ('ENTER Y-AXIS LABEL : ',fr^.x.lable,fr^.x.lable);
01822      2  2       ESC:  ;
01823      2  2       OTHERWISE bell;
01824      2  1       END;
01825      1  0 END;
01826   C  1  0 {------------------------------}
01827      1  1 BEGIN
01828      1  1 getcursorpoint (pt,ipt);
01829      1  1 ww := winlinkofframelink (pt.f);
01830      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
01831      1  1 IF ww <> NIL
01832      1  1  THEN
01833      1  2   CASE ww^.curveclass OF
01834      1  2      C_EMP:  ;
01835      1  2      C_LOC:  ;
01836      1  2      C_FRE:  selectfreqr;
01837      1  2      C_TIR:  selecttimer;
01838      1  2      END
01839      1  1  ELSE bell;
01840      0  0 END;
01841   C  0  0 {-----------------------------------------------------------------------------}
01842      1  0 PROCEDURE T_command (ipt : ipoint);
01843      1  0 VAR
01844      1  0    j   : integer;
01845      1  0    pt  : point;
01846      1  0    ww  : winlink;
01847   C  1  0 {------------------------------}
01848      2  0 PROCEDURE typedatasummary;
01849      2  0 VAR
01850      2  0    j   : integer;
01851      2  1 BEGIN
01852      2  1 setcolor ('RED');
01853      2  1 newline;  grprint ('SUMMARY OF DATA');
01854      2  1 newline;
01855      2  1 WITH ww^ DO
01856      2  1    FOR j := 1 TO line.count DO
01857      2  2       BEGIN
01858      2  2       newline;
01859      2  2       grprint (curve.data[line.data[j].curveix].lable);
01860      2  1       END;
01861      1  0 END;
01862   C  1  0 {------------------------------}
01863      2  0 PROCEDURE typelocussummary;
01864      2  1 BEGIN
01865      2  1 WITH curve.data[ww^.line.data[j].curveix].lcptr^,l DO
01866      2  2    CASE ltype OF
01867      2  2       EVA:  writegraffcn (locfcn);
01868      2  3       RCO:  BEGIN
01869      2  3             grprint (expression);
01870      2  3             newline;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   35
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01871      2  3             grprint ('varying ' + independent);
01872      2  3             newline;
01873      2  3             grprint ('from ' + strofr(indmin,13));
01874      2  3             newline;
01875      2  3             grprint ('to   ' + strofr(indmax,13));
01876      2  2             END;
01877      2  1       END;
01878      1  0 END;
01879   C  1  0 {------------------------------}
01880      2  0 PROCEDURE typefreqrsummary;
01881      2  1 BEGIN
01882      2  1 WITH curve.data[ww^.line.data[j].curveix].fcptr^,f DO
01883      2  2    BEGIN
01884      2  2    IF bodsfcn.plane <> 'K' THEN writegraffcn (bodsfcn);
01885      2  2    IF zoh THEN grprint ('ZERO ORDER HOLD');
01886      2  2    IF zoh AND (compdelay <> 0) THEN newline;
01887      2  2    IF compdelay <> 0 THEN grprint ('DELAY=' + strofr (compdelay,13));
01888      2  2    newline;
01889      2  2    IF bodzfcn.plane <> 'K' THEN writegraffcn (bodzfcn);
01890      2  1    END;
01891      1  0 END;
01892   C  1  0 {------------------------------}
01893      2  0 PROCEDURE typetimersummary;
01894   C  2  0 {--------------------}
01895      3  0 PROCEDURE typegains;
01896      3  0 VAR
01897      3  0    k    : integer;
01898      3  1 BEGIN
01899      3  1 WITH curve.data[ww^.line.data[j].curveix].tcptr^ DO
01900      3  2    BEGIN
01901      3  2    grprint ('COMPENSATION GAINS:');
01902      3  2    FOR k := 1 TO count DO
01903      3  3       BEGIN
01904      3  3       newline;
01905      3  3       grprint (strofi (k,2) + '= ' + strofr(compgain[k],13));
01906      3  2       END;
01907      3  2    newline;
01908      3  2    newline;
01909      3  1    END;
01910      2  0 END;
01911   C  2  0 {--------------------}
01912      2  1 BEGIN
01913      2  1 WITH curve.data[ww^.line.data[j].curveix].tcptr^ DO
01914      2  2    BEGIN
01915      2  3    CASE blocktype OF
01916      2  4       'S':  BEGIN
01917      2  4             grprint ('SIMPLE SYSTEM');
01918      2  4             writegraffcn (plantfcn);
01919      2  3             END;
01920      2  4       'C':  BEGIN
01921      2  4             grprint ('CLOSED LOOP SYSTEM');
01922      2  4             newline;
01923      2  4             grprint ('PLANT FUNCTION');
01924      2  4             writegraffcn (plantfcn);
01925      2  4             grprint ('FEEDBACK FUNCTION');

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   36
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01926      2  4             writegraffcn (feedbackfcn);
01927      2  4             typegains;
01928      2  4             newline;
01929      2  4             newline;
01930      2  3             END;
01931      2  4       'P':  BEGIN
01932      2  4             grprint ('SAMPLER IN PLANT LOOP');
01933      2  4             newline;
01934      2  4             grprint ('PLANT FUNCTION (S)');
01935      2  4             writegraffcn (plantfcn);
01936      2  4             grprint ('PLANT FUNCTION (Z)');
01937      2  4             writegraffcn (samplerfcn);
01938      2  4             typegains;
01939      2  4             grprint ('COMPUTATIONAL DELAY = ' + strofr(compdelay,13));
01940      2  4             newline;
01941      2  4             IF zoh
01942      2  4              THEN grprint ('ZOH')
01943      2  4              ELSE grprint ('NO ZOH');
01944      2  4             grprint ('FEEDBACK FUNCTION');
01945      2  4             writegraffcn (feedbackfcn);
01946      2  3             END;
01947      2  4       'F':  BEGIN
01948      2  4             grprint ('SAMPLER IN FEEDBACK LOOP');
01949      2  4             newline;
01950      2  4             grprint ('PLANT FUNCTION');
01951      2  4             writegraffcn (plantfcn);
01952      2  4             grprint ('FEEDBACK FUNCTION (S)');
01953      2  4             writegraffcn (feedbackfcn);
01954      2  4             grprint ('FEEDBACK FUNCTION (Z)');
01955      2  4             writegraffcn (samplerfcn);
01956      2  4             typegains;
01957      2  4             grprint ('COMPUTATIONAL DELAY = ' + strofr(compdelay,13));
01958      2  4             newline;
01959      2  4             IF zoh
01960      2  4              THEN grprint ('ZOH')
01961      2  4              ELSE grprint ('NO ZOH');
01962      2  4             newline;
01963      2  4             newline;
01964      2  3             END;
01965      2  2       END;
01966      2  2    grprint ('INPUT FUNCTION');
01967      2  2    writegraffcn (inputfcn);
01968      2  1    END;
01969      1  0 END;
01970   C  1  0 {------------------------------}
01971      1  1 BEGIN
01972      1  1 getcursorpoint (pt,ipt);
01973      1  1 ww := winlinkofframelink (pt.f);
01974      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
01975      1  1 IF ww <> NIL
01976      1  1  THEN
01977      1  1   WITH ww^ DO
01978      1  2      BEGIN
01979      1  2      IF line.count > 1
01980      1  2       THEN readint ('ENTER CURVE NUMBER : ',j,0,line.count,0)

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   37
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

01981      1  2       ELSE j := 1;
01982      1  2      position (ipt.ix, ipt.iy);
01983      1  2      IF j = 0
01984      1  2       THEN typedatasummary
01985      1  2       ELSE
01986      1  3        BEGIN
01987      1  3        setcolor (line.data[j].color);
01988      1  4        CASE curveclass OF
01989      1  4           C_EMP:  ;
01990      1  4           C_LOC:  typelocussummary;
01991      1  4           C_FRE:  typefreqrsummary;
01992      1  4           C_TIR:  typetimersummary;
01993      1  3           END;
01994      1  2        END;
01995      1  2      END
01996      1  1  ELSE bell;
01997      0  0 END;
01998   C  0  0 {-----------------------------------------------------------------------------}
01999      1  0 PROCEDURE V_command (ipt : ipoint;  key : char);
02000      1  0 VAR
02001      1  0    pt  : point;
02002      1  0    ww  : winlink;
02003   C  1  0 {------------------------------}
02004      2  0 PROCEDURE findgval;
02005      2  0 VAR
02006      2  0    i,j,br          : integer;
02007      2  0    gi,loggain,fr   : real;
02008      2  0    zf              : complex;
02009      2  0    found           : real;
02010      2  1 BEGIN
02011      2  1 readreal ('ENTER GAIN/IND : ',gi,-BIG,BIG,1);
02012      2  1 IF gi > 0
02013      2  1  THEN loggain := log10(abs(gi))
02014      2  1  ELSE loggain := UNDEFINED_REAL;
02015      2  1 
02016      2  1 position (ipt.ix, ipt.iy);
02017      2  1 gcount := gcount+1;
02018      2  1 setcolor ('FIND');
02019      2  1 stardraw (2+gcount,config.resolution*2);
02020      2  1 moveto (1280,-384);
02021      2  1 grprint ('G/I=' + strofr(gi,13));
02022      2  1 
02023      2  1 WITH ww^ DO
02024      2  1  FOR j := 1 TO line.count DO
02025      2  1   WITH curve.data[line.data[j].curveix].lcptr^,l DO
02026      2  1    FOR br := 1 TO brmax DO WITH branch[br] DO
02027      2  1       FOR i := locmin TO locmax-1 DO
02028      2  2          BEGIN
02029      2  3          CASE ltype OF
02030      2  3             EVA:  IF (loggain > dat[i].lg) AND (loggain <= dat[i+1].lg)
02031      2  3                    THEN fr := (loggain-dat[i].lg)/(dat[i+1].lg - dat[i].lg)
02032      2  3                    ELSE fr := UNDEFINED_REAL;
02033      2  3             RCO:  IF (gi > dat[i].ind) AND (gi <= dat[i+1].ind)
02034      2  3                    THEN fr := (gi-dat[i].ind)/(dat[i+1].ind - dat[i].ind)
02035      2  3                    ELSE fr := UNDEFINED_REAL;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   38
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02036      2  2             END;
02037      2  2          IF fr <> UNDEFINED_REAL
02038      2  2           THEN
02039      2  3            BEGIN
02040      2  3            zf.re := dat[i].pt.re + fr * (dat[i+1].pt.re - dat[i].pt.re);
02041      2  3            zf.im := dat[i].pt.im + fr * (dat[i+1].pt.im - dat[i].pt.im);
02042      2  3            IF inside (loc.fr,scale (convert (pointofr (loc.fr,zf.re,zf.im))))
02043      2  3             THEN
02044      2  4              BEGIN
02045      2  4              scaleposition (pointofr (loc.fr,zf.re,zf.im));
02046      2  4              stardraw (2+gcount,config.resolution*2);
02047      2  3              END;
02048      2  4            CASE ltype OF
02049      2  4               EVA:  writeline (aud,'FIND V: Gain is' + strofr(gi,13)
02050      2  4                                       + ' at Point ('+ strofc(zf,13) + ')');
02051      2  4               RCO:  writeline (aud,'FIND V: Ind. is' + strofr(gi,13)
02052      2  4                                       + ' at Point ('+ strofc(zf,13) + ')');
02053      2  3               END;
02054      2  2            END;
02055      2  1          END;
02056      1  0 END;
02057   C  1  0 {------------------------------}
02058      2  0 PROCEDURE findwval;
02059      2  0 VAR
02060      2  0    i,j            : integer;
02061      2  0    w              : real;
02062      2  0    strw,strmag    : anystring;
02063      2  0    strpha         : anystring;
02064      2  0    popx,popy      : real;
02065      2  0    fr             : fredat_type;
02066      2  0    foundandtypeok : boolean;
02067      2  0    rightcommand   : boolean;
02068   C  2  0 {--------------------}
02069      3  0 PROCEDURE drawpoint (fr : framelink;  x,y : real);
02070      3  0 VAR
02071      3  0    pt : point;
02072      3  1 BEGIN
02073      3  1 pt := pointofr (fr,x,y);
02074      3  1 IF inside (fr,scale (convert (pt)))
02075      3  1  THEN BEGIN  scaleposition (pt);  stardraw (2+gcount,config.resolution*2);  END;
02076      3  1 writeline (aud,'     The point (' + strmag + ', ' + strpha + ')');
02077      2  0 END;
02078   C  2  0 {--------------------}
02079      2  1 BEGIN
02080      2  1 WITH ww^ DO
02081      2  2    BEGIN
02082      2  2    rightcommand := false;
02083      2  2    FOR j := 1 TO line.count DO
02084      2  2       WITH curve.data[line.data[j].curveix].fcptr^,f DO
02085      2  2          FOR i := 2 TO steps DO
02086      2  3             CASE key OF
02087      2  3                'V': IF ftype = SFR THEN rightcommand := true;
02088      2  3                'A': IF ftype = DES THEN rightcommand := true;
02089      2  2                END;
02090      2  2    IF rightcommand

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   39
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02091      2  2     THEN
02092      2  3      BEGIN
02093      2  4      CASE key OF
02094      2  4         'V': IF fre.freqformat.hz
02095      2  4               THEN
02096      2  5                BEGIN
02097      2  5                readreal('ENTER FREQUENCY (HZ): ',w,0,BIG,1);
02098      2  5                w := w * 2d0 * PI;
02099      2  5                END
02100      2  4               ELSE readreal('ENTER FREQUENCY (rps): ',w,0,BIG,1);
02101      2  4         'A':  readreal('ENTER AMPLITUDE: ',w,0,BIG,1);
02102      2  3         END;
02103      2  3      gcount := gcount+1;
02104      2  3      position (ipt.ix, ipt.iy);
02105      2  3      setcolor ('FIND');
02106      2  3      stardraw (2+gcount,config.resolution*2);
02107      2  3      moveto (1280,-384);
02108      2  3      grprint (strofr (w,13));
02109      2  4      CASE key OF
02110      2  4         'V' : writeline (aud,'FIND VAL: The frequency is' + strw + ' at ..');
02111      2  4         'A' : writeline (aud,'FIND VAL: The amplitude is' + strw + ' at ..');
02112      2  3         END;
02113      2  3      FOR j := 1 TO line.count DO
02114      2  3         WITH curve.data[line.data[j].curveix].fcptr^,f DO
02115      2  3            FOR i := 2 TO steps DO
02116      2  4               BEGIN
02117      2  4               foundandtypeok:= false;
02118      2  4               IF (w > dat[i-1].omega) <> (w >= dat[i].omega)
02119      2  4                THEN
02120      2  5                 CASE key OF
02121      2  5                    'V' : IF ftype = SFR
02122      2  5                           THEN foundandtypeok := true
02123      2  5                           ELSE foundandtypeok := false;
02124      2  5                    'A' : IF ftype = DES
02125      2  5                           THEN foundandtypeok := true
02126      2  5                           ELSE foundandtypeok := false;
02127      2  4                    END;
02128      2  4               IF foundandtypeok
02129      2  4                THEN
02130      2  5                 BEGIN
02131      2  5                 fr.db    := interpolate (w,dat[i-1].omega,dat[i].omega,
02132      2  5                                            dat[i-1].db,   dat[i].db);
02133      2  5                 fr.phase := interpolate (w,dat[i-1].omega,dat[i].omega,
02134      2  5                                            dat[i-1].phase,dat[i].phase);
02135      2  5                 fr.phase := phnorm (fr.phase);
02136      2  5                 fr.omega := w;
02137      2  5                 popx := exp10(fr.db/20d0) * cos (fr.phase *PI/180d0);
02138      2  5                 popy := exp10(fr.db/20d0 + log10 (fr.omega))
02139      2  5                                           * sin (fr.phase*PI/180d0);
02140      2  5                 strfromfredattype (strw,strmag,strpha,fr,
02141      2  5                                    fre.freqformat,13,f.ftype);
02142      2  6                 CASE fre.freqformat.freqplot OF
02143      2  7                    bod:  BEGIN
02144      2  7                          drawpoint (fre.fr1, fr.omega, fr.db);
02145      2  7                          drawpoint (fre.fr2, fr.omega, fr.phase);

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   40
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02146      2  6                          END;
02147      2  7                    bmp:  BEGIN
02148      2  7                          drawpoint (fre.fr1, fr.omega, fr.db);
02149      2  7                          drawpoint (fre.fr2, fr.omega, fr.phase);
02150      2  6                          END;
02151      2  6                    mag:  drawpoint (fre.fr1, fr.omega, fr.db);
02152      2  6                    pha:  drawpoint (fre.fr1, fr.omega, fr.phase);
02153      2  6                    nyq:  drawpoint (fre.fr1, fr.db,    fr.phase);
02154      2  6                    nic:  drawpoint (fre.fr1, fr.phase, fr.db);
02155      2  6                    pop:  drawpoint (fre.fr1, popx,     popy);
02156      2  5                    END;
02157      2  4                 END;
02158      2  3               END;
02159      2  3      END
02160      2  2     ELSE bell;
02161      2  1    END;
02162      1  0 END;
02163   C  1  0 {------------------------------}
02164      1  1 BEGIN
02165      1  1 getcursorpoint (pt,ipt);
02166      1  1 ww := winlinkofframelink (pt.f);
02167      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
02168      1  1 IF ww <> NIL
02169      1  1  THEN
02170      1  2   CASE ww^.curveclass OF
02171      1  2      C_EMP:  ;
02172      1  2      C_LOC:  findgval;
02173      1  2      C_FRE:  findwval;
02174      1  2      C_TIR:  ;
02175      1  2      END
02176      1  1  ELSE bell;
02177      0  0 END;
02178   C  0  0 {-----------------------------------------------------------------------------}
02179      1  0 PROCEDURE W_command (ipt : ipoint);
02180      1  0 VAR
02181      1  0    i,j     : integer;
02182      1  0    key     : char;
02183      1  0    pt      : point;
02184      1  0    ww      : winlink;
02185      1  1 BEGIN
02186      1  1 getcursorpoint (pt,ipt);
02187      1  1 ww := winlinkofframelink (pt.f);
02188      1  1 IF (ww = NIL) AND (win.count = 1) THEN ww := win.data[1];
02189      1  1 IF ww <> NIL
02190      1  1  THEN
02191      1  2   BEGIN
02192      1  2   setcolor ('GIN_WINDOW');
02193      1  2   WITH ww^.box DO drawbox (xmin,xmax,ymin,ymax);
02194      1  2   readcursor (key,ipt,'GIN_WINDOW');
02195      1  3   CASE key OF
02196      1  4      'B':  BEGIN
02197      1  4            j := 0;
02198      1  4            FOR i := 1 TO win.count DO
02199      1  4               IF ww = win.data[i] THEN j := i;
02200      1  4            FOR i := j-1 DOWNTO 1 DO

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   41
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02201      1  4               win.data[i+1] := win.data[i];
02202      1  4            win.data[1] := ww;
02203      1  4            plotinca;
02204      1  3            END;
02205      1  4      'D':  BEGIN
02206      1  4            deletewin (ww);
02207      1  4            plotinca;
02208      1  3            END;
02209      1  4      'F':  BEGIN
02210      1  4            j := 0;
02211      1  4            FOR i := 1 TO win.count DO
02212      1  4               IF ww = win.data[i] THEN j := i;
02213      1  4            FOR i := j+1 TO win.count DO
02214      1  4               win.data[i-1] := win.data[i];
02215      1  4            win.data[win.count] := ww;
02216      1  4            plotinca;
02217      1  3            END;
02218      1  3      'I':  WITH frame.data[0]^ DO
02219      1  3               IF uset AND lset
02220      1  3                THEN
02221      1  4                 BEGIN
02222      1  4                 win.count := win.count + 1;
02223      1  4                 new (win.data[win.count]);
02224      1  4                 win.data[win.count]^ := ww^;
02225      1  4                 WITH win.data[win.count]^ DO
02226      1  5                    BEGIN
02227      1  5                    box.xmin := round (rmin (templim.min.x,templim.max.x));
02228      1  5                    box.xmax := round (rmax (templim.min.x,templim.max.x));
02229      1  5                    box.ymin := round (rmin (templim.min.y,templim.max.y));
02230      1  5                    box.ymax := round (rmax (templim.min.y,templim.max.y));
02231      1  6                    CASE curveclass OF
02232      1  6                       C_EMP:  ;
02233      1  7                       C_LOC:  BEGIN
02234      1  7                               new (loc.fr);
02235      1  7                               loc.fr^ := ww^.loc.fr^;
02236      1  7                               loc.fr^.firstzoom := NIL;
02237      1  7                               WITH loc.fr^ DO IF uset AND lset
02238      1  7                                THEN
02239      1  8                                 BEGIN
02240      1  8                                 currlim.min.x := rmin (templim.min.x,
02241      1  8                                                        templim.max.x);
02242      1  8                                 currlim.max.x := rmax (templim.min.x,
02243      1  8                                                        templim.max.x);
02244      1  8                                 currlim.min.y := rmin (templim.min.y,
02245      1  8                                                        templim.max.y);
02246      1  8                                 currlim.max.y := rmax (templim.min.y,
02247      1  8                                                        templim.max.y);
02248      1  7                                 END;
02249      1  6                               END;
02250      1  7                       C_FRE:  BEGIN
02251      1  7                               new (fre.fr1);
02252      1  7                               fre.fr1^ := ww^.fre.fr1^;
02253      1  7                               fre.fr1^.firstzoom := NIL;
02254      1  7                               IF fre.fr2 <> NIL
02255      1  7                                THEN

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   42
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02256      1  8                                 BEGIN
02257      1  8                                 new (fre.fr2);
02258      1  8                                 fre.fr2^ := ww^.fre.fr2^;
02259      1  8                                 fre.fr2^.firstzoom := NIL;
02260      1  8                                 END
02261      1  7                                ELSE
02262      1  7                                 WITH fre.fr1^ DO IF uset AND lset
02263      1  7                                  THEN
02264      1  8                                   BEGIN
02265      1  8                                   currlim.min.x := rmin (templim.min.x,
02266      1  8                                                          templim.max.x);
02267      1  8                                   currlim.max.x := rmax (templim.min.x,
02268      1  8                                                          templim.max.x);
02269      1  8                                   currlim.min.y := rmin (templim.min.y,
02270      1  8                                                          templim.max.y);
02271      1  8                                   currlim.max.y := rmax (templim.min.y,
02272      1  8                                                          templim.max.y);
02273      1  7                                   END;
02274      1  6                               END;
02275      1  7                       C_TIR:  BEGIN
02276      1  7                               new (tir.fr);
02277      1  7                               tir.fr^ := ww^.tir.fr^;
02278      1  7                               tir.fr^.firstzoom := NIL;
02279      1  7                               WITH tir.fr^ DO IF uset AND lset
02280      1  7                                THEN
02281      1  8                                 BEGIN
02282      1  8                                 currlim.min.x := rmin (templim.min.x,
02283      1  8                                                        templim.max.x);
02284      1  8                                 currlim.max.x := rmax (templim.min.x,
02285      1  8                                                        templim.max.x);
02286      1  8                                 currlim.min.y := rmin (templim.min.y,
02287      1  8                                                        templim.max.y);
02288      1  8                                 currlim.max.y := rmax (templim.min.y,
02289      1  8                                                        templim.max.y);
02290      1  7                                 END;
02291      1  6                               END;
02292      1  5                       END;
02293      1  5                    usertitle := 'INSET';
02294      1  4                    END;
02295      1  4                 plotinca;
02296      1  4                 END
02297      1  3                ELSE bell;
02298      1  3      'Z':  WITH frame.data[0]^,ww^ DO
02299      1  3               IF uset AND lset
02300      1  3                THEN
02301      1  4                 BEGIN
02302      1  4                 box.xmin := round (rmin (templim.min.x,templim.max.x));
02303      1  4                 box.xmax := round (rmax (templim.min.x,templim.max.x));
02304      1  4                 box.ymin := round (rmin (templim.min.y,templim.max.y));
02305      1  4                 box.ymax := round (rmax (templim.min.y,templim.max.y));
02306      1  4                 plotinca;
02307      1  4                 END
02308      1  3                ELSE bell;
02309      1  3      ESC:  ;
02310      1  3      OTHERWISE bell;

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   43
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02311      1  2      END;
02312      1  2   END
02313      1  1  ELSE bell;
02314      0  0 END;
02315   C  0  0 {=============================================================================}
02316   C  0  0 {-- ROUTINE TO DO PLOT COMMAND -----------------------------------------------}
02317   C  0  0 {=============================================================================}
02318      1  0 PROCEDURE plot;
02319      1  0 VAR
02320      1  0    modi         : command_type;
02321      1  0    go,plotagain : boolean;
02322      1  0    firsttime    : boolean;
02323      1  0    key          : char;
02324      1  0    ipt          : ipoint;
02325      1  1 BEGIN
02326      1  1 startcommand ('PLOT',true);
02327      1  1 setcommand ('Empty');
02328      1  1 setcommand ('New');
02329      1  1 setcommand ('Old');
02330      1  1 readcommand (modi,'N',false,'PLOT');
02331      1  1 go := true;
02332      1  2 CASE chofcom (modi) OF
02333      1  2    'E':  purgewins;
02334      1  3    'N':  BEGIN
02335      1  3          purgewins;
02336      1  3          addwin (0,65000,2000,46000);
02337      1  3          go := win.count <> 0;
02338      1  2          END;
02339      1  2    'O':  ;
02340      1  2    ESC:  go := false;
02341      1  1    END;
02342      1  1 IF havehandler THEN ESTABLISH (handler);
02343      1  1 firsttime := true;
02344      1  1 WHILE go DO
02345      1  2    BEGIN
02346      1  2    IF firsttime
02347      1  2     THEN
02348      1  3      BEGIN
02349      1  3      plotinca;
02350      1  3      firsttime := false;
02351      1  3      key := NUL;
02352      1  3      END
02353      1  2     ELSE readcursor (key,ipt,'GIN_NORMAL');
02354      1  2    checkcursor (key,ipt,go,plotagain);
02355      1  2 
02356      1  2 
02357      1  3    CASE key OF
02358      1  3       NUL:  IF plotagain THEN plotinca;
02359      1  3       'A':  V_command (ipt,key);
02360      1  3       'C':  C_command (ipt);
02361      1  3       'F',
02362      1  3       'G':  F_command (ipt,key);
02363      1  3       'H':  H_command (ipt);
02364      1  3       'I':  I_command (ipt);
02365      1  3       'M':  M_command (ipt);

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   44
INCA                            Source Listing                  30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

-LINE-IDC-PL-SL-

02366      1  3       'O':  O_command (ipt);
02367      1  3       'S':  S_command (ipt);
02368      1  3       'T':  T_command (ipt);
02369      1  3       'V':  V_command (ipt,key);
02370      1  3       'W':  W_command (ipt);
02371      1  3       'Y':  F_command (ipt,key);
02372      1  3       OTHERWISE bell;
02373      1  2       END;
02374      1  2    IF length(err) <> 0
02375      1  2     THEN
02376      1  3      BEGIN
02377      1  3      writeerror;
02378      1  3      IF err = 'FATAL ERROR' THEN BEGIN  REVERT;  resignal;  END;
02379      1  3      err := '';
02380      1  2      END;
02381      1  1    END;
02382      1  1 IF havehandler THEN REVERT;
02383      1  1 clearframe;
02384      1  1 clearscreen;
02385      0  0 END;
02386   C  0  0 {-----------------------------------------------------------------------------}
02387      0  0 END.

PLOTINCA                                                        23-Dec-1988 11:04:18    VAX Pascal V3.7-254                Page   45
INCA                            Pascal Compilation Statistics   30-Nov-1988 15:50:49    DUA1:[QPLOT.INCA.SOURCE]PLOT.PAS;8 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               45087  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                              13607  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
LIB$INITIALIZE                          4  NOVEC,NOWRT,  RD,NOEXE,NOSHR,  GBL,  REL,  CON,NOPIC,ALIGN(0)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260         0         0
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        61        49
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204       125        61
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        39        54
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59        31        53
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        13        21
DUA1:[QPLOT.QPLOT.SOURCE]COLOR.PEN;1                      93         0         0
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213       125        59
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39         8        21
DUA1:[QPLOT.QPLOT.SOURCE]UTILITIES.PEN;1                 105         8         8
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292       179        61
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       312        82
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        74        30
DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PEN;1                    144         0         0
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        11         6
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289       195        67



LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:GENERAL',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:MATH',
00007      0  0                'QLIBHOME:COMPLEX',
00008      0  0                'QLIBHOME:HANDLER',
00009      0  0                'QLIBHOME:IO',
00010      0  0                'QLIBHOME:FIG',
00011      0  0                'QLIBHOME:PLOT',
00012      0  0                'CURVE','FCNIO','FCNEVAL','FCN','LONGREAL','POLYMATH','UTIL'), 
00013      0  0   ENVIRONMENT ('LOCUS')]
00014      0  0 MODULE locus;
00015      0  0 TYPE
00016      0  0    brtemp_item_type  = RECORD
00017      0  0                        done     : boolean;
00018      0  0                        sstart   : complex;
00019      0  0                        thstart  : real;
00020      0  0                        END;
00021      0  0 VAR
00022      0  0    brtemp            : ARRAY [1..LOCBRASIZE] OF brtemp_item_type;
00023   C  0  0 {=============================================================================}
00024   C  0  0 {-- ROUTINES TO CALCULATE ROOT LOCUS -----------------------------------------}
00025   C  0  0 {=============================================================================}
00026      0  0 [ HIDDEN ]
00027      1  0 PROCEDURE arclocus (VAR lc : loccurve_type;  VAR theta : real;  
00028      1  0    VAR sarc : complex;  VAR locend : locend_type;  
00029      1  0    thmin,thmax,radius,dtheta : real;  scen : complex);
00030   C  1  0 {                                                                             }
00031   C  1  0 {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
00032   C  1  0 { Purpose -- Find locus pt. SARC at angle THETA on arc of RADIUS around SCEN. }
00033   C  1  0 {                                                                             }
00034   C  1  0 {  THETA     = OUTPUT : Angle of next point (DEG).                            }
00035   C  1  0 {  SARC      = OUTPUT : Location of next point.                               }
00036   C  1  0 {  OCEND     = OUTPUT : Next point was found (ok) or not (no_loci).           }
00037   C  1  0 {  THMIN     = INPUT  : Angle to start search (DEG).                          }
00038   C  1  0 {  THMAX     = INPUT  : Angle to stop search (DEG).                           }
00039   C  1  0 {  RADIUS    = INPUT  : Radius of search circle.                              }
00040   C  1  0 {  DTHETA    = INPUT  : Initial angular step rate (DEG).                      }
00041   C  1  0 {  SCEN      = INPUT  : Center of search circle.                              }
00042   C  1  0 {  LOCFCN    = GLOBAL : Function we are doing locus of.                       }
00043   C  1  0 {                                                                             }
00044   C  1  0 {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
00045      1  0 VAR
00046      1  0     isnold,isnnew,i : integer;
00047      1  0     phase,thetarad  : real;
00048      1  0     z               : complex;
00049      1  1 BEGIN
00050      1  1 WITH lc,l DO 
00051      1  2    BEGIN
00052      1  2    locend := no_loci;
00053      1  2    isnold := -2;
00054      1  2    theta  := thmin - dtheta;
00055      1  3    REPEAT

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00056      1  3       theta := theta + dtheta;
00057      1  3       thetarad := theta * PI / 180d0;
00058      1  3       sarc.re := scen.re + radius * cos(thetarad);
00059      1  3       sarc.im := scen.im + radius * sin(thetarad);
00060      1  3       phase   := fcnevalph (locfcn,sarc,phaseangle);
00061      1  3       isnnew  := round (MTH$DSIGN (1d0, phase));
00062      1  3       IF (abs(phase) < 90d0) AND (isnnew <> isnold) AND (isnold <> -2)
00063      1  3        THEN
00064      1  4         BEGIN
00065      1  4         locend := ok;
00066      1  4         dtheta := -dtheta;
00067      1  3         END;
00068      1  3       isnold := isnnew;
00069      1  3       IF (locend = ok) THEN dtheta := dtheta / 2d0;
00070      1  2       UNTIL (abs(dtheta) < 1d-9) OR (theta > thmax) AND (locend <> ok);
00071      1  2    IF (locend = ok) AND (abs(phase) > 1d-6) THEN locend := numeric_prob;
00072      1  1    END;
00073      0  0 END;
00074   C  0  0 {-----------------------------------------------------------------------------}
00075      0  0 [ HIDDEN ]
00076      1  0 PROCEDURE rlocusbranch (VAR lc : loccurve_type;  br : integer;  
00077      1  0    dr,rstart,dt,thbend : real);  
00078   C  1  0 {                                                                             }
00079   C  1  0 {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
00080   C  1  0 { Purpose -- Track one branch of the root locus.                              }
00081   C  1  0 {                                                                             }
00082   C  1  0 {               -----SUBROUTINE ARGUMENT DESCRIPTIONS-----                    }
00083   C  1  0 {                                                                             }
00084   C  1  0 {  br      = INPUT  : Branch being calculated.                                }
00085   C  1  0 {  dr      = INPUT  : Parameter used to control maximum radius of the         }
00086   C  1  0 {                     search circle.  A good value is 0.25.  The algorithm    }
00087   C  1  0 {                     is structured to iteratively search for the loci        }
00088   C  1  0 {                     crossing point on a circle centered at the last         }
00089   C  1  0 {                     computed loci point.  The algorithm adjusts the circle  }
00090   C  1  0 {                     radius in such a manner that sharp turns of the loci    }
00091   C  1  0 {                     are prohibited within the search circle.  If it appears }
00092   C  1  0 {                     that a break point has been stepped over decrease the   }
00093   C  1  0 {                     value of dr.                                            }
00094   C  1  0 {  rstart  = INPUT  : Starting radius.                                        }
00095   C  1  0 {  dt      = INPUT  : Parameter used to control sweep angle in search circle. }
00096   C  1  0 {  thbend  = INPUT  : Maximum loci bending allowed in one step.  5 (deg) is   }
00097   C  1  0 {                     a good number.                                          }
00098   C  1  0 {                                                                             }
00099   C  1  0 {  branch[br] = GLOB:                                                         }
00100   C  1  0 {            locmin : First point of this branch.                             }
00101   C  1  0 {            locmax : Last point on this branch.                              }
00102   C  1  0 {            locend : Reason end of locus was found.                          }
00103   C  1  0 {  brtemp[br] = GLOB:                                                         }
00104   C  1  0 {            done   : Was branch taken to a succesful end yet?                }
00105   C  1  0 {            thstart: Angle at which search is begun.                         }
00106   C  1  0 {            sstart : Point where locus is begun.                             }
00107   C  1  0 {                                                                             }
00108   C  1  0 {  locfcn  = GLOBAL : Function we are processing.                             }
00109   C  1  0 {  loc[]   = GLOBAL :                                                         }
00110   C  1  0 {            pt     : Point on locus.                                         }

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00111   C  1  0 {            g      : Open loop gain of locus.                                }
00112   C  1  0 {            dg     : Logarithmic derivative of gain along locus.             }
00113   C  1  0 {            th     : Locus slope in degrees.                                 }
00114   C  1  0 {                                                                             }
00115   C  1  0 {~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
00116      1  0 VAR
00117      1  0     i,ic                              : integer;
00118      1  0     radmin,radius,droot1,droot2       : real;
00119      1  0     logderiv,k,thcen,tharc,thsrch     : real;
00120      1  0     scen,sarc,croot1,croot2           : complex;
00121      1  0     normal                            : boolean;
00122      1  0     str                               : anystring;
00123      1  1 BEGIN
00124      1  1 WITH lc,l,branch[br],brtemp[br] DO 
00125      1  2    BEGIN
00126      1  2    tharc  := thstart;
00127      1  2    sarc   := sstart;
00128      1  2    IF rstart = 0
00129      1  2     THEN radius := dr * 0.05 * fcnevalnearroot (croot1,locfcn,sarc)
00130      1  2     ELSE radius := rstart;
00131      1  2    ic     := 0;
00132      1  2    normal := false;
00133      1  2    locend := ok;
00134      1  2 
00135      1  2    IF br = 1 THEN locmin := 1 ELSE locmin := branch[br-1].locmax+1;
00136      1  2    locmax := locmin;
00137      1  2    dat[locmax].pt := sstart;
00138      1  2    dat[locmax].lg := -fcnevallogabs (locfcn,sstart);
00139      1  2    dat[locmax].th := 0;
00140      1  2    dat[locmax].dg := 0;
00141      1  3    REPEAT 
00142      1  3       thcen  := tharc;
00143      1  3       scen   := sarc;
00144      1  3       radmin := dr * 1d-4 * fcnevalnearroot (croot1,locfcn,scen);
00145      1  4       REPEAT
00146      1  4          IF      locmax = locmin       THEN thsrch := dt
00147      1  4          ELSE IF radius < radmin*1.75  THEN thsrch := 170
00148      1  4          ELSE                               thsrch := thbend;
00149      1  4          arclocus (lc,tharc,sarc,locend,thcen-thsrch,thcen+thsrch,
00150      1  4               radius,thbend,scen); 
00151      1  4          ic       := ic + 1;
00152      1  4          k        := -fcnevallogabs (locfcn,sarc);
00153      1  4          logderiv := fcnevallogderiv (tharc,locfcn,sarc);
00154      1  4          droot1   := fcnevalnearroot (croot1,locfcn,sarc);
00155      1  4          droot2   := fcnevalnearroot (croot2,locfcn,croot1);
00156      1  4 
00157      1  4          IF locend IN [no_loci,numeric_prob]
00158      1  4           THEN 
00159      1  4          ELSE IF k <= dat[locmax].lg
00160      1  4           THEN locend := gain_decrease
00161      1  4          ELSE IF (locfcn.plane IN ['S','W']) AND (radius > radmin * 1.75)
00162      1  4            AND ((sarc.re * scen.re) < 0)
00163      1  4            AND (abs(cos(tharc*PI/180)) > 0.01)
00164      1  4           THEN locend := near_boundary
00165      1  4          ELSE IF (locmax > locmin) AND (radius > radmin) 

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00166      1  4               AND (logderiv < rmin (1d0,dat[locmax].dg/1.3d0))
00167      1  4           THEN locend := deriv_gain
00168      1  4          ELSE IF (cos ((tharc-thcen) * PI/180d0) < cos (thbend * PI/180d0))
00169      1  4               AND (locmax > locmin + 1)
00170      1  4           THEN locend := sharp_bend
00171      1  4          ELSE IF (-fcnevallogabs (locfcn,croot1) > 0) 
00172      1  4               AND (logderiv*droot2 > 100)
00173      1  4           THEN locend := zero_found
00174      1  4          ELSE IF (droot1 < radius/2)
00175      1  4           THEN locend := near_root
00176      1  4          ELSE IF normal AND (logderiv*droot1 < 0.001d0)
00177      1  4           THEN locend := breakpoint
00178      1  4          ELSE IF (sarc.re > lim.max.x) OR (sarc.re < lim.min.x) 
00179      1  4               OR (sarc.im > lim.max.y) OR (sarc.im < lim.min.y)
00180      1  4           THEN locend := outside_reg;
00181      1  4 
00182      1  4          IF locend <> ok THEN radius := radius/1.75;
00183      1  3          UNTIL (locend IN [ok,outside_reg]) OR (radius < radmin);
00184      1  3 
00185      1  3       IF NOT normal AND (logderiv*droot1 > 0.0002d0) THEN normal := true;
00186      1  3       locmax := locmax+1;
00187      1  3       dat[locmax].pt := sarc;
00188      1  3       dat[locmax].lg := k;
00189      1  3       dat[locmax].dg := logderiv;
00190      1  3       dat[locmax].th := tharc;
00191      1  3       IF locmax >= LOCARRSIZE THEN locend := storage_full;
00192      1  3 
00193      1  3       IF (cos((tharc-thcen)*PI/180) > cos(thbend/2d0*PI/180))
00194      1  3        THEN radius := radius * 1.75;
00195      1  3       radius := rmin (radius,droot1);
00196      1  2       UNTIL locend <> ok;
00197      1  2 
00198      1  2    IF locend = zero_found 
00199      1  2     THEN 
00200      1  3      BEGIN
00201      1  3      droot1 := fcnevalnearroot (croot1,locfcn,sarc);
00202      1  3      locmax := locmax+1;
00203      1  3      dat[locmax].pt := croot1;
00204      1  3      dat[locmax].lg := -fcnevallogabs (locfcn,croot1);
00205      1  3      dat[locmax].dg := 0;
00206      1  3      dat[locmax].th := 0;
00207      1  2      END;
00208      1  2    done := NOT (locend IN [breakpoint,numeric_prob,deriv_gain]);
00209      1  2    IF NOT done THEN locmax := locmax + 1;
00210      1  2    writev (str,locend);
00211      1  2    writeline (both,'Br='  + strofi(brmax,3) 
00212      1  2               + '  pts='  + strofi(locmax-locmin+1,4) 
00213      1  2               + '  Arcs=' + strofi(ic,3) 
00214      1  2               + '  End='  + strfix (stripblank (str),12)
00215      1  2               + '  at   ' + strofc(dat[locmax-1].pt,11));
00216      1  1    END;
00217      0  0 END;
00218   C  0  0 {-----------------------------------------------------------------------------}
00219      0  0 [ HIDDEN ]
00220      1  0 PROCEDURE findbreak (VAR lc : loccurve_type;  VAR clean : boolean;  

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00221      1  0    VAR smid : complex;  VAR points : cpoly);
00222   C  1  0 { Purpose -- Find a breakpoint by searching branches that are not DONE. }
00223      1  0 VAR
00224      1  0     br,lowbr,i    : integer;
00225      1  0     gmin,th,r,dif : real;
00226      1  0     sx            : complex;
00227      1  0     foundall      : boolean;
00228      1  1 BEGIN
00229      1  1 WITH lc,l DO 
00230      1  2    BEGIN
00231      1  2    gmin  := BIG;
00232      1  2    FOR br := 1 TO brmax DO WITH branch[br],brtemp[br] DO
00233      1  2       IF (NOT done) AND (dat[locmax-1].lg < gmin)
00234      1  2        THEN 
00235      1  3         BEGIN 
00236      1  3         gmin  := dat[locmax-1].lg;  
00237      1  3         lowbr := br;
00238      1  2         END;
00239      1  2    clean := (gmin = BIG);
00240      1  2    IF clean
00241      1  2     THEN points.deg := 0
00242      1  2     ELSE WITH branch[lowbr],brtemp[lowbr] DO
00243      1  3      BEGIN
00244      1  3      writeline (aud,'Breakpoint found --');
00245      1  3      points.deg := 1;
00246      1  3      points.f[1] := dat[locmax-1].pt;
00247      1  3      writeline (aud,'Branch #' + strofi(points.deg,2) + ' Ends at (' 
00248      1  3        + strofc(points.f[points.deg],13) + ')');
00249      1  3      done := true;
00250      1  3      dat[locmax].pt.re := UNDEFINED_REAL;
00251      1  3 
00252   C  1  3      { CALCULAT MAXIMUM RADIUS }
00253      1  3      r := fcnevalnearroot (sx,locfcn,points.f[1]) / 10;
00254      1  3      FOR br := 1 TO brmax DO WITH branch[br],brtemp[br] DO
00255      1  3         IF NOT done 
00256      1  3          THEN
00257      1  4           BEGIN
00258      1  4           dif := cabsdif(points.f[1],dat[locmax-1].pt);
00259      1  4           r := rmin (dif*2,r);
00260      1  3           END;
00261      1  3 
00262   C  1  3      { FIND OTHER POINTS }
00263      1  3      smid := points.f[1];
00264      1  4      REPEAT
00265      1  4         foundall := true;
00266      1  4         FOR br := 1 TO brmax DO WITH branch[br],brtemp[br] DO
00267      1  5            BEGIN
00268      1  5            sx := dat[locmax-1].pt;
00269      1  5            FOR i := 1 TO points.deg DO 
00270      1  6               BEGIN
00271      1  6               dif := cabsdif (points.f[i],sx);
00272      1  6               IF NOT done AND (dif < r)
00273      1  6                THEN
00274      1  7                 BEGIN
00275      1  7                 r := rmax (r,dif*2);

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00276      1  7                 points.deg := points.deg+1;
00277      1  7                 points.f[points.deg] := sx;
00278      1  7                 writeline (aud,'Branch #' + strofi(points.deg,2) + ' Ends at (' 
00279      1  7                    + strofc(points.f[points.deg],13) + ')');
00280      1  7                 done := true;
00281      1  7                 dat[locmax].pt.re := UNDEFINED_REAL;
00282      1  7                 smid := cadd (smid,sx);
00283      1  7                 foundall := false;
00284      1  6                 END;    
00285      1  5               END;    
00286      1  4            END;
00287      1  3         UNTIL foundall;
00288      1  3      smid.re := smid.re / points.deg;
00289      1  3      smid.im := smid.im / points.deg;
00290      1  3      FOR br := 1 TO brmax DO WITH branch[br],brtemp[br] DO
00291      1  3         IF dat[locmax].pt.re = UNDEFINED_REAL
00292      1  3          THEN
00293      1  4           BEGIN
00294      1  4           dat[locmax].pt := smid;
00295      1  4           dat[locmax].lg := -fcnevallogabs (locfcn,smid);
00296      1  4           dat[locmax].dg := fcnevallogderiv (dat[locmax].th,locfcn,smid);
00297      1  3           END;
00298      1  3      IF r * fcnevallogderiv (th,locfcn,smid) > 1d-2
00299      1  3       THEN raise ('Unable to pick up locus after breakpoint')
00300      1  3       ELSE writeline (aud,'CENTER AT (' + strofc(smid,13) + ')');
00301      1  2      END;
00302      1  1    END;
00303      0  0 END;
00304   C  0  0 {-----------------------------------------------------------------------------}
00305      1  0 PROCEDURE calclocusEVA (VAR lc : loccurve_type);
00306   C  1  0 { Purpose -- Calculate the various branches of the Root Locus.  }
00307      1  0 VAR
00308      1  0     i,j           : integer;
00309      1  0     thsrch,d,th1  : real;
00310      1  0     spt           : complex;
00311      1  0     clean,room    : boolean;
00312      1  0     points        : cpoly;
00313      1  0     nu,de         : cpoly;
00314      1  1 BEGIN
00315      1  1 WITH lc,l DO
00316      1  2    BEGIN
00317      1  2    ltype := EVA;
00318      1  2    fcncalclimits (lim,locfcn,window*2);
00319      1  2    plane := locfcn.plane;
00320      1  2    brmax := 0;
00321      1  2    room := true;
00322      1  2 
00323      1  2    cpolysfromcspoly (nu,de,locfcn.ro);
00324      1  2    FOR i := 1 TO de.deg DO
00325      1  2       FOR j := 1 TO de.p[i] DO
00326      1  3          BEGIN
00327      1  3          brmax := brmax+1;
00328      1  3          thsrch := 180d0/de.p[i];
00329      1  3          WITH branch[brmax],brtemp[brmax] DO IF j = 1 
00330      1  3           THEN thstart := 0

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00331      1  3           ELSE thstart := dat[branch[brmax-1].locmin+1].th + 2*thsrch;
00332      1  3          brtemp[brmax].sstart := cneg(de.f[i]);
00333      1  3          IF room THEN rlocusbranch (lc,brmax,dr,0,thsrch,thbend);
00334      1  3          IF branch[brmax].locend = storage_full THEN room := false;
00335      1  3          IF (branch[brmax].locend = outside_reg)
00336      1  3            AND (numord (locfcn) = denord (locfcn))
00337      1  3           THEN
00338      1  4            BEGIN
00339      1  4            brmax := brmax+1;
00340      1  4            thsrch := 5;
00341      1  4            IF dat[branch[brmax-1].locmax].pt.re > 0
00342      1  4             THEN
00343      1  5              BEGIN
00344      1  5              brtemp[brmax].thstart := 0;
00345      1  5              brtemp[brmax].sstart  := cofr (lim.min.x);
00346      1  5              END
00347      1  4             ELSE
00348      1  5              BEGIN
00349      1  5              brtemp[brmax].thstart := 180;
00350      1  5              brtemp[brmax].sstart  := cofr (lim.max.x);
00351      1  4              END;
00352      1  4            IF room THEN rlocusbranch (lc,brmax,dr,0,thsrch,thbend);
00353      1  4            IF branch[brmax].locend = storage_full THEN room := false;
00354      1  3            END;
00355      1  2          END;
00356      1  3    REPEAT
00357      1  3       findbreak (lc,clean,spt,points);
00358      1  3       FOR i := 1 TO points.deg DO
00359      1  4          BEGIN
00360      1  4          th1 := angle(csub(points.f[1],spt)) * 180d0/PI + 180d0/points.deg;
00361      1  4          brmax := brmax+1;
00362      1  4          brtemp[brmax].thstart := th1 + (i-1) * 360d0 / points.deg;
00363      1  4          brtemp[brmax].sstart  := spt;
00364      1  4          IF room  
00365      1  4           THEN rlocusbranch (lc,brmax,dr,cabsdif(points.f[i],spt),
00366      1  4                          90d0/points.deg,thbend);
00367      1  4          IF branch[brmax].locend = storage_full THEN room := false;
00368      1  3          END;
00369      1  2       UNTIL clean;
00370      1  2    fcncalclimits (lim,locfcn,window);
00371      1  1    END;
00372      0  0 END;
00373   C  0  0 {-----------------------------------------------------------------------------}
00374      1  0 PROCEDURE calclocusRCO (VAR lc : loccurve_type);
00375   C  1  0 { Purpose -- Calculate the various branches of the Root Contour.  }
00376      1  0 VAR
00377      1  0    c,oldc     : cpoly;
00378      1  0    ch         : char;
00379      1  0    ind,dind   : real;
00380      1  0    farthest   : real;
00381      1  0    i,j,br     : integer;
00382      1  0    bdif,step  : integer;
00383   C  1  0 {------------------------------}
00384      2  0 PROCEDURE rootRCO (VAR out : cpoly;  VAR plane : char;  r : real);
00385      2  0 VAR

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00386      2  0    fn       : fcn;
00387      2  0    nu,de    : cpoly;
00388      2  1 BEGIN
00389      2  1 WITH lc,l DO 
00390      2  2    BEGIN
00391      2  2    special.name := independent;
00392      2  2    special.val  := r;
00393      2  2    fn := evalfcn ('1+(' + expression + ')');
00394      2  1    END;
00395      2  1 out.deg := 0;
00396      2  1 cpolysfromcspoly (nu,de,fn.ro);
00397      2  1 plane := fn.plane;
00398      2  1 FOR i := 1 TO nu.deg DO
00399      2  1    FOR j := 1 TO nu.p[i] DO
00400      2  2       BEGIN
00401      2  2       out.deg := out.deg + 1;
00402      2  2       out.f[out.deg] := cneg (nu.f[i]);
00403      2  2       out.p[out.deg] := 1;
00404      2  1       END;
00405      1  0 END;
00406   C  1  0 {------------------------------}
00407      2  0 PROCEDURE matchpoly (VAR c1,c2 : cpoly;  VAR farthest : real);
00408      2  0 VAR
00409      2  0    i1,i2,j1,j2,k,br : integer;
00410      2  0    dif              : real;
00411      2  0    c3               : cpoly;
00412      2  1 BEGIN
00413      2  1 farthest := 0;
00414      2  1 FOR k := 1 TO c1.deg DO
00415      2  2    BEGIN
00416      2  2    dif := BIG;
00417      2  2    FOR i1 := 1 TO c1.deg DO
00418      2  2       IF c1.p[i1] > 0
00419      2  2        THEN
00420      2  2         FOR i2 := 1 TO c2.deg DO
00421      2  2           IF c2.p[i2] > 0
00422      2  2            THEN
00423      2  2             IF cabsdif (c1.f[i1],c2.f[i2]) < dif
00424      2  2              THEN
00425      2  3               BEGIN
00426      2  3               dif := cabsdif (c1.f[i1],c2.f[i2]);
00427      2  3               j1 := i1;
00428      2  3               j2 := i2;
00429      2  2               END;
00430      2  2    c3.f[j1] := c2.f[j2];
00431      2  2    farthest := rmax (farthest,dif);
00432      2  2    c3.p[j1] := 1;
00433      2  2    c1.p[j1] := 0;
00434      2  2    c2.p[j2] := 0;
00435      2  1    END;
00436      2  1 c3.deg := c2.deg;
00437      2  1 c2 := c3;
00438      2  1 FOR i1 := 1 TO c1.deg DO c1.p[i1] := 1;
00439      1  0 END;
00440   C  1  0 {------------------------------}

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00441      1  1 BEGIN
00442      1  1 WITH lc,l DO 
00443      1  2    BEGIN
00444      1  2    ltype := RCO;
00445      1  2    lim := plotlimits ((0,0),(0,0));
00446      1  2    step := 0;
00447      1  2 
00448      1  2    ind := indmin;
00449      1  2    dind := (indmax-indmin) / 100;
00450      1  2    rootRCO (c,plane,ind);
00451      1  2    IF c.deg = 0 THEN raise ('Root Contour degree is zero');
00452      1  2    brmax := c.deg;
00453      1  2    writeline (both,'Number of branches is ' + strofi (c.deg,6));
00454      1  2    bdif := LOCARRSIZE DIV brmax;
00455      1  2    FOR br := 1 TO brmax DO
00456      1  2       WITH branch[br],brtemp[br] DO
00457      1  3          BEGIN
00458      1  3          locmin := bdif * (br-1) + 1;
00459      1  3          locmax := locmin;
00460      1  3          locend := zero_found;
00461      1  3          done := true;
00462      1  3          sstart := cofi(0);
00463      1  3          thstart := UNDEFINED_REAL;
00464      1  3          dat[locmin].pt := c.f[br];
00465      1  3          dat[locmin].ind := ind;
00466      1  2          END;
00467      1  2    WHILE ind < indmax DO
00468      1  3       BEGIN
00469      1  3       step := step + 1;
00470      1  3       IF step MOD 50 = 1
00471      1  3        THEN writeline (both,'Step=' + strofi (step,6) 
00472      1  3                                             + '  Ind.=' + strofr (ind,13));
00473      1  3       oldc := c;
00474      1  3 
00475      1  4       REPEAT
00476      1  4          rootRCO (c,ch,rmin (ind+dind,indmax));
00477      1  4          IF c.deg <> brmax THEN raise ('Root Contour change in degree');
00478      1  4          IF ch <> plane THEN raise ('Root Contour change in plane');
00479      1  4          matchpoly (oldc,c,farthest);
00480      1  4          IF farthest < ds/2 THEN dind := dind * 2;
00481      1  4          IF farthest > ds THEN dind := dind / 2;
00482      1  3          UNTIL farthest <= ds;
00483      1  3 
00484      1  3       ind := rmin (ind+dind,indmax);
00485      1  3       FOR br := 1 TO brmax DO
00486      1  3          WITH branch[br] DO
00487      1  4             BEGIN
00488      1  4             locmax := locmax + 1;
00489      1  4             IF (locmax > bdif) AND (br = 1)
00490      1  4              THEN raise ('Locus array space exhausted');
00491      1  4             dat[locmax].pt := c.f[br];
00492      1  4             dat[locmax].ind := ind;
00493      1  4             broadenxy (lim, dat[locmax].pt.re, dat[locmax].pt.im);
00494      1  3             END;
00495      1  2       END;

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00496      1  1    END;
00497      0  0 END;
00498   C  0  0 {=============================================================================}
00499   C  0  0 {-- LOCUS COMMAND ------------------------------------------------------------}
00500   C  0  0 {=============================================================================}
00501      1  0 PROCEDURE locus;
00502      1  0 VAR
00503      1  0    ix                  : integer;
00504      1  0    dr,thbend,window,ds : real;
00505      1  0    modi,sel            : command_type;
00506      1  0    name                : logicalname;
00507      1  0    string,filename,st  : anystring;
00508      1  0    lable               : anystring;
00509      1  0    lc                  : loccurve_type;
00510      1  1 BEGIN
00511      1  1 startcommand ('ROOT LOCUS',true);
00512      1  1 setcommand ('Contour');
00513      1  1 setcommand ('Expression');
00514      1  1 setcommand ('Function');
00515      1  1 setcommand ('Roots_Only');
00516      1  1 readcommand (modi,'F',false,'ANALYZE ROOT_LOCUS');
00517      1  1 
00518      1  1 IF modi <> ESC
00519      1  1  THEN WITH lc,l DO 
00520      1  2   BEGIN
00521      1  3   CASE chofcom(modi) OF
00522      1  4      'C':  BEGIN
00523      1  4            readvary ('ENTER EXPRESSION            : ',expression,'');
00524      1  4            lable := expression;
00525      1  4            readlogicalname ('ENTER IND. VARIABLE         : ',independent,'T');
00526      1  4            readreal ('ENTER IND. VARIABLE MINIMUM : ',indmin,-BIG,BIG,1);
00527      1  4            readreal ('ENTER IND. VARIABLE MAXIMUM : ',indmax,indmin,BIG,1);
00528      1  4            readreal ('ENTER MIN. POINT DISTANCE   : ',ds,0,BIG,0.1);
00529      1  4            writeline (aud,'EXPRESSION    : ' + expression);
00530      1  4            writeline (aud,'INDEPENDENT   : ' + independent);
00531      1  4            writeline (aud,'IND. MINIMUM  : ' + strofr(indmin,13));
00532      1  4            writeline (aud,'IND. MAXIMUM  : ' + strofr(indmax,13));
00533      1  4            writeline (aud,'MIN. DISTANCE : ' + strofr(ds,13));
00534      1  4            writeline (both,'');
00535      1  4            writeline (both,'');
00536      1  4            writeline (both,'Calculating ROOT CONTOUR');
00537      1  4            writeline (both,'');
00538      1  4            writeline (both,'Steps completed :');
00539      1  4            writeline (both,'');
00540      1  4            calclocusRCO (lc);
00541      1  3            END;
00542      1  3      'E',
00543      1  4      'F':  BEGIN
00544      1  5            CASE chofcom(modi) OF
00545      1  6               'E':  BEGIN
00546      1  6                     readvary   ('ENTER EXPRESSION        : ',string,'');
00547      1  6                     locfcn := evalfcn (string);
00548      1  6                     locfcn.name := 
00549      1  6                           substr(string,1,imin(LOGICALNAMESIZE,length(string)));
00550      1  5                     END;

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                   7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

-LINE-IDC-PL-SL-

00551      1  6               'F':  BEGIN
00552      1  6                     selectfunction (sel,false,false);
00553      1  6                     fcnsearch (locfcn,sel);
00554      1  6                     locfcn := fcnFCTofany (locfcn);
00555      1  5                     END;
00556      1  4               END;
00557      1  4            lable := locfcn.name;
00558      1  4            readreal   ('ENTER PHASE ANGLE       : ',phaseangle,-180,360,180);
00559      1  4            readreal   ('ENTER RADIUS CONTROL DR : ',dr,1d-6,1d0,0.25d0);
00560      1  4            readreal   ('ENTER MAX BEND ALLOWED  : ',thbend,1d-6,40d0,5d0);
00561      1  4            readreal   ('ENTER WINDOW SIZE       : ',window,1.2d0,100d0,2d0);
00562      1  4            writeline (aud,'EXPRESSION    : ' + locfcn.name);
00563      1  4            writeline (aud,'PHASE ANGLE   : ' + strofr(phaseangle,13));
00564      1  4            writeline (aud,'RADIUS CONTROL: ' + strofr(dr,13));
00565      1  4            writeline (aud,'MAXIMUM BEND  : ' + strofr(thbend,13));  
00566      1  4            writeline (aud,'WINDOW SIZE   : ' + strofr(window,13));  
00567      1  4            writeline (both,'');
00568      1  4            writeline (both,'');
00569      1  4            writeline (both,'Calculating ROOT LOCUS');
00570      1  4            writeline (both,'');
00571      1  4            writeline (both,'Full branches =' + strofi (denord (locfcn),3));
00572      1  4            writeline (both,'Branches completed :');
00573      1  4            writeline (both,'');
00574      1  4            calclocusEVA (lc);
00575      1  3            END;
00576      1  4      'R':  BEGIN
00577      1  4            readvary   ('ENTER EXPRESSION        : ',string,'');
00578      1  4            locfcn := evalfcn (string);
00579      1  4            plane := locfcn.plane;
00580      1  4            locfcn.name := substr(string,1,imin(LOGICALNAMESIZE,length(string)));
00581      1  4            lable := locfcn.name;
00582      1  4            writeline (aud,'EXPRESSION    : ' + locfcn.name);
00583      1  4            fcncalclimits (lim,locfcn,1.5);
00584      1  4            brmax := 0;
00585      1  3            END;
00586      1  3      ESC:  ;
00587      1  2      END;
00588      1  2 
00589      1  2   readvary   ('ENTER CURVE NAME        : ',name,'RL');
00590      1  2   ix := createcurve (C_LOC,name,lable);
00591      1  2   curve.data[ix].lcptr^ := lc;
00592      1  2   readvary   ('ENTER ADDITIONAL CURVES : ',st,'');
00593      1  2   unread ('PLOT NEW ' + name + ' ' + st);
00594      1  2   END
00595      1  1  ELSE readargument (string);
00596      1  1 clearscreen;
00597      0  0 END;
00598   C  0  0 {=============================================================================}
00599      0  0 END.

LOCUS                                                           23-Dec-1988 11:12:11    VAX Pascal V3.7-254                Page   12
INCA                            Pascal Compilation Statistics    7-Jan-1988 13:39:13    DUA1:[QPLOT.INCA.SOURCE]LOCUS.PAS;789 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               12866  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               7500  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260         4         2
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        50        40
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20         0         0
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        26        36
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         9        15
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        28        45
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39        10        26
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        64        31
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        25        12
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292        10         3
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       303        80
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        19        10
DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PEN;1                    144       100        69
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        13         5
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         0         0
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        24        15
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289        73        25



FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:MATH',
00004      0  0                'QLIBHOME:COMPLEX',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:HANDLER',
00007      0  0                'QLIBHOME:FIG',
00008      0  0                'QLIBHOME:PLOT',
00009      0  0                'QLIBHOME:IO',
00010      0  0                'CURVE','BLOCK','POLYMATH','FCN','FCNEVAL',
00011      0  0                'FCNIO','PLOT','UTIL'),
00012      0  0   ENVIRONMENT ('FREQR')]
00013      0  0 MODULE freqr;
00014      0  0 VAR
00015      0  0    worsfcn   : fcn;
00016      0  0    worzfcn   : fcn;
00017   C  0  0 {=============================================================================}
00018   C  0  0 {-- ROUTINES TO CALCULATE FREQUENCY RESPONSE ---------------------------------}
00019   C  0  0 {=============================================================================}
00020      1  0 PROCEDURE calcfreqr (VAR fc : frecurve_type);
00021      1  0 TYPE
00022      1  0    bodstatustype = (a_ok,root_found,leave_root,
00023      1  0                     nyq_change,phase_change,db_change,
00024      1  0                     s_near,z_near);
00025      1  0 VAR
00026      1  0    bodstatus     : bodstatustype;
00027      1  0    i,k           : integer;
00028      1  0    w,dw          : real;
00029      1  0    ptx           : complex;
00030      1  0    ptz,ptzold    : complex;
00031      1  0    pts,ptsold    : ARRAY [-50..50] OF complex;
00032   C  1  0 {------------------------------}
00033      2  0 PROCEDURE addwstep (w : real);
00034      2  0 VAR
00035      2  0    k            : integer;
00036      2  0    maxdb        : real;
00037      2  0    z,csum,ctemp : complex;
00038      2  0    cnum,cden    : complex;
00039      2  0    pts,ptz,ptx  : complex;
00040      2  0    fr           : ARRAY [-50..50] OF fredat_type;
00041      2  1 BEGIN
00042      2  2 WITH fc,f DO BEGIN
00043      2  2 FOR k := -level TO level DO 
00044      2  3    BEGIN
00045      2  3    pts.re := 0;  
00046      2  3    pts.im := w + k * 2d0 * PI / tau;
00047      2  3    IF fcnevalnearroot (ptx,worsfcn,pts) < closezero * cabs(pts) 
00048      2  3     THEN 
00049      2  3      IF ptx.re = 0 THEN pts := ptx;
00050      2  3    IF tau = UNDEFINED_REAL
00051      2  3     THEN ptz := complex (0,0)
00052      2  3     ELSE
00053      2  4      BEGIN
00054      2  4      ptz.re := cos (w * tau);
00055      2  4      ptz.im := sin (w * tau);

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00056      2  4      IF fcnevalnearroot(ptx,worzfcn,ptz) < closezero * cabs(ptz) 
00057      2  4       THEN 
00058      2  4        IF cabs (ptx) - 1 < nearness THEN ptz := ptx;
00059      2  3      END;
00060      2  3    fr[k].omega := pts.im;
00061      2  3    fr[k].db    := fcnevallogabs(worsfcn,pts) * 20
00062      2  3                 + fcnevallogabs(worzfcn,ptz) * 20;
00063      2  3    fr[k].phase := fcnevalph (worsfcn,pts,0) 
00064      2  3                 + fcnevalph (worzfcn,ptz,0)
00065      2  3                 - compdelay * pts.im * 180d0 / PI;
00066      2  2    END;
00067      2  2 IF star 
00068      2  2  THEN 
00069      2  3   BEGIN
00070      2  3   maxdb := 1/BIG;
00071      2  3   csum := cofi(0);
00072      2  3   FOR k := -level TO level DO maxdb := rmax (maxdb,fr[k].db);
00073      2  3   FOR k := -level TO level DO
00074      2  4      BEGIN
00075      2  4      ctemp.re := exp10 (fr[k].db/20d0 + log10 (BIG/100) - maxdb/20d0) 
00076      2  4                   * cos (fr[k].phase/180d0*PI);
00077      2  4      ctemp.im := exp10 (fr[k].db/20d0 + log10 (BIG/100) - maxdb/20d0) 
00078      2  4                   * sin (fr[k].phase/180D0*PI);
00079      2  4      csum := cadd (csum,ctemp);
00080      2  3      END;
00081      2  3   steps := steps + 1;
00082      2  3   dat[steps].db := log10(cabs(csum)) * 20d0 + maxdb - log10 (BIG/100) * 20d0
00083      2  3                  - log10(tau) * 20d0;
00084      2  3   dat[steps].phase := angle (csum) * 180d0 / PI;
00085      2  3   END
00086      2  2  ELSE 
00087      2  3   BEGIN
00088      2  3   steps := steps + 1;
00089      2  3   dat[steps] := fr[0];
00090      2  2   END;
00091      2  2 WHILE dat[steps].phase >= 180d0 DO dat[steps].phase := dat[steps].phase -360d0;
00092      2  2 WHILE dat[steps].phase < -180d0 DO dat[steps].phase := dat[steps].phase +360d0;
00093      2  2 dat[steps].omega := w;
00094      2  1 END;
00095      1  0 END;
00096   C  1  0 {------------------------------}
00097      2  0 PROCEDURE calcpoints;
00098      2  0 VAR
00099      2  0    k : integer;
00100      2  1 BEGIN
00101      2  1 WITH fc,f DO
00102      2  2    BEGIN
00103      2  2    FOR k := -level TO level DO
00104      2  3       BEGIN
00105      2  3       pts[k].re := 0;
00106      2  3       pts[k].im := w + level * 2d0 * PI / tau;
00107      2  2       END;
00108      2  2    IF tau = UNDEFINED_REAL
00109      2  2     THEN ptz := complex (0,0)
00110      2  2     ELSE

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00111      2  3      BEGIN 
00112      2  3      ptz.re := cos (w * tau);
00113      2  3      ptz.im := sin (w * tau);
00114      2  2      END;
00115      2  1    END;
00116      1  0 END;
00117   C  1  0 {------------------------------}
00118      2  0 FUNCTION anglelessthan : boolean;
00119      2  0 VAR 
00120      2  0    pt1,pt2 : complex;
00121      2  1 BEGIN
00122      2  1 WITH fc,f DO 
00123      2  2    BEGIN
00124      2  2    IF steps < 3 
00125      2  2     THEN anglelessthan := true
00126      2  2    ELSE IF abs (dat[steps].db) > 10 * LOGINFINITY
00127      2  2     THEN anglelessthan := true
00128      2  2    ELSE IF abs (dat[steps-1].db) > 10 * LOGINFINITY
00129      2  2     THEN anglelessthan := true
00130      2  2    ELSE IF abs (dat[steps-2].db) > 10 * LOGINFINITY
00131      2  2     THEN anglelessthan := true
00132      2  2     ELSE
00133      2  3      BEGIN
00134      2  3      pt1.re := (dat[steps].db - dat[steps-1].db) * 3;
00135      2  3      pt2.re := (dat[steps-1].db - dat[steps-2].db) * 3;
00136      2  3      pt1.im := dat[steps].phase - dat[steps-1].phase;
00137      2  3      pt2.im := dat[steps-1].phase - dat[steps-2].phase;
00138      2  3      IF pt2.im - pt1.im > 180 THEN pt1.im := pt1.im + 360d0;
00139      2  3      IF pt2.im - pt1.im < -180 THEN pt1.im := pt1.im - 360d0;
00140      2  3      anglelessthan := cos (angle(pt1) - angle(pt2)) > cos (nyqdif * PI / 180d0);
00141      2  2      END;
00142      2  1    END;
00143      1  0 END;
00144   C  1  0 {------------------------------}
00145      1  1 BEGIN
00146      1  1 WITH fc,f DO 
00147      1  2    BEGIN
00148   C  1  2    { CALCULATE THE FREQUENCIES }
00149      1  2    IF zoh 
00150      1  2     THEN worsfcn := fcndiv (bodsfcn,sfcn)
00151      1  2     ELSE worsfcn := bodsfcn;
00152      1  2    IF zoh 
00153      1  2     THEN worzfcn := fcnmul (bodzfcn,evalfcn ('(Z-1)/Z'))
00154      1  2     ELSE worzfcn := bodzfcn; 
00155      1  2    w := wmin;
00156      1  2    steps := 0;
00157      1  2    addwstep (w);
00158      1  2    IF abs (dat[1].db) > 10 * LOGINFINITY THEN dw := closezero ELSE dw := 1;
00159      1  3    REPEAT
00160      1  4       REPEAT
00161      1  4          calcpoints;
00162      1  4          ptsold := pts;
00163      1  4          ptzold := ptz;
00164      1  4          bodstatus := a_ok;
00165      1  4          IF abs(dat[steps].db) < 10 * LOGINFINITY

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00166      1  4           THEN w := dat[steps].omega + dw
00167      1  4           ELSE
00168      1  5            REPEAT
00169      1  5               dw := dw * 1.75;
00170      1  5               w := dat[steps].omega + dw;
00171      1  5               bodstatus := leave_root;  
00172      1  5               addwstep (w);
00173      1  5               steps := steps - 1;
00174      1  4               UNTIL abs (dat[steps+1].db) < 10 * LOGINFINITY;
00175      1  4          addwstep (w);
00176      1  4          calcpoints;
00177      1  4          FOR k := -level TO level DO
00178      1  4             IF (bodstatus = a_ok) AND (cabsdif(pts[k],ptsold[k]) 
00179      1  4                                    > fcnevalnearroot(ptx,worsfcn,pts[k])/1.5)
00180      1  4              THEN bodstatus := s_near;
00181      1  4          IF (bodstatus = a_ok) AND 
00182      1  4              (cabsdif(ptz,ptzold) > fcnevalnearroot(ptx,worzfcn,ptz) / 1.5)
00183      1  4           THEN bodstatus := z_near;
00184      1  4    
00185      1  4          IF bodstatus = leave_root
00186      1  4           THEN
00187      1  4          ELSE IF bodstatus = s_near
00188      1  4           THEN
00189      1  4          ELSE IF bodstatus = z_near
00190      1  4           THEN
00191      1  4          ELSE IF ( abs (dat[steps].db) > 10 * LOGINFINITY) 
00192      1  4           THEN bodstatus := root_found
00193      1  4          ELSE IF abs (dat[steps].db - dat[steps-1].db) > dbdif
00194      1  4           THEN bodstatus := db_change
00195      1  4          ELSE IF cos ((dat[steps].phase - dat[steps-1].phase) * PI / 180d0)
00196      1  4                < cos (phdif * PI / 180d0)
00197      1  4           THEN bodstatus := phase_change
00198      1  4          ELSE IF (NOT anglelessthan) AND (steps > 2) AND
00199      1  4                ((abs (dat[steps].db - dat[steps-1].db) > dbdif/1000) OR
00200      1  4                (cos ((dat[steps].phase - dat[steps-1].phase) * PI / 180d0)
00201      1  4                < cos (phdif/1000 * PI / 180d0)))
00202      1  4           THEN bodstatus := nyq_change;
00203      1  4 
00204      1  4          IF bodstatus IN [a_ok,root_found,leave_root]
00205      1  4           THEN dw := dw * 1.75
00206      1  4          ELSE IF bodstatus = nyq_change
00207      1  5           THEN BEGIN  dw := dw / 4.00;  steps := steps - 2;  END
00208      1  4           ELSE BEGIN  dw := dw / 1.75;  steps := steps - 1;  END;
00209      1  4          w := dat[steps].omega;
00210      1  3          UNTIL bodstatus IN [a_ok,root_found,leave_root];
00211      1  3 
00212      1  3       IF steps MOD 50 <> 0
00213      1  3        THEN
00214      1  3       ELSE IF defaultfreqformat.hz 
00215      1  3        THEN writeline (both,'Step=' + strofi(steps,4) 
00216      1  3                      + '     W=' + strofr(w/2/PI,13) + ' Hz')
00217      1  3        ELSE writeline (both,'Step=' + strofi(steps,4) 
00218      1  3                      + '     W=' + strofr(w,13) + ' rps');
00219      1  2       UNTIL w > wmax - wmax * closezero;
00220      1  2    steps := steps - 1;

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00221      1  2    addwstep (wmax);
00222      1  2 
00223   C  1  2    { FILL IN UNDEFINED PHASES AT POLES AND ZEROES  }
00224      1  2    FOR i := 1 TO steps DO 
00225      1  2       IF abs (dat[i].db) > 10 * LOGINFINITY THEN dat[i].phase := 0;
00226      1  1    END;
00227      0  0 END;
00228   C  0  0 {=============================================================================}
00229   C  0  0 {-- FREQR COMMAND ------------------------------------------------------------}
00230   C  0  0 {=============================================================================}
00231      1  0 PROCEDURE freqr;
00232      1  0 VAR
00233      1  0    modi,sel   : command_type;
00234      1  0    name       : logicalname;
00235      1  0    i,ix       : integer;
00236      1  0    fn         : fcn;
00237      1  0    arg,st     : anystring;
00238      1  0    lable      : anystring;
00239      1  0    fc         : frecurve_type;
00240      1  1 BEGIN
00241      1  1 startcommand ('FREQUENCY RESPONSE',true);
00242      1  1 setcommand ('Expression');
00243      1  1 setcommand ('Function');
00244      1  1 setcommand ('Star');
00245      1  1 readcommand (modi,'F',false,'ANALYZE FREQUENCY_RESPONSE');
00246      1  1 
00247      1  1 IF modi <> ESC
00248      1  1  THEN
00249      1  2   BEGIN
00250      1  2   WITH fc,f DO 
00251      1  3      BEGIN
00252      1  3      bodsfcn := onefcn;
00253      1  3      bodzfcn := onefcn;
00254      1  3      tau     := UNDEFINED_REAL;
00255      1  3      zoh     := false;
00256      1  3      compdelay := 0;
00257      1  4      CASE chofcom(modi) OF
00258      1  5         'E':  BEGIN
00259      1  5               readvary ('ENTER FUNCTION OR EXPRSN: ',arg,'');
00260      1  5               fn := evalfcn (arg);
00261      1  6               CASE fn.plane OF
00262      1  6                  'K':  bodsfcn := fn;
00263      1  6                  'S':  bodsfcn := fn;
00264      1  6                  'Z':  bodzfcn := fn;
00265      1  6                  'W':  bodzfcn := fcnzoffcnw (fn);
00266      1  5                  END;
00267      1  5               level := 0;
00268      1  5               star := false;
00269      1  5               tau := bodzfcn.tau;
00270      1  5               lable := strtrunc('FCN= ' + arg,80);
00271      1  4               END;
00272      1  5         'F':  BEGIN
00273      1  5               selectfunction (sel,false,false);
00274      1  5               fcnsearch (fn,sel);
00275      1  5               IF fn.name = '' THEN raise ('Aborting frequency response');

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00276      1  5               fn := fcnFCTofany (fn);
00277      1  6               CASE fn.plane OF
00278      1  6                  'K':  bodsfcn := fn;
00279      1  6                  'S':  bodsfcn := fn;
00280      1  6                  'Z':  bodzfcn := fn;
00281      1  6                  'W':  bodzfcn := fcnzoffcnw (fn);
00282      1  5                  END;
00283      1  5               level := 0;
00284      1  5               star := false;
00285      1  5               tau := bodzfcn.tau;
00286      1  5               lable := strtrunc('FCN= ' + sel,80);
00287      1  4               END;
00288      1  5         'S':  BEGIN
00289      1  5               clearscreen;
00290      1  5               config.overlaykill := false;
00291      1  5               setcolor ('WHITE');
00292      1  5               position (33000,40000);  
00293      1  5               centergrprint ('FREQUENCY RESPONSE STAR OPERATOR');
00294      1  5               position (33000,38000);  
00295      1  5               centergrprint ('OPEN LOOP TRANSFER FUNCTION = OUT/IN');
00296      1  5               position (10000,30500);   centergrprint ('IN');
00297      1  5               position (17000,26000);   centergrprint ('OUT');
00298      1  5 
00299      1  5               drb_line    ('R',0,30000,10000);
00300      1  5               drb_summer  (15000,30000);
00301      1  5               drb_line    ('R',17000,30000,7000);
00302      1  5               drb_block   ('R',24000,30000,7000,'PLANT (S plane)','');
00303      1  5               drb_line    ('R',40000,30000,15000);
00304      1  5               drb_end     (55000,30000,10000);
00305      1  5               drb_line    ('D',55000,30000,20000);
00306      1  5               drb_line    ('L',55000,10000,5000);
00307      1  5               drb_sampler ('L',50000,10000,'');
00308      1  5               drb_block   ('L',45000,10000,4000,'ZOH (opt)','');
00309      1  5               drb_block   ('L',35000,10000,7000,'FEEDBACK (Z/W plane)','');
00310      1  5               drb_line    ('L',19000,10000,4000);
00311      1  5               drb_line    ('U',15000,10000,5000);
00312      1  5               drb_block   ('U',15000,15000,5000,'DELAY (opt)','');
00313      1  5               drb_line    ('U',15000,21000,6000);
00314      1  5 
00315      1  5               revfcn ('ENTER PLANT FUNCTION    : ',bodsfcn,arg,'KS','1');
00316      1  5               drb_block ('R',24000,30000,7000,'',arg);
00317      1  5               lable := strtrunc('P= ' + arg,80);
00318      1  5               revfcn ('ENTER FEEDBACK FUNCTION : ',bodzfcn,arg,'KZW','1');
00319      1  5               drb_block ('L',35000,10000,7000,'',arg);
00320      1  5               lable := strtrunc(lable + ', F= ' + arg,80);
00321      1  5               tau := bodzfcn.tau;
00322      1  5 
00323      1  5               IF tau = UNDEFINED_REAL
00324      1  5                THEN 
00325      1  6                 BEGIN
00326      1  6                 revfcn('ENTER SAMPLING PERIOD  : ',fn,arg,'K','UNDEFINED');
00327      1  6                 tau := roffcn (fn);
00328      1  5                 END;
00329      1  5               drb_sampler ('L',50000,10000,'T=' + strofr (tau,9));
00330      1  5 

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00331      1  5               zoh := readyes ('ZERO ORDER HOLD (Y/N)     ? ');
00332      1  5               IF zoh 
00333      1  5                THEN arg := '(1-1/Z) / S' 
00334      1  5                ELSE arg := '1'; 
00335      1  5               drb_block ('L',45000,10000,4000,'',arg);
00336      1  5               IF zoh THEN lable := strtrunc(lable + ', ZOH',80);
00337      1  5 
00338      1  5               revfcn ('ENTER DELAY TIME (sec)  : ',fn,arg,'K','0');
00339      1  5               compdelay := roffcn(fn);
00340      1  5               IF compdelay = 0
00341      1  5                THEN arg := 'no delay'
00342      1  5                ELSE lable := strtrunc(lable + ', delay= ' + arg,80);
00343      1  5               drb_block ('U',15000,15000,5000,'',arg);
00344      1  5               readint ('ENTER SUMMATION LEVEL   : ',level,0,50,7);
00345      1  5               star := true;
00346      1  4               END;
00347      1  3         END;
00348      1  3      IF NOT (bodsfcn.plane IN ['S','K']) 
00349      1  3       THEN raise ('Illegal S-plane function');
00350      1  3      IF NOT (bodzfcn.plane IN ['Z','K']) 
00351      1  3       THEN raise ('Illegal Z-plane function');
00352      1  3      IF (tau = UNDEFINED_REAL) AND ((level <> 0) OR (bodzfcn.plane='Z'))
00353      1  3       THEN readreal ('ENTER SAMPLING PERIOD   : ',tau,1d-10,1d10,tau);
00354      1  3 
00355      1  3      IF tau <> UNDEFINED_REAL 
00356      1  4       THEN BEGIN  wmin := 0;  wmax := PI / tau;  END
00357      1  3       ELSE
00358      1  4        BEGIN
00359      1  4        wmin := BIG;
00360      1  4        wmax := 0;
00361      1  4        FOR i := 1 TO bodsfcn.ro.deg DO
00362      1  4           WITH bodsfcn.ro.f[i] DO
00363      1  4              IF cabs (v) > 0
00364      1  4               THEN
00365      1  5                BEGIN
00366      1  5                wmin := rmin (wmin,0.01 * cabs(v));
00367      1  5                wmax := rmax (wmax,100  * cabs(v));
00368      1  4                END;
00369      1  4        IF wmin = BIG THEN BEGIN  wmin := 0.01;  wmax := 100;  END;
00370      1  3        END;
00371      1  3      defaultfreqformat.flog := tau = UNDEFINED_REAL;
00372      1  3 
00373      1  3      IF defaultfreqformat.hz
00374      1  3       THEN
00375      1  4        BEGIN
00376      1  4        wmin := wmin / 2d0 / PI;
00377      1  4        wmax := wmax / 2d0 / PI;
00378      1  4        readreal ('ENTER MINIMUM FREQ (Hz) : ',wmin,0,BIG,wmin);
00379      1  4        readreal ('ENTER MAXIMUM FREQ (Hz) : ',wmax,wmin,BIG,wmax);
00380      1  4        wmin := wmin * 2d0 * PI;
00381      1  4        wmax := wmax * 2d0 * PI;
00382      1  4        END
00383      1  3       ELSE
00384      1  4        BEGIN
00385      1  4        readreal ('ENTER MINIMUM FREQ (rps): ',wmin,0,BIG,wmin);

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

-LINE-IDC-PL-SL-

00386      1  4        readreal ('ENTER MAXIMUM FREQ (rps): ',wmax,wmin,BIG,wmax);
00387      1  3        END;
00388      1  3      readreal ('ENTER MAX DB CHANGE     : ',dbdif,0.01,400d0,5d0);
00389      1  3      readreal ('ENTER MAX PHASE CHANGE  : ',phdif,0.01,400d0,5d0);
00390      1  3      readreal ('ENTER MAX NYQ ANG CHANGE: ',nyqdif,0.01,400d0,5d0);
00391      1  3 
00392      1  3      IF chofcom(modi) = 'S' 
00393      1  3       THEN 
00394      1  4        BEGIN
00395      1  4        writeline (out,'Press "X" to continue...');
00396      1  4        graphicpause;
00397      1  4        config.overlaykill := true;
00398      1  3        END;
00399      1  3      writeline (aud,'S FUNCTION NAME     = ' + bodsfcn.name);
00400      1  3      writeline (aud,'Z FUNCTION NAME     = ' + bodzfcn.name);
00401      1  3      writeline (aud,'SAMPLING PERIOD     = ' + strofr(tau,13));
00402      1  3      writeline (aud,'EVALUATION LEVEL    = ' + strofi(level,3));
00403      1  3      IF zoh THEN writeline (aud,'ZERO ORDER HOLD INCLUDED');
00404      1  3      writeline (aud,'COMPUTAIONAL DELAY  = ' + strofr(compdelay,13));
00405      1  3      writeline (aud,'MINIMUM FREQUENCY   = ' + strofr(wmin,13) + ' rps    '
00406      1  3                                              + strofr(wmin/2d0/PI,13) + ' Hz');
00407      1  3      writeline (aud,'MAXIMUM FREQUENCY   = ' + strofr(wmax,13) + ' rps    '
00408      1  3                                              + strofr(wmax/2d0/PI,13) + ' Hz');
00409      1  3      writeline (aud,'MAX DB CHANGE       = ' + strofr(dbdif,13));
00410      1  3      writeline (aud,'MAX PHASE CHANGE    = ' + strofr(phdif,13));
00411      1  3      writeline (aud,'MAX ANGLE CHANGE    = ' + strofr(nyqdif,13));
00412      1  3      writeline (aud,'');
00413      1  3 
00414      1  3      writeline (both,'Calculating Frequency Response');
00415      1  3      writeline (both,'Steps completed');
00416      1  3      writeline (both,'Maximum       W=' + strofr(wmax,13) + ' rps');
00417      1  2      END;
00418      1  2 
00419      1  2   calcfreqr (fc);
00420      1  2   readvary ('ENTER CURVE NAME        : ',name,'FR');
00421      1  2   ix := createcurve (C_FRE,name,lable);
00422      1  2   curve.data[ix].fcptr^ := fc;
00423      1  2   readvary ('ENTER ADDITIONAL CURVES : ',st,'');
00424      1  2   pwsqueeze(st);
00425      1  2   unread ('PLOT NEW ' + name + ' ' + st);
00426      1  2   END
00427      1  1  ELSE readargument (arg);
00428      1  1 clearscreen;
00429      0  0 END;
00430   C  0  0 {=============================================================================}
00431      0  0 END.

FREQR                                                           23-Dec-1988 11:14:55    VAX Pascal V3.7-254                Page    9
INCA                            Pascal Compilation Statistics   14-Nov-1988 13:12:52    DUA1:[QPLOT.INCA.SOURCE]FREQR.PAS;8 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               12783  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               5136  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        48        39
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59        14        24
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        21        34
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        23        32
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39        10        26
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        42        20
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292         9         3
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        81        40
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       299        79
DUA1:[QPLOT.INCA.SOURCE]BLOCK.PEN;1                       72        28        39
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         2         1
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        93        38
DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PEN;1                    144        17        12
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184         8         4
DUA1:[QPLOT.INCA.SOURCE]PLOT.PEN;1                       446        22         5
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289        89        31



DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00001      0  0 [  IDENT       ('INCA'),
00002      0  0    INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:MATH',
00004      0  0                'QLIBHOME:COMPLEX',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:HANDLER',
00007      0  0                'QLIBHOME:FIG',
00008      0  0                'QLIBHOME:IO',
00009      0  0                'CURVE','POLYMATH','FCN','FCNEVAL',
00010      0  0                'PLOT','FCNIO','UTIL'), 
00011      0  0   ENVIRONMENT ('DESCF')]
00012      0  0 MODULE descf;
00013   C  0  0 {-----------------------------------------------------------------}
00014      1  0 PROCEDURE descf;
00015      1  0 CONST
00016      1  0    width = 1;
00017      1  0    start = 1;
00018      1  0    slope = 2;
00019   C  1  0 {* Quantizer *}
00020      1  0    levels = 2;
00021      1  0    limit = 3;
00022   C  1  0 {* Schmitt Trigger and PWPF *}
00023      1  0    umax = 1;
00024      1  0    uon = 2;
00025      1  0    uoff = 3;
00026   C  1  0 {* PWPF Modulator *}
00027      1  0    km = 4; tm = 5;
00028      1  0 
00029      1  0 VAR
00030      1  0    modi,sel     	           : command_type;
00031      1  0    name                            : logicalname;
00032      1  0    i,ix,n,j                        : integer;
00033      1  0    indexlength                     : integer;
00034      1  0    xmin,ommin,ommax,omdel,omega    : real;
00035      1  0    xdef         		   : real;
00036      1  0    fn                              : fcn;
00037      1  0    arg,st,nameofeverycurve         : anystring;
00038      1  0    index,tn                        : anystring;
00039      1  0    fc                              : frecurve_type;
00040   C  1  0 {=============================================================================}
00041   C  1  0 {-- ROUTINES TO CALCULATE DESCRIBING FUNCTION---------------------------------}
00042   C  1  0 {=============================================================================}
00043      2  0 FUNCTION anglelessthan : boolean;
00044      2  0 VAR 
00045      2  0    pt1,pt2 : complex;
00046      2  1 BEGIN
00047      2  1 WITH fc,f DO 
00048      2  2    BEGIN
00049      2  2    IF steps < 3 
00050      2  2     THEN anglelessthan := true
00051      2  2    ELSE IF abs (dat[steps].db) > 10 * LOGINFINITY
00052      2  2     THEN anglelessthan := true
00053      2  2    ELSE IF abs (dat[steps-1].db) > 10 * LOGINFINITY
00054      2  2     THEN anglelessthan := true
00055      2  2    ELSE IF abs (dat[steps-2].db) > 10 * LOGINFINITY

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00056      2  2     THEN anglelessthan := true
00057      2  2     ELSE
00058      2  3      BEGIN
00059      2  3      pt1.re := (dat[steps].db - dat[steps-1].db) * 3;
00060      2  3      pt2.re := (dat[steps-1].db - dat[steps-2].db) * 3;
00061      2  3      pt1.im := dat[steps].phase - dat[steps-1].phase;
00062      2  3      pt2.im := dat[steps-1].phase - dat[steps-2].phase;
00063      2  3      IF pt2.im - pt1.im > 180 THEN pt1.im := pt1.im + 360d0;
00064      2  3      IF pt2.im - pt1.im < -180 THEN pt1.im := pt1.im - 360d0;
00065      2  3      anglelessthan := cos (angle(pt1) - angle(pt2)) > cos (nyqdif * PI / 180d0);
00066      2  2      END;
00067      2  1    END;
00068      1  0 END;
00069   C  1  0 {-----------------------------------------------------------------------------}
00070      2  0 PROCEDURE memoryless;
00071   C  2  0 {----------------------------------------}
00072      3  0 PROCEDURE calcdescf (VAR fc : frecurve_type; omega : real);
00073      3  0 TYPE
00074      3  0    dfstatustype = (a_ok,spike_found,leave_spike,
00075      3  0                     nyq_change,phase_change,db_change);
00076      3  0 VAR
00077      3  0    dfstatus      : dfstatustype;
00078      3  0    i,k           : integer;
00079      3  0    a,da          : real;
00080      3  0    ptx,dn        : complex;
00081   C  3  0 {------------------------------}
00082      4  0 PROCEDURE addastep (a : real);
00083      4  0 VAR
00084      4  0     i,limiter         : integer;
00085      4  0     sum, sa           : real;
00086      4  1 BEGIN
00087      4  1 WITH fc,f DO
00088      4  2 BEGIN
00089      4  3 CASE chofcom(dftype) OF
00090      4  4    'D': BEGIN
00091      4  4         sa := p[1]/a;
00092      4  4 	dn.im := 0d0;
00093      4  4         dn.re := p[2] - 2*p[2]/pi * (arcsin(sa) + sa*sqrt(1 - sa*sa));
00094      4  3 	END;
00095      4  4    'L': BEGIN
00096      4  4 	sa := p[1]/a;
00097      4  4 	dn.im := 0d0;
00098      4  4         dn.re := 2 * p[2] / pi * (arcsin(sa) + sa * sqrt(1 - sa * sa));
00099      4  3         END;
00100      4  4    'Q': BEGIN
00101      4  4 	sum := 0;
00102      4  4 	limiter := trunc((2 * a / round(p[1]) + 1) / 2);
00103      4  4 	limiter := min(limiter,round(p[2]));
00104      4  4 	IF limiter = 0 THEN
00105      4  4 	   sum := 1d-10
00106      4  4 	 ELSE
00107      4  4 	   FOR i := 1 TO limiter DO
00108      4  4 	       sum := sum + sqrt(1-sqr((2 * i - 1) * p[1] / 2 / a));
00109      4  4 	dn.im := 0d0;
00110      4  4 	dn.re := 4 * p[3] / pi / a * sum;

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00111      4  3 	END;
00112      4  4    'S': BEGIN
00113      4  4 	dn.im := -2 * p[1] * (p[2] - p[3]) / pi / a / a;
00114      4  4 	dn.re := 2 * p[1] * (sqrt(1 - (p[3] / a)**2)
00115      4  4                 + sqrt(1 - (p[2] / a)**2)) / pi / a;
00116      4  3 	END;
00117      4  2    END; {CASE}
00118      4  2 dn := cneg(cinv(dn));
00119      4  2 steps := steps + 1;
00120      4  2 dat[steps].db := 20d0 * log10(cabs(dn));
00121      4  2 dat[steps].phase := angle(dn) * 180d0 / pi;
00122      4  2 WHILE dat[steps].phase >= 180d0 DO dat[steps].phase := dat[steps].phase -360d0;
00123      4  2 WHILE dat[steps].phase < -180d0 DO dat[steps].phase := dat[steps].phase +360d0;
00124      4  2 dat[steps].amp := a;
00125      4  1 END;
00126      3  0 END;
00127   C  3  0 {------------------------------}
00128      3  1 BEGIN {* calcdescf *}
00129      3  1 WITH fc,f DO 
00130      3  2    BEGIN
00131   C  3  2    { CALCULATE THE AMPLITUDES }
00132      3  2    a := amin;
00133      3  2    steps := 0;
00134      3  2    addastep (a);
00135      3  2    IF abs (dat[1].db) > 10 * LOGINFINITY THEN da := closezero ELSE da := 1;
00136      3  3    REPEAT
00137      3  4       REPEAT
00138      3  4          dfstatus := a_ok;
00139      3  4          IF abs(dat[steps].db) < 10 * LOGINFINITY
00140      3  4           THEN a := dat[steps].amp + da
00141      3  4           ELSE
00142      3  5            REPEAT
00143      3  5               da := da * 1.75;
00144      3  5               a := dat[steps].amp + da;
00145      3  5               dfstatus := leave_spike;  
00146      3  5               addastep (a);
00147      3  5               steps := steps - 1;
00148      3  4               UNTIL abs (dat[steps+1].db) < 10 * LOGINFINITY;
00149      3  4          addastep (a);
00150      3  4          IF dfstatus = leave_spike
00151      3  4           THEN
00152      3  4          ELSE IF ( abs (dat[steps].db) > 10 * LOGINFINITY) 
00153      3  4           THEN dfstatus := spike_found
00154      3  4          ELSE IF abs (dat[steps].db - dat[steps-1].db) > dbdif
00155      3  4           THEN dfstatus := db_change
00156      3  4          ELSE IF cos ((dat[steps].phase - dat[steps-1].phase) * PI / 180d0)
00157      3  4                < cos (phdif * PI / 180d0)
00158      3  4           THEN dfstatus := phase_change
00159      3  4          ELSE IF (NOT anglelessthan) AND (steps > 2)
00160      3  4           THEN dfstatus := nyq_change;
00161      3  4          IF dfstatus IN [a_ok,spike_found,leave_spike]
00162      3  4           THEN da := da * 1.75
00163      3  4          ELSE IF dfstatus = nyq_change
00164      3  5           THEN BEGIN  da := da / 4.00;  steps := steps - 2;  END
00165      3  4           ELSE BEGIN  da := da / 1.75;  steps := steps - 1;  END;

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00166      3  4          a := dat[steps].amp;
00167      3  3          UNTIL dfstatus IN [a_ok,spike_found,leave_spike];
00168      3  3       IF steps MOD 50 = 0
00169      3  3        THEN writeline (both,'Step=' + strofi(steps,4) 
00170      3  3                      + '     X=' + strofr(a,13) );
00171      3  2       UNTIL a > amax - amax * closezero;
00172      3  2    steps := steps - 1;
00173      3  2    addastep (amax);
00174      3  2 
00175   C  3  2    { FILL IN UNDEFINED PHASES AT POLES AND ZEROES  }
00176      3  2    FOR i := 1 TO steps DO 
00177      3  2       IF abs (dat[i].db) > 10 * LOGINFINITY THEN dat[i].phase := 0;
00178      3  1    END;
00179      2  0 END; {* calcdescf *}
00180   C  2  0 {---------------------------------------}
00181      2  1 BEGIN {* memoryless *}
00182      2  1 startcommand ('MEMORYLESS_SYSTEM',true);
00183      2  1 setcommand ('Dead_Zone');
00184      2  1 setcommand ('Limiter');
00185      2  1 setcommand ('Quantizer');
00186      2  1 setcommand ('Schmitt_Trigger');
00187      2  1 readcommand (modi,ESC,false,'ANALYZE DESCRIBING_FUNCTION MEMORYLESS_SYSTEM');
00188      2  1 
00189      2  1 IF modi <> ESC
00190      2  1  THEN WITH fc,f DO 
00191      2  2   BEGIN
00192      2  2   dftype := modi;
00193      2  2   xdef := 1d0;
00194      2  3   CASE chofcom(modi) OF
00195      2  4     'D':  BEGIN
00196      2  4           readreal ('ENTER DEAD_ZONE WIDTH: ',p[width],0,BIG,1d0);
00197      2  4           readreal ('ENTER DEAD_ZONE SLOPE: ',p[slope],1d-10,BIG,1d0);
00198      2  4           writeline (aud,'DEAD_ZONE WIDTH     = ' + strofr(p[width],13));
00199      2  4           writeline (aud,'LIMITER SLOPE       = ' + strofr(p[slope],13));
00200      2  4           xdef := max(1.05D0,p[width]);
00201      2  3           END;
00202      2  4     'L':  BEGIN
00203      2  4           readreal ('ENTER DEADBAND AMPLITUDE: ',p[start],0,BIG,1d0);
00204      2  4           readreal ('ENTER LIMITER SLOPE: ',p[slope],1d-10,BIG,1d0);
00205      2  4           writeline (aud,'DEADBAND AMPLITUDE  = ' + strofr(p[start],13));
00206      2  4           writeline (aud,'LIMITER SLOPE       = ' + strofr(p[slope],13));
00207      2  4           xdef := p[start];
00208      2  3           END;
00209      2  4     'Q':  BEGIN
00210      2  4           readreal ('ENTER NUMBER OF OUTPUT LEVELS: ',p[levels],1,BIG,1d0);
00211      2  4           readreal ('ENTER AMPLITUDE OF FIRST OUTPUT STATE: ',p[limit]
00212      2  4                     ,1d-10,BIG,1d0);
00213      2  4           readreal ('ENTER QUANTIZATION WIDTH: ',p[width],0,BIG,1d0);
00214      2  4           writeline (aud,'NO. OF OUTPUT LEVELS            = ' +
00215      2  4                      strofr(p[levels],13));
00216      2  4           writeline (aud,'AMPLITUDE OF FIRST OUTPUT STATE = ' +
00217      2  4                      strofr(p[limit],13));
00218      2  4           writeline (aud,'QUANTIZATION WIDTH              = ' +
00219      2  4                      strofr(p[width],13));
00220      2  3           END;

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00221      2  4     'S':  BEGIN
00222      2  4           readreal ('ENTER U-MAX.: ',p[umax],0,BIG,1d0);
00223      2  4           readreal ('ENTER U-ON  : ',p[uon],0,BIG,1d0);
00224      2  4           readreal ('ENTER U-OFF : ',p[uoff],-BIG,BIG,0.8d0);
00225      2  4           writeline (aud,'U-MAX.         = ' +strofr(p[umax],13));
00226      2  4           writeline (aud,'U-ON           = ' + strofr(p[uon],13));
00227      2  4           writeline (aud,'U-OFF          = ' + strofr(p[uoff],13));
00228      2  4           xdef := max(p[uon],p[uoff]);
00229      2  3           END;
00230      2  2      END;
00231      2  2 
00232      2  2    defaultfreqformat.flog := TRUE;
00233      2  2    writeline (both,'');
00234      2  2    readreal ('ENTER MINIMUM INPUT AMPLITUDE: ',amin,xdef,1000d0,xdef);
00235      2  2    readreal ('ENTER MAXIMUM INPUT AMPLITUDE: ',amax,amin,1000d0,1000d0);
00236      2  2    readreal ('ENTER MAX DB CHANGE     : ',dbdif,0.01,400d0,5d0);
00237      2  2    readreal ('ENTER MAX PHASE CHANGE  : ',phdif,0.01,400d0,5d0);
00238      2  2    readreal ('ENTER MAX NYQ ANG CHANGE: ',nyqdif,0.01,400d0,5d0);
00239      2  2 
00240      2  2    writeline (aud,'MINIMUM AMPLITUDE   = ' + strofr(amin,13));
00241      2  2    writeline (aud,'MAXIMUM AMPLITUDE   = ' + strofr(amax,13));
00242      2  2    writeline (aud,'MAX DB CHANGE       = ' + strofr(dbdif,13));
00243      2  2    writeline (aud,'MAX PHASE CHANGE    = ' + strofr(phdif,13));
00244      2  2    writeline (aud,'MAX ANGLE CHANGE    = ' + strofr(nyqdif,13));
00245      2  2    writeline (aud,'');
00246      2  2    writeline (both,'Calculating Describing Function');
00247      2  2    writeline (both,'Steps completed');
00248      2  2    writeline (both,'Maximum       X=' + strofr(amax,13));
00249      2  2    writeline (aud,'');
00250      2  2 
00251      2  2    calcdescf (fc,0);
00252      2  2    readvary ('ENTER CURVE NAME        : ',name,'DF');
00253      2  2    ix := createcurve (C_FRE,name,name);
00254      2  2    ftype := DES;
00255      2  2    curve.data[ix].fcptr^ := fc;
00256      2  2    readvary ('ENTER ADDITIONAL CURVES : ',st,'');
00257      2  2    unread ('PLOT NEW ' + name + ' ' + st);
00258      2  2    END {* WITH *}
00259      2  1  ELSE readargument (arg);
00260      1  0 END; {* memoryless *}
00261   C  1  0 {-----------------------------------------------------------------------------}
00262      2  0 PROCEDURE memory;
00263      2  0 VAR
00264      2  0    incr, i1, j, k                          : integer;
00265      2  0    gotapulse, multipulse, curve_no_good    : boolean;
00266      2  0    a,da,aminold                            : real;
00267      2  0    ptx,dn                                  : complex;
00268      2  0    min_amp_for_omega,omega_for_min_amp	   : ARRAY [1..10] OF real;
00269   C  2  0 {---------------------------------}
00270      3  0 PROCEDURE addastep (a : real);
00271      3  0 VAR
00272      3  0     sa : real;
00273   C  3  0 {---------------------------------}
00274      4  0 PROCEDURE modulate(amp, w: real; VAR dn: complex);
00275      4  0 CONST

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00276      4  0    dt = 0.02;
00277      4  0    tol = 1e-3;
00278      4  0    err = 1e-3;
00279      4  0 VAR
00280      4  0    ifss                                   : boolean;
00281      4  0    ns                                     : integer;
00282      4  0    t, x, xi, u, tf, tp                    : real;
00283      4  0    a1, b1                                 : real;
00284      4  0    ts, us                                 : ARRAY [1..100] OF real;
00285   C  4  0 {------------------------------}
00286      5  0 FUNCTION sign(a, b : real) : real;
00287      5  1 BEGIN
00288      5  1    IF b >= 0 THEN
00289      5  1      sign := abs(a)
00290      5  1    ELSE
00291      5  1      sign := -abs(a);
00292      4  0 END;
00293   C  4  0 {----------------------------------}
00294      5  0 PROCEDURE pwpf(tpre, xpre: real);
00295      5  0 VAR
00296      5  0    xc1, xc2, time : real;
00297      5  1 BEGIN
00298      5  1 WITH fc,f DO
00299      5  2 BEGIN
00300      5  2 time := p[tm];
00301      5  2 xc1 := exp(-(t-tpre)/p[tm]); 
00302      5  2 xc2:= amp*p[km]/(1.0+(w*p[tm])**2); 
00303      5  2 x := xc2*(sin(w*t)-(w*p[tm])*cos(w*t))
00304      5  2      + xc1*(xpre-xc2*(sin(w*tpre)-(w*p[tm])*cos(w*tpre)))
00305      5  2      -u*p[km]*(1.0-xc1);
00306      5  1 END;
00307      4  0 END; 
00308   C  4  0 {----------------------------------}
00309      5  0 PROCEDURE swfunc(x: real; VAR sw: real);
00310      5  1 BEGIN
00311      5  1 WITH fc,f DO
00312      5  2 BEGIN
00313      5  2 IF u = 0 THEN
00314      5  2    sw := sign(1.0,x) * (x-sign(1.0,x)*p[uon])
00315      5  2   ELSE
00316      5  2    IF u = p[umax] THEN
00317      5  2       sw := p[uoff] - x
00318      5  2      ELSE
00319      5  2       sw := x + p[uoff];
00320      5  1 END; {* WITH *}
00321      4  0 END; {* swfunc *}
00322   C  4  0 {-----------------------------------}
00323      5  0 PROCEDURE swpt(VAR tl, xl, t, x: real);
00324      5  0 CONST
00325      5  0    nim = 200;
00326      5  0 VAR 
00327      5  0    getout : boolean;
00328      5  0    dt,th, tsave, xh, swl, swh ,sw : real;
00329      5  0    i : integer;
00330      5  1 BEGIN

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00331      5  1 IF tol <> 1 THEN
00332      5  2    BEGIN
00333      5  2    th := t;
00334      5  2    xh := x;
00335      5  2    swfunc(xl,swl);
00336      5  2    swfunc(xh,swh);
00337      5  2    i := 0;
00338      5  2    getout := false;
00339      5  2    WHILE (i <= nim) AND NOT getout DO
00340      5  3      BEGIN
00341      5  3      i := i + 1;
00342      5  3      dt := -swl*(th-tl)/(swh-swl);
00343      5  3      tsave := t;
00344      5  3      t := tl + dt;
00345      5  3      pwpf(tl,xl);
00346      5  3      swfunc(x,sw);
00347      5  3      IF (abs(sw) > tol) OR (abs(t-tsave) > tol) THEN
00348      5  3         IF (sw >= 0) THEN
00349      5  4            BEGIN
00350      5  4            th := t;
00351      5  4            xh := x;
00352      5  4            swh := sw;
00353      5  4            END
00354      5  3          ELSE
00355      5  4    	   BEGIN
00356      5  4 	   tl := t;
00357      5  4 	   xl := x;
00358      5  4 	   swl := sw;
00359      5  4 	   END
00360      5  3        ELSE
00361      5  3         getout := true;
00362      5  2      END; {* FOR *}
00363      5  1    END; {* IF *}
00364      4  0 END; {* swpt *}
00365   C  4  0 {----------------------------------}
00366      5  0 PROCEDURE simul;
00367      5  0 VAR
00368      5  0    tpre, xpre, sw : real;
00369      5  0    k : integer;
00370      5  1 BEGIN
00371      5  1 ns := 0;
00372      5  1 IF u <> 0 THEN
00373      5  2    BEGIN
00374      5  2    ns := ns + 1;
00375      5  2    ts[ns] := t;
00376      5  2    us[ns] := u;
00377      5  1    END;
00378      5  1 WHILE t < tf DO
00379      5  2 BEGIN
00380      5  2   tpre := t;
00381      5  2   xpre := x;
00382      5  2   t := tpre + dt;
00383      5  2   IF t > tf THEN 
00384      5  2      t := tf; 
00385      5  2   pwpf(tpre,xpre);

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00386      5  2   swfunc(x,sw);
00387      5  2   IF sw >= 0 THEN
00388      5  3      BEGIN
00389      5  3      swpt(tpre,xpre,t,x);
00390      5  3      IF u = 0 THEN
00391      5  3         u := sign(fc.f.p[umax],x)
00392      5  3        ELSE
00393      5  3         u := 0;
00394      5  3      ns := ns +1;
00395      5  3      ts[ns] := t;
00396      5  3      us[ns] := u;
00397      5  2      END;
00398      5  2   IF (t = tf) AND (u <> 0) THEN
00399      5  3      BEGIN
00400      5  3      ns := ns + 1;
00401      5  3      ts[ns] := t;
00402      5  3      us[ns] := u;
00403      5  2      END;
00404      5  1   END; {* WHILE *}
00405      5  1 gotapulse := (ns <> 0);
00406      5  1 multipulse := (ns > 4);
00407      4  0 END; {* simul *}
00408   C  4  0 {--------------------------------}
00409      5  0 PROCEDURE ssck;
00410      5  1 BEGIN
00411      5  1 ifss := (abs(xi-x) <= tol);
00412      4  0 END; {* ssck *}
00413   C  4  0 {--------------------------------}
00414      5  0 PROCEDURE aft;
00415      5  0 VAR
00416      5  0    istop, i, n : integer;
00417      5  1 BEGIN
00418      5  1 a1 := 0;
00419      5  1 b1 := 0;
00420      5  1 istop := round((ns-2)/2) + 1;
00421      5  1 FOR i := 1 TO istop DO
00422      5  2   BEGIN
00423      5  2   n := 2 * i;
00424      5  2   a1 := a1+us[n-1]*(sin(w*ts[n])-sin(w*ts[n-1])); 
00425      5  2   b1 := b1+us[n-1]*(cos(w*ts[n])-cos(w*ts[n-1])); 
00426      5  1   END;
00427      5  1 dn.im := a1/pi/amp;
00428      5  1 dn.re := -b1/pi/amp;
00429      4  0 END; {* aft *}
00430   C  4  0 {--------------------------------}
00431      4  1 BEGIN {* modulate *}
00432      4  1 tp := 2 * pi /w;
00433      4  1 multipulse := false;
00434      4  1 ifss := false;
00435      4  1 u := 0;
00436      4  1 t := 0;
00437      4  1 x := 0;
00438      4  1 WHILE NOT ifss DO
00439      4  2    BEGIN
00440      4  2    tf := t + tp;

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00441      4  2    xi := x;
00442      4  2    simul;
00443      4  2    ssck;
00444      4  1    END;
00445      4  1 IF gotapulse AND NOT multipulse THEN aft;
00446      3  0 END; {* modulate *}
00447   C  3  0 {----------------------------------------}
00448      3  1 BEGIN {* addastep *}
00449      3  1 WITH fc,f DO
00450      3  2    BEGIN
00451      3  3    CASE chofcom(dftype) OF
00452      3  4        'P': BEGIN
00453      3  4             modulate(a,omega,dn);
00454      3  3 	    END;
00455      3  2         END; {CASE}
00456      3  2 
00457      3  2    dat[steps].amp := a;
00458      3  2    IF gotapulse AND NOT multipulse THEN
00459      3  3       BEGIN
00460      3  3       dn := cneg(cinv(dn));
00461      3  3       dat[steps].db := 20d0 * log10(cabs(dn));
00462      3  3       dat[steps].phase := angle(dn) * 180d0 / pi;
00463      3  3       WHILE dat[steps].phase >= 180d0 DO 
00464      3  3             dat[steps].phase := dat[steps].phase -360d0;
00465      3  3       WHILE dat[steps].phase < -180d0 DO 
00466      3  3             dat[steps].phase := dat[steps].phase +360d0;
00467      3  3       END {* IF *}
00468      3  2     ELSE
00469      3  3       BEGIN
00470      3  3       dat[steps].db := 0;
00471      3  2       END;
00472      3  1    END; {* WITH *}
00473      2  0 END; {* addastep *}
00474   C  2  0 {--------------------------------------------------------------------}
00475      3  0 PROCEDURE calcmin (da: real);
00476      3  1 BEGIN {* calcmin *}
00477      3  1 a := aminold;
00478      3  1 writeline(both,'   a = ' + strofr(a,13) + 'da = ' + strofr(da,13));
00479      3  1 addastep(a);
00480      3  1 curve_no_good := multipulse;
00481      3  1 IF multipulse THEN 
00482      3  2    BEGIN
00483      3  2    writeline(both,'Got multiple pulses');
00484      3  2    writeline(both,'INCA only works with single pulse curves');
00485      3  2    pause;
00486      3  2    END
00487      3  1  ELSE 
00488      3  2    BEGIN
00489      3  2    WITH fc,f DO 
00490      3  3       BEGIN
00491      3  3       amax := 1d2;
00492      3  4       REPEAT
00493      3  4       a := a + da;
00494      3  4       addastep(a);
00495      3  4       writeline(both,'   a = ' + strofr(a,13)+'da = ' + strofr(da,13));

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00496      3  3       UNTIL gotapulse;
00497      3  4       REPEAT
00498      3  4       da := da / 2;
00499      3  4       IF gotapulse THEN
00500      3  5 	 BEGIN
00501      3  5 	 a := a - da;
00502      3  5 	 END
00503      3  4        ELSE
00504      3  5 	 BEGIN
00505      3  5 	 a := a + da;
00506      3  4 	 END;
00507      3  4        writeline(both,'   a = ' + strofr(a,13)+'da = ' + strofr(da,13));
00508      3  4        addastep (a);
00509      3  4        UNTIL ((a > amax - amax * closezero) OR (da < 1d-6)) AND 
00510      3  3               (gotapulse AND NOT multipulse);
00511      3  2    END; {* WITH *}
00512      3  2    aminold := a;
00513      3  1    END; {multipulse IF}
00514      2  0 END; {* calcmin *}
00515   C  2  0 {------------------------------}
00516      3  0 PROCEDURE calcdescf (VAR fc : frecurve_type; omega : real);
00517      3  0 TYPE
00518      3  0    dfstatustype = (a_ok,spike_found,leave_spike,
00519      3  0                     nyq_change,phase_change,db_change);
00520      3  0 VAR
00521      3  0    i,k                    : integer;
00522      3  0    dfstatus               : dfstatustype;
00523      3  1 BEGIN {* calcdescf *}
00524      3  1 WITH fc,f DO 
00525      3  2    BEGIN
00526   C  3  2    { CALCULATE THE AMPLITUDES }
00527      3  2    steps := 1;
00528      3  2    calcmin (0.05d0);
00529      3  2    IF gotapulse AND NOT multipulse THEN
00530      3  3    BEGIN
00531      3  3    writeline (both,'Step=' + strofi(steps,4) 
00532      3  3                  + '     X=' + strofr(a,13) );
00533      3  3    min_amp_for_omega[j] := aminold;
00534      3  3    IF abs (dat[1].db) > 10 * LOGINFINITY THEN 
00535      3  3       da := closezero 
00536      3  3     ELSE
00537      3  3       da := 0.005d0;
00538      3  4    REPEAT
00539      3  5       REPEAT
00540      3  5          dfstatus := a_ok;
00541      3  5          IF abs(dat[steps].db) < 10 * LOGINFINITY
00542      3  5           THEN a := dat[steps].amp + da
00543      3  5           ELSE
00544      3  6              REPEAT
00545      3  6              da := da * 1.75;
00546      3  6              a := dat[steps].amp + da;
00547      3  6              dfstatus := leave_spike;  
00548      3  6              addastep (a);
00549      3  5              UNTIL abs (dat[steps+1].db) < 10 * LOGINFINITY;
00550      3  5          steps := steps + 1;

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00551      3  5          addastep (a);
00552      3  5          IF NOT multipulse
00553      3  6             THEN BEGIN
00554      3  6          IF dfstatus = leave_spike
00555      3  6           THEN
00556      3  6          ELSE IF ( abs (dat[steps].db) > 10 * LOGINFINITY) 
00557      3  6           THEN dfstatus := spike_found
00558      3  6          ELSE IF abs (dat[steps].db - dat[steps-1].db) > dbdif
00559      3  6           THEN dfstatus := db_change
00560      3  6          ELSE IF cos ((dat[steps].phase - dat[steps-1].phase) * PI / 180d0)
00561      3  6                < cos (phdif * PI / 180d0)
00562      3  6           THEN dfstatus := phase_change
00563      3  6          ELSE IF (NOT anglelessthan) AND (steps > 2)
00564      3  6           THEN dfstatus := nyq_change;
00565      3  6          IF dfstatus IN [a_ok,spike_found,leave_spike]
00566      3  6           THEN da := da * 1.75
00567      3  6          ELSE IF dfstatus = nyq_change
00568      3  7           THEN BEGIN  da := da / 4.00;  steps := steps - 2;  END
00569      3  6           ELSE BEGIN  da := da / 1.75;  steps := steps - 1;  END;
00570      3  6          a := dat[steps].amp;
00571      3  5          END; {* multipulse IF *}
00572      3  4          UNTIL (dfstatus IN [a_ok,spike_found,leave_spike]) or multipulse;
00573      3  4          writeline (both,'Step=' + strofi(steps,4) 
00574      3  4                        + '     X=' + strofr(a,13) );
00575      3  3       UNTIL (a > amax - amax * closezero) OR multipulse OR (da < 1e-5);
00576      3  3    steps := steps - 1;
00577      3  3 
00578   C  3  3    { FILL IN UNDEFINED PHASES AT POLES AND ZEROES  }
00579      3  3    FOR i := 1 TO steps DO 
00580      3  3       IF abs (dat[i].db) > 10 * LOGINFINITY THEN dat[i].phase := 0;
00581      3  3    END {* gotapulse AND NOT multipulse IF *}
00582      3  1    END; {* WITH *}
00583      2  0 END; {* calcdescf *}
00584   C  2  0 {--------------------------------}
00585      2  1 BEGIN {* memory *}
00586      2  1 startcommand ('MEMORY_SYSTEM',true);
00587      2  1 setcommand ('PWPF_Modulator');
00588      2  1 readcommand (modi,ESC,false,'ANALYZE DESCRIBING_FUNCTION MEMORY_SYSTEM');
00589      2  1 
00590      2  1 xdef := 1d0;
00591      2  1 IF modi <> ESC
00592      2  1  THEN WITH fc,f DO
00593      2  2   BEGIN
00594      2  2   dftype := modi;
00595      2  3   CASE chofcom(modi) OF
00596      2  4      'P': BEGIN
00597      2  4           readreal ('ENTER U-MAX. : ',p[umax],0,BIG,1d0);
00598      2  4           readreal ('ENTER U-ON   : ',p[uon],0,BIG,1d0);
00599      2  4           readreal ('ENTER U-OFF  : ',p[uoff],-BIG,BIG,0);
00600      2  4           readreal ('ENTER FILTER GAIN: ',p[km],0,BIG,4.5d0);
00601      2  4           readreal ('ENTER FILTER TIME CONST.: ',p[tm],1d-3,BIG,0.2d0);
00602      2  4           writeline (aud,'U-MAX.              = ' + strofr(p[umax],13));
00603      2  4           writeline (aud,'U-ON                = ' + strofr(p[uon],13));
00604      2  4           writeline (aud,'U-OFF               = ' + strofr(p[uoff],13));
00605      2  4           writeline (aud,'FILTER GAIN            = ' + strofr(p[km],13));

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00606      2  4           writeline (aud,'FILTER TIME CONSTANT   = ' + strofr(p[tm],13));
00607      2  3           END;
00608      2  2      END; {* CASE *}
00609      2  2 
00610      2  2   readreal ('ENTER START FREQUENCY: ',ommin,1e-3,BIG,4);
00611      2  2   readreal ('ENTER STOP FREQUENCY: ',ommax,ommin,BIG,ommin);
00612      2  2   readreal ('ENTER INCREMENT OF FREQUENCY: ',omdel,0,ommax-ommin,ommax-ommin);
00613      2  2   readreal ('ENTER INITAL AMPLITUDE: ',amin,0,1d2,0);
00614      2  2   writeline (aud,'START FREQUENCY            = ' + strofr(ommin,13));
00615      2  2   writeline (aud,'STOP FREQUENCY             = ' + strofr(ommax,13));
00616      2  2   writeline (aud,'INCREMENT OF FREQUENCY     = ' + strofr(omdel,13));
00617      2  2   writeline (aud,'INITIAL AMPLITUDE          = ' + strofr(amin,13));
00618      2  2   defaultfreqformat.flog := TRUE;
00619      2  2   writeline (both,'');
00620      2  2   readreal ('ENTER MAX DB CHANGE     : ',dbdif,0.01,400d0,5d0);
00621      2  2   readreal ('ENTER MAX PHASE CHANGE  : ',phdif,0.01,400d0,5d0);
00622      2  2   readreal ('ENTER MAX NYQ ANG CHANGE: ',nyqdif,0.01,400d0,5d0);
00623      2  2 
00624      2  2   writeline (aud,'MAX DB CHANGE       = ' + strofr(dbdif,13));
00625      2  2   writeline (aud,'MAX PHASE CHANGE    = ' + strofr(phdif,13));
00626      2  2   writeline (aud,'MAX ANGLE CHANGE    = ' + strofr(nyqdif,13));
00627      2  2   writeline (aud,'');
00628      2  2   writeline (both,'Calculating Describing Function');
00629      2  2   writeline (aud,'');
00630      2  2 
00631      2  2   readvary ('ENTER CURVE NAME        : ',name,'PWPF');
00632      2  2   IF omdel = 0
00633      2  2    THEN n := 1
00634      2  2    ELSE n:= trunc ((ommax - ommin)/omdel) + 1;
00635      2  2   nameofeverycurve := '';
00636      2  2   aminold := amin;
00637      2  2   k := 0;
00638      2  2   FOR  j := 1 to n DO
00639      2  3      BEGIN
00640      2  3      omega := ommin + (j-1)*omdel;
00641      2  3      writeline(both,'---Frequency = ' + strofr(omega,15) + '---');
00642      2  3      calcdescf(fc,omega);
00643      2  3      IF NOT curve_no_good 
00644      2  3       THEN
00645      2  4        BEGIN
00646      2  4        k := k + 1;
00647      2  4        indexlength := trunc(log10(k)) + 1;
00648      2  4        index := strofi( k, indexlength);
00649      2  4        ix := createcurve (C_FRE,name + index,name + index);
00650      2  4        omega_for_min_amp[k] := omega;
00651      2  4        pwpf_omega := omega;
00652      2  4        ispwpf := true;
00653      2  4        ftype := DES;
00654      2  4        curve.data[ix].fcptr^ := fc;
00655      2  4        nameofeverycurve := nameofeverycurve + ' ' + curve.data[ix].name;
00656      2  3        END; { NOT multipulse IF }
00657      2  2      END; { FOR }
00658      2  2   IF NOT curve_no_good AND (n <> 1) 
00659      2  2    THEN
00660      2  3     BEGIN 

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                   2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

-LINE-IDC-PL-SL-

00661      2  3     writeline(both,'Calculating Minimum Amplitude Line');
00662      2  3     FOR incr := 1 TO k DO
00663      2  4        BEGIN
00664      2  4        steps := incr;
00665      2  4        omega := omega_for_min_amp[incr];
00666      2  4        writeline(both,'   Frequency = ' + strofr(omega,15));
00667      2  4        a := min_amp_for_omega[incr];
00668      2  4        addastep (a);
00669      2  4        aminold := a;
00670      2  3        END;
00671      2  3 	
00672      2  3     ispwpf := false; 
00673      2  3     indexlength := trunc(log10(k+1)) + 1;
00674      2  3     index := strofi( k+1, indexlength);
00675      2  3     ix := createcurve (C_FRE,name + index,name + index);
00676      2  3     ftype := DES;
00677      2  3     curve.data[ix].fcptr^ := fc;
00678      2  3     nameofeverycurve := nameofeverycurve + ',' + curve.data[ix].name;
00679      2  3 
00680      2  3     readvary ('ENTER ADDITIONAL CURVES : ',st,'');
00681      2  3     pwsqueeze(st);
00682      2  3     unread ('PLOT NEW ' + nameofeverycurve + ' ' +  st);
00683      2  3     ix := createcurve (C_FRE,name,'MULTI_PWPF');
00684      2  3     ftype := MNY;
00685      2  3     pwpftype := modi;
00686      2  3     numname := k;
00687      2  3     curve.data[ix].fcptr^ := fc;
00688      2  2     END; {* curve_no_good IF *}
00689      2  2   END {* WITH *}
00690      2  1  ELSE readargument(arg);
00691      1  0 END; {* memory *}
00692   C  1  0 {=============================================================================}
00693   C  1  0 {-- DESCF COMMAND ------------------------------------------------------------}
00694   C  1  0 {=============================================================================}
00695      1  1 BEGIN {* descf *}
00696      1  1 startcommand ('DESCRIBING_FUNCTION',true);
00697      1  1 setcommand ('mEmoryless_System');
00698      1  1 setcommand ('Memory_System');
00699      1  1 readcommand (modi,ESC,false,'ANALYZE DESCRIBING_FUNCTION');
00700      1  2 CASE chofcom(modi) OF
00701      1  2    'E': memoryless;
00702      1  2    'M': memory;
00703      1  1 END; {* CASE *}
00704      1  1 clearscreen;
00705      0  0 END; {* descf *}
00706   C  0  0 {=============================================================================}
00707      0  0 END.

DESCF                                                           23-Dec-1988 11:17:15    VAX Pascal V3.7-254                Page   14
INCA                            Pascal Compilation Statistics    2-Dec-1988 15:06:48    DUA1:[QPLOT.INCA.SOURCE]DESCF.PAS;3 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               17755  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        40        32
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         8        14
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        16        26
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        19        26
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39        10        26
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        18         8
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        56        27
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       298        79
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         1         1
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        71        29
DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PEN;1                    144         0         0
DUA1:[QPLOT.INCA.SOURCE]PLOT.PEN;1                       446        22         5
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184         0         0
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289         6         2



TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:STRING',
00004      0  0                'QLIBHOME:MATH',
00005      0  0                'QLIBHOME:COMPLEX',
00006      0  0                'QLIBHOME:HANDLER',
00007      0  0                'QLIBHOME:FIG',
00008      0  0                'QLIBHOME:IO',
00009      0  0                'QLIBHOME:PLOT',
00010      0  0                'CURVE','BLOCK','UTIL',
00011      0  0                'FCN','FCNEVAL','FCNIO','LONGREAL','POLYMATH'),
00012      0  0   ENVIRONMENT ('TIMER')]
00013      0  0 MODULE timer;
00014   C  0  0 {=============================================================================}
00015   C  0  0 {-- ROUTINES TO CALCULATE TIME RESPONSE --------------------------------------}
00016   C  0  0 {=============================================================================}
00017      1  0 PROCEDURE calctimer (VAR tc : tircurve_type);
00018      1  0 VAR
00019      1  0    sub,i,j,k,n     : integer;
00020      1  0    time,delta,r    : real;
00021      1  0    z               : complex;
00022      1  0    fn              : fcn;
00023      1  0    kplntfcn        : fcn;
00024      1  0    c               : ARRAY [1..MAXDEG*3] OF complex;
00025   C  1  0 {------------------------------}
00026      2  0 FUNCTION convertfcn (infcn : fcn;  plane : char;  tau : real) : fcn;
00027      2  1 BEGIN   
00028      2  2 CASE plane OF
00029      2  3    'S':  CASE infcn.plane OF
00030      2  3             'K',
00031      2  3             'S':  convertfcn := infcn;
00032      2  3             'Z',
00033      2  3             'W':  raise ('Sampled function illegal in continuous systems.');
00034      2  2             END;
00035      2  3    'Z':  CASE infcn.plane OF
00036      2  3             'K':  convertfcn := infcn;
00037      2  3             'S':  convertfcn := fcnzoffcns (infcn,tau,false,0);
00038      2  3             'Z':  convertfcn := infcn;
00039      2  3             'W':  convertfcn := fcnzoffcnw (infcn);
00040      2  2             END;
00041      2  1    END;
00042      1  0 END;
00043   C  1  0 {------------------------------}
00044      2  0 FUNCTION fcnzoffcnsd (sfcn : fcn;  tau : real;  zoh : boolean;
00045      2  0    adv : real;  delay : real) : fcn;
00046      2  0 VAR
00047      2  0    i,nz  : integer;
00048      2  0    delta : real;
00049      2  0    out   : fcn;
00050      2  1 BEGIN
00051      2  1 nz := gile (delay / tau - adv) + 1;
00052      2  1 delta := nz - (delay / tau - adv);
00053      2  1 out := fcnzoffcns (sfcn,tau,zoh,delta);
00054      2  1 FOR i := 1 TO nz DO out := fcndiv (out,zfcn);
00055      2  1 fcnzoffcnsd := out;

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00056      1  0 END;
00057   C  1  0 {------------------------------}
00058      1  1 BEGIN
00059      1  1 writeline (out,'Calculating Time Response');
00060      1  1 writeline (out,'');
00061      1  1 IF havehandler THEN ESTABLISH (handler);
00062      1  1 WITH tc DO 
00063      1  1    FOR k := 1 TO count DO
00064      1  2       BEGIN
00065      1  2       FOR sub := 0 TO substeps-1 DO 
00066      1  3          BEGIN
00067   C  1  3          { CREATE WORKING FUNCTION FN }
00068      1  3          kplntfcn := plantfcn;
00069      1  3          kplntfcn.gain := kplntfcn.gain * compgain[k];
00070      1  3          delta := 1d0 * sub / substeps;
00071      1  4          CASE blocktype OF
00072      1  4             'S':  fn := fcnmul (convertfcn (inputfcn,workplane,tau),
00073      1  4                                 convertfcn (plantfcn,workplane,tau));
00074      1  4             'C':  fn := fcndiv (fcnmul (convertfcn (inputfcn,workplane,tau), 
00075      1  4                                         convertfcn (kplntfcn,workplane,tau)),
00076      1  4                                 fcnadd (onefcn, 
00077      1  4                                 fcnmul (convertfcn (kplntfcn,workplane,tau),
00078      1  4                                       convertfcn (feedbackfcn,workplane,tau))));
00079      1  4             'P':  fn := fcndiv (fcnmul (fcnzoffcns (inputfcn,tau,false,0),
00080      1  4                                         fcnmul (samplerfcn,
00081      1  4                                                 fcnzoffcnsd(kplntfcn,tau,zoh,
00082      1  4                                                             delta,compdelay))),
00083      1  4                                 fcnadd (onefcn,
00084      1  4                                         fcnmul (samplerfcn,
00085      1  4                                                 fcnzoffcnsd(fcnmul (kplntfcn,
00086      1  4                                                         feedbackfcn),tau,zoh,0,
00087      1  4                                                                  compdelay))));
00088      1  4             'F':  fn := fcndiv (fcnzoffcns (fcnmul (kplntfcn,
00089      1  4                                                     inputfcn),tau,zoh,delta),
00090      1  4                                 fcnadd (onefcn,
00091      1  4                                 fcnmul (samplerfcn,
00092      1  4                                         fcnzoffcnsd(fcnmul (kplntfcn,
00093      1  4                                                     feedbackfcn),tau,zoh,0,
00094      1  4                                                                  compdelay))));
00095      1  3             END;
00096      1  3          IF fn.plane = 'Z' THEN fn := fcndiv (fn,zfcn);
00097      1  3 
00098   C  1  3          { NOW CALCULATE INVERSE LAPLACE TRANSFORM }
00099      1  3          steps := sub + 1;
00100      1  3          time := tmin + dt * sub;
00101      1  3 
00102      1  3          fn := fcnPARofFCT (fn);
00103      1  3          WHILE time <= tmax + dt/2 DO 
00104      1  3             WITH fn.pfe DO
00105      1  4                BEGIN
00106      1  4                dat[steps].value[k] := 0;
00107      1  5                CASE workplane OF
00108      1  5                   'S':  FOR i := 1 TO deg DO
00109      1  6                            BEGIN
00110      1  6                            r := 1;

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00111      1  6                            FOR j := 1 TO t[i].p-1 DO r := r * time / j;
00112      1  6                            z := cmul (t[i].v, cexp (cmul (t[i].f,cofr(-time))));
00113      1  6                            dat[steps].value[k] := dat[steps].value[k] + r*z.re;
00114      1  5                            END;
00115      1  6                   'Z':  BEGIN
00116      1  6                         n := (steps- 1) DIV substeps + 1;
00117      1  6                         FOR i := 1 TO deg DO
00118      1  7                            BEGIN
00119      1  7                            IF n < t[i].p
00120      1  7                             THEN c[i] := cofi(0)
00121      1  7                            ELSE IF n = t[i].p
00122      1  7                             THEN c[i] := t[i].v
00123      1  7                             ELSE c[i] := cmul (c[i], cmul (cneg (t[i].f),
00124      1  7                                             cofr ((n-1d0) / (n-t[i].p))));
00125      1  7                            dat[steps].value[k] := dat[steps].value[k] + c[i].re;
00126      1  6                            END;
00127      1  5                         END;
00128      1  4                   END;
00129      1  4                dat[steps].time     := time;
00130      1  4                dat[steps].value[k] := rmin (1d20,dat[steps].value[k]);
00131      1  4                IF steps MOD 200 = sub+1
00132      1  4                 THEN writeline (out,'Step=' + strofi(steps,5) 
00133      1  4                                + '   Time=' + strofr(dat[steps].time,14)
00134      1  4                               + '   Value=' + strofr(dat[steps].value[k],14));
00135      1  4                steps := steps + substeps;
00136      1  4                time := time + dt * substeps;
00137      1  3                END;
00138      1  3          steps := steps - substeps;
00139      1  2          END;
00140      1  2       writeline (out,'');
00141      1  2       writeline (out,'Curve ' + strofi(k,2) + ' completed.');
00142      1  2       writeline (out,'');
00143      1  1       END;
00144      1  1 IF length(err) <> 0
00145      1  1  THEN
00146      1  2   BEGIN
00147      1  2   writeerror;
00148      1  2   IF err = 'FATAL ERROR' THEN BEGIN  REVERT;  resignal;  END;
00149      1  2   err := '';
00150      1  1   END;
00151      1  1 IF havehandler THEN REVERT;
00152      0  0 END;
00153   C  0  0 {=============================================================================}
00154   C  0  0 {-- TIME RESPONSE COMMAND ----------------------------------------------------}
00155   C  0  0 {=============================================================================}
00156      1  0 PROCEDURE timer;
00157      1  0 VAR
00158      1  0    modi              : command_type;  
00159      1  0    name              : logicalname;
00160      1  0    i,k,cix           : integer;
00161      1  0    filename,string   : anystring;
00162      1  0    str,st            : anystring;
00163      1  0    fn                : fcn;
00164      1  0    lable             : anystring;
00165      1  0    tc                : tircurve_type;

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00166   C  1  0 {------------------------------}
00167      2  0 PROCEDURE readinput (ix,iy : integer);
00168      2  0 VAR
00169      2  0    ch             : char;
00170      2  0    str,str1,str2  : anystring;
00171      2  1 BEGIN
00172      2  1 readch   ('SELECT TYPE OF INPUT FCN. : ',ch,'ISRACOU','I');
00173      2  1 drb_input   (ch,ix,iy,'');
00174      2  2 WITH tc DO CASE ch OF
00175      2  3    'I':  BEGIN
00176      2  3          inputfcn := evalfcn ('1');
00177      2  3          writeline (aud,'INPUT FUNCTION IS IMPULSE');
00178      2  2          END;
00179      2  3    'S':  BEGIN
00180      2  3          readvary ('ENTER STEP COEFFICIENT    : ',str,'1');
00181      2  3          inputfcn := evalfcn ('$STEP(' + str + ')');
00182      2  3          drb_input   (ch,ix,iy,str);
00183      2  3          writeline (aud,'INPUT FUNCTION IS STEP OF SIZE ' + str);
00184      2  2          END;
00185      2  3    'R':  BEGIN
00186      2  3          readvary ('ENTER RAMP COEFFICIENT    : ',str,'1');
00187      2  3          inputfcn := evalfcn ('$RAMP(' + str + ')');
00188      2  3          drb_input   (ch,ix,iy,str);
00189      2  3          writeline (aud,'INPUT FUNCTION IS RAMP OF SIZE ' + str);
00190      2  2          END;
00191      2  3    'A':  BEGIN
00192      2  3          readvary ('ENTER ACCELERATION COEF.  : ',str,'1');
00193      2  3          inputfcn := evalfcn ('$ACC(' + str + ')');
00194      2  3          drb_input   (ch,ix,iy,str);
00195      2  3          writeline (aud,'INPUT FUNCTION IS ACCELERATION OF SIZE ' + str);
00196      2  2          END;
00197      2  3    'C':  BEGIN
00198      2  3          readvary ('ENTER STEP COEFFICIENT    : ',str,'0');
00199      2  3          readvary ('ENTER RAMP COEFFICIENT    : ',str1,'0');
00200      2  3          readvary ('ENTER ACCELERATION COEF.  : ',str2,'0');
00201      2  3          inputfcn := evalfcn ('$SRA(' + str + ',' 
00202      2  3          + str1 + ',' + str2 + ')');
00203      2  3          drb_input   (ch,ix,iy,'S=' + str + ',R=' + str1 + ',A=' + str2);
00204      2  3          writeline (aud,'INPUT FUNCTION IS COMBINATION');
00205      2  3          writeline (aud,'STEP SIZE IS ' + str);
00206      2  3          writeline (aud,'RAMP SIZE IS ' + str1);
00207      2  3          writeline (aud,'ACC. SIZE IS ' + str2);
00208      2  2          END;
00209      2  3    'O':  BEGIN
00210      2  3          readvary ('ENTER OSCILLATOR FREQ(rps): ',str,'1');
00211      2  3          readvary ('ENTER OSCILLATOR MAGNITUDE: ',str1,'1');
00212      2  3          inputfcn := evalfcn ('$DOSC(' + str + ')*' + str1);
00213      2  3          drb_input   (ch,ix,iy,str + ' rps');
00214      2  3          writeline (aud,'INPUT FUNCTION IS OSCILLATOR OF FREQUENCY ' 
00215      2  3                          + str + ' rps');
00216      2  3          writeline (aud,'AND HAS A MAGNITUDE OF ' 
00217      2  3                          + str1);
00218      2  2          END;
00219      2  3    'U':  BEGIN
00220      2  4          CASE workplane OF

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00221      2  4             'S':  revfcn ('ENTER USER FUNCTION       : ',inputfcn,str,'KS','1');
00222      2  4             'Z':  revfcn ('ENTER USER FUNCTION       : ',inputfcn,str,
00223      2  4                                                                 goodplanes,'1');
00224      2  3             END;
00225      2  3          drb_input   (ch,ix,iy,str);
00226      2  3          writeline (aud,'INPUT FUNCTION IS USER DEFINED, NAME IS ' + str);
00227      2  2          END;
00228      2  1    END;
00229      1  0 END;
00230   C  1  0 {------------------------------}
00231      2  0 PROCEDURE readgain (ix,iy : integer);
00232      2  0 VAR
00233      2  0    ch             : char;
00234      2  0    str,str1       : anystring;
00235      2  0    fn             : fcn;
00236      2  1 BEGIN
00237      2  1 readch   ('SELECT TYPE GAIN CONTROL  : ',ch,'OS','O');
00238      2  1 drb_gain    (ch,ix,iy,'');
00239      2  1 WITH tc DO 
00240      2  2    BEGIN
00241      2  3    CASE ch OF
00242      2  4       'O':  BEGIN
00243      2  4             count := 1;
00244      2  4             revfcn ('ENTER GAIN                : ',fn,str,'K','1');
00245      2  4             compgain[1] := roffcn(fn);
00246      2  4             drb_gain    (ch,ix,iy,str);
00247      2  3             END;           
00248      2  4       'S':  BEGIN
00249      2  4             str1 := '';
00250      2  4             readint  ('ENTER NUMBER OF GAIN STEPS: ',count,1,TIRARRLIM,5);
00251      2  4             IF readyes ('DO YOU WISH TO ENTER EACH GAIN ? ')
00252      2  4              THEN
00253      2  4               FOR k := 1 TO count DO
00254      2  5                  BEGIN
00255      2  5                  revfcn ('ENTER GAIN                : ',fn,str,'K','1');
00256      2  5                  compgain[k] := roffcn(fn);
00257      2  5                  IF k <> 1 THEN str1 := str1 + ',';
00258      2  5                  str1 := str1 + str;
00259      2  5                  END
00260      2  4              ELSE
00261      2  5               BEGIN
00262      2  5               revfcn   ('ENTER MINIMUM GAIN        : ',fn,str,'K','1');
00263      2  5               compgain[1] := roffcn(fn);
00264      2  5               str1 := str1 + str;
00265      2  5               revfcn   ('ENTER MAXIMUM GAIN        : ',fn,str,'K','5');
00266      2  5               compgain[count] := roffcn(fn);
00267      2  5               str1 := str1 + '..' + str;
00268      2  5               FOR k := 2 TO count-1 DO
00269      2  5                  compgain[k] := compgain[1] + (compgain[count] - compgain[1]) 
00270      2  5                                              * (k-1) / (count-1);
00271      2  4               END;
00272      2  4             drb_gain    (ch,ix,iy,str1);
00273      2  3             END;
00274      2  2       END;
00275      2  2    writeline (aud,'NUMBER OF GAIN STEPS      : ' + strofi(count,2));

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00276      2  2    FOR k := 1 TO count DO
00277      2  2       writeline(aud,'COMPENSATION GAIN ' + strofi(k,1) 
00278      2  2                       + ' : ' + strofr(compgain[k],13));
00279      2  1    END;
00280      1  0 END;
00281   C  1  0 {------------------------------}
00282      2  0 PROCEDURE readtime;
00283      2  0 VAR
00284      2  0    str            : anystring;
00285      2  0    fn             : fcn;
00286      2  1 BEGIN
00287      2  1 WITH tc DO 
00288      2  2    BEGIN
00289      2  2    tau := addtau (addtau (plantfcn.tau, feedbackfcn.tau), 
00290      2  2                   addtau (inputfcn.tau, samplerfcn.tau));
00291      2  2    IF (tau = UNDEFINED_REAL) AND 
00292      2  2       ((blocktype IN ['P','F']) OR (plantfcn.plane IN ['Z','W']))
00293      2  2     THEN 
00294      2  3      BEGIN
00295      2  3      revfcn ('ENTER SAMPLE PERIOD       : ',fn,str,'K','1');
00296      2  3      tau := roffcn(fn);
00297      2  2      END;
00298      2  2 
00299      2  2    IF blocktype IN ['P','F']
00300      2  2     THEN
00301      2  3      BEGIN
00302      2  3      readint ('ENTER NUMBER OF SUBSTEPS  : ',substeps,1,20,1);
00303      2  3      dt := tau / substeps;
00304      2  3      continuous := substeps <> 1;
00305      2  3      END
00306      2  2    ELSE IF tau = UNDEFINED_REAL
00307      2  2     THEN
00308      2  3      BEGIN
00309      2  3      substeps := 1;
00310      2  3      readreal ('ENTER TIME INCREMENT      : ',dt,1d-10,1d10,1);
00311      2  3      continuous := true;
00312      2  3      END
00313      2  2     ELSE
00314      2  3      BEGIN
00315      2  3      substeps := 1;
00316      2  3      dt := tau;
00317      2  3      continuous := false;
00318      2  2      END;  
00319      2  2 
00320      2  2    tmin := 0;
00321      2  2    readreal ('ENTER STOPPING TIME       : ',tmax,tmin,
00322      2  2      tmin + dt*(TIRARRSIZE-1),tmin + dt*(TIRARRSIZE-1)/3);
00323      2  2    writeline (aud,'STARTING TIME             = ' + strofr (tmin,13));
00324      2  2    writeline (aud,'STOPPING TIME             = ' + strofr (tmax,13));
00325      2  1    END;
00326      1  0 END;
00327   C  1  0 {------------------------------}
00328      1  1 BEGIN
00329      1  1 startcommand ('TIME RESPONSE',true);
00330      1  1 setcommand ('Closed_loop'); 

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00331      1  1 setcommand ('Feedback_sampler');
00332      1  1 setcommand ('Plant_sampler');
00333      1  1 setcommand ('Simple_system');
00334      1  1 readcommand (modi,'S',false,'ANALYZE TIME_RESPONSE');
00335      1  1 
00336      1  1 IF modi <> ESC
00337      1  1  THEN WITH tc DO 
00338      1  2   BEGIN
00339      1  2   config.overlaykill := false;
00340      1  3   CASE chofcom(modi) OF
00341      1  3      ' ',
00342      1  4      'S':  BEGIN
00343      1  4            blocktype := 'S';
00344      1  4            clearscreen;
00345      1  4            setcolor ('WHITE');
00346      1  4            position (33000,40000);  
00347      1  4            centergrprint ('TIME RESPONSE');
00348      1  4 
00349      1  4            drb_input   (' ',0,30000,'');
00350      1  4            drb_line    ('R',10000,30000,17000);
00351      1  4            drb_block   ('R',27000,30000,7000,'FUNCTION','');
00352      1  4            drb_line    ('R',43000,30000,12000);
00353      1  4            drb_end     (55000,30000,10000);
00354      1  4            revfcn ('ENTER FUNCTION OR EXPRSN  : ',plantfcn,str,goodplanes,'1');
00355      1  4            drb_block   ('R',27000,30000,7000,'',str);
00356      1  4            writeline (aud,'FUNCTION NAME         = ' + str);
00357      1  4 
00358      1  4            feedbackfcn := evalfcn('0');
00359      1  4            samplerfcn  := evalfcn('0');
00360      1  4            count       := 1;
00361      1  4            compgain[1] := 1;
00362      1  4            compdelay   := 0;
00363      1  4            zoh         := false;
00364      1  4 
00365      1  4            IF plantfcn.plane IN ['Z','W'] 
00366      1  4             THEN workplane := 'Z'
00367      1  4             ELSE workplane := 'S';
00368      1  4            readinput (0,30000);
00369      1  4            readtime;
00370      1  4            lable := 'FCN= ' + str;
00371      1  4            writeline (out,'Press "X" to continue...');
00372      1  4            graphicpause;  
00373      1  4            calctimer (tc);
00374      1  3            END;
00375      1  4      'C':  BEGIN
00376      1  4            readargument (str);
00377      1  4            blocktype := 'C';
00378      1  4            clearscreen;
00379      1  4            setcolor ('WHITE');
00380      1  4            position (33000,40000);  
00381      1  4            centergrprint ('CLOSED LOOP TIME RESPONSE');
00382      1  4            position (33000,38000);  
00383      1  4            centergrprint ('OPTIONAL SENSITIVITY ANALYSIS');
00384      1  4 
00385      1  4            drb_input   (' ',0,30000,'');

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00386      1  4            drb_summer  (15000,30000);
00387      1  4            drb_line    ('R',17000,30000,2000);
00388      1  4            drb_gain    (' ',19000,30000,'');
00389      1  4            drb_block   ('R',35000,30000,7000,'PLANT FUNCTION','');
00390      1  4            drb_line    ('R',51000,30000,4000);
00391      1  4            drb_end     (55000,30000,10000);
00392      1  4            drb_line    ('D',55000,30000,20000);
00393      1  4            drb_line    ('L',55000,10000,12000);
00394      1  4            drb_block   ('L',43000,10000,7000,'FEEDBACK FUNCTION','');
00395      1  4            drb_line    ('L',27000,10000,12000);
00396      1  4            drb_line    ('U',15000,10000,17000);
00397      1  4 
00398      1  4            revfcn ('ENTER PLANT FUNCTION      : ',plantfcn,string,
00399      1  4                                                   goodplanes,'1');
00400      1  4            drb_block   ('R',35000,30000,7000,'',string);
00401      1  4            writeline (aud,'PLANT FUNCTION            : ' + string);
00402      1  4 
00403      1  5            CASE plantfcn.plane OF
00404      1  5               'K':  revfcn ('ENTER FEEDBACK FUNCTION   : ',feedbackfcn,string,
00405      1  5                                                            goodplanes,'1');
00406      1  5               'S':  revfcn ('ENTER FEEDBACK FUNCTION   : ',feedbackfcn,string,
00407      1  5                                                            'KS','1');
00408      1  5               'Z',
00409      1  5               'W':  revfcn ('ENTER FEEDBACK FUNCTION   : ',feedbackfcn,string,
00410      1  5                                                            'KZW','1');
00411      1  4               END;
00412      1  4            drb_block   ('L',43000,10000,7000,'',string);
00413      1  4            writeline (aud,'FEEDBACK FUNCTION         : ' + string);
00414      1  4 
00415      1  4            workplane := 'S';
00416      1  4            IF plantfcn.plane IN ['Z','W'] THEN workplane := 'Z';
00417      1  4            IF feedbackfcn.plane IN ['Z','W'] THEN workplane := 'Z';
00418      1  4            samplerfcn  := evalfcn('0');
00419      1  4            readinput (0,30000);
00420      1  4            readgain  (19000,30000);
00421      1  4            readtime;
00422      1  4            compdelay := 0;
00423      1  4            zoh := false;
00424      1  4            lable := 'CLOSED LOOP';
00425      1  4            writeline (out,'Press "X" to continue...');
00426      1  4            graphicpause;  
00427      1  4            calctimer (tc);
00428      1  3            END;
00429      1  4      'P':  BEGIN
00430      1  4            readargument (str);
00431      1  4            blocktype := 'P';
00432      1  4            clearscreen;
00433      1  4            setcolor ('WHITE');
00434      1  4            position (33000,40000);  
00435      1  4            centergrprint ('CLOSED LOOP INTER SAMPLE TIME RESPONSE');
00436      1  4            position (33000,38000);  
00437      1  4            centergrprint ('SAMPLER IN PLANT LOOP');
00438      1  4            position (33000,36000);  
00439      1  4            centergrprint ('OPTIONAL SENSITIVITY ANALYSIS');
00440      1  4 

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00441      1  4            drb_input   (' ',0,30000,'');
00442      1  4            drb_summer  (15000,30000);
00443      1  4            drb_sampler ('R',17000,30000,'');
00444      1  4            drb_line    ('R',22000,30000,4000);
00445      1  4            drb_block   ('R',26000,30000,4000,'ZOH (opt)','');
00446      1  4            drb_gain    (' ',36000,30000,'');
00447      1  4            drb_line    ('R',52000,30000,3000);
00448      1  4            drb_line    ('D',55000,30000,3000);
00449      1  4            drb_block   ('D',55000,27000,5000,'DELAY (opt)','');
00450      1  4            drb_block   ('D',55000,22000,7000,'PLANT FUNCTION (S)','');
00451      1  4            drb_block   ('D',55000,17000,7000,'PLANT FUNCTION (Z,W)','');
00452      1  4            drb_line    ('D',55000,11000,1000);
00453      1  4            drb_end     (55000,10000,10000);
00454      1  4            drb_line    ('L',55000,10000,12000);
00455      1  4            drb_block   ('L',43000,10000,7000,'FEEDBACK FUNCTION (S)','');
00456      1  4            drb_line    ('L',27000,10000,12000);
00457      1  4            drb_line    ('U',15000,10000,17000);
00458      1  4 
00459      1  4            revfcn ('ENTER PLANT FUNCTION (S)  : ',plantfcn,string,'KS','1');
00460      1  4            drb_block   ('D',55000,22000,7000,'',string);
00461      1  4            writeline (aud,'PLANT FUNCTION (S)        : ' + string);
00462      1  4 
00463      1  4            revfcn ('ENTER PLANT FUNCTION (Z)  : ',samplerfcn,string,'KZW','1');
00464      1  4            drb_block   ('D',55000,17000,7000,'',string);
00465      1  4            writeline (aud,'PLANT FUNCTION (Z)        : ' + string);
00466      1  4 
00467      1  4            revfcn ('ENTER FEEDBACK FUNCTION   : ',feedbackfcn,string,'KS','1');
00468      1  4            drb_block   ('L',43000,10000,7000,'',string);
00469      1  4            writeline (aud,'FEEDBACK FUNCTION         : ' + string);
00470      1  4 
00471      1  4            zoh := readyes ('ZERO ORDER HOLD (Y/N)     ? ');
00472      1  4            IF zoh 
00473      1  4             THEN string := '(1-1/Z) / S' 
00474      1  4             ELSE string := '1';
00475      1  4            drb_block ('R',26000,30000,4000,'',string);
00476      1  4 
00477      1  4            revfcn ('ENTER DELAY TIME (sec)    : ',fn,string,'K','0');
00478      1  4            compdelay := roffcn(fn);
00479      1  4            IF compdelay = 0 
00480      1  4             THEN string := 'no delay';
00481      1  4            drb_block ('D',55000,27000,5000,'',string);
00482      1  4 
00483      1  4            workplane := 'Z';
00484      1  4            readinput (0,30000);
00485      1  4            readgain  (36000,30000);
00486      1  4            readtime;
00487      1  4            drb_sampler ('R',17000,30000,'T=' + strofr (tau,9));
00488      1  4            lable := 'PLANT SAMPLER CLOSED LOOP';
00489      1  4            writeline (out,'Press "X" to continue...');
00490      1  4            graphicpause;  
00491      1  4            calctimer (tc);
00492      1  3            END;
00493      1  4      'F':  BEGIN
00494      1  4            readargument (str);
00495      1  4            blocktype := 'F';

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00496      1  4            clearscreen;
00497      1  4            setcolor ('WHITE');
00498      1  4            position (33000,40000);  
00499      1  4            centergrprint ('CLOSED LOOP INTER SAMPLE TIME RESPONSE');
00500      1  4            position (33000,38000);  
00501      1  4            centergrprint ('SAMPLER IN FEEDBACK LOOP');
00502      1  4            position (33000,36000);  
00503      1  4            centergrprint ('OPTIONAL SENSITIVITY ANALYSIS');
00504      1  4 
00505      1  4            drb_input   (' ',0,30000,'');
00506      1  4            drb_summer  (15000,30000);
00507      1  4            drb_line    ('R',17000,30000,2000);
00508      1  4            drb_gain    (' ',19000,30000,'');
00509      1  4            drb_block   ('R',35000,30000,7000,'PLANT FUNCTION','');
00510      1  4            drb_line    ('R',51000,30000,4000);
00511      1  4            drb_end     (55000,30000,10000);
00512      1  4            drb_line    ('D',55000,30000,7000);
00513      1  4            drb_block   ('D',55000,23000,7000,'FEEDBACK FCN (S)','');
00514      1  4            drb_line    ('D',55000,17000,7000);
00515      1  4            drb_line    ('L',55000,10000,5000);
00516      1  4            drb_sampler ('L',50000,10000,'');
00517      1  4            drb_block   ('L',45000,10000,4000,'ZOH (opt)','');
00518      1  4            drb_block   ('L',35000,10000,7000,'FEEDBACK FCN (Z)','');
00519      1  4            drb_line    ('L',19000,10000,2000);
00520      1  4            drb_line    ('U',17000,10000,4000);
00521      1  4            drb_block   ('U',17000,14000,5000,'DELAY (opt)','');
00522      1  4            drb_line    ('L',17000,20000,2000);
00523      1  4            drb_line    ('U',15000,20000,7000);
00524      1  4 
00525      1  4            revfcn ('ENTER PLANT FUNCTION      : ',plantfcn,string,'KS','1');
00526      1  4            drb_block   ('R',35000,30000,7000,'',string);
00527      1  4            writeline (aud,'PLANT FUNCTION            : ' + string);
00528      1  4 
00529      1  4            revfcn ('ENTER FEEDBACK FCN (S)    : ',feedbackfcn,string,'KS','1');
00530      1  4            drb_block   ('D',55000,23000,7000,'',string);
00531      1  4            writeline (aud,'FEEDBACK FUNCTION (S)     : ' + string);
00532      1  4 
00533      1  4            revfcn ('ENTER FEEDBACK FCN (Z)    : ',samplerfcn,string,'KZW','1');
00534      1  4            drb_block   ('L',35000,10000,7000,'',string);
00535      1  4            writeline (aud,'FEEDBACK FUNCTION (Z)     : ' + string);
00536      1  4 
00537      1  4            zoh := readyes ('ZERO ORDER HOLD (Y/N)     ? ');
00538      1  4            IF zoh 
00539      1  4             THEN string := '(1-1/Z) / S' 
00540      1  4             ELSE string := '1';
00541      1  4            drb_block ('L',45000,10000,4000,'',string);
00542      1  4 
00543      1  4            revfcn ('ENTER DELAY TIME (sec)    : ',fn,string,'K','0');
00544      1  4            compdelay := roffcn(fn);
00545      1  4            IF compdelay = 0 
00546      1  4             THEN string := 'no delay';
00547      1  4            drb_block ('U',17000,14000,5000,'',string);
00548      1  4 
00549      1  4            workplane := 'Z';
00550      1  4            readinput (0,30000);

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

-LINE-IDC-PL-SL-

00551      1  4            readgain  (19000,30000);
00552      1  4            readtime;
00553      1  4            drb_sampler ('L',50000,10000,'T=' + strofr (tau,9));
00554      1  4            lable := 'FEEDBACK SAMPLER CLOSED LOOP';
00555      1  4            writeline (out,'Press "X" to continue...');
00556      1  4            graphicpause;  
00557      1  4            calctimer (tc);
00558      1  3            END;
00559      1  2      END;
00560      1  2 
00561      1  2   readvary ('ENTER CURVE NAME         : ',name,'TR');
00562      1  2   cix := createcurve (C_TIR,name,lable);
00563      1  2   config.overlaykill := true;
00564      1  2   curve.data[cix].tcptr^ := tc;
00565      1  2   readvary ('ENTER ADDITIONAL CURVES  : ',st,'');
00566      1  2   unread ('PLOT NEW ' + name + ' ' + st);
00567      1  2   END
00568      1  1  ELSE readargument (str);
00569      1  1 clearscreen;
00570      0  0 END;
00571   C  0  0 {=============================================================================}
00572      0  0 END.

TIMER                                                           23-Dec-1988 11:20:18    VAX Pascal V3.7-254                Page   12
INCA                            Pascal Compilation Statistics   20-Oct-1988 14:35:36    DUA1:[QPLOT.INCA.SOURCE]TIMER.PAS;534 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               21268  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        49        40
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        19        26
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         6        10
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        20        32
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39        18        46
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        42        20
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        89        44
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292         1         0
DUA1:[QPLOT.INCA.SOURCE]CURVE.PEN;1                      379       302        80
DUA1:[QPLOT.INCA.SOURCE]BLOCK.PEN;1                       72        38        53
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289        84        29
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248       109        44
DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PEN;1                    144         0         0
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184         0         0
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         0         0
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         2         1



INCA                                                            23-Dec-1988 11:23:14    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  30-Aug-1988 15:26:54    DUA1:[QPLOT.INCA.SOURCE]MAIN.PAS;1020 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT   ('INCA'),
00002      0  0   INHERIT ('QLIBHOME:STANDARD',
00003      0  0            'QLIBHOME:GENERAL',
00004      0  0            'QLIBHOME:DIRECTORY',
00005      0  0            'QLIBHOME:IO',
00006      0  0            'QLIBHOME:STRING',
00007      0  0            'QLIBHOME:COLOR',
00008      0  0            'QLIBHOME:FIG',
00009      0  0            'QLIBHOME:UTILITIES',
00010      0  0            'QLIBHOME:HANDLER',
00011      0  0            'QLIBHOME:IOBASE',
00012      0  0            'FCN','FCNIO','UTIL',
00013      0  0            'CONVERT','LOCUS','FREQR','DESCF','TIMER','PLOT','MISC') ]
00014      0  0 PROGRAM inca;
00015   C  0  0 {-----------------------------------------------------------------------------}
00016      1  0 PROCEDURE main;
00017      1  0 VAR
00018      1  0    go       : boolean;
00019      1  0    com,sel  : command_type;
00020      1  0    arg      : anystring;
00021      1  1 BEGIN   
00022   C  1  1 { INITIALIZE GLOBAL VARIABLES }
00023      1  1 addDEF ('BOUNDARY',     'RED');
00024      1  1 addDEF ('C1',           'GREEN');
00025      1  1 addDEF ('C2',           'BLUE');
00026      1  1 addDEF ('C3',           'CYAN');
00027      1  1 addDEF ('C4',           'MAGENTA');
00028      1  1 addDEF ('C5',           'BLUE MAGENTA');
00029      1  1 addDEF ('C6',           'BLUE CYAN');
00030      1  1 addDEF ('C7',           'GREEN CYAN');
00031      1  1 addDEF ('C8',           'GREEN YELLOW');
00032      1  1 addDEF ('C9',           'YELLOW');
00033      1  1 addDEF ('C10',          'RED');
00034      1  1 addDEF ('C11',          'LAVENDER');
00035      1  1 addDEF ('C12',          'LIGHT BLUE');
00036      1  1 addDEF ('C13',          'PURPLE');
00037      1  1 addDEF ('C14',          'BROWN');
00038      1  1 addDEF ('C15',          'PINK');
00039      1  1 addDEF ('FILL',         'BLACK');
00040      1  1 addDEF ('FIND',         'MAGENTA');
00041      1  1 addDEF ('GIN_SELECT',   'GREEN');
00042      1  1 addDEF ('GIN_WINDOW',   'MAGENTA');
00043      1  1 addDEF ('HELP',         'RED');
00044      1  1 addDEF ('LOGOEDGE',     'YELLOW');
00045      1  1 addDEF ('LOGOFILL',     'RED');
00046      1  1 addDEF ('LOGOLINE',     'ORANGE');
00047      1  1 addDEF ('MAGNITUDE',    'GREEN');
00048      1  1 addDEF ('PHASE',        'BLUE');
00049      1  1 addDEF ('POLE',         'BLUE CYAN');
00050      1  1 addDEF ('PROJECT',      'CYAN');
00051      1  1 addDEF ('T1',           'GREEN');
00052      1  1 addDEF ('T2',           'GREEN 2 CYAN');
00053      1  1 addDEF ('T3',           'CYAN');
00054      1  1 addDEF ('T4',           'BLUE CYAN');
00055      1  1 addDEF ('T5',           'BLUE');

INCA                                                            23-Dec-1988 11:23:14    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  30-Aug-1988 15:26:54    DUA1:[QPLOT.INCA.SOURCE]MAIN.PAS;1020 (1)

-LINE-IDC-PL-SL-

00056      1  1 addDEF ('T6',           'BLUE MAGENTA');
00057      1  1 addDEF ('T7',           'MAGENTA');
00058      1  1 addDEF ('T8',           'RED');
00059      1  1 addDEF ('T9',           'ORANGE');
00060      1  1 addDEF ('T10',          'BROWN');
00061      1  1 addDEF ('TIME',         'RED');
00062      1  1 addDEF ('ZERO',         'CYAN');
00063      1  1 
00064      1  1 arg := registerqplot ('INCA','QPLOTHOME:INCA.HLB','FUNCTION COMPUTE');
00065      1  1 curvecolormax := 15;
00066      1  1 startclock  := clock; 
00067      1  1 
00068      1  1 go := arg <> '';
00069      1  1 IF NOT go
00070      1  1  THEN
00071      1  2   BEGIN
00072      1  2   clearscreen;
00073      1  2   incalogo (10000,40000,600);
00074      1  2   newlogo (6400,32000,500);
00075      1  2   wait (2);
00076      1  2   clearscreen;
00077      1  1   END;
00078      1  1 unread (arg);
00079      1  1 
00080      1  2 REPEAT
00081      1  2    selectproject (sel,true);
00082      1  2    IF sel = 'New'
00083      1  2     THEN readlogicalname ('ENTER PROJECT:  ',sel,ESC)
00084      1  2    ELSE IF ((sel <> '') AND (sel <> ESC)) 
00085      1  2     THEN
00086      1  2    ELSE IF arg = ''
00087      1  2     THEN readlogicalname ('ENTER PROJECT:  ',sel,ESC)
00088      1  2     ELSE sel := arg;
00089      1  1    UNTIL sel <> ESC;
00090      1  1 readargument (arg);
00091      1  1 project := strtrunc (sel,9);
00092      1  1 loadproject (project);
00093      1  1 
00094      1  1 viewnews (out);
00095      1  1 IF NOT go THEN pause;
00096      1  1 IF terminal.name = 'NONE    '
00097      1  1  THEN opensourcefile (project,'.SOU')
00098      1  1  ELSE opensourcefile ('INCA.SOU','.SOU');
00099      1  1 openaudit (project + '.AUD');
00100      1  1 writeline (aud,pad('','=',128));
00101      1  1 writeline (aud,INCAVERSION + '       ' + strtime);
00102      1  1 writeline (aud,'Terminal type is ' + terminal.name);
00103      1  1 writeline (aud,'');
00104      1  1 writeline (aud,'Project ' + project);
00105      1  1 writeline (aud,pad('','=',128));
00106      1  1 
00107      1  1 IF havehandler THEN ESTABLISH (handler);
00108      1  1 go := true;
00109      1  2 REPEAT
00110      1  2    startcommand ('INCA',true);

INCA                                                            23-Dec-1988 11:23:14    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  30-Aug-1988 15:26:54    DUA1:[QPLOT.INCA.SOURCE]MAIN.PAS;1020 (1)

-LINE-IDC-PL-SL-

00111      1  2    setcommand ('Analyze');
00112      1  2    setcommand ('Curve');
00113      1  2    setcommand ('Function');
00114      1  2    setcommand ('proJect');
00115      1  2    setcommand ('Misc');
00116      1  2    setcommand ('Plot');
00117      1  2    setcommand ('Set');
00118      1  2    setcommand ('Utilities');
00119      1  2    setcommand ('View');
00120      1  2    setcommand ('Xit');
00121      1  2    readcommand (com,ESC,true,'');
00122      1  2    IF chofcom(com) IN ['A'..'Z']
00123      1  2     THEN
00124      1  3      BEGIN
00125      1  3      writeline (aud,pad('','=',128));
00126      1  3      writeline (aud,com + ' executed.         ' + strtime);
00127      1  2      END;
00128      1  3    CASE chofcom(com) OF
00129      1  4       'A':  BEGIN
00130      1  4             startcommand ('ANALYZE',true);
00131      1  4             setcommand ('Describing_function');
00132      1  4             setcommand ('Frequency_response');
00133      1  4             setcommand ('Root_locus');
00134      1  4             setcommand ('Time_response');
00135      1  4             readcommand (com,ESC,false,'ANALYZE');
00136      1  5             CASE chofcom(com) OF
00137      1  5                'D':  descf;
00138      1  5                'F':  freqr;
00139      1  5                'R':  locus;
00140      1  5                'T':  timer;
00141      1  5                ESC:  ;
00142      1  4                END;
00143      1  3             END;
00144      1  3       'C':  curvecommand;
00145      1  3       'F':  functioncommand;
00146      1  3       'J':  projectcommand;
00147      1  4       'M':  BEGIN
00148      1  4             startcommand ('MISC',true);
00149      1  4             setcommand ('Convert_INCA_200');
00150      1  4             setcommand ('No_error_trap');
00151      1  4             setcommand ('String_Test');
00152      1  4             setcommand ('Zap_screen');
00153      1  4             readcommand (com,ESC,false,'MISC');
00154      1  5             CASE chofcom(com) OF
00155      1  5                'C':  convert;
00156      1  5                'N':  IF readyes ('Do you REALLY want NO error handling ? ')
00157      1  5                       THEN BEGIN  REVERT;  havehandler := false;  END;
00158      1  6                'S':  BEGIN
00159      1  6                      writeline (out,strofr (-1.2e+35,0));
00160      1  6                      writeline (out,strofr (-1.2e+10,0));
00161      1  6                      writeline (out,strofr (-1234.5,0));
00162      1  6                      writeline (out,strofr (-1,0));
00163      1  6                      writeline (out,strofr (-000.345,0));
00164      1  6                      writeline (out,strofr (-1.2e-10,0));
00165      1  6                      writeline (out,strofr (-1.2e-35,0));

INCA                                                            23-Dec-1988 11:23:14    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  30-Aug-1988 15:26:54    DUA1:[QPLOT.INCA.SOURCE]MAIN.PAS;1020 (1)

-LINE-IDC-PL-SL-

00166      1  6                      writeline (out,strofr (0,0));
00167      1  6                      writeline (out,strofr (+1.2e-35,0));
00168      1  6                      writeline (out,strofr (+1.2e-10,0));
00169      1  6                      writeline (out,strofr (+000.345,0));
00170      1  6                      writeline (out,strofr (+1,0));
00171      1  6                      writeline (out,strofr (+1234.5,0));
00172      1  6                      writeline (out,strofr (+1.2e+10,0));
00173      1  6                      writeline (out,strofr (+1.2e+35,0));
00174      1  6                      pause;
00175      1  5                      END;
00176      1  5                'Z':  zap;
00177      1  5                ESC:  ;
00178      1  4                END;
00179      1  3             END;
00180      1  3       'P':  plot;
00181      1  3       'S':  setter;
00182      1  3       'U':  utilities;
00183      1  3       'V':  view;
00184      1  3       'X':  xit (go);
00185      1  3       ESC:  ;
00186      1  3       OTHERWISE
00187      1  4             BEGIN
00188      1  4             writeline (out,'Bad command -- try "HELP"');
00189      1  4             readargument (arg);
00190      1  3             END;
00191      1  2       END;
00192      1  2    IF err <> ''
00193      1  2     THEN 
00194      1  3      BEGIN
00195      1  3      clearscreen;
00196      1  3      writeerror;
00197      1  3      IF err = 'FATAL ERROR' THEN BEGIN  REVERT;  resignal;  END;
00198      1  3      err := '';
00199      1  2      END;
00200      1  1    UNTIL NOT go;
00201      1  1 deletejournal;
00202      0  0 END;
00203   C  0  0 {-----------------------------------------------------------------------------}
00204      0  1 BEGIN
00205      0  1 main;
00206      0  0 END.

INCA                                                            23-Dec-1988 11:23:14    VAX Pascal V3.7-254                Page    5
INCA                            Pascal Compilation Statistics   30-Aug-1988 15:26:54    DUA1:[QPLOT.INCA.SOURCE]MAIN.PAS;1020 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                7735  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        37        30
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20         2        10
DUA1:[QPLOT.QPLOT.SOURCE]DIRECTORY.PEN;1                  45         0         0
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        64        31
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        21        29
DUA1:[QPLOT.QPLOT.SOURCE]COLOR.PEN;1                      93         7         8
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        30        14
DUA1:[QPLOT.QPLOT.SOURCE]UTILITIES.PEN;1                 105         9         9
DUA1:[QPLOT.QPLOT.SOURCE]HANDLER.PEN;1                    39         8        21
DUA1:[QPLOT.QPLOT.SOURCE]IOBASE.PEN;1                    104        10        10
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        19         8
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184         7         4
DUA1:[QPLOT.INCA.SOURCE]UTIL.PEN;1                       289        31        11
DUA1:[QPLOT.INCA.SOURCE]CONVERT.PEN;1                    114         1         1
DUA1:[QPLOT.INCA.SOURCE]LOCUS.PEN;1                      249        53        21
DUA1:[QPLOT.INCA.SOURCE]FREQR.PEN;1                      318         1         0
DUA1:[QPLOT.INCA.SOURCE]DESCF.PEN;1                      125         1         1
DUA1:[QPLOT.INCA.SOURCE]TIMER.PEN;1                      202         1         0
DUA1:[QPLOT.INCA.SOURCE]PLOT.PEN;1                       446         1         0
DUA1:[QPLOT.INCA.SOURCE]MISC.PEN;1                       219        10         5



