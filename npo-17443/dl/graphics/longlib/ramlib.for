C
C *** LAST REVISED ON 20-AUG-1987 16:41:49.45
C *** SOURCE FILE: [DL.GRAPHICS.LONGLIB]RAMLIB.FOR
C
C ***********************************************************************
C
C	RAMTEK COMMUNICATION ROUTINES FOR THE LONGLIB GRAPHICS LIBRARY
C	THIS FILE CONTAINS ROUTINES FOR COMMUNICATION WITH EITHER
C	A 9400 SERIES 1280X1024 (IDEV=1) OR A 512X512 (IDEV=2) RAMTEK DISPLAY.
C	THE SMALL RAMTEK DOES NOT SUPPORT ALL THE OPERATIONS
C
C	THESE ARE, OF NECESSITY, VERY MACHINE DEPENDENT.  VERSION 5
C	ROUTINES HAVE BE EXTENSIVELY MODIFIED FROM VERSION 4.
C
C ***********************************************************************
C
	SUBROUTINE RAMOPEN(ICHAN,IDEV,IDDEV,IERR)
C
C	OPEN RAMTEK I/O CHANNEL
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	IDEV	(I)	DEVICE TYPE (1 OR 2)
C			 TYPE 1 WILL USE VIRTUAL I/O
C			 TYPE 2 WILL USE PHYSICAL I/O
C	OUTPUTS:
C
C	ICHAN	(I)	RETURNED CHANNEL NUMBER
C			 -1 RETURNED ON OPEN ERROR
C	IDDEV	(I)	RETURNED RAMTEK DEVICE NUMBER (0-3)
C	IERR	(I)	RETURNED ERROR CODE (0=NO ERROR)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
C
	CHARACTER*2 DEVICE/'RM'/	! LOGICAL DEVICE NAME FOR RAMTEK
	CHARACTER*65 TRANS		! TRANSLATION FOR LOGICAL NAME
	INTEGER*2 MSG(3),IOSB(4),RET1,ICH
	INTEGER*4 RET,SYS$ASSIGN,SYS$QIOW,SYS$ALLOC,SYS$DALLOC
	INTEGER*4 IO$_CREATE,IO$M_MOUNT,SYS$TRNLOG
	EXTERNAL IO$_CREATE,IO$M_MOUNT
	EQUIVALENCE (RET,RET1)
C
	IERR=0
	IOTYPE=IDEV			! STORE RAMTEK TYPE
	MWID=1				! LINE WIDTH
	IF (IDEV.EQ.2) THEN		! SCREEN SIZE
		IXMAX=511
		IYMAX=511
	ELSE
		IXMAX=1279
		IYMAX=1023
	ENDIF
C
C	NOTE THAT THE FOLLOWING LINES OF CODE ARE REQUIRED ONLY IF THERE
C	ARE MULTIPLE RAMTEKS USING THE SAME UNIT.  TO DISTINQUISH
C	THE TYPE OF DEVICE WE ASSUME THAT ALL RAMTEKS ARE NAMED SUCH
C	THAT THE LAST DIGIT OF DEVICE NAME CORESPONDS TO RAMTEK INTERNAL
C	DEVICE NUMBER (I.E. "RMA0" => DEVICE 0.  SEE DOCUMENTATION.
C
	IODEV=0				! DEFAULT DEVICE NUMBER
	RET = SYS$TRNLOG(DEVICE,IOSB,TRANS,,,)	! GET LOGICAL NAME TRANSLATION
	IF (RET.NE.1) THEN			! IF RETURN IS NOT NORMAL
		ICHAN = -1			! RETURN AN ERROR
		IERR = RET1
		RETURN
	ENDIF
	IF (TRANS(4:4).EQ.'1') IODEV=1
	IF (TRANS(4:4).EQ.'2') IODEV=2
	IF (TRANS(4:4).EQ.'3') IODEV=3
C
	IDDEV=IODEV				! RETURN RAMTEK DEVICE NUMBER
C
C	ALLOCATE RAMTEK DEVICE
C
	RET = SYS$ALLOC(DEVICE,,,)
	IF (RET.NE.1.AND.RET.NE.1601) THEN	! IF RETURN IS NOT NORMAL
		ICHAN = -1			! AND DEVICE IS NOT ALREADY
		IERR = RET1			! ALLOCATED, ERROR RETURN
		RETURN
	ENDIF
C
C	ASSIGN AN I/O CHANNEL
C
	RET = SYS$ASSIGN(DEVICE,ICH,,)
	IF (RET.NE.1.OR.ICH.LT.1) THEN		! IF RETURN IS NOT NORMAL
		IERR = RET1			! RETURN AN ERROR
		RET = SYS$DALLOC(DEVICE,,)	! DEALLOCATE
		ICHAN = -1
		RETURN
	ENDIF
	ICHAN=ICH
C
C	CREATE THE I/O CHANNEL WITH A MOUNT OPTION
C
	IF (IDEV.EQ.2) RETURN			! DON'T NEED FOR PHYS IO
	IJK = IOR(%LOC(IO$_CREATE),%LOC(IO$M_MOUNT))
	RET = SYS$QIOW(,%VAL(ICHAN),%VAL(IJK),IOSB,,,,,,,,)
	IF (RET.NE.1) THEN			! IF ABORNMAL RETURN
		IERR = RET1			! RETURN ERROR
		CALL SYS$DASSGN(%LOC(ICHAN))	! DE-ASSIGN CHANNEL
		RET = SYS$DALLOC(DEVICE,,)	! DE-ALLOCATE DEVICE
		ICHAN = -1
		RETURN
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE RAMCLOSE(ICHAN)
	ENTRY REFDIS
C
C	CLOSE RAMTEK CHANNEL, DEALLOCATE DEVICE (WE DON'T CHECK FOR ERRORS)
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL NUMBER
C
	INTEGER*2 ICH
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
C
	ICH=ICHAN
	CALL SYS$DASSGN(%LOC(ICH))
	CALL SYS$DALLOC(DEVICE)
	RETURN
	END
C
C
	SUBROUTINE RMRESET(ICHAN,IERR)
C
C	SEND CODES TO RESET RAMTEK DISPLAY
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL NUMBER
C
	INTEGER*2 IOP
	IOP='0500'X
	CALL RAMOUT(ICHAN,IOP,2,IERR)
	RETURN
	END
C
C
	SUBROUTINE RAMOUT(ICHAN,M,N,IERR)
C
C	OUTPUT BYTE DATA TO RAMTEK DISPLAY DEVICE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	M	(B)	BYTE ARRAY OF DATA
C	N	(I)	NUMBER OF BYTES
C	IERR	(I)	STATUS ERROR
C
	BYTE M(1)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MC
	INTEGER*2 IOSB(4)
	INTEGER*4 RET,SYS$QIOW, RET1
	EXTERNAL IO$_WRITEVBLK,IO$_WRITEPBLK
	INTEGER*4 IO$M_MOUNT,IO$M_DMOUNT
	EXTERNAL IO$M_MOUNT,IO$M_DMOUNT
C
C	WRITE OUTPUT DATA TO RAMTEK CHANNEL
C
	IF (IOTYPE.EQ.2) THEN
	 RET=SYS$QIOW(,%VAL(ICHAN),IO$_WRITEPBLK,IOSB,,,M,%VAL(N),,,,)
	ELSE
	 RET=SYS$QIOW(,%VAL(ICHAN),IO$_WRITEVBLK,IOSB,,,M,%VAL(N),,,,)
	ENDIF
	IERR=0
C
C	CHECK FOR ERROR
C
	IF (RET.NE.1) THEN
		IERR=IOSB(1)
		RETURN
	ENDIF
C
C	CHECK FOR TIME OUT MOUNT ERROR
C
	IF (IOSB(1).EQ.124) THEN	! REMOUNT IF NEEDED
	 IJK = IOR(%LOC(IO$_WRITEVBLK),%LOC(IO$M_MOUNT))
	 RET=SYS$QIOW(,%VAL(ICHAN),%VAL(IJK),IOSB,,,M,%VAL(N),,,,)
	 IF (RET.NE.1) IERR=IOSB(1)
	ENDIF
	RETURN
	END
C
	SUBROUTINE RMPLOT(ICHAN,N,M,ICOL,IERR)
C
C	PLOT A LINE OF CONNECTED VECTORS
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	N	(I)	NUMBER OF VECTOR PAIRS (MAX 128)
C	M	(I)	ARRAY OF X,Y LOCATIONS OF POINTS
C	ICOL	(I)	PLOTTING COLOR (0-1024 FOR LARGE, 0-255 SMALL)
C	IERR	(I)	IO ERROR (RETURNED)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
C
	DIMENSION M(1)
	INTEGER*2 IH(6),B(256)
C
C	ARRAYS FOR LINE WIDTH SIMULATION
C
	INTEGER MWP(7),MWX(44),MWY(44)
	DATA MWP/1,5,12,21,26,37,44/
	DATA MWX/0,-1,1,1,-1,-1,0,2,1,0,0,-1,0,-1,-1,-1,0,0,1,1,1,1,
     $   1,0,0,-1,-1,-1,-1,-1,-1,0,0,1,1,1,1,1,1,1,0,0,-1,-1/
	DATA MWY/0,0,1,-1,-1,0,2,0,0,-1,-1,0,-1,0,0,1,1,1,1,0,0,0,-1,
     $   -1,-1,-1,-1,0,0,1,1,1,1,1,1,0,0,0,-1,-1,-1,-1,-1,-1/
C
	IF (N.LE.0) RETURN
	IH(1)='0E0B'X
	IH(2)='8002'X
	IH(3)=ICOL
	NN=4*(N-1)
	IH(6)=NN
C
	DO 5 IN=1,2*N
		B(IN)=M(IN)
5	CONTINUE
	IF (MWID.EQ.0) MWID=1
	LW=MWP(MWID)
	IF (LW.EQ.1) THEN		! UNIT LINE WIDTH
		IH(4)=B(1)
		IH(5)=B(2)
		CALL RAMOUT(ICHAN,IH,12,IERR)
		IF (IERR.LT.0) GOTO 20
		IF (N.GT.1) CALL RAMOUT(ICHAN,B(3),NN,IERR)
	ELSE				! SIMULATED LINE WIDTH
	    DO 25 IW=1,LW
		DO 10 IN=1,N
			IX=2*IN-1
			IY=2*IN
			B(IX)=B(IX)+MWX(IW)
			B(IY)=B(IY)+MWY(IW)
			IF (B(IX).LT.0) B(IX)=0
			IF (B(IX).GT.IXMAX) B(IX)=IXMAX
			IF (B(IY).LT.0) B(IY)=0
			IF (B(IY).GT.IYMAX) B(IX)=IYMAX
10		CONTINUE
		IH(4)=B(1)
		IH(5)=B(2)
		CALL RAMOUT(ICHAN,IH,12,IERR)
		IF (IERR.LT.0) GOTO 20
		IF (N.GT.1) THEN
			CALL RAMOUT(ICHAN,B(3),NN,IERR)
			IF (IERR.LT.0) GOTO 20
		ENDIF
25	    CONTINUE
	ENDIF
20	RETURN
	END
C
	SUBROUTINE RMTEXTURE(ICHAN,ITEXT,IWIDE,ISIZE,IERR)
C
C	CHANGE PLOT LINE TEXTURE AND SCALING
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	ITEXT	(I)	TEXTURE CODE (0-15)
C	IWIDE	(I)	LINE WIDTH (IN RMPLOT)
C	ISIZE	(I)	PIXEL SCALING
C	IERR	(I)	STATUS ERROR
C
C	LINE TYPE BIT MAPS (16 BITS)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
C
	INTEGER ILT(16)		! LINE TYPE ARRAYS
	DATA ILT/-1,21845,13311,16191,8191,13119,16359,255,23485,
     $	 13107,7295,15567,22015,3855,24383,23485/
C
	INTEGER*2 IH(5)
	DATA IWD/16/
C
	MWID=IWIDE
	IF (IWIDE.LT.1) MWID=1
	IF (IWIDE.GT.7) MWID=7
C
	IH(1)='080C'X
	IH(2)='0008'X
	IT=ITEXT+1
	IF (IT.LT.1) IT=1
	IF (IT.GT.16) IT=MOD(IT,16)+1
	IH(3)=ILT(IT)
	IH(4)=IWD*256+ISIZE
	CALL RAMOUT(ICHAN,IH,8,IERR)
	RETURN
	END
C
	SUBROUTINE RMCLEAR(ICHAN,IERR)
C
C	CLEAR RAMTEK SCREEN
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IERR	(I)	STATUS ERROR
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
	INTEGER*2 IH
C
	IH='2B00'X			! RAMTEK FAST SCREEN CLEAR
	IF (IOTYPE.EQ.2) IH='0900'X	! RAMTEK SLOW SCREEN CLEAR
	CALL RAMOUT(ICHAN,IH,2,IERR)
	RETURN
	END
C
C
	SUBROUTINE RAMOUTIN(ICHAN,CMD,NC,BUF,NB,IERR)
C
C	READ FROM RAMTEK
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL NUMBER
C	CMD	(B)	ARRAY OF DATA TO PROMPT DEVICE WITH
C	NC	(I)	NUMBER OF BYTES TO PROMPT WITH
C
C	OUTPUTS:
C
C	BUF	(B)	RETURNED DATA BYTES
C	NB	(I)	NUMBER OF BYTES TO READ
C	IERR	(I)	IO STATUS ERROR
C
	INTEGER*2 IOSB(4)
	BYTE CMD(1),BUF(1)
	INTEGER*4 RET,SYS$QIOW
	EXTERNAL IO$_READPROMPT
C
C	READ DEVICE WITH IO READ PROMPTING
C
	RET=SYS$QIOW(,%VAL(ICHAN),IO$_READPROMPT,IOSB,,
     $		,BUF,%VAL(NB),CMD,%VAL(NC),,)
	IERR=0
	IF (RET.NE.1) IERR=IOSB(1)
	RETURN
	END
C
	SUBROUTINE RMREADCURSOR(ICHAN,IDEV,IX,IY,ITRK,IVIS,IENT,IERR)
C
C	READ CURSOR POSITION FROM RAMTEK DEVICE IDEV
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IDEV	(I)	CURSOR DEVICE CODE
C
C	OUTPUTS:
C
C	IX,IY	(I)	PIXEL POSITION OF CURSOR
C	ITRK	(I)	"TRACK" SWITCH ON FLAG (0,1)
C	IVIS	(I)	CURSOR VISIBLE FLAG (0,1)
C	IENT	(I)	"ENTER" SWITCH ON FLAG (0,1)
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IBUF(2),IB
C
	IB='1700'X + IDEV
	CALL RAMOUTIN(ICHAN,IB,2,IBUF,4,IERR)
	IX=IBUF(1)
	IY=IBUF(2)
	ITRK=IBITS(IY,12,1)
	IVIS=IBITS(IY,10,1)
	IENT=IBITS(IY,13,1)
	IY=IBITS(IY,0,10)
	RETURN
	END
C
	SUBROUTINE RMREADCOL(ICHAN,IS,N,IERR)
C
C	READS INTEGER*4 COLOR TABLE FROM RAMTEK
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	N	(I)	NUMBER OF WORDS TO READ
C
C	OUTPUTS:
C
C	IS	(I)	ARRAY OF COLOR TABLE DATA (I*4)
C	IERR	(I)	STATUS ERROR
C
	INTEGER*4 IS(1)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
C
	INTEGER*2 CMD(3)
	CMD(1)='0400'X + IODEV
	CMD(2)=0
	CMD(3)=N*4
	CALL RAMOUTIN(ICHAN,CMD,6,IS,N*4,IERR)
	RETURN
	END
C
	SUBROUTINE RMWRITECOL(ICHAN,IS,N,IERR)
C
C	WRITE LONGWORD COLOR TABLE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IS	(B)	ARRAY OF COLOR TABLE DATA (I*4)
C	N	(I)	NUMBER OF WORDS TO READ
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER IS(1)
C
	COMMON /RAMTEKIO/IOTYPE,IODEV,MWID,IXMAX,IYMAX
	INTEGER*2 IH(3)
C
	IH(1)='0300'X + IODEV
	IH(2)=0
	IH(3)=N*4
	CALL RAMOUT(ICHAN,IH,6,IERR)
	CALL RAMOUT(ICHAN,IS,N*4,IERR)
	RETURN
	END
C
	SUBROUTINE RMREADBYTE(ICHAN,IS,N,IERR)
C
C	READ DATA BYTE FROM RAMTEK IMAGE MODE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	N	(I)	NUMBER OF BYTES TO READ OF IMAGE
C
C	OUTPUTS:
C
C	IS	(B)	ARRAY OF IMAGE DATA
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(4)
	BYTE IS(1)
	IH(1)='0B05'X
	IH(2)='0020'X
	IH(3)=1
	IH(4)=N
	CALL RAMOUTIN(ICHAN,IH,8,IS,N,IERR)
	RETURN
	END
C
	SUBROUTINE RMREADWORD(ICHAN,IS,N,IERR)
C
C	READ INTEGER*2 WORD FROM RAMTEK IMAGE MODE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	N	(I)	NUMBER OF WORDS TO READ
C
C	OUTPUTS:
C
C	IS	(I*2)	ARRAY OF IMAGE DATA
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(4)
	INTEGER*2 IS(1)
	IH(1)='0B05'X
	IH(2)='0020'X
	IH(3)=0
	IH(4)=N*2
	CALL RAMOUTIN(ICHAN,IH,8,IS,N,IERR)
	RETURN
	END
C
	SUBROUTINE RMWRITEBYTE(ICHAN,IS,N,IERR)
C
C	WRITE BYTE DATA TO RAMTEK IN IMAGE MODE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IS	(B)	ARRAY OF IMAGE DATA
C	N	(I)	NUMBER OF BYTES TO WRITE
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(4)
	BYTE IS(1)
	IH(1)='0A05'X
	IH(2)='0020'X
	IH(3)=1
	IH(4)=N
	CALL RAMOUT(ICHAN,IH,8,IERR)
	CALL RAMOUT(ICHAN,IS,N,IERR)
	RETURN
	END
C
	SUBROUTINE RMWRITEWORD(ICHAN,IS,N,IERR)
C
C	WRITE INTEGER*2 WORDS TO RAMTEK IN IMAGE MODE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IS	(I)	ARRAY OF IMAGE DATA
C	N	(I)	NUMBER OF INTEGER*2 WORDS TO WRITE
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(4)
	BYTE IS(1)
	IH(1)='0A05'X
	IH(2)='0020'X
	IH(3)=0
	IH(4)=N*2
	CALL RAMOUT(ICHAN,IH,8,IERR)
	CALL RAMOUT(ICHAN,IS,N*2,IERR)
	RETURN
	END
C
	SUBROUTINE RMSTART(ICHAN,IX,IY,IERR)
C
C	SET START OF IMAGE WRITE (COP) LOCATION TO (IX,IY)
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IX,IY	(I)	PIXEL LOCATION
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(4)
	IH(1)='0802'X
	IH(2)='8000'X
	IH(3)=IX
	IH(4)=IY
	CALL RAMOUT(ICHAN,IH,8,IERR)
	RETURN
	END
C
	SUBROUTINE RMWIND(ICHAN,IX,IY,IXM,IYM,IERR)
C
C	SET PLOTTING WINDOW ON RAMTEK
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IX,IY	(I)	UPPER-LEFT (MINIMUM) CORNER
C	IXM,IYM	(I)	LOWER-RIGHT (MAXIMUM) CORNER
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(6)
	IH(1)='0802'X
	IH(2)='0040'X
	IH(3)=IX	! MIN POINT
	IH(4)=IY
	IH(5)=IXM	! MAX POINTS
	IH(6)=IYM
	CALL RAMOUT(ICHAN,IH,12,IERR)
	RETURN
	END
C
	SUBROUTINE RMDIR(ICHAN,ISEQ,IERR)
C
C	SET SCAN SEQUENCE FOR IMAGE WRITING ON RAMTEK
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	ISEQ	(I)	SCAN CODE
C		    PIX-TO-PIX  LINE-TO-LINE
C	ISEQ	0	L-R	   T-B
C		1	R-L	   T-B
C		2	L-R	   B-T
C		3	R-L	   B-T
C		4	T-B	   L-R
C		5	B-T	   L-R
C		6	T-B	   R-L
C		7	B-T	   R-L
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(3)
	IH(1)='0802'X
	IH(2)='0080'X
	IH(3)=ISEQ
	CALL RAMOUT(ICHAN,IH,6,IERR)
	RETURN
	END
C
	SUBROUTINE RMZOOM(ICHAN,IFACT,IERR)
C
C	ZOOM RAMTEK SCREEN
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	IFRACT	(I)	ZOOM FRACTION POWER (SAME IN BOTH DIRECTIONS)
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(2)
	IH(1)='2600'X
	IH(2)=IFACT*'0101'X
	CALL RAMOUT(ICHAN,IH,4,IERR)
	RETURN
	END
C
	SUBROUTINE RMPAN(ICHAN,LEFTX,TOPY,IERR)
C
C	PAN RAMTEK SCREEN
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	LEFTX	(I)	LEFT-RIGHT PAN
C	TOPY	(I)	UP-DOWN PAN
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(5)
	IH(1)='080A'X
	IH(2)='0020'X
	IH(3)=LEFTX
	IH(4)=TOPY
	CALL RAMOUT(ICHAN,IH,8,IERR)
	RETURN
	END
C
	SUBROUTINE RMSETCUR(ICHAN,ICUR,IX,IY,IBL,IVI,IERR)
C
C	SET CURSOR OPTIONS AND MOVE TO LOCATION (IX,IY)
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	ICUR	(I)	CURSOR DEVICE NUMBER (0-3)
C	IX,IY	(I)	CURSOR PIXEL LOCATION
C	IBL	(I)	BLINK CODE
C			 = 1: NO BLINK
C			 = 2: BLINK
C	IVI	(I)	VISIBILITY CODE
C			 = 0: INVISIBLE
C			 = 2: VISIBLE
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(3)
	IH(1)='1600'X + ICUR
	IH(2)=IX
	IH(3)=IY+IBL*2**10+IVI*2**11
	CALL RAMOUT(ICHAN,IH,6,IERR)
	RETURN
	END
C
	SUBROUTINE RMTEXT(ICHAN,ICOL,IX,IY,IS,TEXT,ILEN,IERR)
C
C	PRINT CHARACTER STRING DATA ON RAMTEK
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	ICOL	(I)	TEXT COLOR
C	IX,IY	(I)	STARTING LOCATION IN PIXELS OF TEXT
C	IS	(I)	TEXT SIZE IN PIXELS
C	TEXT	(B)	ARRAY OF TEXT CHARACTERS
C	ILEN	(I)	NUMBER OF BYTES OF TEXT
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER IH(7)
	BYTE TEXT(1)
	IH(1)='0C2B'X
	IH(2)='8402'X
	IH(3)=ICOL
	IH(4)='0101'X * (IS-1)
	IH(5)=IX
	IH(6)=IY
	IH(7)=2*(ILEN+1)/2
	CALL RAMOUT(ICHAN,IH,14,IER)
	CALL RAMOUT(ICHAN,TEXT,IH(7),IERR)
	RETURN
	END
C
	SUBROUTINE RMFNTSIZE(ICHAN,HD,VD,HS,VS,IERR)
C
C	SET TEXT SIZE
C	WRITTEN: DGL JAN 1986
C
C	INPUTS:
C
C	ICHAN	(I)	CHANNEL
C	HD	(I)	HORIZONTAL DIMENSION
C	VD	(I)	VERTICAL DIMENSION
C	HS	(I)	HORIZONTAL SPACING
C	VS	(I)	VERTICAL SPACING
C
C	OUTPUTS:
C
C	IERR	(I)	STATUS ERROR
C
	INTEGER*2 IH(8)
	IH(1)='080A'X
	IH(2)='0300'X
	IH(3)=HD
	IH(4)=VD
	IH(5)=HS
	IH(6)=VS
	CALL RAMOUT(ICHAN,IH,12,IERR)
	RETURN
	END
