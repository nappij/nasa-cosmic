C
      SUBROUTINE HYBRDC (IV, IOUT, D, E, DIF)
C
C     SUBROUTINE HYBRID USES A HYBRID METHOD TO COMPRESS AN IMAGE.
C     THIS METHOD CONSISTS OF A 1-D ORTHOGONAL (HADAMARD OR COSINE)
C     TRANSFORM IN THE VERTICAL DIRECTION FOLLOWED BY A 1-D DPCM IN THE
C     HORIZONTAL DIRECTION.  THE TRANSFORMED COEFFICIENTS ARE
C     ADAPTIVELY QUANTIZED.  USING THESE COEFFICIENTS, THE IMAGE IS
C     RECONSTRUCTED BY DOING INVERSE TRANSFORMATIONS.
C
C        NPL   - NUMBER OF PIXELS PER LINE
C        ITT   - TYPE OF ORTHOGONAL TRANSFORM
C        1 - HADAMARD                  2-COSINE
C        A - INPUT 16 X 1 ARRAY
C        B - TRANSFORMED 16 X 1 OUTPUT ARRAY
C        MINP  - MINIMUM VALUE OF INPUT IMAGE
C        MAXP  - MAXIMUM VALUE OF INPUT IMAGE
C
C     LOGICAL UNITS
C       10 - INPUT PICTURE (BYTES)
C       NB - RECONSTRUCTED PICTURE (BYTES)
C **********************************************************************
C
      DIMENSION IV(4,NPL), IOUT(NPL), D(16,NPL), E(16,NPL), DIF(NPL),
     . A(16), B(16), RHO(16)
      LOGICAL*1 IV, IOUT
      REAL MEAN,MAXP,MINP,MAX(4)/3*127.0,63.0/,MIN(4)/4*0.0/
      INTEGER BIT(16)
      COMMON NB, NLINE, BIT, NPL
      DATA M /16/
C
C     ENTRY FOR COSINE TRANSFORM
      ITT=2
      WRITE(6,45)
      GO TO 10
C
C     ENTRY FOR HADAMARD TRANSFORM
      ENTRY HYBRDH (IV, IOUT, D, E, DIF)
      ITT=1
      WRITE(6,46)
C
C     INITIALIZE COUNTERS, SET IMAGE PARAMETERS
   10 CONTINUE
      ISUM1=0
      ISUM2=0
      NBPV=NLINE/M
      ANPL=NPL
      MAXP = MAX(NB)
      MINP = MIN(NB)
C
C     CHECK FOR INDEX OF FIRST ZERO BIT RATE
C     KZ IS THE POINTER FOR THE LOCATION OF THE FIRST ZERO BIT RATE
          DO 25 I=1,M
          IF ( BIT(I) .NE. 0 ) GO TO 25
          KZ=I
          GO TO 30
   25     CONTINUE
          KZ=M+1
   30     CONTINUE
C
C     STORE CORRELATION FACTORS FOR EACH ROW OF TRANSFORMED DATA
            DO 50 I=1,4
            RHO(I)=15./16.
            RHO(I+4)=3./4.
            RHO(I+8)=0.5
   50       RHO(I+12) =0.5
C
C     READ IN 16 LINES OF DATA, PICK OFF DESIRED BAND AND STORE
C     IN D ARRAY
          DO 500 NV=1,NBPV
            DO 125 I=1,M
            READ(10) IV
              DO 120 J=1,NPL
              IIV = IV(NB,J)
              D(I,J) = IIV
              ISUM1 = ISUM1 + IIV
  120         CONTINUE
  125       CONTINUE
C
C     PERFORM EITHER A HADAMARD OR COSINE TRANSFORM ON COLUMNS OF D
C     DEPENDING ON THE VALUE OF ITT.
            DO 160 J=1,NPL
              DO 130 I=1,M
  130         A(I)=D(I,J)
            GO TO (131,132), ITT
  131       CALL HADD (A, B)
            GO TO 135
  132       CALL COST (A, B, 1)
  135       CONTINUE
C
C     D(I,J).......TRANSFORMED DATA
              DO 140 I=1,M
  140         D(I,J)=B(I)
  160       CONTINUE
C
C     DO DPCM ON ROWS OF ARRAY D
C
C     COMPUTE THE MEAN OF EACH ROW OF ARRAY D AND THE
C     DEVIATION OF EACH POINT IN THE ROW FROM THE MEAN
            DO 350 I=1,M
            SUM=0.0
              DO 220 J=1,NPL
              SUM=SUM+D(I,J)
  220         CONTINUE
            MEAN = SUM/ANPL
            IF ( I .GE. KZ ) GO TO 300
C
C     DIF(J).........ZERO CENTERED TRANSFORMED DATA.
              DO 225 J=1,NPL
              DIF(J) = D(I,J) - MEAN
  225         CONTINUE
C
C     E(I,J).......DIFFERENCE BETWEEN THE DEVIATION AND THE
C     PREVIOUS DEVIATION MULTIPLIED BY THE CORRELATION FACTOR
            E(I,1)=0.0
              DO 240 J=2,NPL
  240         E(I,J)=DIF(J)-DIF(J-1)*RHO(I)
C
C     COMPUTE THE VARIANCE OF THE ERROR AND THE SCALING FACTOR
            PA=0.0
              DO 250 J=1,NPL
  250         PA=PA+E(I,J)
            PA=PA/ANPL
            FA=0.0
              DO 260 J=1,NPL
              FA=FA+(E(I,J)-PA)**2
  260         CONTINUE
            SGM=SQRT(FA/ANPL)
            CALL DSQ (3.0, SGM)
            LEVEL = 2**(BIT(I)-1)
C
C     QUANTIZE DEVIATION FROM THE MEAN FOR THE FIRST SAMPLE
            AF=DIF(1)
            CALL QUAN (AF, LEVEL, EQ)
            EE = EQ
            E(I,1) = EE + MEAN
C
C     ADAPTIVELY QUANTIZE THE DIFFERENCE BETWEEN THE DEVIATION FROM
C     THE MEAN AND THE PREDICTED VALUE.  ADD THE PREDICTED VALUE TO THE
C     QUANTIZED OUTPUT.  FINALLY, ADD BACK THE MEAN.
              DO 320 J=2,NPL
              AF = DIF(J) - RHO(I)*EE
              CALL QUAN (AF, LEVEL, EQ)
              EE = EQ + RHO(I)*EE
              E(I,J) = EE + MEAN
  320         CONTINUE
            GO TO 350
C
C      OUTPUT FOR CASE OF ZERO BIT RATE
  300       DO 310 I=KZ,M
            DO 310 J=1,NPL
            E(I,J)=MEAN
  310       CONTINUE
  350       CONTINUE
C
C     DO INVERSE 1-D HADAMARD OR COSINE TRANSFORM
            DO 450 J=1,NPL
              DO 410 I=1,M
  410         A(I)=E(I,J)
            GO TO (411,412), ITT
  411       CALL HADD (A, B)
            GO TO 415
  412       CALL COST (A, B, -1)
  415       CONTINUE
C
C     D(I,J).......RECONSTRUCTED  DATA.
              DO 420 I=1,M
              IF (B(I).LT.MINP) B(I) = MINP
              IF (B(I).GT.MAXP) B(I) = MAXP
  420         D(I,J) = B(I)
  450       CONTINUE
C
            DO 490 I=1,M
              DO 480 J=1,NPL
              IOUT(J)=D(I,J)+0.5
              ISUM2 = ISUM2 + IOUT(J)
  480         CONTINUE
            WRITE(NB) IOUT
  490       CONTINUE
  500     CONTINUE
C
C     COMPUTE MEANS OF ORIGINAL AND RECONSTRUCTED IMAGES
          PIX=NLINE*NPL
      AMEAN1 = ISUM1 / PIX
      AMEAN2 = ISUM2 / PIX
C
      WRITE(6,43) BIT
      WRITE(6,40) NPL,NLINE,NB,MAXP,MINP
      WRITE(6,41) AMEAN1, AMEAN2
      RETURN
C
   40 FORMAT(' NPL =',I5,15X,'NLINE =',I5,15X,'BAND NO.',I2,15X,'MAXP ='
     .,F6.1,15X,'MINP =',F6.1/)
   41 FORMAT (' MEAN OF ORIGINAL IMAGE =',F8.3,26X,'MEAN OF RECONSTRUCTE
     .D IMAGE =',F8.3//)
   43 FORMAT(' BIT RATES ',16I2,/)
   45 FORMAT(20X,'HYBRID METHOD USING A 1-D COSINE AND A 1-D DPCM TRANSF
     .ORM'//)
   46 FORMAT(25X,'HYBRID METHOD USING A 1-D HADAMARD AND A 1-D DPCM TRAN
     .SFORM'//)
      END
C
      SUBROUTINE HADD(SPACE,HAD)
C
C     HADD DOES A FAST HADAMARD TRANSFORMATION ON A 16 X 1 ARRAY
C     THE MATRIX IS NORMALIZED SO THAT THE FORWARD AND INVERSE
C     MAPPINGS ARE THE SAME.
C
C        SPACE - INPUT ARRAY
C        HAD   - TRANSFORMED OUTPUT ARRAY
C***********************************************************************
C
      REAL      SPACE(16),BLOCK5(8),BLOCK6(4),BLOCK7(2),IPGM(8),HAD(16)
C
      XN=4.
      IPGM(1)=1
        DO 30 N=2,4
        IDISPL=2**(N-2)+1
        IDELT=0
   20   IPGM(IDISPL+IDELT)=N
        IDELT=IDELT+2**(N-1)
        IF(IDELT+IDISPL-8) 20,20,30
   30   CONTINUE
C
        DO 150 J=1,8
        L=J+J
        I=IPGM(J)
        GO TO (50,200,220,240),I
   50     DO 60 I=1,8
          K=I+I
   60     BLOCK5(I)=SPACE(K-1)+SPACE(K)
   70       DO 80 I=1,4
            K=I+I
   80       BLOCK6(I)=BLOCK5(K-1)+BLOCK5(K)
   90         DO 100 I=1,2
              K=I+I
  100         BLOCK7(I)=BLOCK6(K-1)+BLOCK6(K)
  120   HAD(L-1)=(BLOCK7(1)+BLOCK7(2))/XN
  150   HAD(L) = (BLOCK7(1)-BLOCK7(2))/XN
      RETURN
C
  200 BLOCK7(1)=BLOCK6(1)-BLOCK6(2)
      BLOCK7(2)=BLOCK6(4)-BLOCK6(3)
      GO TO 120
  220   DO 230 I=1,4,2
        K=I+I
        BLOCK6(I)=BLOCK5(K-1)-BLOCK5(K)
  230   BLOCK6(I+1)=BLOCK5(K+2)-BLOCK5(K+1)
      GO TO 90
  240   DO 250 I=1,8,2
        K=I+I
        BLOCK5(I)=SPACE(K-1)-SPACE(K)
  250   BLOCK5(I+1)=SPACE(K+2)-SPACE(K+1)
      GO TO 70
      END
C
      SUBROUTINE DSQ (XMULT, SIGMA)
C
C     AN ASSUMED LAPLACIAN DISTRIBUTION OF THE COEFFICIENTS IS TRANS-
C     FORMED TO A UNIFORM DISTRIBUTION BEFORE QUANTIZATION.
C     DSQ COMPUTES THE CONSTANTS OF THE MAPPING FUNCTION.
C        XMULT = ESTIMATED NUMBER OF SIGMAS IN THE DATA RANGE
C        SIGMA = ESTIMATED VARIANCE OF THE INPUT VALUE
C **********************************************************************
C
      EMAX=XMULT*SIGMA
      EM = SQRT(2.0*EMAX) / (3.0*SIGMA)
      EXPM=EXP(-EM)
      EM1 = -EM/EMAX
      RETURN
C***********************************************************************
C
      ENTRY QUAN (F, LEVEL, EQ)
C
C      QUANTIZATION OF AC COEFFICIENTS.
C        F     = VALUE TO BE QUANTIZED
C        LEVEL = NUMBER OF LEVELS IN THE QUANTIZER
C        EQ    = REPRESENTATIVE VALUE FOR F
C **********************************************************************
C
      II=0
      IF(F.GE.0.0)GO TO 2
      F=-F
      II=1
 2    CONTINUE
C
C     FORWARD MAPPING
      EW = F*EM1
      EXPE=EXP(EW)
      Z=EMAX*(1.-EXPE)/(1.-EXPM)
C
      LEVEL1=LEVEL-1
      IZ=(Z/EMAX)*LEVEL
      IF(IZ.LT.0)IZ=0
      IF(IZ.GT.LEVEL1)IZ=LEVEL1
C
C     INVERSE MAPPING
      ZQ=(FLOAT(IZ)+0.5)/FLOAT(LEVEL)
      ZQW=1.-ZQ*(1.-EXPM)
      EQ=-EMAX/EM*ALOG(ZQW)
      IF(II.EQ.1)EQ=-EQ
      RETURN
      END
C
      SUBROUTINE COST (INPUT, COSOUT, ITYPE)
C
C GENERALIZED FAST COSINE TRANSFORM ROUTINE
C THERE IS A CHECK MADE SO THE TABLE IS ONLY CALCULATED THE FIRST TIME
C MAXIMUM SIZE ARRAY = 256 ELEMENTS
C
C INPUT = INPUT ARRAY
C COSOUT= COSINE TRANSFORMED ARRAY
C ITYPE:   1= FORWARD TRANSFORM
C         -1= INVERSE TRANSFORM
C ISIZE = NUMBER OF ELEMENTS IN INPUT/OUTPUT ARRAY
C***********************************************************************
C
      REAL INPUT(1)
      DIMENSION COSOUT(1), COSINE(15), SINE(15), OUTPUT(64), S(15)
      LOGICAL FIRST /.TRUE./
      DATA ISIZE, MM /16, 5/
C
      IF (.NOT.FIRST) GO TO 951
      ISIZEF=ISIZE*4
      SQRT2=SQRT(2.0)
C
C COSINE TRANSFORM TABLE GENERATION
      Y=3.1415927/2.0/FLOAT(ISIZE)
      CC=COS(Y)
      SC=SIN(Y)
      COSINE(1)=CC
      SINE(1)=SC
      JJ=ISIZE-2
      DO 950 I=1,JJ
      COSINE(I+1)=COSINE(I)*CC - SINE(I)*SC
950   SINE(I+1)=SINE(I)*CC + COSINE(I)*SC
      CALL MDFT (OUTPUT, MM, 1, S, 0, IFERR)
      FIRST = .FALSE.
C
C BRANCH TO DO FORWARD OR INVERSE TRANSFORM
  951 IF (ITYPE.EQ.-1) GO TO 888
C
C FORWARD TRANSFORM
      OUTPUT(1)=INPUT(1)
      OUTPUT(2)=0.0
      DO 900 I=2,ISIZE
      OUTPUT(I*2-1)=INPUT(I)
      OUTPUT(ISIZEF+3-I*2)=0.0
      OUTPUT(ISIZEF+4-I*2)=0.0
900   OUTPUT(I*2)=0.0
      OUTPUT(2*ISIZE+1)=0.
      OUTPUT(2*ISIZE+2)=0.
C
      CALL MDFT (OUTPUT, MM, 1, S, 2*ITYPE, IFERR)
C
      COSOUT(1) = OUTPUT(1)*SQRT2
      DO 810 I=2,ISIZE
810   COSOUT(I) = 2.0*(OUTPUT(2*I-1)*COSINE(I-1)-OUTPUT(2*I)*SINE(I-1))
      RETURN
C
C INVERSE TRANSFORM
888   SUM=INPUT(1)/SQRT2
      CT=SUM*(1.0-1.0/SQRT2)/FLOAT(ISIZE)
C
      OUTPUT(1)=INPUT(1)
      OUTPUT(2)=0.0
      DO 910 I=2,ISIZE
      OUTPUT(2*I-1)=       INPUT(I)*COSINE(I-1)
      OUTPUT(ISIZEF+3-I*2)=INPUT(I)*COSINE(I-1)
      OUTPUT(ISIZEF+4-I*2)=INPUT(I)*SINE(I-1)
910   OUTPUT(2*I)=       -(INPUT(I)*SINE(I-1))
      OUTPUT(2*ISIZE+1)=0.
      OUTPUT(2*ISIZE+2)=0.
C
      CALL MDFT (OUTPUT, MM, 1, S, 2*ITYPE, IFERR)
C
      DO 811 I=1,ISIZE
811   COSOUT(I) = OUTPUT(2*I-1) + CT
      RETURN
      END
C
      SUBROUTINE MDFT(A,MC,ND,S,IFS,IFERR)
C
C         MDFT, MULTI-DIMENSIONAL FINITE FOURIER TRANSFORM
C
C     MDFT TOGETHER WITH MFORT IS A MODIFICATION OF FORT
C     A SUBROUTINE SUPPLIED BY J.W. COOLEY OF IBM. FORT
C     COMPUTES ONE-DIMENSIONAL FOURIER TRANSFORMS, MDFT-
C     MFORT GIVES TRANSFORMS IN UP TO SIX DIMENSIONS
C
C     A IS A COMPLEX ARRAY WITH DIMENSION A(NN(1),...,NN(ND)),
C     WHERE NN(K)=2**MC(K).  A IS TO BE SET BY THE USER.
C
C     MC IS A VECTOR SET BY USER. 0.LT.MC(K).LE.13 FOR
C     K=1,2,...,ND.  IN ADDITION MC(1)+MC(2)+...+NC(ND).LE.13.
C     (IF IFS=0 THE 13 IN THE TWO ABOVE COMMENTS CAN BE REPLACED BY 14.)
C     IN THE COMMENTS WHICH FOLLOW, M=MAX(MC(K)).
C
C     ND IS THE DIMENSION OF THE COMPLEX ARRAY A.  ND IS
C     SUPPLIED BY THE USER.
C
C     S IS A VECTOR S(J)= SIN(2*PI*J/NP ), J=1,2,....,NP/4-1,
C     WHERE NP=MAX(NN(K)).  S IS COMPUTED BY THE PROGRAM.
C
C     IFS IS A PARAMETER TO BE SET BY USER AS FOLLOWS-
C     IFS=0 TO SET NP=2**M AND SET UP SINE TABLE.
C
C     IFS=1 TO SET N=NP=2**M, SET UP SIN TABLE, AND DO FOURIER
C     SYNTHESIS.  THE ARRAY A(J(1),J(2),...,J(ND)) IS REPLACED BY
C     X(J(1),J(2),...,J(ND))= SUM OVER 0.LE.K(1).LE.NN(1)-1,
C     0.LE.K(2).LE.NN(2)-1,...,0.LE.K(ND).LE.NN(ND)-1  OF
C     A(K(1),K(2),...,K(ND))*(EXP(2*PI*J(1)*K(1)*I/NN(1)))*
C     (EXP(2*PI*J(2)*K(2)*I/NN(2)))*...*(EXP(2*PI*J(ND)*K(ND)*I/NN(ND)))
C     0.LE.J(1).LE.NN(1)-1,0.LE.J(2).LE.NN(2)-1,...,
C     0.LE.J(ND).LE.NN(ND)-1, WHERE I=SQRT(-1).
C     THE X'S ARE STORED WITH RE X(J(1),J(2),...,J(ND)) IN CELL
C     1+2*(J(1)+J(2)*NN(1)+J(3)*NN(1)*NN(2)+...
C     +J(ND)*NN(1)*NN(2)*...*NN(ND-1)),  AND
C     IM X(J(1),...,J(ND)) IN THE CELL FOLLOWING
C     RE X(J(1),...,J(ND)).
C     THE  A'S  ARE STORED IN THE SAME MANNER.
C
C     IFS=-1   TO SET  N=NP=2**M,SET UP SIN TABLE, AND DO FOURIER
C     ANALYSIS,TAKING THE INPUT ARRAY A AS X AND
C     REPLACING IT BY THE A  SATISFYING THE ABOVE FOURIER SERIES.
C
C     IFS=+2 TO DO FOURIER SYNTHESIS ONLY, WITH A PRE-COMPUTED S.
C
C     IFS=-2 TO DO FOURIER ANALYSIS ONLY, WITH A PRE-COMPUTED S.
C
C     IFERR   IS SET BY PROGRAM TO-
C     =0 IF NO ERROR DETECTED.
C     =1 IF THE MC(K)'S DO NOT SATISFY THE CONDITIONS ABOVE,
C         OR ND DOES NOT SATISFY 1.LE.ND.LE.6.
C     =-1 WHEN IFS=1,0,OR -1 AND THE S TABLE NEED NOT BE COMPUTED.
C     =-2 WHEN IFS=2 OR -2 AND THE S TABLE NEED BE COMPUTED.
C
C     AS STATED ABOVE, MC(1)+MC(2)+...+MC(ND).LE.13.IF THE
C     COMPUTER USED HAS A GREATER STORAGE CAPACITY THAN THE
C     IBM 7094 THIS MAXIMUM MAY BE INCREASED BY REPLACING
C     13 IN STATEMENT 6 BELOW WITH M=LOG2 N,WHERE N IS
C     THE MAXIMUM NUMBER OF COMPLEX NUMBERS ONE CAN STORE
C     IN HIGH SPEED CORE.  THE DIMENSION OF KE MUST BE SET
C     EQUAL TO M+1 IN BOTH MDFT AND MFORT. THE DO LOOP
C     JUST BEFORE STATEMENT 40 MUST EXTEND TO M-1 INSTEAD OF 12.
C     THE 14 IN STATEMENT 105 MUST BE CHANGED TO M+1.
C     IN MFORT ONE MUST CHANGE THE EQUIVALENCE STATEMENTS FOR
C     THE KE'S AND ADD MORE DO STATEMENTS TO THE BINARY SORT
C     JUST ABOVE STATEMENT 28.
C
      DIMENSION A(1),S(1),MC(1)
      DIMENSION NF(7),NN(6)
      DIMENSION KE(14)
      EQUIVALENCE (KE(1),JD)
      DATA NF(1)/2/, NPD/0/
C
C     NOTE THAT THE NAMED COMMON,CFORTC, IS USED FOR
C     COMMUNICATION BETWEEN MDFT AND MFORT.
      COMMON/CFORTC/M,N,NT,KS,KS2,KST,KE
C
      NDD=ND
      IF (NDD) 110,110,2
 2    IF(ND.GT.6) GO TO 110
      IFSS=IFS
      MS=0
      KM=1
      DO 10 K=1,NDD
      M=MC(K)
      IF(M) 110,110,4
 4    MS=MS+M
      IF(MS.GT.13) GO TO 105
 8    NN(K)=2**M
      NF(K+1)=NF(K)*NN(K)
 10   IF(NN(K).GT.NN(KM)) KM=K
      IFERR=0
      IF (IABS(IFSS).LT.2) GO TO 160
      IF(NPD.LT.NN(KM)) GO TO 150
 15   NTOT2=NF(NDD+1)
      IF(IFSS) 20,110,30
C
C     DOING FOURIER ANALYSIS SO DIVIDE BY NN(1)*NN(2)*...*NN(ND) AND
C     CONJUGATE.
 20   FN=NTOT2/2
      DO 25 I=1,NTOT2,2
      A(I)=A(I)/FN
 25   A(I+1)=-A(I+1)/FN
C
C     BEGINNING OF LOOP FOR COMPUTING MULTIPLE SUM
 30   DO 50 K=1,NDD
      M=MC(K)
      N=NN(K)
      KS=NF(K)
      KS1=KS-1
      KS2=2*KS
      KST=KS+2
      KE(1)=NF(K+1)
      DO 35 L=2,M
 35   KE(L)=KE(L-1)/2
      DO 40 L=M,12
 40   KE(L+1)=KS
      DO 50 J=1,NTOT2,JD
      KSS=J+KS1
      DO 50 I=J,KSS,2
 50   CALL MFORT(A(I),S)
C     END OF LOOP FOR COMPUTING MULTIPLE SUM
C
 70   IF(IFSS) 75,110,100
C
C     DOING FOURIER ANALYSIS. REPLACE A BY CONJUGATE.
 75   DO 80 I=2,NTOT2,2
 80   A(I)=-A(I)
      GO TO 100
 105  IF((IFS.EQ.0).AND.(MS.EQ.14)) GO TO 8
 110  IFERR=1
      GO TO 100
 150  IFERR=-2
 160  NPD=NN(KM)
      M=MC(KM)
      IF (NP.GE.NPD) IFERR=-1
C
C     MAKE TABLE OF S(J)=SIN(2*PI*J/NP),J=1,2,....NT-1,NT=NP/4
 200  NP=NPD
      NT=NP/4
      MT=M-2
      IF(MT) 260,260,205
 205  THETA=.7853981633974483
C
C     THETA=PI/2**(L+1)    FOR L=1
      JSTEP = NT
C
C     JSTEP = 2**( MT-L+1 ) FOR L=1
      JDIF = NT/2
C
C     JDIF = 2**(MT-L)  FOR L=1
      S(JDIF) = SIN(THETA)
      IF (MT-2)260,220,220
  220 DO 250 L=2,MT
      THETA = THETA/2.
      JSTEP2 = JSTEP
      JSTEP = JDIF
      JDIF = JDIF/2
      S(JDIF)=SIN(THETA)
      JC1=NT-JDIF
      S(JC1)=COS(THETA)
      JLAST=NT-JSTEP2
      IF(JLAST-JSTEP)250,230,230
  230 DO 240 J=JSTEP,JLAST,JSTEP
      JC=NT-J
      JD=J+JDIF
  240 S(JD)=S(J)*S(JC1)+S(JDIF)*S(JC)
  250 CONTINUE
 260  IF(IFSS) 15,100,15
 100  RETURN
      END
C
      SUBROUTINE MFORT(A,S)
C
C         MFORT, MODIFIED VERSION OF FORT FOR USE
C         AS SUBROUTINE BY MDFT
C
      DIMENSION A(1),S(1)
      DIMENSION KE(14)
      COMMON/CFORTC/M,N,NT,KS,KS2,KST,KE
      EQUIVALENCE (KE(13),K1),(KE(12),K2),(KE(11),K3),(KE(10),K4)
      EQUIVALENCE (KE( 9),K5),(KE( 8),K6),(KE( 7),K7),(KE( 6),K8)
      EQUIVALENCE (KE( 5),K9),(KE(4),K10),(KE(3),K11),(KE(2),K12)
      EQUIVALENCE (KE(1),K13),(KE(1),N2)
C
C     SCRAMBLE A, BY SANDE'S METHOD
C     NOTE EQUIVALENCE OF KL AND KE(14-L)
C     BINARY SORT-
      IJ=2
      DO 30 J1=2,K1,KS
      DO 30 J2=J1,K2,K1
      DO 30 J3=J2,K3,K2
      DO 30 J4=J3,K4,K3
      DO 30 J5=J4,K5,K4
      DO 30 J6=J5,K6,K5
      DO 30 J7=J6,K7,K6
      DO 30 J8=J7,K8,K7
      DO 30 J9=J8,K9,K8
      DO 30 J10=J9,K10,K9
      DO 30 J11=J10,K11,K10
      DO 30 J12=J11,K12,K11
      DO 30 JI=J12,K13,K12
      IF(IJ-JI)28,30,30
   28 T=A(IJ-1 )
      A(IJ-1)=A(JI-1)
      A(JI-1)=T
      T=A(IJ)
      A(IJ)=A(JI)
      A(JI)=T
 30   IJ=IJ+KS
C
C     SPECIAL CASE- L=1
 36   DO 40 I=2,N2,KS2
      KSI=I+KS
      T=A(I-1)
      A(I-1)=T+A(KSI-1)
      A(KSI-1)=T-A(KSI-1)
      T=A(I)
      A(I)=T+A(KSI)
 40   A(KSI)=T-A(KSI)
      IF (M.LE.1) GO TO 1
C
C     SET FOR L=2
 50   LEXP1=KS
C
C     LEXP1=KS*2**(L-2)
      LEXP=4*LEXP1
C
C     LEXP=KS*2**L
      NPL=NT
C
C     NPL=NT*2**(2-L)
C     NT=NP/4,NP IS DEFINED IN COMMENTS IN MDFT.
      DO 130 L=2,M
C
C     SPECIAL CASE- J=0
      DO 80 I=2,N2,LEXP
      I1=I + LEXP1
      I2=I1+ LEXP1
      I3 =I2+LEXP1
      T=A(I-1)
      A(I-1) = T +A(I2-1)
      A(I2-1) = T-A(I2-1)
      T =A(I)
      A(I) = T+A(I2)
      A(I2) = T-A(I2)
      T= -A(I3)
      TI = A(I3-1)
      A(I3-1) = A(I1-1) - T
      A(I3   ) = A(I1 )   - TI
      A(I1-1) = A(I1-1) +T
   80 A(I1)   = A(I1   )  +TI
      IF(L-2) 120,120,90
   90 KLAST=N2-LEXP
      JJ=NPL
C
      DO 110 J=KST,LEXP1,KS
      NPJJ=NT-JJ
      UR=S(NPJJ)
      UI=S(JJ)
      ILAST=J+KLAST
C
      DO 100 I= J,ILAST,LEXP
      I1=I+LEXP1
      I2=I1+LEXP1
      I3=I2+LEXP1
      T=A(I2-1)*UR-A(I2)*UI
      TI=A(I2-1)*UI+A(I2)*UR
      A(I2-1)=A(I-1)-T
      A(I2  )=A(I   ) - TI
      A(I-1) =A(I-1)+T
      A(I)   =A(I)+TI
      T=-A(I3-1)*UI-A(I3)*UR
      TI=A(I3-1)*UR-A(I3)*UI
      A(I3-1)=A(I1-1)-T
      A(I3)   =A(I1  )-TI
      A(I1-1)=A(I1-1)+T
  100 A(I1)   =A(I1)   +TI
C     END OF I LOOP
C
  110 JJ=JJ+NPL
C     END OF J LOOP
C
  120 LEXP1=2*LEXP1
      LEXP = 2*LEXP
  130 NPL=NPL/2
C     END OF L LOOP
C
    1 RETURN
      END
