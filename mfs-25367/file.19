C
      SUBROUTINE PEELS (NTI,NTO,NREC,NEL,IT,MPASS,ITYPE,LX,LY,IBDY)
C
C  THIS SUBROUTINE PEELS THE OUTER LAYERS FROM THE BOUNDARY LINES OF AN
C  IMAGE WHILE PRESERVING THE DISTINCTNESS OF REGIONS SEPARATED BY
C  THE BOUNDARY LINES
C
C     DIMENSION LX(36*((NEL-1)/32+1)),LY((NEL-1)/4+1),IBDY(NEL)
      DIMENSION LX(1),LY(1),IBDY(1)
      DATA MDEV, NDEV /1, 2/
C
      N=(NEL-1)/32+1
      REWIND MDEV
      DO 10 I=1,NREC
      CALL SARN(NTI,LX,NEL)
      IF(I.EQ.1.OR.I.EQ.NREC) CALL SVSCL1(LX,NEL,0)
      LX(1) = 0
      LX(NEL) = 0
      CALL VLTHR(LX,NEL,IT,LY)
      LX(N)=0
      CALL CMPRES(LY,NEL,LX)
      CALL SAWN(MDEV,LX,N*4)
10    CONTINUE
C
      DO 20 IPASS=1,MPASS
      REWIND MDEV
      REWIND NDEV
      IF (MOD(IPASS,2).EQ.1)
     .CALL PEELER(MDEV,NDEV,NREC,ITYPE,N,LX,LX(12*N+1),LX(24*N+1),LY,NP)
      IF (MOD(IPASS,2).EQ.0)
     .CALL PEELER(NDEV,MDEV,NREC,ITYPE,N,LX,LX(12*N+1),LX(24*N+1),LY,NP)
      WRITE(6,100) IPASS,NP
      IF(NP.EQ.0)GO TO 30
20    CONTINUE
      IPASS=MPASS
C
30    IF(MOD(IPASS,2).EQ.1)JDEV=NDEV
      IF(MOD(IPASS,2).EQ.0)JDEV=MDEV
      REWIND JDEV
      DO 40 I=1,NREC
      CALL SARN(JDEV,LX,N*4)
      CALL EXPBDY (LX,N,I,NREC,NEL,IBDY,J)
      WRITE (NTO) J, (IBDY(L), L=1,J)
40    CONTINUE
      RETURN
C
100   FORMAT(5X'DURING PASS NUMBER'I3,' THROUGH PEELER'I6,' WORDS OF COM
     -PRESSED BOUNDARY INFORMATION WERE CHANGED.')
      END
C
      SUBROUTINE VLTHR(LX,N,IT,LY)
C
      LOGICAL*1 LX(N),LY(N),F/.FALSE./,T/.TRUE./
C
C     THRESHOLD A VECTOR LX OF 8 BIT INTEGERS TO GET A T-F VECTOR.
C     IF 'IT' IS POSITIVE, LY(I) IS TRUE FOR LX(I) .GE. IT.
C     IF 'IT' IS NEGATIVE, LY(I) IS TRUE FOR LX(I) .LE. IABS(IT).
C
      ITT=IABS(IT)
      IF(IT.LT.0)GO TO 10
      DO 20 I=1,N
      LY(I)=F
      IF(LX(I).GE.ITT)LY(I)=T
20    CONTINUE
      RETURN
C
10    DO 30 I=1,N
      LY(I)=F
      IF(LX(I).LE.ITT)LY(I)=T
30    CONTINUE
      RETURN
      END
C
      SUBROUTINE CMPRES(LX,NEL,LY)
C
C  THIS SUBROUTINE IS USED TO PACK THE INFORMATION IN LX INTO THE FIRST
C  NEL BITS OF THE ARRAY LY
C
      LOGICAL*1 LX(NEL)
      DIMENSION LY(1)
C
      JWRD=1
      JBIT=33
      DO 10 I=1,NEL
      JBIT=JBIT-1
      IF(JBIT.NE.0)GO TO 20
      JBIT=32
      JWRD=JWRD+1
20    IX=LX(I)
      LY(JWRD)=ISTORE(IX,LY(JWRD),JBIT,1)
10    CONTINUE
      RETURN
      END
C
      SUBROUTINE PEELER (MDEV,NDEV,NREC,ITYPE,N,LX,LXR,LXL,LY,NP)
C
C  THIS SUBROUTINE INITIATES THE REMOVAL OF ONE LAYER OF THICK BOUNDARIE
C  FROM TOP, LEFT, BOTTOM AND RIGHT OF AN IMAGE
C
      DIMENSION LX(N,3,4),LXR(N,3,4),LXL(N,3,4),LY(N),J(3)
C
      NREC1=NREC+1
      NREC2=NREC+2
      NREC3=NREC+3
      NREC4=NREC+4
      J(1)=1
      J(2)=2
      J(3)=3
      CALL SVSCI(LX ,12*N,0)
      CALL SVSCI(LXR,12*N,0)
      CALL SVSCI(LXL,12*N,0)
      NP=0
C
      DO 10 I=1,NREC4
      DO 20 K=1,4
      IF(I.LE.NREC+K)GO TO 20
      CALL SVSCI(LX (1,J(3),K),N,0)
      CALL SVSCI(LXR(1,J(3),K),N,0)
      CALL SVSCI(LXL(1,J(3),K),N,0)
20    CONTINUE
      IF (I.LE.NREC) CALL PEELR1 (MDEV,LX,LXR,LXL,J,N)
      IF(I.GT.1.AND.I.LE.NREC1)
     .   CALL PEELRO(LX(1,1,1),LXR(1,1,1),LXL(1,1,1),J,N,1,
     .     LX(1,J(3),2),LXR(1,J(3),2),LXL(1,J(3),2),NP,ITYPE)
      IF(I.GT.2.AND.I.LE.NREC2)
     .   CALL PEELRO(LX(1,1,2),LXR(1,1,2),LXL(1,1,2),J,N,2,
     .     LX(1,J(3),3),LXR(1,J(3),3),LXL(1,J(3),3),NP,ITYPE)
      IF(I.GT.3.AND.I.LE.NREC3)
     .   CALL PEELRO(LX(1,1,3),LXR(1,1,3),LXL(1,1,3),J,N,3,
     .     LX(1,J(3),4),LXR(1,J(3),4),LXL(1,J(3),4),NP,ITYPE)
      IF(I.GT.4)
     .   CALL PEELRO(LX(1,1,4),LXR(1,1,4),LXL(1,1,4),J,N,4,
     .     LY,0,0,NP,ITYPE)
      IF(I.GT.4) CALL SAWN(NDEV,LY,4*N)
      DO 30 K=1,3
      J(K)=MOD(J(K),3)+1
30    CONTINUE
10    CONTINUE
      RETURN
      END
C
      SUBROUTINE EXPBDY(LX,N,IREC,NREC,NEL,IBDY,J)
C
C  THIS SUBROUTINE SENSES EACH BIT IN A RECORD AND CONVERTS THE RECORD
C  TO SCAN LINE INTERSECTION CODE FORMAT
C
      DIMENSION LX(N),IBDY(1)
      LOGICAL ILOAD
C
      IF(IREC.EQ.1.OR.IREC.EQ.NREC) GO TO 10
      GO TO 30
   10 J=NEL
      DO 20 I=1,NEL
      IBDY(I)=I
   20 CONTINUE
      GO TO 60
   30 JWRD=1
      JBIT=33
      J=0
      DO 50 I=1,NEL
      JBIT=JBIT-1
      IF(I.EQ.1.OR.I.EQ.NEL) GO TO 70
      IF(JBIT.NE.0) GO TO 40
      JBIT=32
      JWRD=JWRD+1
   40 IF(.NOT.ILOAD(LX(JWRD),JBIT,1)) GO TO 50
   70 J=J+1
      IBDY(J)=I
   50 CONTINUE
   60 RETURN
      END
C
      SUBROUTINE PEELR1 (MDEV, LX, LXR, LXL, J, N)
C
C  THIS SUBROUTINE READS ONE RECORD OF THE INPUT IMAGE AND SETS UP TWO
C  ARRAYS, ONE WITH THE BITS OF THE RECORD SHIFTED ONE BIT TO THE LEFT,
C  AND THE OTHER WITH THE BITS SHIFTED ONE BIT TO THE RIGHT
C
      DIMENSION LX(N,3), LXR(N,3), LXL(N,3), J(3)
C
      CALL SARN (MDEV, LX(1,J(3)), 4*N)
C
      CALL BLSFTV (LX(1,J(3)), N, LXL(1,J(3)))
      CALL BRSFTV (LX(1,J(3)), N, LXR(1,J(3)))
      RETURN
      END
C
      SUBROUTINE PEELRO (LX,LXR,LXL,J,N,ISIDE,LY,LYR,LYL,NP,ITYPE)
C
C  THIS SUBROUTINE PERFORMS THE PEELING OF ONE RECORD
C
      DIMENSION LX(N,3),LXR(N,3),LXL(N,3),LY(N),LYR(N),LYL(N),J(3)
C
      DO 60 I=1,N
      LY(I)=LX(I,J(2))
      IF(LY(I).EQ.0)GO TO 60
      GO TO (1, 2), ITYPE
C
C  ** TYPE 1 ALGORITHM - DIAGONAL CONNECTIONS
1     GO TO (10,20,30,40),ISIDE
C
C  TOP PEEL
10    IW1 = IOR  (LX (I,J(1)), ICOMP1(LX (I,J(3)),32,32))
      IW2 = IAND (LXR(I,J(1)), ICOMP1(LXR(I,J(2)),32,32))
      IW3 = IAND (LXL(I,J(1)), ICOMP1(LXL(I,J(2)),32,32))
      GO TO 50
C
C  LEFT PEEL
20    IW1 = IOR  (LXR(I,J(2)), ICOMP1(LXL(I,J(2)),32,32))
      IW2 = IAND (LXR(I,J(1)), ICOMP1(LX (I,J(1)),32,32))
      IW3 = IAND (LXR(I,J(3)), ICOMP1(LX (I,J(3)),32,32))
      GO TO 50
C
C  BOTTOM PEEL
30    IW1 = IOR  (LX (I,J(3)), ICOMP1(LX (I,J(1)),32,32))
      IW2 = IAND (LXR(I,J(3)), ICOMP1(LXR(I,J(2)),32,32))
      IW3 = IAND (LXL(I,J(3)), ICOMP1(LXL(I,J(2)),32,32))
      GO TO 50
C
C  RIGHT PEEL
40    IW1 = IOR  (LXL(I,J(2)), ICOMP1(LXR(I,J(2)),32,32))
      IW2 = IAND (LXL(I,J(1)), ICOMP1(LX (I,J(1)),32,32))
      IW3 = IAND (LXL(I,J(3)), ICOMP1(LX (I,J(3)),32,32))
      GO TO 50
C
C  ** TYPE 2 ALGORITHM - PERPENDICULAR CONNECTIONS
2     GO TO (11,22,33,44),ISIDE
C
C  TOP PEEL
11    IW1 = IOR  (LX (I,J(1)), ICOMP1(LX (I,J(3)),32,32))
      IW2 = IAND (LXR(I,J(2)), ICOMP1(LXR(I,J(3)),32,32))
      IW3 = IAND (LXL(I,J(2)), ICOMP1(LXL(I,J(3)),32,32))
      GO TO 50
C
C  LEFT PEEL
22    IW1 = IOR  (LXR(I,J(2)), ICOMP1(LXL(I,J(2)),32,32))
      IW2 = IAND (LX (I,J(3)), ICOMP1(LXL(I,J(3)),32,32))
      IW3 = IAND (LX (I,J(1)), ICOMP1(LXL(I,J(1)),32,32))
      GO TO 50
C
C  BOTTOM PEEL
33    IW1 = IOR  (LX (I,J(3)), ICOMP1(LX (I,J(1)),32,32))
      IW2 = IAND (LXL(I,J(2)), ICOMP1(LXL(I,J(1)),32,32))
      IW3 = IAND (LXR(I,J(2)), ICOMP1(LXR(I,J(1)),32,32))
      GO TO 50
C
C  RIGHT PEEL
44    IW1 = IOR  (LXL(I,J(2)), ICOMP1(LXR(I,J(2)),32,32))
      IW2 = IAND (LX (I,J(1)), ICOMP1(LXR(I,J(1)),32,32))
      IW3 = IAND (LX (I,J(3)), ICOMP1(LXR(I,J(3)),32,32))
C
50    IW1 = IOR (IW1, IW2)
      IW1 = IOR (IW1, IW3)
      LY(I) = IAND (LY(I), IW1)
      IF (LX(I,J(2)).NE.LY(I)) NP=NP+1
60    CONTINUE
C
      IF(ISIDE.EQ.4)RETURN
      CALL BLSFTV(LY,N,LYL)
      CALL BRSFTV(LY,N,LYR)
      RETURN
      END
C
      SUBROUTINE BLSFTV(IX,N,IY)
C
C  THIS SUBROUTINE GENERATES ARRAY IY WITH THE BITS IN IX SHIFTED ONE
C  BIT TO THE LEFT
C
      DIMENSION IX(N),IY(N)
      N1=N-1
      DO 10 I=1,N1
C
C     MOVE ONE BIT FROM BIT POSITION 32 OF IX(I+1) INTO IY(I) AND
C     RIGHT JUSTIFY
      IY(I)=ILOAD(IX(I+1),32,1)
C
C     MOVE RIGHTMOST 31 BITS FROM IX(I) INTO IY(I) STARTING AT BIT
C     POSITION 32
      IY(I)=ISTORE(IX(I),IY(I),32,31)
10    CONTINUE
      IY(N)=0
      IY(N)=ISTORE(IX(N),IY(N),32,31)
      RETURN
C
C **********************************************************************
C
      ENTRY BRSFTV(IX,N,IY)
C
C  THIS ENTRY GENERATES ARRAY IY WITH THE BITS IN IX SHIFTED ONE BIT
C  TO THE RIGHT
C
C     MOVE 31 BITS FROM BIT POSITION 32 OF IX(I) INTO IY(I) AND RIGHT
C     JUSTIFY
      IY(1)=ILOAD(IX(1),32,31)
      DO 20 I=2,N
      IY(I)=ILOAD(IX(I),32,31)
C
C     MOVE RIGHTMOST BIT FROM IX(I-1) INTO IY(I) STARTING AT BIT
C     POSITION 32
      IY(I)=ISTORE(IX(I-1),IY(I),32,1)
20    CONTINUE
      RETURN
      END
C
      SUBROUTINE SVSCI(IX,N,IS)
C
C  THIS SUBROUTINE SETS ALL ELEMENTS OF AN INTEGER*4 VECTOR TO A GIVEN
C  NUMBER
C
      DIMENSION IX(N)
      DO 10 I=1,N
      IX(I)=IS
10    CONTINUE
      RETURN
C
      ENTRY SVSCI2(I2,N,IS)
C
C  THIS ENTRY SETS ALL ELEMENTS OF AN INTEGER*2 VECTOR TO A GIVEN NUMBER
      INTEGER*2 I2(N)
      DO 20 I=1,N
20    I2(I)=IS
      RETURN
C
      ENTRY SVSCL1(I3,N,L)
C
C  THIS ENTRY SETS ALL ELEMENTS OF A LOGICAL*1 VECTOR TO A GIVEN NUMBER
      LOGICAL*1 I3(N)
      DO 30 I=1,N
      I3(I)=L
30    CONTINUE
      RETURN
      END
C
C     THIS SUBROUTINE READS N BYTES FROM DIRECT ACCESS DEVICE IDEV
C     STARTING AT RECORD IX INTO ARRAY X
C
      LOGICAL*1 X(N)
      READ(IDEV'IREC)X
      RETURN
C
      ENTRY DAWN(IDEV,IREC,X,N)
C
C  THIS ENTRY WRITES N BYTES OF ARRAY X ONTO RECORD IX OF DIRECT ACCESS
C  DEVICE IDEV
      WRITE(IDEV'IREC)X
      RETURN
C
      ENTRY SARN(NTAPI,X,N)
C
C  THIS ENTRY READS N BYTES FROM SEQUENTIAL ACCESS UNIT NTAPI INTO
C  ARRAY X
      READ(NTAPI)X
      RETURN
C
      ENTRY SAWN(NTAPO,X,N)
C
C  THIS ENTRY WRITES N BYTES OF ARRAY X ONTO SEQUENTIAL ACCESS
C  UNIT NTAPI
      WRITE(NTAPO)X
      RETURN
      END
