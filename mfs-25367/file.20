C
      SUBROUTINE REGION (IX, IH, ISEQ, IW1, IW2, ITABL, IS, LW, IDENT,
     .                  NREC, NEL, MR)
C
C  THIS SUBROUTINE IDENTIFIES ALL DISTINCT REGIONS IN AN IMAGE AND
C  PRODUCES A MAP WITH A NUMBER AT EACH POINT SHOWING THE REGION TO
C  WHICH IT BELONGS
C
C     D'N IX(MAX(N,NR)),ISEQ(NR) WHERE NR=MAX.NO.OF REGIONS EXPECTED AND
C         N= MAX NO. OF BOUNDARY POINTS EXPECTED IN ANY RECORD
C     D'N ITABL(MR,MSEG),IS(MCR) WHERE MSEG IS THE MAXIMUM
C     NUMBER OF SEGMENTS EXPECTED FOR HANDLING THE GIVEN BOUNDARY IMAGE
C     MCR=MAX NUMBER OF REGION NUMBERS EXPECTED TO OCCUR IN ANY RECORD.
      DIMENSION IX(1), IH(MR,1), ISEQ(1), IRES(20)
      INTEGER*2 IW1(NEL), IW2(NEL), ITABL(MR,1), IS(MR), LW(MR)
      LOGICAL*1 IDENT(MR,MR)
      DATA NDEVI, NDEVM, NDEVO /8, 10, 12/
C
C     CALL REGION IDENTIFICATION ROUTINE
      WRITE(6,100) NREC,NEL
      CALL RIDER1 (IX, IH, IRES, IW1, IW2, ITABL, IS, LW, IDENT, NREC,
     .            NEL, MR, NR, ISEG, NDEVI, NDEVM)
C
C     COMPUTE FINAL HISTOGRAM FOR ALL SEGMENTS USING 'ITABL'
      NR1 = NR + 1
      DO 5 I=2,NR1
5     IX(I) = 0
      NTOT = 0
      DO 10 I=1,MR
      DO 10 J=1,ISEG
      NREG = ITABL(I,J) + 1
      IF (NREG.GT.1) IX(NREG) = IX(NREG) + IH(I,J)
      NTOT = NTOT + IH(I,J)
10    CONTINUE
      IX(1) = NREC*NEL - NTOT
C
C     PRINT HISTOGRAM OF REGION IDENTIFICATION MAP
      WRITE(6,200)
      DO 40 I=1,NR1
      J=I-1
      WRITE (6,350) J, IX(I)
40    CONTINUE
C
C     REARRANGE REGION NUMBERS IN DESCENDING ORDER OF POPULATIONS.
C     LEAVE 0 UNCHANGED SINCE IT CORRESPONDS TO BOUNDARY POINTS
      DO 20 I=1,NR1
      ISEQ(I)=I-1
20    CONTINUE
      CALL SORTLS (IX(2), ISEQ(2), 1, NR)
      WRITE(6,400)
      DO 50 I=1,NR1
      J=I-1
      WRITE (6,350) J, IX(I), ISEQ(I)
50    CONTINUE
      DO 60 I=1,NR1
      NSORT = ISEQ(I)
      IX(NSORT+1) = I-1
60    CONTINUE
C
C     MODIFY REGION NUMBERS ACCORDING TO TABLES 'ITABL' AND 'IX'
      REWIND NDEVM
      JSEG = 0
      DO 70 IREC=1,NREC
      READ (NDEVM) IW1
      IF (IREC.EQ.IRES(JSEG+1)) JSEG = JSEG + 1
      DO 80 IEL=1,NEL
      I=IW1(IEL)
      IF (I.EQ.0) J = 0
      IF (I.NE.0) J = ITABL(I,JSEG)
      IW1(IEL) = IX(J+1)
80    CONTINUE
      WRITE (NDEVO) IW1
70    CONTINUE
      RETURN
C
100   FORMAT(//' IMAGE SIZE=('I5,','I5,')')
200   FORMAT(//10X'REGION NO.'10X'NO. OF PIXELS')
350   FORMAT(11XI6,16XI9,17XI6)
400   FORMAT('1',10X,'REGIONS AFTER REASSIGNMENTS:'//10X,'REGION NO.',
     .10X,'NO. OF PIXELS',10X,'OLD REGION NO.')
      END
C
      SUBROUTINE RIDER1 (IBDY, IH, IRES, IW1, IW2, ITABL, IS, LW, IDENT,
     .                  NREC, NEL, MR, NR, ISEG, NDEVI, NDEVM)
C
C     TO IDENTIFY ALL DISTINCT CONNECTED REGIONS IN A PICTURE SEPARATED
C     BY BOUNDARY LINES.THE BOUNDARY DATA ARE GIVEN AS NREC RECORDS ON A
C     SEQUENTIAL FILE NDEVI, EACH RECORD BEING WRITTEN AS
C     N,(IBDY(I),I=1,N)
C     THE OUTPUT OF THE PROGRAM IS AN NREC*NEL SEQUENTIAL ACCESS FILE ON
C     NDEVO CONSISTING OF 0' S FOR BOUNDARY POINTS AND DISTINCT REGION
C     NUMBERS FOR EACH OF THE CONNECTED REGIONS.
C
      DIMENSION IBDY(1), IH(MR,1), IRES(20)
      INTEGER*2 IW1(NEL), IW2(NEL), ITABL(MR,1), IS(MR), LW(MR)
      LOGICAL*1 IDENT(MR,MR)
      DATA MSEG /20/
C
C     INITIALIZE A WORK ARRAY IW1 WITH 1'S AND IDENT WITH .FALSE.
      DO 2 I=1,NEL
    2 IW1(I) = 1
      DO 4 I=1,MR
      DO 4 J=1,MR
    4 IDENT(I,J) = .FALSE.
      DO 6 I=1,MR
      DO 6 J=1,MSEG
    6 IH(I,J) = 0
      REWIND NDEVM
      ISEG=1
      IRES(1)=1
      NR=0
C
C     LOOP ON RECORDS
      DO 10 IREC=1,NREC
C
C     READ ONE RECORD OF BOUNDARY INFORMATION
      READ(NDEVI)N,(IBDY(I),I=1,N)
C
C     DESIGNATE ALL BOUNDARY POINTS AS 'REGION 0'
      DO 8 I=1,N
      J=IBDY(I)
    8 IW2(J) = 0
C
C     USE IW1 AND IBDY TO SET ARRAY IW2 AND MATRIX IDENT
      N1=N-1
   30 CONTINUE
      CALL RIDER2 (IBDY, IW1, IW2, IDENT, ISEG, N1, NEL, MR, NR)
      IF(NR.GT.-1) GO TO 20
      WRITE(6,200) IREC,NR
      IF(IREC.EQ.IRES(ISEG))GO TO 40
      NR=-NR
      CALL RIDER4(IDENT,LW,MR,NR,ITABL,ISEG,IW1,NEL,IS,.FALSE.)
      ISEG=ISEG+1
      IF(ISEG.GT.MSEG)GO TO 40
      IRES(ISEG)=IREC
      IF(NR.LE.MR)GO TO 30
C
   20 WRITE (NDEVM) IW2
      DO 21 I=1,NEL
   21 IW1(I) = IW2(I)
      DO 25 I=1,N1
      L1 = IBDY(I) + 1
      L2 = IBDY(I+1) - 1
      IF (L1.GT.L2) GO TO 25
      KR = IW2(L1)
      IH(KR,ISEG) = IH(KR,ISEG) + L2 - L1 + 1
   25 CONTINUE
   10 CONTINUE
C
C     OBTAIN LOOKUP TABLE FOR THE FINAL SEGMENT
      CALL RIDER4(IDENT,LW,MR,NR,ITABL,ISEG,IW1,NEL,IS, .TRUE.)
      CALL RIDER3 (ITABL, MR*ISEG)
C
C     FIND HIGHEST REGION NUMBER
      NR=0
      DO 35 I=1,MR
      DO 35 J=1,ISEG
   35 IF (ITABL(I,J).GT.NR) NR = ITABL(I,J)
      RETURN
C
   40 WRITE (6,100) IREC
      NR=0
      RETURN
C
100   FORMAT(' ERROR CONDITION IN RIDER.  SUPPLIED MR OR MSEG WAS EXCEED
     .ED AT RECORD NUMBER'I6,'.  RETURNING WITH NR=0')
200   FORMAT(' (IREC, NR) = '2I6)
      END
C
      SUBROUTINE RIDER2 (IBDY, IX, IY, IDENT, ISEG, N1, NEL, MR, NR)
C
C     GIVEN CURRENT SET OF BOUNDARY ADDRESSES (IBDY(I),I=1,N) AND THE
C     LAST ARRAY IX, FIND CURRENT ARRAY IY CONTAINING REGION IDENTIFICA-
C     TION NUMBERS.  ALSO, IF THE NONBOUNDARY ELEMENTS IN CURRENT ROW
C     ARE CONTIGUOUS WITH ANY NONBOUNDARY POINTS OF THE LAST ROW, SET
C     THE CORRESPONDING ELEMENTS IN IDENT MATRIX.
C
      DIMENSION IBDY(1)
      INTEGER*2 IX(NEL),IY(NEL)
      LOGICAL*1 IDENT(MR,MR)
C
C     FOR I=1,N-1 EXAMINE IX(J) FOR IBDY(I).LT.J.LT.IBDY(I+1)
C     AND SET IY ACCORDINGLY.  A NEW REGION NUMBER IS STARTED WHEN IX(J)
C     IS 0 FOR ALL J IN THE ABOVE RANGE.
      NRP=NR
      DO 40 I=1,N1
      L1=IBDY(I)+1
      L2=IBDY(I+1)-1
      IF(L1.GT.L2)GO TO 40
C
C     LOOP OVER PIXELS BETWEEN BOUNDARY POINTS AT L1 AND L2
      DO 50 L=L1,L2
      IF(IX(L).EQ.0)GO TO 50
C
C     GO TO 60 IF IX(L) IS NOT A BOUNDARY
      GO TO 60
   50 CONTINUE
C
C  START NEW REGION IF PREVIOUS LINE (IX) IS ALL BOUNDARY POINTS
      NR=NR+1
      IF (NR.GT.MR) GO TO 90
      DO 55 K=L1,L2
   55 IY(K) = NR
      IDENT(NR,NR)=.TRUE.
      GO TO 40
C
C  IF IX(L) IS NOT A BOUNDARY, SET IY FROM L1 TO L2 TO IX(L)
   60 CONTINUE
      DO 61 K=L1,L2
   61 IY(K) = IX(L)
C
   40 CONTINUE
C
C     SET IDENT MATRIX TO INDICATE REGION NUMBERS CORRESPONDING TO
C     IDENTICAL REGIONS.
   20   CONTINUE
      DO 80 IEL=1,NEL
      I=IX(IEL)
      IF(I.EQ.0)GO TO 80
      J=IY(IEL)
      IF(J.EQ.0)GO TO 80
      IDENT(I,J)=.TRUE.
   80 CONTINUE
      RETURN
C
   90 CONTINUE
      NR=-NRP
      RETURN
      END
C
      SUBROUTINE RIDER3 (ITABL, NRSEG)
C
C     CHANGE REGION NUMBERS SUCH THAT CONSECUTIVE NUMBERS ARE USED.
C
      INTEGER*2 ITABL(NRSEG,2)
C
C     FIND THE SET OF NUMBERS IN ITABL(*,1).
      DO 5 I=1,NRSEG
      ITABL(I,2)=0
5     CONTINUE
      DO 10 I=1,NRSEG
      J=ITABL(I,1)
      IF (J.NE.0) ITABL(J,2) = 1
10    CONTINUE
C
C     CHANGE ITABL(*,2) TO GET A LOOKUP TABLE FOR ITABL(*,1).
      J=0
      DO 20 I=1,NRSEG
      IF(ITABL(I,2).EQ.0)GO TO 20
      J=J+1
      ITABL(I,2)=J
20    CONTINUE
C
C     CHANGE ITABL(*,1).
      DO 30 I=1,NRSEG
      ITABL(I,1)=ITABL(ITABL(I,1),2)
30    CONTINUE
      RETURN
      END
C
      SUBROUTINE RIDER4(IDENT,LW,MR,NR,ITABL,ISEG,IW1,NEL,IS,LAST)
C
C     THIS ROUTINE IS CALLED FROM RIDER1 WHEN ALL RECORDS ARE PROCESSED
C     (LAST=.TRUE.) OR WHEN THE NUMBER OF REGION NUMBERS FOUND WHILE
C     TESTING (IREC+1)'TH RECORD EXCEEDS MR. (LAST=.FALSE.).  THEN,
C          1. THE REGION CONNECTIVITY MATRIX IDENT IS REDUCED TO GET A
C     LOOKUP TABLE FOR THE CURRENT SEGMENT.
C         2. THE LOOK-UP TABLES CORRESPONDING TO EARLIER SEGMENTS ARE
C     MODIFIED BASED ON NEWLY FOUND CONNECTIVITIES, IF ANY.
C          3. THE DISTINCT REGION NUMBERS OCCURRING IN THE IREC'TH SEG.
C     ARE FOUND: A CORRESPONDENCE ARRAY IS BETWEEN CURRENT AND NEXT
C     SEGMENT SET UP.  THE LAST RECORD(IW1) IS MODIFIED TO MATCH THE
C     NUMBERING OF THE NEXT SEGMENT.
C        4. THE CONNECTIVITY MATRIX IS MODIFIED TO PRESERVE THE INFORMA-
C     TION ON THE CONNECTIONS BETWEEN REGIONS IN IREC'TH RECORD.
C
      INTEGER*2 ITABL(MR,1),LW(MR),IS(1),IW1(NEL)
      LOGICAL*1 IDENT(MR,MR)
      LOGICAL LAST
C
C               SECTION 1.
      DO 10 I=1,NR
      DO 10 J=1,NR
      IDENT(I,J)=IDENT(I,J).OR.IDENT(J,I)
10    CONTINUE
      CALL RIDER5(IDENT,MR,NR,ITABL(1,ISEG),LW)
      ISEGT=(ISEG-1)*MR
      DO 20 I=1,NR
      ITABL(I,ISEG) = ITABL(I,ISEG) + ISEGT
20    CONTINUE
      IF (MR.LE.NR) GO TO 50
      NR1 = NR + 1
      DO 30 I=NR1,MR
      ITABL(I,ISEG) = 0
30    CONTINUE
C
C              SECTION 2.
50    CONTINUE
      IF(ISEG.EQ.1)GO TO 60
      ISEG1=ISEG-1
      CALL RIDER7(ITABL(1,ISEG),IS,NCR,ITABL,MR*ISEG1)
C
C              SECTION 3.
60    IF(LAST)RETURN
      CALL RIDER6(IW1,NEL,IS,NR)
      NCR=NR
      DO 70 I=1,NR
      IS(I)=ITABL(IS(I),ISEG)
70    CONTINUE
C
C              SECTION 4.
C     CONNECTIVITIES BETWEEN NEW REGIONS I,J IN THE LAST RECORD ARE FOUN
C     BY TESTING WHETHER IS(I).EQ.IS(J)
      DO 80 I=1,MR
      DO 80 J=1,MR
80    IDENT(I,J) = .FALSE.
      DO 100 I=1,NR
      IDENT(I,I)=.TRUE.
      IF (I.EQ.NR) GO TO 100
      I1=I+1
      DO 90 J=I1,NR
90    IDENT(I,J)=IS(I).EQ.IS(J)
100   CONTINUE
      RETURN
      END
C
      SUBROUTINE RIDER5(IDENT,MD,N,IT,M)
C
C     TO GENERATE A TABLE IT MAPPING J=1,...,N TO I=IT(J)= SMALLEST K
C     SUCH THAT THERE EXISTS A SEQUENCE (K(ID),ID=1,...,L) WITH K(I)=I,
C     K(L)=J AND IDENT(K(ID),K(ID+1))=.TRUE.
C
      INTEGER*2 IT(N),M(1)
      LOGICAL*1 IDENT(MD,N)
C
      DO 100 I=1,N
      IT(I)=I
100   CONTINUE
      I=0
10    I=I+1
      IF(I.LE.N)GO TO 20
      RETURN
20    IF(IT(I).LT.I)GO TO 10
      J=0
      K=0
30    J=J+1
      IF(J.LE.N)GO TO 40
      L=0
50    L=L+1
      IF(L.GT.K)GO TO 10
      J=0
70    J=J+1
      IF(J.GT.N)GO TO 50
      IF(.NOT.IDENT(M(L),J))GO TO 70
      IF(IT(J).EQ.I)GO TO 70
      IT(J)=I
      K=K+1
      M(K)=J
      GO TO 70
40    IF(.NOT.IDENT(I,J))GO TO 30
      IT(J)=I
      K=K+1
      M(K)=J
      GO TO 30
      END
C
      SUBROUTINE RIDER6 (IX, NEL, IS, N)
C
C     FIND A SET IS OF DISTINCT NONZERO ELEMENTS IN IX.  THE NUMBER OF
C     SUCH ELEMENTS IS N.
C
      INTEGER*2 IX(NEL), IS(1)
C
      N = 0
      DO 10 I=1,NEL
      IF (IX(I).EQ.0) GO TO 10
      IF(N.EQ.0)GO TO 20
C
C     CHECK ELEMENTS OF IS ALREADY LOADED
      DO 30 J=1,N
      IF(IS(J).EQ.IX(I))GO TO 40
30    CONTINUE
C
C     CURRENT ELEMENT OF IX IS DISTINCT
20    N=N+1
      IS(N)=IX(I)
      IX(I)=N
      GO TO 10
C
C     CURRENT ELEMENT OF IX EQUALS J-TH DISTINCT ELEMENT
40    IX(I)=J
10    CONTINUE
      RETURN
      END
C
      SUBROUTINE RIDER7(IX,IS,N,IY,M)
C
C  MODIFY RELEVANT ENTRIES IN IY ACCORDING TO CONNECTIVITIES FOUND IN IS
C
      INTEGER*2 IX(N),IS(N),IY(M)
C
      IF (N.EQ.0) RETURN
      MAX = IS(1)
      MIN = IS(1)
      DO 5 I=1,N
      IF (IS(I).GT.MAX) MAX = IS(I)
    5 IF (IS(I).LT.MIN) MIN = IS(I)
C
C     CHECK FOR REGION NUMBERS OUTSIDE RANGE OF IY (PREVIOUS SEGMENTS)
      DO 10 J=1,M
      IF(IY(J).LT.MIN.OR.IY(J).GT.MAX)GO TO 10
C
C     MODIFY PREVIOUS TABLE (IY) USING CURRENT TABLE (IX)
      DO 20 I=1,N
      IF(IY(J).NE.IS(I))GO TO 20
      IY(J)=IX(I)
      GO TO 10
20    CONTINUE
10    CONTINUE
      RETURN
      END
C
      SUBROUTINE SORTSL (A1, A2, II, JJ)
C
C  SORT ARRAY A1 AND ARRANGE ARRAY A2 CORRESPONDINGLY
C  DO FROM ELEMENTS II TO JJ
C
      DIMENSION A1(1), A2(1), IU(16), IL(16)
      INTEGER A1, A2, T1, T2, TT1, TT2
      LOGICAL*1 SL
      SL = .TRUE.
      GO TO 1
C
      ENTRY SORTLS (A1, A2, II, JJ)
C
      SL = .FALSE.
    1 ND = JJ - II + 1
      M=1
      I=II
      J=JJ
   5  IF(I.GE.J) GOTO 70
   10 K=I
      IJ=(J+I)/2
      T1 = A1(IJ)
      T2 = A2(IJ)
      IF (A1(I).LE.T1) GO TO 20
      A1(IJ) = A1(I)
      A2(IJ) = A2(I)
      A1(I) = T1
      A2(I) = T2
      T1 = A1(IJ)
      T2 = A2(IJ)
   20 L=J
      IF (A1(J).GE.T1) GO TO 40
      A1(IJ) = A1(J)
      A2(IJ) = A2(J)
      A1(J) = T1
      A2(J) = T2
      T1 = A1(IJ)
      T2 = A2(IJ)
      IF (A1(I).LE.T1) GO TO 40
      A1(IJ) = A1(I)
      A2(IJ) = A2(I)
      A1(I) = T1
      A2(I) = T2
      T1 = A1(IJ)
      T2 = A2(IJ)
      GOTO 40
   30 A1(L) = A1(K)
      A2(L) = A2(K)
      A1(K) = TT1
      A2(K) = TT2
  40  L=L-1
      IF (A1(L).GT.T1) GO TO 40
      TT1 = A1(L)
      TT2 = A2(L)
 50   K=K+1
      IF (A1(K).LT.T1) GO TO 50
      IF(K.LE.L) GOTO 30
      IF(L-I.LE.J-K) GOTO 60
      IL(M)=I
      IU(M)=L
      I=K
      M=M+1
      GOTO 80
   60 IL(M) = K
      IU(M)=J
      J=L
      M=M+1
      GOTO 80
   70 M=M-1
      IF (M.NE.0) GO TO 75
      IF (SL) RETURN
      ND2 = ND/2
      I1 = II
      I2 = JJ
      DO 110 I=1,ND2
      T1 = A1(I1)
      T2 = A2(I1)
      A1(I1) = A1(I2)
      A2(I1) = A2(I2)
      A1(I2) = T1
      A2(I2) = T2
      I1 = I1 + 1
  110 I2 = I2 - 1
      RETURN
   75 I=IL(M)
      J=IU(M)
  80  IF(J-I.GE.II) GOTO 10
      IF(I.EQ.II) GOTO 5
      I=I-1
   90 I=I+1
      IF(I.EQ.J) GOTO 70
      T1 = A1(I+1)
      T2 = A2(I+1)
      IF (A1(I).LE.T1) GO TO 90
      K=I
  100 A1(K+1) = A1(K)
      A2(K+1) = A2(K)
      K=K-1
      IF (T1.LT.A1(K)) GO TO 100
      A1(K+1) = T1
      A2(K+1) = T2
      GOTO 90
      RETURN
      END
