C
C *** LAST REVISED ON 20-AUG-1987 10:39:32.39
C *** SOURCE FILE: [DL.GRAPHICS.LONGLIB]CURSORLIB.FOR
C
C ***********************************************************************
C
C	CURSOR ROUTINES AND PAUSE ROUTINES
C	FOR THE LONGLIB GRAPHICS LIBRARY.
C
C	NOTE THAT CURSOR ROUTINES ARE SCREEN GRAPHICS DEVICE DEPENDENT
C	THIS FILE CONTAINS ROUTINES FOR TEK4010 COMPATIBLE TERMINALS WHICH
C	HAVE BUILT IN CURSORS.  IT ALSO CONTAINS ROUTINES WHICH SIMULATE
C	A CURSOR BY DRAWING AND REDRAWING A CURSOR.  SEE NOTES BELOW.
C	PAUSE ROUTINES WHICH USE SOME DIRECT TERMINAL I/O ARE ALSO
C	INCLUDED IN THIS FILE.  THE ROUTINES AT THE END OF THE FILE
C	ARE VERY MACHINE DEPENDENT.  THOSE NEAR THE TOP OF THE FILE
C	ARE ESSENTIALLY FORTRAN-77 COMPATIBLE WITH SOME EXCEPTIONS.
C
C ***********************************************************************
C
	SUBROUTINE GETCURSOR(X,Y,IKEY,ARESX,ARESY)
C
C	CREATED BY D. LONG    MAR, 1985		AT JPL
C
C	THIS ROUTINE READS THE GRAPHICS INPUT DEVICE ON A TEKTRONICS
C	COMPATIBLE GRAPHICS TERMINAL 
C
C INPUTS: (NONE)
C
C OUTPUTS:
C
C	X,Y	RETURNED CURSOR POSITION RELATIVE TO INITIALIZED GRAPHICS PACKAGE
C	IKEY	GIN STATUS (DEVICE DEPENDENT CODE)
C	ARESX,ARESY RESOLUTION OF SCREEN DEVICE (RETURNED)
C
	COMMON/VT100/IVT100,NIVM(32),VRE(2),VOX,VOY,VSF,NNIVM,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	CHARACTER*1 S(6)
	CHARACTER*(*) PROMPT
	PARAMETER (PROMPT=CHAR(29)//CHAR(27)//CHAR(26))
C
	IF (IVT100.LT.0) RETURN
	IF (ITERM.LT.5) RETURN
C
C	PROMPT FOR GIN CURSOR LOCATION
C
	WRITE(*,1) PROMPT
 1	FORMAT(X,A3,$)
	READ(*,2) S
 2	FORMAT(6A1)
C
C	GET STATUS BYTE
C
	IKEY=ICHAR(S(1))
C
C	CONVERT GRAPHICS INPUT STRING TO TEK 4014 COORDINATES
C
	IXH=ICHAR(S(2))-32
	IXL=ICHAR(S(3))-32
	IX=(IXL+IXH*32)*4
	IYH=ICHAR(S(4))-32
	IYL=ICHAR(S(5))-32
	IY=(IYL+IYH*32)*4
C
C	SET UP CONVERSION CONSTANTS
C
	RESX=VRE(1)
	RESY=VRE(2)
	ARESX=RESX/VSF
	ARESY=RESY/VSF
	ANG=VANG
	COSA=COS(ANG*0.0174532)
	SINA=SIN(ANG*0.0174532)
C
C	COMPUTE LOCATION OF CURSOR RELATIVE TO PLOT PACKAGE
C
	X=((FLOAT(IX)*RESX-VOX)*COSA+(FLOAT(IY)*RESY-VOY)*SINA)/VSF
	Y=(-(FLOAT(IX)*RESX-VOX)*SINA+(FLOAT(IY)*RESY-VOY)*COSA)/VSF
C
	RETURN
	END
C
C
	SUBROUTINE CURLOCATE(X,Y,INUM,IDEV)
C
C	CREATED BY D. LONG    OCT, 1983	AT JPL
C	REVISED BY D. LONG    AUG, 1987
C
C	THIS ROUTINE PRODUCES A CROSS-HAIR "CURSOR MARK" ON A GRAPHICS
C	TERMINAL DEVICE.  IT USES THE CURSOR ON THE RAMTEK DEVICE SCREEN.
C
C	INPUTS:
C
C	X,Y	CURSOR POSITION RELATIVE TO INTIALIZED GRAPHICS PACKAGE
C	INUM	CURSOR NUMBER/LENGTH (1-4)
C		> 0 PUTS CURSOR DOWN (DRAWS CURSOR)
C		< 0 REMOVES CURSOR (ERASES CURSOR)
C	IDEV	DEVICE CODE (RECOGNIZED ONLY WHEN RAMTEK USED
C		= 0 USE RAMTEK CURSOR DEVICES
C		= 1 PLOT SIMULATED CURSOR MARK
C
C	THIS ROUTINE CHECKS FIRST TO SEE IF A TERMINAL SCREEN DEVICE IS
C	ENABLED.  IF IT IS, THE TERMINAL IS USED AS OUTPUT OTHERWISE
C	THE RAMTEK DEVICE IS CHECKED TO SEE IF IT IS ENABLED. THEN IF
C	THE RAMTEK DEVICE IS ENABLED, IT USES THE RAMTEK SCREEN AS
C	OUTPUT.  OTHERWISE, THE ROUTINE RETURNS.
C
	INTEGER X0,Y0,IUSE(2),IR(12)
	LOGICAL DEVICE
	DATA ICLV/14/
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,NIVM(32),VRE(2),VOX,VOY,VSF,NNIVM,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	DEVICE=.TRUE.
	RESX=VRE(1)
	RESY=VRE(2)
	OX=VOX
	OY=VOY
	SF=VSF
	ANG=VANG
	IYR=IYREV
C
C	DETERMINE OUTPUT DEVICE AND SET PARAMETERS
C
	IF (IVT100.LT.0) THEN
	    IF (ICHAN.LT.0) RETURN
	    DEVICE=.FALSE.
	    RESX=RRE(1)
	    RESY=RRE(2)
	    OX=ROX
	    OY=ROY
	    SF=RSF
	    ANG=RANG
	    IYR=1
	ENDIF
	ARESX=RESX/SF
	ARESY=RESY/SF
	ITYPE=IABS(INUM)
	IF (DEVICE) THEN
	    IUSE(1)=IXLIM
	    IUSE(2)=IYLIM
	    IF (ITYPE.EQ.0) ITYPE=1
	ELSE
	    IUSE(1)=IRXLIM
	    IUSE(2)=IRYLIM
	ENDIF
	IY=ICLV*ITYPE
	IX=IY*RESY/RESX
	IVI=2
	IBL=1
C
C	TRANSFORM INPUT POINT
C
	COSA=COS(ANG*0.0174532)
	SINA=SIN(ANG*0.0174532)
	XX=COSA*X-SINA*Y
	YY=SINA*X+COSA*Y
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	X0=XX/RESX
	Y0=YY/RESY
C
C	CLIP LOCATION TO SCREEN SIZE
C
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	IF (X0.LT.0) X0=0
	IF (X0.GT.IUSE(1)) X0=IUSE(1)
	IF (Y0.LT.0) Y0=0
	IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
C
C	LOAD CURSOR MARK ARRAY
C
	IR(1)=X0-IX
	IR(2)=Y0+IY
	IR(3)=X0
	IR(4)=Y0
	IR(5)=X0-IX
	IR(6)=Y0-IY
	IR(7)=X0+IX
	IR(8)=Y0+IY
	IR(9)=X0
	IR(10)=Y0
	IR(11)=X0+IX
	IR(12)=Y0-IY
C
C	CLIP VECTOR EDGES
C
	DO 543 I=1,11,2
		IF (IR(I).LT.0) IR(I)=0
		IF (IR(I).GT.IUSE(1)) IR(I)=IUSE(1)
		IF (IR(I+1).LT.0) IR(I+1)=0
		IF (IR(I+1).GT.IUSE(2)) IR(I+1)=IUSE(2)
543	CONTINUE
C
C	OUTPUT CURSOR MARK
C
	IF (INUM.GT.0) THEN
		IF (DEVICE) THEN
C
C	XOR CURSOR MARK DOWN
C
			CALL CTERM(-1)
			CALL VTPLOT(3,IR,1,1)
			CALL VTPLOT(3,IR(7),1,1)
		ELSE
			IF (IDEV.EQ.0) THEN
C
C	USE RAMTEK CURSOR DEVICE (MOVE AND MAKE VISIBLE)
C
			  CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,IBL,IVI,IERR)
			ELSE
C
C	PLOT CURSOR MARK WITH COLOR 255
C
			  CALL RMPLOT(ICHAN,3,IR,255,IERR)
			  CALL RMPLOT(ICHAN,3,IR(7),255,IERR)
			ENDIF
		ENDIF
	ELSE
		IF (DEVICE) THEN
C
C	XOR CURSOR MARK UP
C
			CALL CTERM(-1)
			CALL VTPLOT(3,IR,3,1)
			CALL VTPLOT(3,IR(7),3,1)
		ELSE
			IF (IDEV.EQ.0) THEN
C
C	USE RAMTEK CURSOR DEVICE (MAKE INVISIBLE)
C
			  CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,0,0,IERR)
			ELSE
C
C	PLOT CURSOR MARK WITH COLOR 0
C
			  CALL RMPLOT(ICHAN,3,IR,0,IERR)
			  CALL RMPLOT(ICHAN,3,IR(7),0,IERR)
			ENDIF
		ENDIF
	ENDIF
	RETURN
	END
C
C
C ***********************************************************************
C
C	THE FOLLOWING CURSOR ROUTINES SIMULATE A GRAPHICS INPUT DEVICE
C	FROM EITHER A TERMINAL OR RAMTEK DISPLAY.  THE SIMULATED CURSOR
C	CAN BE MOVED USING A VT100-COMPATIBLE KEYPAD.  THESE ROUTINES WORK
C	BEST WHEN THE GRAPHICS DEVICE SUPORT XOR PLOT MODE.  THEY USE
C	A MACHINE-DEPENDENT ROUTINE TO GET THE NEXT CHARACTER FROM THE
C	TERMINAL
C
C ***********************************************************************
C
C
	SUBROUTINE CURMOTION(X,Y,IFLAG,ARESX,ARESY)
C
C	CREATED BY D. LONG    OCT, 1983		AT JPL
C	REVISED BY D. LONG    AUG, 1987
C
C	THIS ROUTINE MOVES A CROSS-HAIR "CURSOR" ON THE GRAPHICS
C	DEVICE USING THE VT100 CURSOR MOTION ESCAPE KEYS
C	IT WILL HANDLE THE RAMTEK DISPLAY USING THE RAMTEK CURSOR
C
C	OUTPUTS:
C
C	X,Y	CURSOR POSITION RELATIVE TO INTIALIZED GRAPHICS PACKAGE
C		CURSOR STARTS FROM THIS POSITION.  NEW POSITION IS RETURNED.
C	IFLAG	RETURN FLAG
C		< 0  ROUTINE ERROR
C		= 0  NORMAL RETURN
C		> 0  PF KEY NUMBER (KEYS 2,3,4) OR KEY PAD KEYCODE
C	ARESX,ARESY RESOLUTION OF SCREEN DEVICE (RETURNED)
C
C	THIS ROUTINE CHECKS FIRST TO SEE IF A TERMINAL SCREEN DEVICE IS
C	ENABLED.  IF IT IS, THE TERMINAL IS USED AS OUTPUT OTHERWISE
C	THE RAMTEK DEVICE IS CHECKED TO SEE IF IT IS ENABLED. THEN IF
C	THE RAMTEK DEVICE IS ENABLED, IT USES THE RAMTEK SCREEN AS
C	OUTPUT.  OTHERWISE, THE ROUTINE RETURNS.
C
	INTEGER ESC,EQUAL,GREAT,KEYS(14)
	INTEGER X0,Y0,IX(2),IY(2),IUSE(2),IR(10)
	LOGICAL DEVICE,MOVE,MOVE2
C
	DATA ESC/27/,EQUAL/61/,GREAT/62/
	DATA KEYS/112,113,114,115,116,117,118,119,120,121,110,
     $		72,108,109/
	DATA ICLV/64/,ICLR/32/,ICY/0/
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,NIVM(32),VRE(2),VOX,VOY,VSF,NNIVM,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	IFLAG=-1
	DEVICE=.TRUE.
	RESX=VRE(1)
	RESY=VRE(2)
	OX=VOX
	OY=VOY
	SF=VSF
	ANG=VANG
	IYR=IYREV
	IF (IVT100.LT.0) THEN
	    IF (ICHAN.LT.0) RETURN
	    DEVICE=.FALSE.
	    RESX=RRE(1)
	    RESY=RRE(2)
	    OX=ROX
	    OY=ROY
	    SF=RSF
	    ANG=RANG
	    IYR=1
	ENDIF
	ARESX=RESX/SF
	ARESY=RESY/SF
1	FORMAT('+',11A1,$)
	MOVE=.TRUE.
	MOVE2=.FALSE.
	IF (DEVICE) THEN
	    IUSE(1)=IXLIM
	    IUSE(2)=IYLIM
	    ICYO=ICLV
	    ICXO=ICLV*RESY/RESX
	    IPIXX0=ICXO*2
	    IPIXY0=ICLV*2
	ELSE
	    IUSE(1)=IRXLIM
	    IUSE(2)=IRYLIM
	    ICXO=ICLR
	    ICYO=ICLR
	    IPIXX0=32
	    IPIXY0=32
	ENDIF
	IVI=2
	IBL=1
	ITYPE=0
C
C	SCALE AND CLIP INPUT
C
	COSA=COS(ANG*0.0174532)
	SINA=SIN(ANG*0.0174532)
	XX=COSA*X-SINA*Y
	YY=SINA*X+COSA*Y
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	X0=XX/RESX
	Y0=YY/RESY
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	IF (X0.LT.0) X0=0
	IF (X0.GT.IUSE(1)) X0=IUSE(1)
	IF (Y0.LT.0) Y0=0
	IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
C
C	SET INITIAL MOTION STEP
C
	IF (ICY.EQ.0) THEN
		ICY=ICYO
		ICX=ICXO
		IPIXX=IPIXX0
		IPIXY=IPIXY0
	ENDIF
C
C	SET VT100-COMPATIBLE TERMINAL KEYPAD MODE ON
C
	CALL CTERM(1)
	WRITE(*,11) ESC,EQUAL
11	FORMAT('+',2A1,$)
C
C	TOP OF CURSOR MOTION LOOP
C
 10	CONTINUE
C
C	FILL CURSOR MARK ARRAY
C
	    IX(1)=X0-ICX
	    IX(2)=X0+ICX
	    IY(1)=Y0-ICY
	    IY(2)=Y0+ICY
	    DO 40 I=1,2
		IF (IX(I).LT.0) IX(I)=0
		IF (IX(I).GT.IUSE(1)) IX(I)=IUSE(1)
		IF (IY(I).LT.0) IY(I)=0
		IF (IY(I).GT.IUSE(2)) IY(I)=IUSE(2)
		IR(2*I-1)=IX(I)
		IR(2*I)=Y0
		IR(2*I+3)=X0
		IR(2*I+4)=IY(I)
40	    CONTINUE
C
C	DISPLAY CURRENT CURSOR MARK
C
	    IF (DEVICE) THEN
C
C	XOR CURSOR MARK
C
		CALL CTERM(-1)
		CALL VTPLOT(2,IR,1,1)
		CALL VTPLOT(2,IR(5),1,1)
		CALL CTERM(1)
	    ELSE
C
C	IN THE CASE OF THE RAMTEK, WE WILL PRINT THE CURRENT LOCATION
C	OF THE CURSOR TO THE TERMINAL SCREEN THEN ENABLE THE GRAPHICS CURSOR
C	DEVICE
C
		WRITE(*,14) X0,IUSE(2)-Y0,IPIXX
  14		FORMAT('+Ram Tek Cursor at (',I4,','I4')   Step: ',I2)
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,IBL,IVI,IERR)
	    ENDIF
C
C	READ THE NEXT CHARACTER FROM THE TERMINAL AS AN ASCII VALUE
C
 199	    CONTINUE
	    IN=INXTCHR()
C
C	DECODE CHARACTER
C
	    IF (IN.EQ.13.OR.IN.EQ.32) THEN		! RETURN KEY
		IFLAG=0
		IF (IN.EQ.32) THEN IFLAG=1
		GOTO 99
	    ENDIF
C
C	IF NOT AN ESCAPE KEY, EXIT
C
	    IF (IN.NE.ESC) THEN
C		IFLAG=IN
		GOTO 199
	    ENDIF
C
C	GET NEXT KEY STROKES TO FINISH ESCAPE SEQUENCE
C
	    IN=INXTCHR()
	    IF ((IN.NE.79).AND.(IN.NE.91)) GOTO 199
	    IN=INXTCHR()
C
C	DECODE ESCAPE SEQUENCE COMMAND
C	THESE COMMANDS ARE FOR EXITS ON PF KEYS 2-4
C
	    IF (IN.EQ.81) THEN		     ! PF KEY 2
		IFLAG=2
		GOTO 99
	    ENDIF
	    IF (IN.EQ.82) THEN		     ! PF KEY 3
		IFLAG=3
		GOTO 99
	    ENDIF
	    IF (IN.EQ.83) THEN		     ! PF KEY 4
		IFLAG=4
		GOTO 99
	    ENDIF
	    IF (IN.EQ.80) THEN		     ! PF KEY 1
C
C	IF PF KEY 1 STRUCK, THEN TOGGLE THE STEP SIZE OF THE CURSOR MOTION
C
		IF (MOVE) THEN
		    ICX=ICX/2
		    ICY=ICY/2
		    IPIXY=IPIXY/4
		    IPIXX=IPIXX/4
		    IF (MOVE2) THEN
			MOVE=.FALSE.
			IPIXY=1
			IPIXX=1
		    ENDIF
		    MOVE2=.TRUE.
		ELSE
		    MOVE2=.FALSE.
		    ICX=ICXO
		    ICY=ICYO
		    IPIXY=IPIXY0
		    IPIXX=IPIXX0
		    MOVE=.TRUE.
		ENDIF
		GOTO 100
	    ENDIF
C
C	DECODE CURSOR MOVE COMMANDS
C
	    IF (IN.EQ.65) THEN	    ! CURSOR UP
		Y0=Y0+IPIXY
		IF (IYR.EQ.1) Y0=Y0-2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.66) THEN	    ! CURSOR DOWN
		Y0=Y0-IPIXY
		IF (IYR.EQ.1) Y0=Y0+2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.67) THEN	    ! CURSOR RIGHT
		X0=X0+IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.68) THEN	    ! CURSOR LEFT
		X0=X0-IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
C
C	DECODE WHICH OF THE KEYPAD KEYS WERE STRUCK
C
	    DO 45 I=1,14
		IF (IN.EQ.KEYS(I)) THEN
		    IFLAG=9+I
		    GOTO 99
		ENDIF
45	    CONTINUE
 99	CONTINUE
C
C	COMPUTE LOCATION OF CURSOR AND ERASE IT
C
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	X=((FLOAT(X0)*RESX-OX)*COSA+(FLOAT(Y0)*RESY-OY)*SINA)/SF
	Y=(-(FLOAT(X0)*RESX-OX)*SINA+(FLOAT(Y0)*RESY-OY)*COSA)/SF
	    IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
	    ELSE
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,0,0,IERR)
	    ENDIF
	    GOTO 999
100	CONTINUE
C
C	PLOT CURSOR UP
C
	IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
		CALL CTERM(1)
	ENDIF
	GOTO 10
999	CONTINUE		! RETURN SCREEN TO NORMAL
C
C	DISABLE KEYPAD ESCAPE SEQUENCES AND RETURN
C
	CALL CTERM(1)
	WRITE(*,11) ESC,GREAT
	CALL CTERM(-1)
	RETURN
	END
C
C
	SUBROUTINE CURBAND(X,Y,IFLAG,ARESX,ARESY,X1,Y1,X2,Y2)
C
C	CREATED BY D. LONG    OCT, 1983	AT JPL
C	REVISED BY D. LONG    AUG, 1987
C
C	THIS ROUTINE MOVES A CROSS-HAIR "CURSOR" ON THE GRAPHICS
C	DEVICE USING THE VT100 CURSOR MOTION ESCAPE KEYS
C	IT WILL HANDLE THE RAMTEK DISPLAY USING THE RAM TEK CURSOR
C
C	OUTPUTS:
C
C	X,Y	RETURNED CURSOR POSITION RELATIVE TO INTIALIZED GRAPHICS PACKAGE
C	IFLAG	RETURN FLAG
C		< 0  ROUTINE ERROR
C		= 0  NORMAL RETURN
C		> 0  PF KEY NUMBER (KEYS 2,3,4)
C	ARESX,ARESY RESOLUTION OF SCREEN DEVICE
C	X1,Y1	= START POINT OF RUBBER BANDED LINE
C	X2,Y2	= END POINT OF RUBBER BANDED LINE (=999.,999. DOES NOT USE)
C
C	THIS ROUTINE CHECKS FIRST TO SEE IF A TERMINAL SCREEN DEVICE IS
C	ENABLED.  IF IT IS, THE TERMINAL IS USED AS OUTPUT OTHERWISE
C	THE RAMTEK DEVICE IS CHECKED TO SEE IF IT IS ENABLED. THEN IF
C	THE RAMTEK DEVICE IS ENABLED, IT USES THE RAMTEK SCREEN AS
C	OUTPUT.  OTHERWISE, THE ROUTINE RETURNS.
C
	INTEGER ESC,EQUAL,GREAT,KEYS(14)
	INTEGER X0,Y0,IX(2),IY(2),IUSE(2)
	INTEGER IR(8),IR1(4),IR2(4),IP(6)
	EQUIVALENCE (IR,IR1),(IR(5),IR2(1))
	LOGICAL DEVICE,MOVE,MOVE2
C
	DATA ESC/27/,EQUAL/61/,GREAT/62/
	DATA KEYS/112,113,114,115,116,117,118,119,120,121,110,
     $		72,108,109/
	DATA ICLV/64/,ICLR/64/,ICOL1/255/,ICOL2/0/,ICY/0/
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,NIVM(32),VRE(2),VOX,VOY,VSF,NNIVM,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	IFLAG=-1
	DEVICE=.TRUE.
	RESX=VRE(1)
	RESY=VRE(2)
	OX=VOX
	OY=VOY
	SF=VSF
	ANG=VANG
	IYR=IYREV
	IF (IVT100.LT.0) THEN
	    IF (ICHAN.LT.0) RETURN
	    DEVICE=.FALSE.
	    RESX=RRE(1)
	    RESY=RRE(2)
	    OX=ROX
	    OY=ROY
	    SF=RSF
	    ANG=RANG
	    IYR=1
	ENDIF
	ARESX=RESX/SF
	ARESY=RESY/SF
1	FORMAT('+',2A1,$)
	MOVE=.TRUE.
	MOVE2=.FALSE.
	IF (DEVICE) THEN
	    IUSE(1)=IXLIM
	    IUSE(2)=IYLIM
	    ICYO=ICLV
	    ICXO=ICLV*RESY/RESX
	    IPIXX0=ICXO*2
	    IPIXY0=ICLV*2
	ELSE
	    IUSE(1)=IRXLIM
	    IUSE(2)=IRYLIM
	    ICXO=ICLR
	    ICYO=ICLR
	    IPIXX0=24
	    IPIXY0=24
	ENDIF
	IVI=2
	IBL=1
	ITYPE=0
C
C	SCALE INPUT POINTS AND CLIP
C
	COSA=COS(ANG*0.0174532)
	SINA=SIN(ANG*0.0174532)
	XX=COSA*X-SINA*Y
	YY=SINA*X+COSA*Y
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	X0=XX/RESX
	Y0=YY/RESY
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	IF (X0.LT.0) X0=0
	IF (X0.GT.IUSE(1)) X0=IUSE(1)
	IF (Y0.LT.0) Y0=0
	IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
	XX=COSA*X1-SINA*Y1
	YY=SINA*X1+COSA*Y1
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	IX1=XX/RESX
	IY1=IUSE(2)-YY/RESY
	XX=COSA*X2-SINA*Y2
	YY=SINA*X2+COSA*Y2
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	IF (X2.EQ.999..OR.Y2.EQ.999.) THEN
		IX2=IX1
		IY2=IY1
	ELSE
		IX2=XX/RESX
		IY2=IUSE(2)-YY/RESY
	ENDIF
	IP(1)=IX1
	IP(2)=IY1
	IP(3)=X0
	IP(4)=Y0
	IP(5)=IX2
	IP(6)=IY2
	DO 341 I=1,5,2
		IF (IP(I).LT.0) IP(I)=0
		IF (IP(I).GT.IUSE(1)) IP(I)=IUSE(1)
		IF (IP(I+1).LT.0) IP(I+1)=0
		IF (IP(I+1).GT.IUSE(2)) IP(I+1)=IUSE(2)
341	CONTINUE
C
C	START CURSOR AT CURRENT LOCATION
C
	IF (ICY.EQ.0) THEN
		ICY=ICYO
		ICX=ICXO
		IPIXX=IPIXX0
		IPIXY=IPIXY0
	ENDIF
C
C	ENABLE VT100 KEYPAD FOR ESCAPE SEQUENCES
C
	CALL CTERM(1)
	WRITE(*,1) ESC,EQUAL
C
	IOLDT=MV
	IOLDW=MVW
C
C	MAKE A TEXTURED LINE (DOTTED)
C
	CALL NEWVPEN(1,1)
	CALL RMTEXTURE(ICHAN,1,1,1,IERR)
	ICP=3
C
C	TOP OF GET KEY LOOP
C
 10	CONTINUE
C
C	CURSOR MARK, ETC. ARRAYS
C
	    IX(1)=X0-ICX
	    IX(2)=X0+ICX
	    IY(1)=Y0-ICY
	    IY(2)=Y0+ICY
	    DO 30 I=1,2
		IF (IX(I).LT.0) IX(I)=0
		IF (IX(I).GT.IUSE(1)) IX(I)=IUSE(1)
		IF (IY(I).LT.0) IY(I)=0
		IF (IY(I).GT.IUSE(2)) IY(I)=IUSE(2)
		IR(2*I-1)=IX(I)
		IR(2*I)=Y0
		IR(2*I+3)=X0
		IR(2*I+4)=IY(I)
30	    CONTINUE
	    IP(3)=X0
	    IP(4)=Y0
	    IF (X2.EQ.999.) THEN
		IP(5)=X0
		IP(6)=Y0
		ICP=2
	    ENDIF
	    IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(3,IP,1,1)
		CALL VTPLOT(2,IR,1,1)
		CALL VTPLOT(2,IR(5),1,1)
		CALL CTERM(1)
	    ELSE
		WRITE(*,14) X0,IUSE(2)-Y0,IPIXX
  14		FORMAT('+Ram Tek Cursor at (',I4,','I4')   Step: ',I2)
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,IBL,IVI,IERR)
		CALL RMPLOT(ICHAN,ICP,IP,ICOL1,IERR)
	    ENDIF
C
C	READ NEXT KEY FROM TERMINAL
C
 199	    CONTINUE
	    IN=INXTCHR()
	    IF (IN.EQ.CM.OR.IN.EQ.32) THEN		! RETURN KEY
		IFLAG=0
		IF (IN.EQ.32) THEN IFLAG=1
		GOTO 99
	    ENDIF
	    IF (IN.NE.ESC) THEN
C		IFLAG=IN
		GOTO 199
	    ENDIF
C
C	GET REMAINDER OF ESCAPE SEQUENCE
C
	    IN=INXTCHR()
	    IF ((IN.NE.79).AND.(IN.NE.91)) GOTO 199
	    IN=INXTCHR()
	    IF (IN.EQ.81) THEN		     ! PF KEY 2
		IFLAG=2
		GOTO 99
	    ENDIF
	    IF (IN.EQ.82) THEN		     ! PF KEY 3
		IFLAG=3
		GOTO 99
	    ENDIF
	    IF (IN.EQ.83) THEN		     ! PF KEY 4
		IFLAG=4
		GOTO 99
	    ENDIF
	    IF (IN.EQ.80) THEN		     ! PF KEY 1
C
C	TOGGLE CURSOR STEP SIZE
C
		IF (MOVE) THEN
		    ICX=ICX/2
		    ICY=ICY/2
		    IPIXY=IPIXY/4
		    IPIXX=IPIXX/4
		    IF (MOVE2) THEN
			MOVE=.FALSE.
			IPIXY=1
			IPIXX=1
		    ENDIF
		    MOVE2=.TRUE.
		ELSE
		    MOVE2=.FALSE.
		    ICX=ICXO
		    ICY=ICYO
		    IPIXY=IPIXY0
		    IPIXX=IPIXX0
		    MOVE=.TRUE.
		ENDIF
		GOTO 100
	    ENDIF
C
C	DECODE CURSOR MOTION COMMANDS
C
	    IF (IN.EQ.65) THEN	    ! CURSOR UP
		Y0=Y0+IPIXY
		IF (IYR.EQ.1) Y0=Y0-2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.66) THEN	    ! CURSOR DOWN
		Y0=Y0-IPIXY
		IF (IYR.EQ.1) Y0=Y0+2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.67) THEN	    ! CURSOR RIGHT
		X0=X0+IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.68) THEN	    ! CURSOR LEFT
		X0=X0-IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
C
C	DECODE KEYPAD ESC SEQUENCE
C
	    DO 40 I=1,14
		IF (IN.EQ.KEYS(I)) THEN
		    IFLAG=9+I
		    GOTO 99
		ENDIF
40	   CONTINUE
 99	CONTINUE		    ! RETURN
C
C	COMPUTE LOCATION OF CURSOR
C
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	X=((FLOAT(X0)*RESX-OX)*COSA+(FLOAT(Y0)*RESY-OY)*SINA)/SF
	Y=(-(FLOAT(X0)*RESX-OX)*SINA+(FLOAT(Y0)*RESY-OY)*COSA)/SF
	    IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(3,IP,3,1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
	    ELSE
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,0,0,IERR)
		CALL RMPLOT(ICHAN,ICP,IP,ICOL2,IERR)
	    ENDIF
	    GOTO 999
100	CONTINUE
	IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(3,IP,3,1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
		CALL CTERM(1)
	ELSE
		CALL RMPLOT(ICHAN,ICP,IP,ICOL2,IERR)
	ENDIF
	GOTO 10
999	CONTINUE
C
C	RESTORE EVERYTHING
C
	CALL NEWVPEN(IOLDT,IOLDW)
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR)
	CALL CTERM(1)
	WRITE(*,1) ESC,GREAT
	CALL CTERM(-1)
	RETURN
	END
C
C
	SUBROUTINE CURRECT(X,Y,IFLAG,ARESX,ARESY,X1,Y1,X2,Y2)
C
C	CREATED BY D. LONG    OCT, 1983	AT JPL
C	REVISED BY D. LONG    AUG, 1987
C
C	THIS ROUTINE MOVES A CROSS-HAIR "CURSOR" ON THE GRAPHICS
C	IN CONJUNCTION WITH A RECTANGLE
C	DEVICE USING THE VT100 CURSOR MOTION ESCAPE KEYS
C	IT WILL HANDLE THE RAMTEK DISPLAY USING THE RAM TEK CURSOR
C
C	OUTPUTS:
C
C	X,Y	RETURNED CURSOR POSITION RELATIVE TO INTIALIZED GRAPHICS PACKAGE
C	IFLAG	RETURN FLAG
C		< 0  ROUTINE ERROR
C		= 0  NORMAL RETURN
C		> 0  PF KEY NUMBER (KEYS 2,3,4)
C	ARESX,ARESY RESOLUTION OF SCREEN DEVICE
C	X1,Y1	= LOWER LEFT CORNER OF MOVED RECTANGLE
C	X2,Y2	= UPPER RIGHT CORNER OF MOVED RECTANGLE
C
C	THIS ROUTINE CHECKS FIRST TO SEE IF A TERMINAL SCREEN DEVICE IS
C	ENABLED.  IF IT IS, THE TERMINAL IS USED AS OUTPUT OTHERWISE
C	THE RAMTEK DEVICE IS CHECKED TO SEE IF IT IS ENABLED. THEN IF
C	THE RAMTEK DEVICE IS ENABLED, IT USES THE RAMTEK SCREEN AS
C	OUTPUT.  OTHERWISE, THE ROUTINE RETURNS.
C
	INTEGER ESC,EQUAL,GREAT,KEYS(14)
	INTEGER X0,Y0,IX(2),IY(2),IUSE(2)
	INTEGER IR(8),IR1(4),IR2(4),IP(10)
	LOGICAL DEVICE,MOVE,MOVE2
	EQUIVALENCE (IR,IR1),(IR(5),IR2(1))
C
	DATA ESC/27/,EQUAL/61/,GREAT/62/
	DATA KEYS/112,113,114,115,116,117,118,119,120,121,110,
     $		72,108,109/
	DATA ICLV/64/,ICLR/64/,ICOL1/255/,ICOL2/0/,ICY/0/
	DATA MOVE/.FALSE./,MOVE2/.FALSE./
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,NIVM(32),VRE(2),VOX,VOY,VSF,NNIVM,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	IFLAG=-1
	DEVICE=.TRUE.
	RESX=VRE(1)
	RESY=VRE(2)
	OX=VOX
	OY=VOY
	SF=VSF
	ANG=VANG
	IYR=IYREV
	IF (IVT100.LT.0) THEN
	    IF (ICHAN.LT.0) RETURN
	    DEVICE=.FALSE.
	    RESX=RRE(1)
	    RESY=RRE(2)
	    OX=ROX
	    OY=ROY
	    SF=RSF
	    ANG=RANG
	    IYR=1
	ENDIF
1	FORMAT('+',2A1,$)
	ARESX=RESX*SF
	AREXY=RESY*SF
	IF (DEVICE) THEN
	    IUSE(1)=IXLIM
	    IUSE(2)=IYLIM
	    ICYO=ICLV
	    ICXO=ICLV*RESY/RESX
	    IPIXX0=ICXO*2
	    IPIXY0=ICLV*2
	ELSE
	    IUSE(1)=IRXLIM
	    IUSE(2)=IRYLIM
	    ICXO=ICLR
	    ICYO=ICLR
	    IPIXX0=64
	    IPIXY0=64
	ENDIF
	IVI=2
	IBL=1
	ITYPE=0
C
C	TRANSFORM AND CLIP INPUT COORDINATES
C
	COSA=COS(ANG*0.0174532)
	SINA=SIN(ANG*0.0174532)
	XX=COSA*X-SINA*Y
	YY=SINA*X+COSA*Y
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	X0=XX/RESX
	Y0=YY/RESY
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	IF (X0.LT.0) X0=0
	IF (X0.GT.IUSE(1)) X0=IUSE(1)
	IF (Y0.LT.0) Y0=0
	IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
	XX=COSA*X1-SINA*Y1
	YY=SINA*X1+COSA*Y1
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	IX1D=XX/RESX-X0
	IY1D=IUSE(2)-YY/RESY-Y0
	XX=COSA*X2-SINA*Y2
	YY=SINA*X2+COSA*Y2
	XX=(SF*XX+OX)
	YY=(SF*YY+OY)
	IX2D=XX/RESX-X0
	IY2D=IUSE(2)-YY/RESY-Y0
	IF (ICY.EQ.0) THEN
		ICY=ICYO
		ICX=ICXO
		IPIXX=IPIXX0
		IPIXY=IPIXY0
	ENDIF
C
C	ENABLE VT100 KEYPAD ESCAPE SEQUENCES
C
	CALL CTERM(1)
	WRITE (*,1) ESC,EQUAL
C
C	TEXTURE LINES
C
	IF (DEVICE) THEN
		IOLDT=MV
		IOLTW=MVD
		CALL NEWVPEN(1,1)
	ELSE
		CALL RMTEXTURE(ICHAN,1,1,2,IERR)
		WRITE (*,11) ESC,EQUAL
11	   	FORMAT('+',10A1)
	ENDIF
	ICP=5
C
C	TOP OF MAIN LOOP
C
 10	CONTINUE
	IF (DEVICE) THEN
	    IX(1)=X0-ICX
	    IX(2)=X0+ICX
	    IY(1)=Y0-ICY
	    IY(2)=Y0+ICY
	    DO 30 I=1,2
		IF (IX(I).LT.0) IX(I)=0
		IF (IX(I).GT.IUSE(1)) IX(I)=IUSE(1)
		IF (IY(I).LT.0) IY(I)=0
		IF (IY(I).GT.IUSE(2)) IY(I)=IUSE(2)
		IR(2*I-1)=IX(I)
		IR(2*I)=Y0
		IR(2*I+3)=X0
		IR(2*I+4)=IY(I)
30	   CONTINUE
	ENDIF
	IX1=X0+IX1D
	IY1=Y0+IY1D
	IX2=X0+IX2D
	IY2=Y0+IY2D
	IF (IX1.LT.0) IX1=0
	IF (IX1.GT.IUSE(1)) IX1=IUSE(1)
	IF (IY1.LT.0) IY1=0
	IF (IY1.GT.IUSE(2)) IY1=IUSE(2)
	IF (IX2.LT.0) IX2=0
	IF (IX2.GT.IUSE(1)) IX2=IUSE(1)
	IF (IY2.LT.0) IY2=0
	IF (IY2.GT.IUSE(2)) IY2=IUSE(2)
	IP(1)=IX1
	IP(2)=IY1
	IP(3)=IX2
	IP(4)=IY1
	IP(5)=IX2
	IP(6)=IY2
	IP(7)=IX1
	IP(8)=IY2
	IP(9)=IX1
	IP(10)=IY1
	IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(ICP,IP,1,1)
		CALL VTPLOT(2,IR,1,1)
		CALL VTPLOT(2,IR(5),1,1)
		CALL CTERM(1)
	ELSE
		WRITE (*,14) X0,IUSE(2)-Y0,IPIXX
  14		FORMAT('+Ram Tek Cursor at (',I4,','I4')   Step: ',I2)
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,IBL,IVI,IERR)
		CALL RMPLOT(ICHAN,ICP,IP,ICOL1,IERR)
	ENDIF
C
C	GET NEXT CHARACTER FROM TERMINAL AND DECODE
C
 199	    IN=INXTCHR()				! READ TERMINAL KEY
	    IF (IN.EQ.13.OR.IN.EQ.32) THEN		! RETURN KEY
		IFLAG=0
		IF (IN.EQ.32) THEN IFLAG=1
		GOTO 99
	    ENDIF
	    IF (IN.NE.ESC) THEN
C		IFLAG=IN
		GOTO 199
	    ENDIF
C
C	GET REST OF ESCAPE SEQUENCE
C
	    IN=INXTCHR()				! READ TERMINAL KEY
	    IF ((IN.NE.79).AND.(IN.NE.91)) GOTO 199
	    IN=INXTCHR()				! READ TERMINAL KEY
	    IF (IN.EQ.81) THEN		     ! PF KEY 2
		IFLAG=2
		GOTO 99
	    ENDIF
	    IF (IN.EQ.82) THEN		     ! PF KEY 3
		IFLAG=3
		GOTO 99
	    ENDIF
	    IF (IN.EQ.83) THEN		     ! PF KEY 4
		IFLAG=4
		GOTO 99
	    ENDIF
	    IF (IN.EQ.80) THEN		     ! PF KEY 1 (TOGGLE RESOLUTION)
		IF (MOVE) THEN
		    ICX=ICX/2
		    ICY=ICY/2
		    IPIXY=IPIXY/4
		    IPIXX=IPIXX/4
		    IF (MOVE2) THEN
			MOVE=.FALSE.
			IPIXY=1
			IPIXX=1
		    ENDIF
		    MOVE2=.TRUE.
		ELSE
		    MOVE2=.FALSE.
		    ICX=ICXO
		    ICY=ICYO
		    IPIXY=IPIXY0
		    IPIXX=IPIXX0
		    MOVE=.TRUE.
		ENDIF
		GOTO 100
	    ENDIF
	    IF (IN.EQ.65) THEN	    ! CURSOR UP
		Y0=Y0+IPIXY
		IF (IYR.EQ.1) Y0=Y0-2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.66) THEN	    ! CURSOR DOWN
		Y0=Y0-IPIXY
		IF (IYR.EQ.1) Y0=Y0+2*IPIXY
		IF (Y0.LT.0) Y0=0
		IF (Y0.GT.IUSE(2)) Y0=IUSE(2)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.67) THEN	    ! CURSOR RIGHT
		X0=X0+IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
	    IF (IN.EQ.68) THEN	    ! CURSOR LEFT
		X0=X0-IPIXX
		IF (X0.LT.0) X0=0
		IF (X0.GT.IUSE(1)) X0=IUSE(1)
		GOTO 100
	    ENDIF
C
C	DECODE KEYPAD KEYS
C
	    DO 49 I=1,14
		IF (IN.EQ.KEYS(I)) THEN
		    IFLAG=9+I
		    GOTO 99
		ENDIF
 49	   CONTINUE
 99	CONTINUE		    ! RETURN
C
C	COMPUTE LOCATION OF CURSOR
C
	IF (IYR.EQ.1) Y0=IUSE(2)-Y0
	X=((FLOAT(X0)*RESX-OX)*COSA+(FLOAT(Y0)*RESY-OY)*SINA)/SF
	Y=(-(FLOAT(X0)*RESX-OX)*SINA+(FLOAT(Y0)*RESY-OY)*COSA)/SF
	    IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(ICP,IP,3,1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
	    ELSE
		CALL RMSETCUR(ICHAN,ITYPE,X0,Y0,0,0,IERR)
		CALL RMPLOT(ICHAN,ICP,IP,ICOL2,IERR)
	    ENDIF
	    GOTO 999
100	CONTINUE
	IF (DEVICE) THEN
		CALL CTERM(-1)
		CALL VTPLOT(ICP,IP,3,1)
		CALL VTPLOT(2,IR,3,1)
		CALL VTPLOT(2,IR(5),3,1)
		CALL CTERM(1)
	ELSE
		CALL RMPLOT(ICHAN,ICP,IP,ICOL2,IERR)
	ENDIF
	GOTO 10
999	CONTINUE	! RETURN SCREEN TO NORMAL
C
C	RESTORE EVERYTHING
C
	CALL NEWVPEN(IOLDT,IOLDW)
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR)
	CALL CTERM(1)
	WRITE(*,11) ESC,GREAT
	CALL CTERM(-1)
	RETURN
	END
C
C *********************************************************************
C
C	PAUSE ROUTINES -- THESE ROUTINES USE THE DIRECT TERMINAL I/O
C	ROUTINES INXTCHR.
C
C *********************************************************************
C
	SUBROUTINE PAUSEP
C
C	PROMPTS FOR A KEY STRIKE -- INCLUDE CTERM CALLS
C
	CALL CTERM(1)
	WRITE(*,1)
1	FORMAT('$Pausing... Press any key to continue')
	INPUT=INXTCHR()
	CALL CTERM(-1)
	RETURN
	END
C
	SUBROUTINE PAUSE
C
C	PROMPTS FOR A KEY STRIKE
C
	WRITE (*,1)
1	FORMAT('$Pausing... Press any key to continue')
	INPUT=INXTCHR()
	RETURN
	END
C
C **********************************************************************
C
C	DIRECT TERMINAL I/O COMMUNICATION ROUTINES
C	(USED IN CURSOR AND PAUSE ROUTINES)
C
C	THESE ROUTINES ARE VERY MACHINE DEPENDENT
C
C **********************************************************************
C
	INTEGER FUNCTION INXTCHR
C
C	RETURNS THE NEXT CHARACTER FROM TERMINAL WITH NO ECHO
C	RETURNS -1 WHEN AN IO ERROR OCCURS
C
	BYTE IB
	INTEGER*2 ICHAN,IOSB(4)
	INTEGER*4 RET,SYS$QIOW,I1,IO_READVBLK,IOM_NOECHO
	CHARACTER*2 DEVICE
	DATA IO_READVBLK/'00000031'X/,IOM_NOECHO/'00000040'X/
	DATA ICHAN/0/,DEVICE/'TT'/
	COMMON /TT_IO/ICHAN
	IF (ICHAN.EQ.0) THEN
		CALL SYS$ASSIGN(DEVICE,ICHAN,,)
	ENDIF
	I1=IO_READVBLK.OR.IOM_NOECHO
	RET=SYS$QIOW(,%VAL(ICHAN),%VAL(I1),IOSB,
     $		,,IB,%VAL(1),,,,)
	IF (RET.NE.1) THEN
		INXTCHR=-1
		RETURN
	ENDIF
	INXTCHR=IB
	RETURN
	END
C
C
	INTEGER FUNCTION ICHKCHR(IERR)
C
C	POLL TERMINAL FOR CHARACTER
C	RETURNS -1 ON ERROR OR NO KEY AVAILABLE
C
C	IERR (I*2)	IO STATUS ERROR
C
C	CALLS: ICHRTIME
C
	INTEGER*2 ITIME,IERR
	DATA ITIME/0/
	ICHKCHR=ICHRTIME(ITIME,IERR)
	RETURN
	END
C
C
	INTEGER FUNCTION ICHRTIME(ITIME,IERR)
C
C	RETURNS NEXT CHARACTER FROM TERMINAL WITH TIMEOUT AND NO ECHO
C	OR -1
C
C	ITIME	(I*2)	TIME OUT LENGTH IN SECONDS (0 IS POLLING ONLY)
C	IERR	(I*2)	RETURNS IO STATUS ERROR
C
C	CAUTION: CARELESS USE OF THIS ROUTINE CAN LOCK UP TERMINAL IO
C
	BYTE IB
	INTEGER*2 ICHAN,IOSB(4),ITIME,IERR
	INTEGER*4 RET,SYS$QIOW,I1,IO_READVBLK,IOM_NOECHO,IOM_TIMED
	CHARACTER*2 DEVICE
	DATA IO_READVBLK/'00000031'X/,IOM_NOECHO/'00000040'X/
	DATA IOM_TIMED/'00000080'X/
	DATA DEVICE/'TT'/,ICHAN/0/
	COMMON /TT_IO/ICHAN
	IF (ICHAN.EQ.0) THEN
		CALL SYS$ASSIGN(DEVICE,ICHAN,,)
	ENDIF
	I1=IO_READVBLK.OR.IOM_NOECHO.OR.IOM_TIMED
	IB=-1
	RET=SYS$QIOW(,%VAL(ICHAN),%VAL(I1),IOSB,
     $		,,IB,%VAL(1),%VAL(ITIME),,,)
	IF (RET.NE.1) IERR=IOSB(1)
	ICHRTIME=IB
	RETURN
	END
