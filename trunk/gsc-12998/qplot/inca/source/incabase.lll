LONGREAL                                                        23-Dec-1988 10:39:22    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  14-Dec-1987 13:09:57    [QPLOT.INCA.SOURCE]LONGREAL.PAS;11 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:IO',
00005      0  0                'QLIBHOME:MATH',
00006      0  0                'QLIBHOME:STRING',
00007      0  0                'QLIBHOME:FIG'),
00008      0  0   ENVIRONMENT ('LONGREAL')]
00009      0  0 MODULE longreal;
00010   C  0  0 {=============================================================================}
00011   C  0  0 {-- SUBMODULE LONGREAL -------------------------------------------------------}
00012   C  0  0 {=============================================================================}
00013      0  0 TYPE
00014      0  0    longreal           = quadruple;
00015      0  0 CONST
00016      0  0    LONGBIG            = 1Q4000;
00017      0  0    UNDEFINED_LONGREAL = quad (UNDEFINED_REAL);
00018   C  0  0 {=============================================================================}
00019      0  0 [ GLOBAL ]
00020      1  0 FUNCTION llog10 (l : longreal) : real;
00021   C  1  0 { Purpose -- Find the logarithm to the base 10 of a longreal }
00022      1  1 BEGIN
00023      1  1 IF l = UNDEFINED_LONGREAL
00024      1  1  THEN llog10 := UNDEFINED_REAL
00025      1  1 ELSE IF l <= 0 
00026      1  1  THEN llog10 := -LOGINFINITY 
00027      1  1  ELSE llog10 := dble (MTH$HLOG10 (l));
00028      0  0 END;
00029   C  0  0 {-----------------------------------------------------------------------------}
00030      0  0 [ GLOBAL ]
00031      1  0 FUNCTION lexp10 (x : real) : longreal;
00032   C  1  0 { Purpose -- Find 10**r longreal bulletproof }
00033      1  1 BEGIN
00034      1  1 IF x = UNDEFINED_REAL
00035      1  1  THEN lexp10 := UNDEFINED_LONGREAL
00036      1  1 ELSE IF x < -4000d0
00037      1  1  THEN lexp10 := 0
00038      1  1 ELSE IF x > 4000d0
00039      1  1  THEN lexp10 := LONGBIG
00040      1  1  ELSE lexp10 := 10q0**x;
00041      0  0 END;
00042   C  0  0 {-----------------------------------------------------------------------------}
00043      1  0 FUNCTION strofl (l : longreal;  width : integer) : anystring;
00044   C  1  0 { Purpose -- Generate a string that represents a longreal number.  }
00045   C  1  0 {            Default width is given by the global fieldwidth.      }
00046      1  0 VAR
00047      1  0    i,status : integer;
00048      1  0    st       : PACKED ARRAY [1..80] OF char;
00049      1  0    out      : anystring;
00050      1  1 BEGIN
00051      1  1 IF width = 0 THEN width := fieldwidth;
00052      1  1 IF l = UNDEFINED_LONGREAL
00053      1  1  THEN out := strfix('UNDEFINED',width)
00054      1  1 ELSE IF l = 0 
00055      1  1  THEN out := pad (' 0.','0',width-4) + '      '

LONGREAL                                                        23-Dec-1988 10:39:22    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  14-Dec-1987 13:09:57    [QPLOT.INCA.SOURCE]LONGREAL.PAS;11 (1)

-LINE-IDC-PL-SL-

00056      1  1  ELSE 
00057      1  2   BEGIN
00058      1  2   status := FOR$CVT_H_TG (l,st,width-9,,1,,);
00059      1  2   out := substr (st,81-width,width);
00060      1  1   END;
00061      1  1 strofl := out;
00062      0  0 END;
00063   C  0  0 {-----------------------------------------------------------------------------}
00064      1  0 FUNCTION strofl2 (l : longreal;  width,dec : integer) : anystring;
00065   C  1  0 { Purpose -- Generate a string that represents a longreal number.      }
00066      1  0 VAR
00067      1  0    i,status : integer;
00068      1  0    st       : PACKED ARRAY [1..80] OF char;
00069      1  0    out      : anystring;
00070      1  1 BEGIN
00071      1  1 IF l = UNDEFINED_LONGREAL
00072      1  1  THEN out := strfix('UNDEFINED',width)
00073      1  1  ELSE 
00074      1  2   BEGIN
00075      1  2   status := FOR$CVT_H_TF (l,st,dec,,,,);
00076      1  2   out := substr (st,81-width,width);
00077      1  1   END;
00078      1  1 strofl2 := out;
00079      0  0 END;
00080   C  0  0 {-----------------------------------------------------------------------------}
00081      1  0 FUNCTION lofstr (st : anystring) : longreal;
00082   C  1  0 { Purpose -- Convert character string into longreal number.                   }
00083   C  1  0 {            Variable goodconvert indicates result of conversion.             }
00084      1  0 VAR
00085      1  0    l  : longreal;
00086      1  1 BEGIN
00087      1  1 IF index (st + ' ','PI ') = 1
00088      1  2  THEN BEGIN goodconvert := true;  lofstr := PI;  END
00089      1  1 ELSE IF index (st,'UNDEF') = 1
00090      1  2  THEN BEGIN goodconvert := true;  lofstr := UNDEFINED_LONGREAL;  END
00091      1  1  ELSE 
00092      1  2   BEGIN 
00093      1  2   goodconvert := OTS$CVT_T_H ((st),l,0,0,1) = 1;  
00094      1  2   IF goodconvert THEN lofstr := l ELSE lofstr := 0;
00095      1  1   END;
00096      0  0 END;
00097   C  0  0 {-----------------------------------------------------------------------------}
00098      1  0 PROCEDURE readlongreal (prompt : VARYING [l1] OF CHAR;  VAR l : longreal;  
00099      1  0    min,max,def : longreal);
00100      1  0 VAR
00101      1  0    st   : anystring;
00102      1  1 BEGIN
00103      1  1 convertlower := true;
00104      1  1 IF config.assist 
00105      1  1  THEN writeline (out,'LongReal input between ' + strofl(min,13) + 
00106      1  1     ' and ' + strofl(max,13) + '  Default is' + strofl(def,13));
00107      1  2 REPEAT
00108      1  2    readst (prompt,st);
00109      1  2    l := lofstr (st);
00110      1  2    IF (st = '') OR (st = 'DEFAULT')

LONGREAL                                                        23-Dec-1988 10:39:22    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  14-Dec-1987 13:09:57    [QPLOT.INCA.SOURCE]LONGREAL.PAS;11 (1)

-LINE-IDC-PL-SL-

00111      1  2     THEN 
00112      1  3      BEGIN 
00113      1  3      l :=  def; 
00114      1  3      goodconvert := true;  
00115      1  3      IF config.assist 
00116      1  3       THEN writeline (out,'Input longreal is ' + strofl (l,0));
00117      1  3      END
00118      1  2    ELSE IF index (st,'NEG') = 1
00119      1  2     THEN 
00120      1  3      BEGIN 
00121      1  3      l := -def; 
00122      1  3      goodconvert := true;  
00123      1  3      IF config.assist 
00124      1  3       THEN writeline (out,'Input longreal is ' + strofl (l,0));
00125      1  3      END
00126      1  2    ELSE IF index (st,'LIM') = 1
00127      1  2     THEN writeline (out,'LongReal input between ' + strofl(min,13) + 
00128      1  2        ' and ' + strofl(max,13) + '  Default is' + strofl(def,13))
00129      1  2    ELSE IF NOT goodconvert
00130      1  2     THEN writeline (out,'Input conversion error - Try again')
00131      1  2    ELSE IF l<min
00132      1  2     THEN writeline (out,'Input must be >=' + strofl(min,13) + ' - Try again')
00133      1  2    ELSE IF l>max
00134      1  2     THEN writeline (out,'Input must be <=' + strofl(max,13) + ' - Try again');
00135      1  1    UNTIL goodconvert AND (l>=min) AND (l<=max);
00136      0  0 END;
00137   C  0  0 {=============================================================================}
00138      0  0 END.

LONGREAL                                                        23-Dec-1988 10:39:22    VAX Pascal V3.7-254                Page    4
INCA                            Pascal Compilation Statistics   14-Dec-1987 13:09:57    [QPLOT.INCA.SOURCE]LONGREAL.PAS;11 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                2866  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260        44        17
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        32        26
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        28        14
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         2         3
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72         8        11
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213        24        11



POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:MATH',
00004      0  0                'QLIBHOME:COMPLEX',
00005      0  0                'LONGREAL'),
00006      0  0   ENVIRONMENT ('POLYMATH')]
00007      0  0 MODULE polymath;
00008   C  0  0 { Purpose -- This module defines various polynomial data types.               }
00009   C  0  0 {            While these were designed for use in the program INCA,           }
00010   C  0  0 {            they can also be INHERITed for used in other systems.            }
00011      0  0 CONST
00012      0  0    MAXDEG    = 120;    { Maximum exponents size }
00013      0  0 VAR
00014      0  0    closezero : real    := 1d-12;
00015      0  0    nearness  : real    := 1d-6;
00016      0  0    rootmax   : integer := 20;           { Maximum allowable value is 50  }
00017   C  0  0 {=============================================================================}
00018   C  0  0 {-- SUBMODULE CPOLY MATH -----------------------------------------------------}
00019   C  0  0 {=============================================================================}
00020      0  0 TYPE
00021      0  0   cpoly        = RECORD  { Complex Factored Polynomial }
00022      0  0                  deg     : integer;
00023      0  0                  f       : ARRAY [1..MAXDEG] OF complex;
00024      0  0                  p       : ARRAY [1..MAXDEG] OF integer;
00025      0  0                  END;
00026   C  0  0 {=============================================================================}
00027      1  0 FUNCTION ceqappx (c1,c2 : complex) : boolean;
00028      1  1 BEGIN
00029      1  1 ceqappx := (abs (c1.re - c2.re) < abs (c1.re + c2.re) * nearness) AND
00030      1  1            (abs (c1.im - c2.im) < abs (c1.im + c2.im) * nearness);
00031      0  0 END;
00032   C  0  0 {-----------------------------------------------------------------------------}
00033      1  0 PROCEDURE cpolynorm (VAR v : cpoly);
00034   C  1  0 { Purpose -- Clean up polynomial by combining roots and checking conjugates }
00035      1  0 VAR
00036      1  0    i,j         : integer;
00037      1  0    ptemp       : integer;
00038      1  0    ctemp       : complex;
00039      1  0    found,skip  : boolean;
00040      1  1 BEGIN
00041   C  1  1 { FIRST WE CLEAN UP THE ROOTS }
00042      1  1 FOR i := 1 TO v.deg DO 
00043      1  2    BEGIN
00044      1  2    IF cabs(v.f[i]) < closezero 
00045      1  2     THEN v.f[i] := complex(0,0);
00046      1  2    IF abs(v.f[i].im) <= nearness * abs(v.f[i].re) 
00047      1  2     THEN v.f[i].im := 0;
00048      1  1    END;
00049      1  1 
00050   C  1  1 { NOW WE CHECK THAT COMPLEX ROOTS FORM PAIRS }
00051      1  1 i := 1;
00052      1  1 WHILE i <= v.deg DO
00053      1  1    IF v.f[i].im = 0
00054      1  1     THEN i := i+1
00055      1  1    ELSE IF (i = v.deg) AND (v.f[i].im <> 0) 

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00056      1  1     THEN raise ('CPOLYNORM : Unmatched complex root, try changing nearness')
00057      1  1    ELSE IF ceqappx (v.f[i],ccnj(v.f[i+1]))  AND  (v.p[i] = v.p[i+1])
00058      1  1     THEN 
00059      1  2      BEGIN
00060      1  2      v.f[i+1] := ccnj (v.f[i]);
00061      1  2      i := i+2;
00062      1  2      END
00063      1  1    ELSE IF ceq(v.f[i],ccnj(v.f[i+1]))  AND  (v.p[i] <> v.p[i+1])
00064      1  1     THEN raise ('CPOLYNORM : Exponents of complex pair not equal')
00065      1  1    ELSE
00066      1  2      BEGIN
00067      1  2      FOR j := i+2 TO v.deg DO
00068      1  2         IF ceqappx (v.f[i],ccnj(v.f[j]))
00069      1  2          THEN
00070      1  3           BEGIN
00071      1  3           ctemp := v.f[i+1];  v.f[i+1] := v.f[j];  v.f[j] := ctemp;  
00072      1  3           ptemp := v.p[i+1];  v.p[i+1] := v.p[j];  v.p[j] := ptemp;
00073      1  3           v.f[i+1] := ccnj (v.f[i]);
00074      1  2           END;
00075      1  2      IF ceq(v.f[i],ccnj(v.f[i+1]))  AND  (v.p[i] = v.p[i+1])
00076      1  2       THEN i := i+2
00077      1  2      ELSE IF ceq(v.f[i],ccnj(v.f[i+1]))  AND  (v.p[i] <> v.p[i+1])
00078      1  2       THEN raise ('CPOLYNORM : Exponents of complex pair not equal')
00079      1  2       ELSE raise ('CPOLYNORM : Unmatched complex root, try changing nearness');
00080      1  1      END;
00081      1  1 
00082   C  1  1 { COLLECT NEARLY EQUAL FACTORS BY ADDING EXPONENTS & ZEROING OLD EXPONENTS }
00083      1  1 FOR i := 1 TO v.deg DO
00084      1  1    FOR j := i+1 TO v.deg DO
00085      1  1       IF cabsdif (v.f[i],v.f[j]) <= nearness * cabs (v.f[i])
00086      1  1        THEN BEGIN  v.p[i] := v.p[i] + v.p[j];  v.p[j] := 0;  END;
00087      1  1 
00088   C  1  1 { REMOVE FACTORS WITH EXPONENTS THAT EQUAL 0 }
00089      1  1 j := 0;
00090      1  1 FOR i := 1 TO v.deg DO
00091      1  1    IF v.p[i] > 0 
00092      1  1     THEN BEGIN  j := j+1;  v.f[j] := v.f[i];  v.p[j] := v.p[i];  END;
00093      1  1 v.deg := j;
00094      0  0 END;
00095   C  0  0 {-----------------------------------------------------------------------------}
00096      1  0 FUNCTION cpolymul (v1,v2 : cpoly) : cpoly;
00097   C  1  0 { Purpose -- Multiply factored polynomials }
00098      1  0 VAR
00099      1  0    i       : integer;
00100      1  0    out     : cpoly;
00101      1  1 BEGIN
00102      1  1 IF v1.deg + v2.deg > MAXDEG THEN raise ('CPOLYMUL : Polynomial overflow');
00103      1  1 out := v1;
00104      1  1 FOR i := 1 TO v2.deg DO
00105      1  2    BEGIN
00106      1  2    out.f[out.deg+i] := v2.f[i];
00107      1  2    out.p[out.deg+i] := v2.p[i];
00108      1  1    END;
00109      1  1 out.deg := out.deg + v2.deg;
00110      1  1 cpolynorm (out);

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00111      1  1 cpolymul := out;
00112      0  0 END;
00113   C  0  0 {-----------------------------------------------------------------------------}
00114      1  0 FUNCTION cpolyeval (c : cpoly;  s : real) : longreal;
00115      1  0 VAR
00116      1  0    i   : integer;
00117      1  0    out : longreal;
00118      1  1 BEGIN
00119      1  1 out := 1;
00120      1  1 FOR i := 1 TO c.deg DO
00121      1  1    IF c.f[i].im = 0
00122      1  1     THEN out := out * quad(s + c.f[i].re) ** c.p[i]
00123      1  1    ELSE IF c.f[i].im > 0
00124      1  1     THEN out := out * quad(s*s + 2 * c.f[i].re * s + cabssq (c.f[i])) ** c.p[i];
00125      1  1 cpolyeval := out;
00126      0  0 END;
00127   C  0  0 {=============================================================================}
00128   C  0  0 {-- SUBMODULE UPOLY MATH -----------------------------------------------------}
00129   C  0  0 {=============================================================================}
00130      0  0 TYPE
00131      0  0    upoly        = RECORD  { Real Unfactored Polynomial }
00132      0  0                   deg     : integer;
00133      0  0                   c       : ARRAY [0..MAXDEG] OF real;
00134      0  0                   END;
00135   C  0  0 {=============================================================================}
00136      1  0 FUNCTION upolyadd (u1,u2 : upoly) : upoly;
00137   C  1  0 { Purpose -- Add two unfactored polynomials }
00138      1  0 VAR
00139      1  0    i     : integer;
00140      1  0    out   : upoly;
00141      1  1 BEGIN
00142      1  1 out.deg := imax (u1.deg,u2.deg);
00143      1  1 FOR i := 0 TO out.deg DO
00144      1  1    IF i > u1.deg 
00145      1  1     THEN out.c[i] := u2.c[i]
00146      1  1    ELSE IF i > u2.deg 
00147      1  1     THEN out.c[i] := u1.c[i]
00148      1  1     ELSE out.c[i] := u1.c[i] + u2.c[i];
00149      1  1 WHILE (out.deg > 0) AND (out.c[out.deg] = 0)  DO out.deg := out.deg-1;
00150      1  1 upolyadd := out;
00151      0  0 END;
00152   C  0  0 {-----------------------------------------------------------------------------}
00153      1  0 FUNCTION upolysub (u1,u2 : upoly) : upoly;
00154   C  1  0 { Purpose -- Subtract two unfactored polynomials }
00155      1  0 VAR
00156      1  0    i     : integer;
00157      1  0    out   : upoly;
00158      1  1 BEGIN
00159      1  1 out.deg := imax (u1.deg,u2.deg);
00160      1  1 FOR i := 0 TO out.deg DO
00161      1  1    IF i > u1.deg 
00162      1  1     THEN out.c[i] := -u2.c[i]
00163      1  1    ELSE IF i > u2.deg 
00164      1  1     THEN out.c[i] := u1.c[i]
00165      1  1     ELSE out.c[i] := u1.c[i] - u2.c[i];

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00166      1  1 WHILE (out.deg > 0) AND (out.c[out.deg] = 0)  DO out.deg := out.deg-1;
00167      1  1 upolysub := out;
00168      0  0 END;
00169   C  0  0 {-----------------------------------------------------------------------------}
00170      1  0 FUNCTION upolymul (u1,u2 : upoly) : upoly;
00171   C  1  0 { Purpose -- Multiply two unfactored polynomials }
00172      1  0 VAR
00173      1  0     i,j   : integer;
00174      1  0     out   : upoly;
00175      1  1 BEGIN
00176      1  1 IF u1.deg+u2.deg > MAXDEG THEN raise ('UPOLYMUL : Polynomial overflow');
00177      1  1 out.deg := u1.deg + u2.deg;
00178      1  1 FOR i := 0 TO out.deg DO out.c[i] := 0;
00179      1  1 FOR i := 0 TO u1.deg DO
00180      1  1    FOR j := 0 TO u2.deg DO
00181      1  1       out.c[i+j] := out.c[i+j] + u1.c[i] * u2.c[j];
00182      1  1 upolymul := out;
00183      0  0 END;
00184   C  0  0 {-----------------------------------------------------------------------------}
00185      1  0 FUNCTION upolyderiv (u1 : upoly) : upoly;
00186   C  1  0 { Purpose -- Compute the derivative of a unfactored polynomial }
00187      1  0 VAR
00188      1  0    i     : integer;
00189      1  0    out   : upoly;
00190      1  1 BEGIN
00191      1  1 out.deg := imax (0,u1.deg-1);
00192      1  1 IF u1.deg = 0
00193      1  1  THEN out.c[0] := 0
00194      1  1  ELSE FOR i := 0 TO out.deg DO out.c[i] := (i+1) * u1.c[i+1];
00195      1  1 upolyderiv := out;
00196      0  0 END;
00197   C  0  0 {-----------------------------------------------------------------------------}
00198      1  0 FUNCTION upolybinomex (a : real;  n : integer) : upoly;
00199   C  1  0 { Purpose -- Compute out := (x+a)**n }
00200      1  0 VAR
00201      1  0     i,j     : integer;
00202      1  0     aprod,b : real;
00203      1  0     out     : upoly;
00204      1  1 BEGIN
00205      1  1 IF n > MAXDEG THEN raise ('UPOLYBINOMEX : Polynomial overflow');
00206      1  1 out.deg := n;
00207      1  1 aprod := 1;
00208      1  1 FOR i := 0 TO n DO
00209      1  2    BEGIN
00210      1  2    b := 1;
00211      1  2    FOR j := 0 TO i-1 DO b := b * (n-j) / (i-j);
00212      1  2    out.c[n-i] := b * aprod;
00213      1  2    aprod := aprod * a;
00214      1  1    END;
00215      1  1 upolybinomex := out;
00216      0  0 END;
00217   C  0  0 {-----------------------------------------------------------------------------}
00218      1  0 PROCEDURE upolyfractadd (VAR nout,dout : upoly;  n1,d1,n2,d2 : upoly);
00219   C  1  0 { Purpose -- Add two unfactored polynomial fractions :    }
00220   C  1  0 {            nout/dout := n1/d1 + n2/d2                   }

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00221      1  1 BEGIN
00222      1  1 nout := upolyadd ( upolymul(n1,d2), upolymul(n2,d1) );
00223      1  1 dout := upolymul (d1,d2);
00224      0  0 END;
00225   C  0  0 {-----------------------------------------------------------------------------}
00226      1  0 FUNCTION upolyeval (u : upoly;  s : real) : longreal;
00227      1  0 VAR
00228      1  0    i   : integer;
00229      1  0    out : longreal;
00230      1  1 BEGIN
00231      1  1 out := 0;
00232      1  1 FOR i := u.deg DOWNTO 0 DO
00233      1  1    out := out * s + u.c[i];
00234      1  1 upolyeval := out;
00235      0  0 END;
00236   C  0  0 {=============================================================================}
00237   C  0  0 {-- SUBMODULE CUPOLY MATH ----------------------------------------------------}
00238   C  0  0 {=============================================================================}
00239      0  0 TYPE
00240      0  0    cupoly       = RECORD  { Complex Unfactored Polynomial }
00241      0  0                   deg     : integer;
00242      0  0                   c       : ARRAY [0..MAXDEG] OF complex;
00243      0  0                   END;
00244   C  0  0 {=============================================================================}
00245      1  0 FUNCTION cupolyadd (u1,u2 : cupoly) : cupoly;
00246   C  1  0 { Purpose -- Add two complex unfactored polynomials }
00247      1  0 VAR
00248      1  0     i     : integer;
00249      1  0     out   : cupoly;
00250      1  1 BEGIN
00251      1  1 out.deg := imax (u1.deg,u2.deg);
00252      1  1 FOR i := 0 TO out.deg DO
00253      1  1    IF i > u1.deg 
00254      1  1     THEN out.c[i] := u2.c[i]
00255      1  1    ELSE IF i > u2.deg 
00256      1  1     THEN out.c[i] := u1.c[i]
00257      1  1     ELSE out.c[i] := cadd (u1.c[i],u2.c[i]);
00258      1  1 WHILE (out.deg > 0) AND ceq(out.c[out.deg],complex(0,0))
00259      1  1    DO out.deg := out.deg-1;
00260      1  1 cupolyadd := out;
00261      0  0 END;
00262   C  0  0 {-----------------------------------------------------------------------------}
00263      1  0 FUNCTION cupolysub (u1,u2 : cupoly) : cupoly;
00264   C  1  0 { Purpose -- Subtract two complex unfactored polynomials }
00265      1  0 VAR
00266      1  0     i     : integer;
00267      1  0     out   : cupoly;
00268      1  1 BEGIN
00269      1  1 out.deg := imax (u1.deg,u2.deg);
00270      1  1 FOR i := 0 TO out.deg DO
00271      1  1    IF i > u1.deg 
00272      1  1     THEN out.c[i] := cneg (u2.c[i])
00273      1  1    ELSE IF i > u2.deg 
00274      1  1     THEN out.c[i] := u1.c[i]
00275      1  1     ELSE out.c[i] := csub (u1.c[i],u2.c[i]);

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00276      1  1 WHILE (out.deg > 0) AND ceq(out.c[out.deg],complex(0,0))
00277      1  1    DO out.deg := out.deg-1;
00278      1  1 cupolysub := out;
00279      0  0 END;
00280   C  0  0 {-----------------------------------------------------------------------------}
00281      1  0 FUNCTION cupolymul (u1,u2 : cupoly) : cupoly;
00282   C  1  0 { Purpose -- Multiply two complex unfactored polynomials }
00283      1  0 VAR
00284      1  0     i,j   : integer;
00285      1  0     out   : cupoly;
00286      1  1 BEGIN
00287      1  1 IF u1.deg + u2.deg > MAXDEG THEN raise ('CUPOLYMUL : Polynomial overflow');
00288      1  1 out.deg := u1.deg + u2.deg;
00289      1  1 FOR i := 0 TO out.deg DO out.c[i] := complex(0,0);
00290      1  1 FOR i := 0 TO u1.deg DO
00291      1  1    FOR j := 0 TO u2.deg DO
00292      1  1       out.c[i+j] := cadd (out.c[i+j], cmul(u1.c[i],u2.c[j]) );
00293      1  1 cupolymul := out;
00294      0  0 END;
00295   C  0  0 {-----------------------------------------------------------------------------}
00296      1  0 FUNCTION cupolyderiv (u1 : cupoly) : cupoly;
00297   C  1  0 { Purpose -- Compute the derivative of a complex unfactored polynomial }
00298      1  0 VAR
00299      1  0     i     : integer;
00300      1  0     ctemp : complex;
00301      1  0     out   : cupoly;
00302      1  1 BEGIN
00303      1  1 out.deg := imax(0,u1.deg-1);
00304      1  1 IF u1.deg=0
00305      1  1  THEN out.c[0] := complex(0,0)
00306      1  1  ELSE FOR i := 0 TO out.deg DO out.c[i] := cmul (cofi(i+1),u1.c[i+1]);
00307      1  1 cupolyderiv := out;
00308      0  0 END;
00309   C  0  0 {-----------------------------------------------------------------------------}
00310      1  0 FUNCTION cupolybinomex (a: complex;  n : integer) : cupoly;
00311   C  1  0 { Purpose -- Compute out := (x+a)**n }
00312      1  0 VAR
00313      1  0     i,j     : integer;
00314      1  0     aprod,b : complex;
00315      1  0     out     : cupoly;
00316      1  1 BEGIN
00317      1  1 IF n > MAXDEG THEN raise ('CUPOLYBINOMEX : Polynomial overflow');
00318      1  1 out.deg := n;
00319      1  1 aprod := complex(1,0);
00320      1  1 FOR i := 0 TO n DO
00321      1  2    BEGIN
00322      1  2    b := complex(1,0);
00323      1  2    FOR j := 0 TO i-1 DO b.re := b.re * (n-j) / (i-j);
00324      1  2    out.c[n-i] := cmul (b,aprod);
00325      1  2    aprod := cmul (aprod,a);
00326      1  1    END;
00327      1  1 cupolybinomex := out;
00328      0  0 END;
00329   C  0  0 {-----------------------------------------------------------------------------}
00330      1  0 PROCEDURE cupolyfractadd (VAR nout,dout : cupoly;  n1,d1,n2,d2 : cupoly);

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00331   C  1  0 { Purpose -- Add two complex unfactored polynomial fractions :    }
00332   C  1  0 {            nout/dout := n1/d1 + n2/d2                           }
00333      1  1 BEGIN
00334      1  1 nout := cupolyadd ( cupolymul(n1,d2), cupolymul(n2,d1) );
00335      1  1 dout := cupolymul (d1,d2);
00336      0  0 END;
00337   C  0  0 {=============================================================================}
00338   C  0  0 {-- SUBMODULE CSPOLY MATH ----------------------------------------------------}
00339   C  0  0 {=============================================================================}
00340      0  0 TYPE
00341      0  0   cspolyfactor = RECORD
00342      0  0                  v       : complex;
00343      0  0                  p       : integer;
00344      0  0                  END;
00345      0  0   cspoly       = RECORD  { Complex Signed Factored Polynomial }
00346      0  0                  deg     : integer;
00347      0  0                  f       : ARRAY [1..MAXDEG] OF cspolyfactor;
00348      0  0                  END;
00349   C  0  0 {=============================================================================}
00350      1  0 PROCEDURE cspolynorm (VAR v : cspoly);
00351   C  1  0 { Purpose -- Clean up CS polynomial by combining roots }
00352      1  0 VAR
00353      1  0    i,j,swaps   : integer;
00354      1  0    tempp       : integer;
00355      1  0    tempv       : complex;
00356      1  1 BEGIN
00357   C  1  1 { FIRST WE CLEAN UP THE ROOTS }
00358      1  1 FOR i := 1 TO v.deg DO 
00359      1  2    BEGIN
00360      1  2    IF cabs(v.f[i].v) < closezero 
00361      1  2     THEN 
00362      1  3      BEGIN
00363      1  3      IF v.f[i].v.im <> 0 THEN v.f[i].p := v.f[i].p * 2;
00364      1  3      v.f[i].v := complex(0,0);
00365      1  2      END;
00366      1  2    IF v.f[i].v.im < 0 THEN raise ('CSPOLYNORM : Imaginary part < 0');
00367      1  2    IF v.f[i].v.im <= nearness * abs(v.f[i].v.re) 
00368      1  2     THEN 
00369      1  3      BEGIN
00370      1  3      IF v.f[i].v.im <> 0 THEN v.f[i].p := v.f[i].p * 2;
00371      1  3      v.f[i].v.im := 0;
00372      1  2      END;
00373      1  1    END;
00374      1  1 
00375   C  1  1 { COLLECT NEARLY EQUAL FACTORS BY ADDING EXPONENTS & ZEROING OLD EXPONENTS }
00376      1  1 FOR i := 1 TO v.deg DO
00377      1  1    FOR j := i+1 TO v.deg DO
00378      1  1       IF cabsdif (v.f[i].v,v.f[j].v) <= nearness * cabs (v.f[i].v)
00379      1  1        THEN BEGIN  v.f[i].p := v.f[i].p + v.f[j].p;  v.f[j].p := 0;  END;
00380      1  1 
00381   C  1  1 { REMOVE FACTORS WITH EXPONENTS THAT EQUAL 0 }
00382      1  1 j := 0;
00383      1  1 FOR i := 1 TO v.deg DO
00384      1  1    IF v.f[i].p <> 0 
00385      1  1     THEN BEGIN  j := j+1;  v.f[j] := v.f[i];  END;

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00386      1  1 v.deg := j;
00387      1  1 
00388   C  1  1 { SORT FACTORS USING BUBBLE SORT }
00389      1  2 REPEAT
00390      1  2    swaps := 0;
00391      1  2    FOR i := 1 TO v.deg-1 DO
00392      1  2       IF cabs (v.f[i].v) > cabs (v.f[i+1].v)
00393      1  2        THEN 
00394      1  3         BEGIN
00395      1  3         tempv := v.f[i+1].v;  v.f[i+1].v := v.f[i].v;  v.f[i].v := tempv;
00396      1  3         tempp := v.f[i+1].p;  v.f[i+1].p := v.f[i].p;  v.f[i].p := tempp;
00397      1  3         swaps := swaps + 1;
00398      1  2         END;
00399      1  1    UNTIL swaps = 0;
00400      0  0 END;
00401   C  0  0 {-----------------------------------------------------------------------------}
00402      1  0 FUNCTION cspolymul (v1,v2 : cspoly) : cspoly;
00403   C  1  0 { Purpose -- Multiply Complex Signed Factored polynomials }
00404      1  0 VAR
00405      1  0    i       : integer;
00406      1  0    out     : cspoly;
00407      1  1 BEGIN
00408      1  1 IF v1.deg + v2.deg > MAXDEG THEN raise ('CSPOLYMUL : Polynomial overflow');
00409      1  1 out := v1;
00410      1  1 FOR i := 1 TO v2.deg DO
00411      1  1    out.f[out.deg+i] := v2.f[i];
00412      1  1 out.deg := out.deg + v2.deg;
00413      1  1 cspolynorm (out);
00414      1  1 cspolymul := out;
00415      0  0 END;
00416   C  0  0 {-----------------------------------------------------------------------------}
00417      1  0 FUNCTION cspolydiv (v1,v2 : cspoly) : cspoly;
00418   C  1  0 { Purpose -- Divide Complex Signed Factored polynomials }
00419      1  0 VAR
00420      1  0    i       : integer;
00421      1  0    out     : cspoly;
00422      1  1 BEGIN
00423      1  1 IF v1.deg + v2.deg > MAXDEG THEN raise ('CSPOLYDIV : Polynomial overflow');
00424      1  1 out := v1;
00425      1  1 FOR i := 1 TO v2.deg DO
00426      1  2    BEGIN
00427      1  2    out.f[out.deg+i] := v2.f[i];
00428      1  2    out.f[out.deg+i].p := -out.f[out.deg+i].p;
00429      1  1    END;
00430      1  1 out.deg := out.deg + v2.deg;
00431      1  1 cspolynorm (out);
00432      1  1 cspolydiv := out;
00433      0  0 END;
00434   C  0  0 {-----------------------------------------------------------------------------}
00435      1  0 FUNCTION cspolyeval (cs : cspoly;  s : real) : longreal;
00436      1  0 VAR
00437      1  0    i   : integer;
00438      1  0    out : longreal;
00439      1  1 BEGIN
00440      1  1 out := 1;

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00441      1  1 FOR i := 1 TO cs.deg DO
00442      1  1    IF cs.f[i].v.im = 0
00443      1  1     THEN out := out * quad(s + cs.f[i].v.re) ** cs.f[i].p
00444      1  1     ELSE out := out * 
00445      1  1              quad(s*s + 2 * cs.f[i].v.re * s + cabssq(cs.f[i].v)) ** cs.f[i].p;
00446      1  1 cspolyeval := out;
00447      0  0 END;
00448   C  0  0 {=============================================================================}
00449   C  0  0 {-- SUBMODULE POLY COMVERSION ------------------------------------------------}
00450   C  0  0 {=============================================================================}
00451      1  0 PROCEDURE cpolyfromupoly (VAR out : cpoly;  VAR k: longreal;  u1 : upoly);
00452   C  1  0 { Purpose -- Convert upoly into cpoly by using FORTRAN subroutine POLYRT }
00453   C  1  0 {            Only works if order is less than rootmax }
00454      1  0 VAR
00455      1  0    i           : integer;
00456      1  0    j           : integer;
00457      1  0    ifail       : integer;
00458      1  0    work        : ARRAY [0..51] OF REAL;
00459      1  0    rootr,rooti : ARRAY [1..51] OF REAL;
00460   C  1  0 {------------------------------}
00461      1  0 [EXTERNAL] {SEPARATE}
00462      2  0 PROCEDURE jenkins (op : upoly;  VAR root : cpoly);  
00463      1  0 EXTERN; 
00464   C  1  0 {------------------------------}
00465      1  1 BEGIN
00466      1  1 WHILE (u1.deg > 0) AND (u1.c[u1.deg] = 0) DO u1.deg := u1.deg - 1;
00467      1  1 out.deg := u1.deg;
00468      1  1 k := u1.c[u1.deg];
00469      1  1 IF out.deg > rootmax 
00470      1  1  THEN raise ('CPOLYFROMUPOLY : Attempt to root oversize polynomial')
00471      1  1 ELSE IF out.deg > 0
00472      1  1  THEN
00473      1  2   BEGIN 
00474      1  2   jenkins (u1,out);
00475      1  2   cpolynorm (out);
00476      1  1   END;
00477      0  0 END;
00478   C  0  0 {-----------------------------------------------------------------------------}
00479      1  0 PROCEDURE upolyfromcpoly (VAR out : upoly;  v1 : cpoly;  gain : longreal);
00480      1  0 VAR
00481      1  0    i,j     : integer;
00482      1  0    utemp   : upoly;
00483      1  1 BEGIN
00484      1  1 cpolynorm (v1);
00485      1  1 out.deg := 0;
00486      1  1 out.c[0] := dble(gain);
00487      1  1 FOR i := 1 TO v1.deg DO 
00488      1  2    BEGIN
00489      1  2    IF v1.f[i].im=0.0
00490      1  2     THEN
00491      1  3      BEGIN
00492      1  3      utemp.c[0] := v1.f[i].re;
00493      1  3      utemp.c[1] := 1;
00494      1  3      utemp.deg  := 1;
00495      1  3      END

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00496      1  2    ELSE IF v1.f[i].im>0
00497      1  2     THEN
00498      1  3      BEGIN
00499      1  3      utemp.c[0] := v1.f[i].re **2 + v1.f[i].im **2;
00500      1  3      utemp.c[1] := 2d0 * v1.f[i].re;
00501      1  3      utemp.c[2] := 1;
00502      1  3      utemp.deg  := 2;
00503      1  3      END
00504      1  2    ELSE
00505      1  3      BEGIN
00506      1  3      utemp.c[0] := 1;
00507      1  3      utemp.deg  := 0;
00508      1  2      END;
00509      1  2    FOR j := 1 TO v1.p[i] DO  out := upolymul (out,utemp);
00510      1  1    END;
00511      0  0 END;
00512   C  0  0 {-----------------------------------------------------------------------------}
00513      1  0 PROCEDURE cupolyfromcpoly (VAR out : cupoly;  v : cpoly;  gain : longreal);
00514   C  1  0 { Purpose -- Expand a cpoly into a cupoly }
00515      1  0 VAR
00516      1  0     i,j   : integer;
00517      1  0     utemp : cupoly;
00518      1  1 BEGIN
00519      1  1 out.c[0] := cofr (dble (gain));
00520      1  1 out.deg := 0;
00521      1  1 FOR i := 1 TO v.deg DO
00522      1  2    BEGIN
00523      1  2    utemp.c[0] := v.f[i];
00524      1  2    utemp.c[1] := complex(1,0);
00525      1  2    utemp.deg := 1;
00526      1  2    FOR j := 1 TO v.p[i] DO out := cupolymul (out,utemp);
00527      1  1    END;
00528      0  0 END;
00529   C  0  0 {-----------------------------------------------------------------------------}
00530      1  0 PROCEDURE cspolyfromcpolys (VAR out : cspoly;  vn,vd : cpoly);
00531   C  1  0 { Purpose -- Merge numerator and denominator into cspoly }
00532      1  0 VAR
00533      1  0    i : integer;
00534      1  1 BEGIN
00535      1  1 out.deg := 0;
00536      1  1 FOR i := 1 TO vn.deg DO
00537      1  1    IF vn.f[i].im >= 0
00538      1  1     THEN
00539      1  2      BEGIN
00540      1  2      out.deg := out.deg + 1;
00541      1  2      out.f[out.deg].v := vn.f[i];
00542      1  2      out.f[out.deg].p := vn.p[i];
00543      1  1      END;
00544      1  1 FOR i := 1 TO vd.deg DO
00545      1  1    IF vd.f[i].im >= 0
00546      1  1     THEN
00547      1  2      BEGIN
00548      1  2      out.deg := out.deg + 1;
00549      1  2      out.f[out.deg].v := vd.f[i];
00550      1  2      out.f[out.deg].p := -vd.p[i];

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

-LINE-IDC-PL-SL-

00551      1  1      END;
00552      1  1 cspolynorm (out);
00553      0  0 END;
00554   C  0  0 {-----------------------------------------------------------------------------}
00555      1  0 PROCEDURE cpolysfromcspoly (VAR outn,outd : cpoly;  v : cspoly);
00556   C  1  0 { Purpose -- Merge numerator and denominator into cspoly }
00557      1  0 VAR
00558      1  0    i,j : integer;
00559   C  1  0 {------------------------------}
00560      2  0 PROCEDURE addfactor (VAR v : cpoly;  f : complex;  p : integer);
00561      2  1 BEGIN
00562      2  1 IF v.deg = MAXDEG THEN raise ('CPOLYSFROMCSPOLY : Polynomial overflow');
00563      2  1 v.deg := v.deg + 1;
00564      2  1 v.f[v.deg] := f;
00565      2  1 v.p[v.deg] := p;
00566      1  0 END;
00567   C  1  0 {------------------------------}
00568      1  1 BEGIN
00569      1  1 outn.deg := 0;
00570      1  1 outd.deg := 0;
00571      1  1 FOR i := 1 TO v.deg DO
00572      1  1    IF v.f[i].p > 0
00573      1  1     THEN
00574      1  2      BEGIN
00575      1  2      addfactor (outn,v.f[i].v,v.f[i].p);
00576      1  2      IF v.f[i].v.im > 0 THEN addfactor (outn,ccnj(v.f[i].v),v.f[i].p);
00577      1  2      END
00578      1  1     ELSE
00579      1  2      BEGIN
00580      1  2      addfactor (outd,v.f[i].v,-v.f[i].p);
00581      1  2      IF v.f[i].v.im > 0 THEN addfactor (outd,ccnj(v.f[i].v),-v.f[i].p);
00582      1  1      END;
00583      1  1 cpolynorm (outn);
00584      1  1 cpolynorm (outd);
00585      0  0 END;
00586   C  0  0 {-----------------------------------------------------------------------------}
00587      0  0 END.

POLYMATH                                                        23-Dec-1988 10:40:06    VAX Pascal V3.7-254                Page   12
INCA                            Pascal Compilation Statistics   29-Nov-1988 15:35:52    [QPLOT.INCA.SOURCE]POLYMATH.PAS;86 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                8492  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                                 20  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        27        22
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         3         5
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        42        68
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         1         1



JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:MATH',
00004      0  0                'QLIBHOME:COMPLEX',
00005      0  0                'POLYMATH'),
00006      0  0   CHECK       (NONE) ]
00007      0  0 MODULE jenkins;
00008   C  0  0 {=============================================================================}
00009      0  0 TYPE
00010      0  0    realarray = ARRAY [1..MAXDEG+1] OF real;
00011   C  0  0 {=============================================================================}
00012      0  0 [ OPTIMIZE (INLINE,ALL) ]
00013      1  0 PROCEDURE quad (a,b1,c : real;  VAR sr,si,lr,li : real);
00014      1  0 
00015   C  1  0 {  Calculate the zeros of the quadratic a*x^2+b1*x+c.  The quadratic          }
00016   C  1  0 {  formula, modified to avoid overflow, is used to find the large zero if the }
00017   C  1  0 {  zeros are real and both zeros are complex.  The smaller real zero is found }
00018   C  1  0 {  directly from the product of the zeros c/a.  The discriminant is computed  }
00019   C  1  0 {  in a special way to avoid overflow.                                        }
00020      1  0 
00021      1  0 VAR
00022      1  0    b,d,e  : real;
00023      1  1 BEGIN
00024      1  1 IF a = 0
00025      1  1  THEN
00026      1  2   BEGIN  
00027      1  2   IF b1 = 0 THEN sr := 0 ELSE sr := -c/b1;
00028      1  2   si := 0;
00029      1  2   lr := 0;
00030      1  2   li := 0;
00031      1  2   END
00032      1  1 ELSE IF c = 0 
00033      1  1  THEN
00034      1  2   BEGIN
00035      1  2   sr := 0;
00036      1  2   si := 0;
00037      1  2   lr := -b1/a;
00038      1  2   li := 0;
00039      1  2   END
00040      1  1  ELSE
00041      1  2   BEGIN
00042      1  2   b := b1/2;
00043      1  2   IF abs(b) >= abs(c) 
00044      1  2    THEN
00045      1  3     BEGIN
00046      1  3     e := 1 - (a/b)*(c/b);
00047      1  3     d := sqrt (abs(e)) * abs(b);
00048      1  3     END
00049      1  2    ELSE
00050      1  3     BEGIN
00051      1  3     IF c > 0 
00052      1  3      THEN e := b*(b/abs(c)) - a
00053      1  3      ELSE e := b*(b/abs(c)) + a;
00054      1  3     d := sqrt (abs(e)) * sqrt(abs(c));
00055      1  2     END;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00056      1  2   IF e >= 0
00057      1  2    THEN
00058      1  3     BEGIN
00059      1  3     IF b >= 0 THEN lr := (-b-d)/a ELSE lr := (-b+d)/a;
00060      1  3     li := 0;
00061      1  3     IF lr = 0 THEN sr := 0 ELSE sr := (c/lr)/a;
00062      1  3     si := 0;
00063      1  3     END
00064      1  2    ELSE
00065      1  3     BEGIN
00066      1  3     sr := -b/a;
00067      1  3     si := abs(d/a);
00068      1  3     lr := sr;
00069      1  3     li := -si;
00070      1  2     END;
00071      1  1   END;
00072      0  0 END;
00073   C  0  0 {-----------------------------------------------------------------------------}
00074      0  0 [ OPTIMIZE (INLINE,ALL) ]
00075      1  0 PROCEDURE quadsd (nn : integer;  u,v : real;  VAR p,q : realarray;  
00076      1  0    VAR a,b : real);
00077   C  1  0 {  Divides p by quadratic  1,u,v, placing quotient in q and remainder in a,b  }
00078      1  0 VAR
00079      1  0    i : integer;
00080      1  1 BEGIN
00081      1  1 q[1] := p[1];
00082      1  1 q[2] := p[2] - u*q[1];
00083      1  1 FOR i := 3 TO nn DO
00084      1  1    q[i] := p[i] - u*q[i-1] - v*q[i-2];
00085      1  1 a := q[nn];
00086      1  1 b := q[nn-1];
00087      0  0 END;
00088   C  0  0 {-----------------------------------------------------------------------------}
00089      0  0 [ GLOBAL ]
00090      1  0 PROCEDURE jenkins (op : upoly;  VAR factors : cpoly);
00091      1  0 
00092   C  1  0 {  The following statements set machine constants used in various parts       }
00093   C  1  0 {  of the program.  The values below correspond to the DEC VAX.               }
00094   C  1  0 {  The meaning of the six constants are:                                      }
00095   C  1  0 {  BASE     -- The base of the floating-point number system used.             }
00096   C  1  0 {  ETA      -- The maximum relative representation error which can be         }
00097   C  1  0 {              described as the smallest positive floating point number       }
00098   C  1  0 {              such that 1+eta is greater than 1.                             }
00099   C  1  0 {  INFIN    -- The largest floating-point number.                             }
00100   C  1  0 {  SMALNO   -- The smallest positive floating-point number if the exponent    }
00101   C  1  0 {              range differs in single and double precision then SMALNO and   }
00102   C  1  0 {              INFIN should indicate the smaller range.                       }
00103   C  1  0 {  ARE      -- Unit error in addition.                                        }
00104   C  1  0 {  MRE      -- Unit error in multiplication.                                  }
00105      1  0 
00106      1  0 CONST
00107      1  0    BASE              = 2.0;
00108      1  0    ETA               = BASE**(1-55);
00109      1  0    INFIN             = 0.5E+38;
00110      1  0    SMALNO            = 2.0E-37;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00111      1  0    ARE               = ETA;
00112      1  0    MRE               = ETA;
00113      1  0    LO                = SMALNO/ETA;
00114      1  0 
00115   C  1  0 {  Constants for shift rotation.  }
00116      1  0 CONST
00117      1  0    COSR              = -0.06975644474;
00118      1  0    SINR              =  0.99756405;
00119      1  0 
00120   C  1  0 {  GLOBAL VARIABLES  }
00121      1  0 TYPE
00122      1  0    scale_type        = RECORD
00123      1  0                        scaletype : integer;
00124      1  0                        c,d       : real;
00125      1  0                        e,f,g,h   : real;
00126      1  0                        a1,a3,a7  : real;
00127      1  0                        END;
00128      1  0 VAR
00129      1  0    p,qp,k,qk         : realarray;
00130      1  0    sr,si,u,v,a,b     : real;
00131      1  0    szr,szi,lzr,lzi   : real;
00132      1  0    n,nn              : integer;
00133      1  0    scale             : scale_type;
00134   C  1  0 {------------------------------}
00135      1  0 [ OPTIMIZE (INLINE,ALL) ]
00136      2  0 PROCEDURE addzero (r,i : real);
00137      2  1 BEGIN
00138      2  1 factors.deg := factors.deg + 1;
00139      2  1 factors.f[factors.deg].re := -r;
00140      2  1 factors.f[factors.deg].im := -i;
00141      2  1 factors.p[factors.deg]    := 1;
00142      2  1 nn := nn-1;
00143      2  1 n := n-1;
00144      1  0 END;
00145   C  1  0 {------------------------------}
00146      1  0 [ OPTIMIZE (INLINE,ALL) ]
00147      2  0 PROCEDURE calcsc;
00148   C  2  0 {  This routine calculates scalar quantities used to compute the next k    }
00149   C  2  0 {  polynomial and new estimates of quadratic coefficients.  Type is integer}
00150   C  2  0 {  set here indicating how calculations are normalized to avoid overflow.  }
00151   C  2  0 {  scaletype = 1 indicates that all formulas are divided by c              }
00152   C  2  0 {  scaletype = 2 indicates that all formulas are divided by d              }
00153   C  2  0 {  scaletype = 3 indicates the quadratic is almost a factor of k           }
00154      2  1 BEGIN
00155      2  1 WITH scale DO
00156      2  2    BEGIN
00157      2  2    quadsd (n, u, v, k, qk, c, d);
00158      2  2    IF (abs(c) <= abs(k[n])*100*ETA) AND (abs(d) <= abs(k[n-1])*100*ETA) 
00159      2  2     THEN scaletype := 3
00160      2  2    ELSE IF abs(d) >= abs(c)
00161      2  2     THEN
00162      2  3      BEGIN
00163      2  3      scaletype := 2;
00164      2  3      e := a/d;
00165      2  3      f := c/d;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00166      2  3      g := u*b;
00167      2  3      h := v*b;
00168      2  3      a3 := (a+g)*e + h*(b/d);
00169      2  3      a1 := b*f - a;
00170      2  3      a7 := (f+u)*a + h;
00171      2  3      END
00172      2  2     ELSE
00173      2  3      BEGIN
00174      2  3      scaletype := 1;
00175      2  3      e := a/c;
00176      2  3      f := d/c;
00177      2  3      g := u*e;
00178      2  3      h := v*b;
00179      2  3      a3 := a*e + (h/c+g)*b;
00180      2  3      a1 := b - a*(d/c);
00181      2  3      a7 := a + g*d + h*f;
00182      2  2      END;
00183      2  1    END;
00184      1  0 END;
00185   C  1  0 {------------------------------}
00186      1  0 [ OPTIMIZE (INLINE,ALL) ]
00187      2  0 PROCEDURE nextk;
00188   C  2  0 {  Computes the next k polynomials using scalars computed in CALCSC.  }
00189      2  0 VAR
00190      2  0    temp : real;
00191      2  0    i    : integer;
00192      2  1 BEGIN
00193      2  1 WITH scale DO
00194      2  1    IF scaletype = 3
00195      2  1     THEN
00196      2  2      BEGIN
00197      2  2      k[1] := 0;
00198      2  2      k[2] := 0;
00199      2  2      FOR i := 3 TO n DO k[i] := qk[i-2];
00200      2  2      END
00201      2  1     ELSE
00202      2  2      BEGIN
00203      2  2      IF scaletype = 1
00204      2  2       THEN temp := b
00205      2  2       ELSE temp := a;
00206      2  2      IF abs(a1) <= abs(temp)*ETA*10 
00207      2  2       THEN
00208      2  3        BEGIN
00209   C  2  3        {  If a1 is nearly zero then use a special form of the recurrence.   }
00210      2  3        k[1] := 0;
00211      2  3        k[2] := -a7*qp[1];
00212      2  3        FOR i := 3 TO n DO 
00213      2  3           k[i] := a3*qk[i-2] - a7*qp[i-1];
00214      2  3        END
00215      2  2       ELSE
00216      2  3        BEGIN
00217   C  2  3        {  Use scaled form of the recurrence.  }
00218      2  3        a7 := a7/a1;
00219      2  3        a3 := a3/a1;
00220      2  3        k[1] := qp[1];

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00221      2  3        k[2] := qp[2] - a7*qp[1];
00222      2  3        FOR i := 3 TO n DO
00223      2  3           k[i] := a3*qk[i-2] - a7*qp[i-1] + qp[i];
00224      2  2        END;
00225      2  1      END;
00226      1  0 END;
00227   C  1  0 {------------------------------}
00228      1  0 [ OPTIMIZE (INLINE,ALL) ]
00229      2  0 PROCEDURE newest (VAR uu,vv : real);
00230   C  2  0 {  Compute new estimates of quadratic coef. using scalars computed in CALCSC. }
00231      2  0 VAR
00232      2  0    a4,a5,b1,b2,c4,temp : real;
00233      2  1 BEGIN
00234      2  1 WITH scale DO
00235      2  1    IF scaletype = 3
00236      2  1     THEN
00237      2  2      BEGIN
00238      2  2      uu := 0;
00239      2  2      vv := 0;
00240      2  2      END
00241      2  1     ELSE 
00242      2  2      BEGIN
00243      2  2      IF scaletype = 2
00244      2  2       THEN
00245      2  3        BEGIN
00246      2  3        a4 := (a+g)*f + h;
00247      2  3        a5 := (f+u)*c + v*d;
00248      2  3        END
00249      2  2       ELSE
00250      2  3        BEGIN
00251      2  3        a4 := a + u*b + h*f;
00252      2  3        a5 := c + (u+v*f)*d;
00253      2  2        END;
00254      2  2      b1 := -k[n]/p[nn];
00255      2  2      b2 := -(k[n-1]+B1*p[n])/p[nn];
00256      2  2      c4 := v*b2*a1 - b1*a7 - b1*b1*a3;
00257      2  2      temp := a5 +b1*a4 - c4;
00258      2  2      IF temp = 0
00259      2  2       THEN
00260      2  3        BEGIN
00261      2  3        uu := 0;
00262      2  3        vv := 0;
00263      2  3        END
00264      2  2       ELSE
00265      2  3        BEGIN
00266      2  3        uu := u - (u*b1*(b1*a3+a7) + v*(b1*a1+b2*a7)) / temp;
00267      2  3        vv := v * (1+c4/temp);
00268      2  2        END;
00269      2  1      END;
00270      1  0 END;
00271   C  1  0 {------------------------------}
00272      1  0 [ OPTIMIZE (INLINE,ALL) ]
00273      2  0 PROCEDURE realit (VAR sss : real;  VAR nz : integer; VAR flag : boolean);
00274   C  2  0 {  Variable-shift h polynomial iteration for a real zero.    }
00275   C  2  0 {  sss   -- starting iterate                                 }

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00276   C  2  0 {  nz    -- number of zeros found                            }
00277   C  2  0 {  flag  -- flag to indicate a pair of zeros near real axis. }
00278      2  0 
00279      2  0 VAR
00280      2  0    i,j           : integer;
00281      2  0    pv,kv,s,t     : real;
00282      2  0    ms,mp,omp,ee  : real;
00283      2  1 BEGIN
00284      2  1 nz   := 0;
00285      2  1 s    := sss;
00286      2  1 flag := false;
00287      2  1 j    := 0;
00288      2  1 t    := 0;
00289      2  2 REPEAT
00290      2  2    j := j + 1;
00291   C  2  2    {  Evaluate p at s  }
00292      2  2    qp[1] := p[1];
00293      2  2    FOR i := 2 TO nn DO
00294      2  2       qp[i] := qp[i-1]*s + p[i];
00295      2  2    pv := qp[nn];
00296      2  2 
00297      2  2    mp := abs(pv);
00298   C  2  2    {  Compute a rigorous bound on the error in evaluating p    }
00299      2  2    ms := abs(s);
00300      2  2    ee := (MRE/(ARE+MRE)) * abs(qp[1]);
00301      2  2    FOR i := 2 TO nn DO
00302      2  2       ee := ee*ms + abs(qp[i]);
00303      2  2 
00304      2  2    IF mp <= 20*((ARE+MRE)*ee - MRE*mp)
00305      2  2     THEN
00306      2  3      BEGIN
00307   C  2  3      {  Iteration has converged sufficiently if the         }
00308   C  2  3      {  polynomial value is less than 20 times this bound   }
00309      2  3      nz  := 1;
00310      2  3      szr := s;
00311      2  3      szi := 0;
00312      2  3      END
00313      2  2    ELSE IF (j >= 2) AND (abs(t) <= 0.001*abs(s-t)) AND (mp > omp)
00314      2  2     THEN
00315      2  3      BEGIN
00316   C  2  3      {  A cluster of zeros near the real axis has been encountered.   }
00317   C  2  3      {  Return with iflag set to initiate a quadratic iteration.      }
00318      2  3      flag := true;
00319      2  3      sss  := s;
00320      2  3      END
00321      2  2     ELSE
00322      2  3      BEGIN
00323   C  2  3      { Compute t, the next polynomial, and the new iterate.  }
00324      2  3      omp   := mp;
00325      2  3      qk[1] := k[1];
00326      2  3      FOR i := 2 TO n DO 
00327      2  3         qk[i] := qk[i-1]*s + k[i];
00328      2  3      kv := qk[n];
00329      2  3 
00330   C  2  3      {  If the value of k at s is nonzero, use the scaled form of recurrence . }

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00331      2  3      IF abs (kv) > abs (k[n]) * 10*ETA
00332      2  3       THEN
00333      2  4        BEGIN
00334      2  4        k[1] := qp[1];
00335      2  4        FOR i := 2 TO n DO k[i] := -pv/kv*qk[i-1] + qp[i];
00336      2  4        END
00337      2  3       ELSE
00338      2  4        BEGIN
00339      2  4        k[1] := 0;
00340      2  4        FOR i := 2 TO n DO k[i] := qk[i-1];
00341      2  3        END;
00342      2  3 
00343      2  3      kv := k[1];
00344      2  3      FOR i := 2 TO n DO kv := kv*s + k[i];
00345      2  3 
00346      2  3      IF abs(kv) > abs(k[n])*10*ETA
00347      2  3       THEN t := -pv/kv
00348      2  3       ELSE t := 0;
00349      2  3      s := s + t;
00350      2  2      END;
00351      2  1    UNTIL (j > 10) OR flag OR (nz > 0);
00352      1  0 END;
00353   C  1  0 {------------------------------}
00354      1  0 [ OPTIMIZE (INLINE,ALL) ]
00355      2  0 PROCEDURE quadit (uu,vv : real;  VAR nz : integer);
00356   C  2  0 {  Variable-shift k-polynomial iteration for a quadratic factor    }
00357   C  2  0 {  converges only if the zeros are equimodular or nearly so.       }
00358   C  2  0 {  uu,vv  -- Coefficients of starting quadratic.                   }
00359   C  2  0 {  nz     -- Number of zero found.                                 }
00360      2  0 
00361      2  0 VAR
00362      2  0    ui,vi       : real;
00363      2  0    mp,omp,ee   : real;
00364      2  0    relstp,t,zm : real;
00365      2  0    i,j         : integer;
00366      2  0    tried       : boolean;
00367      2  0    noconverge  : boolean;
00368      2  1 BEGIN
00369      2  1 nz := 0;
00370      2  1 tried := false;
00371      2  1 u := uu;
00372      2  1 v := vv;
00373      2  1 j := 0;
00374      2  1 noconverge := false;
00375      2  2 REPEAT
00376      2  2    j := j + 1;
00377      2  2    quad (1,u,v,szr,szi,lzr,lzi);
00378   C  2  2    {  Return if roots of the quadratic are real and not close   }
00379   C  2  2    {  to multiple or nearly emodi and  of opposite sign.        }
00380      2  2 
00381      2  2    IF abs (abs(szr)-abs(lzr)) > 0.01*abs(lzr) 
00382      2  2     THEN noconverge := true
00383      2  2     ELSE
00384      2  3      BEGIN
00385      2  3      quadsd (nn,u,v,p,qp,a,b);

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00386      2  3      mp := abs(a-szr*b) + abs(szi*b);
00387   C  2  3      {  Compute a rigorous bound on the rounding error in evaluting p.   }
00388      2  3      zm := sqrt(abs(v));
00389      2  3      ee := 2*abs(qp[1]);
00390      2  3      FOR i := 2 TO n DO
00391      2  3         ee := ee*zm + abs(qp[i]);
00392      2  3      t  := -szr*b;
00393      2  3      ee := ee*zm + abs(a+t);
00394      2  3      ee := (5*MRE+4*ARE)*ee - (5*MRE+2*ARE)*(abs(a+t)+abs(b)*zm) + 2*are*abs(t);
00395      2  3 
00396   C  2  3      { Iteration has converged sufficiently if polynomial value is < 20*bound.}
00397      2  3      IF mp <= 20*ee
00398      2  3       THEN nz := 2
00399      2  3       ELSE
00400      2  4        BEGIN
00401   C  2  4        {  A cluster appears to be stalling the convergence.  Five fixed    }
00402   C  2  4        {  shift steps are taken with a u, v close to the cluster.          }
00403      2  4        IF (j >= 2) AND (relstp <= 0.01) AND (mp >= omp) AND NOT tried
00404      2  4         THEN
00405      2  5          BEGIN
00406      2  5          relstp := sqrt (rmax (relstp,ETA));
00407      2  5          u := u - u*relstp;
00408      2  5          v := v + v*relstp;
00409      2  5          quadsd (nn,u,v,p,qp,a,b);
00410      2  5          FOR i := 1 TO 5 DO
00411      2  6             BEGIN
00412      2  6             calcsc;
00413      2  6             nextk;
00414      2  5             END;
00415      2  5          tried := true;
00416      2  5          j := 0;
00417      2  4          END;
00418      2  4 
00419   C  2  4        {  Calculate next k polynomial and new u and v.  }
00420      2  4        omp := mp;
00421      2  4        calcsc;
00422      2  4        nextk;
00423      2  4        calcsc;
00424      2  4        newest (ui, vi);
00425   C  2  4        {  If vi is zero the iteration is not converging.  }
00426      2  4        IF vi = 0 
00427      2  4         THEN noconverge := false
00428      2  4         ELSE
00429      2  5          BEGIN
00430      2  5          relstp := abs((vi-v)/vi);
00431      2  5          u := ui;
00432      2  5          v := vi;
00433      2  4          END;
00434      2  3        END;
00435      2  2      END;
00436      2  1    UNTIL (j > 20) OR (nz > 0) OR noconverge;
00437      1  0 END;
00438   C  1  0 {------------------------------}
00439      1  0 [ OPTIMIZE (INLINE,ALL) ]
00440      2  0 PROCEDURE fxshfr (l2 : integer;  VAR nz : integer);

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00441   C  2  0 {  Computes up to l2 fixed shift k-polynomials, testing for convergence    }
00442   C  2  0 {  in the linear or quadratic case.  Initiates one of the variable shift   }
00443   C  2  0 {  iterations and returns with the number of zeros found.                  }
00444      2  0 
00445      2  0 VAR
00446      2  0    savek          : realarray;
00447      2  0    saveu,savev    : real;
00448      2  0    ui,vi          : real;
00449      2  0    betas,betav    : real;
00450      2  0    oss,ovv,ss,vv  : real;
00451      2  0    ts,tv,ots,otv,tvv,tss  : real;
00452      2  0    j              : integer;
00453      2  0 
00454   C  2  0 {--------------------}
00455      3  0 PROCEDURE checkrealit;
00456      3  0 VAR
00457      3  0    flag : boolean;
00458      3  0    s    : real;
00459      3  1 BEGIN
00460      3  1 u := saveu;
00461      3  1 v := savev;
00462      3  1 k := savek;
00463      3  1 s := ss;
00464      3  1 realit (s,nz,flag);
00465      3  1 betas := betas/4;
00466      3  1 IF flag 
00467      3  1  THEN
00468      3  2   BEGIN
00469      3  2   quadit (-2*s,s*s,nz);
00470      3  2   betav := betav/4;
00471      3  1   END;
00472      2  0 END;
00473   C  2  0 {--------------------}
00474      3  0 PROCEDURE checkquadit;
00475      3  1 BEGIN
00476      3  1 u := saveu;
00477      3  1 v := savev;
00478      3  1 k := savek;
00479      3  1 quadit (ui,vi,nz);
00480      3  1 betav := betav/4;
00481      2  0 END;
00482   C  2  0 {--------------------}
00483      2  1 BEGIN
00484      2  1 nz := 0;
00485      2  1 betav := 0.25;
00486      2  1 betas := 0.25;
00487      2  1 oss := sr;
00488      2  1 ovv := v;
00489      2  1 
00490   C  2  1 {  Evaluate polynomial by synthetic division.    }
00491      2  1 quadsd (nn, u, v, p, qp, a, b);
00492      2  1 calcsc;
00493      2  1 j := 0;
00494      2  2 REPEAT
00495      2  2    j := j+1;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00496   C  2  2    {  Calculate next k polynomial and estimate v and estimate s.  }
00497      2  2    nextk;
00498      2  2    calcsc;
00499      2  2    newest (ui, vi);
00500      2  2 
00501      2  2    vv := vi;
00502      2  2    IF k[n] = 0 
00503      2  2     THEN ss := 0
00504      2  2     ELSE ss := -p[nn]/k[n];
00505      2  2    tv := 1;
00506      2  2    ts := 1;
00507      2  2    IF (j > 1) AND (scale.scaletype <> 3) 
00508      2  2     THEN
00509      2  3      BEGIN
00510   C  2  3      {  Compute relative measures of convergence of s and v sequences    }
00511   C  2  3      {  if decreasing, multiply two most recent convergence measures     }
00512   C  2  3      {  then compare with convergence criteria.                          }
00513      2  3 
00514      2  3      IF vv <> 0 THEN tv := abs((vv-ovv)/vv);
00515      2  3      IF ss <> 0 THEN ts := abs((ss-oss)/ss);
00516      2  3      IF tv < otv THEN tvv := tv*otv ELSE tvv := 1;
00517      2  3      IF ts < ots THEN tss := ts*ots ELSE tss := 1;
00518      2  3      saveu := u;
00519      2  3      savev := v;
00520      2  3      savek := k;
00521      2  3 
00522      2  3      IF (tss < betas) AND (tvv < betav)
00523      2  3       THEN
00524      2  3        IF tss < tvv
00525      2  3         THEN
00526      2  4          BEGIN
00527      2  4          checkrealit;
00528      2  4          IF nz = 0 THEN checkquadit;
00529      2  4          END
00530      2  3         ELSE
00531      2  4          BEGIN
00532      2  4          checkquadit;
00533      2  4          IF nz = 0 THEN checkrealit;
00534      2  4          END
00535      2  3      ELSE IF tss < betas
00536      2  3       THEN checkrealit
00537      2  3      ELSE IF tvv < betav
00538      2  3       THEN checkquadit;
00539      2  3  
00540   C  2  3      {  Recompute qp and scalar values to continue the second stage.  }
00541      2  3      IF nz = 0
00542      2  3       THEN
00543      2  4        BEGIN
00544      2  4        quadsd (nn,u,v,p,qp,a,b);
00545      2  4        calcsc;
00546      2  3        END;
00547      2  2      END;
00548      2  2 
00549      2  2    ovv := vv;
00550      2  2    oss := ss;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00551      2  2    otv := tv;
00552      2  2    ots := ts;
00553      2  1    UNTIL (j > l2) OR (nz > 0);
00554      1  0 END;
00555   C  1  0 {------------------------------}
00556      2  0 PROCEDURE main;
00557      2  0 VAR
00558      2  0    temp,pt           : realarray;
00559      2  0    t,factor          : real;
00560      2  0    max,min           : real;
00561      2  0    xxx,x,sc,bnd,xm   : real;
00562      2  0    ff,df,dx,xx,yy    : real;
00563      2  0    cnt,nz,i,jj       : integer;
00564      2  0    zerok             : boolean;
00565      2  1 BEGIN
00566      2  1 factors.deg := 0;
00567      2  1 n  := op.deg;
00568      2  1 nn := n + 1;
00569      2  1 xx :=  0.70710678;
00570      2  1 yy := -0.70710678;
00571      2  1 
00572   C  2  1 {  Copy coefficients into working array p[i].  }
00573   C  2  1 {  Make sure to normalize polynomial.          }
00574   C  2  1 {  Then remove zeros at origin.                }
00575      2  1 
00576      2  1 IF op.c[op.deg] = 0 THEN raise ('JENKINS ROOTER : Leading coefficient is zero');
00577      2  1 
00578      2  1 FOR i := nn DOWNTO 1 DO p[i] := op.c[nn-i] / op.c[op.deg];
00579      2  1 WHILE p[nn] = 0 DO addzero (0,0);
00580      2  1 
00581      2  1 WHILE n > 0 DO
00582      2  2    CASE n OF
00583      2  2       0:  ;
00584      2  2       1:  addzero (-p[2]/p[1],0);
00585      2  3       2:  BEGIN
00586      2  3           quad (p[1],p[2],p[3],szr,szi,lzr,lzi);
00587      2  3           addzero (szr,szi);
00588      2  3           addzero (lzr,lzi);
00589      2  2           END;
00590      2  2       OTHERWISE
00591      2  3           BEGIN
00592   C  2  3           {  First find largest and smallest moduli of coefficients.  Scale   }
00593   C  2  3           {  if ther are very large or very small coefficients.  Compute      }
00594   C  2  3           {  a scale factor to multiply the coefficients of the polynomial.   }
00595   C  2  3           {  The scaling is done to avoid overflow and to avoid undetected    }
00596   C  2  3           {  underflow interfering with the convergence criterion.  The       }
00597   C  2  3           {  factor is a power of the base.                                   }
00598      2  3           max := 0;
00599      2  3           min := INFIN;
00600      2  3           FOR i := 1 TO nn DO
00601      2  4              BEGIN
00602      2  4              max := rmax (max,abs(p[i]));
00603      2  4              IF p[i] <> 0 THEN min := rmin (min,abs(p[i]));
00604      2  3              END;
00605      2  3           sc := LO/MIN;

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00606      2  3           IF sc = 0 THEN sc := SMALNO;
00607      2  3           IF ((sc > 1) AND (INFIN/sc >= max)) OR
00608      2  3              ((sc <=1) AND (max >= 10)) 
00609      2  3            THEN
00610      2  4             BEGIN
00611      2  4             factor := BASE ** round (ln(sc)/ln(base));
00612      2  4             FOR i := 1 TO nn DO p[i] := factor * p[i];
00613      2  3             END;
00614      2  3 
00615   C  2  3           {  Compute lower bound on moduli of zeros. }
00616      2  3           FOR i := 1 TO nn DO pt[i] := abs(p[i]);
00617      2  3           pt[nn] := -pt[nn];
00618      2  3 
00619   C  2  3           {  Compute upper estimate of bound.  }
00620   C  2  3           {  If newton step at the origin is better, use it.  }
00621      2  3           x := exp ((ln (-pt[nn]) - ln (pt[1])) / n);
00622      2  3           IF pt[n] <> 0 THEN x := rmin (x,-pt[nn]/pt[n]);
00623      2  3 
00624   C  2  3           {  Chop the interval (0,x) until ff <= 0.  }
00625      2  4           REPEAT
00626      2  4              xm := x/10;
00627      2  4              ff := pt[1];
00628      2  4              FOR i := 2 TO nn DO ff := ff * xm + pt[i];
00629      2  4              IF ff > 0 THEN x := xm;
00630      2  3              UNTIL ff <= 0;
00631      2  3 
00632   C  2  3           {  Do newton iteration until x converges to two decimal places.  }
00633      2  3           dx := x;
00634      2  3           WHILE abs (dx/x) > 0.005 DO
00635      2  4              BEGIN
00636      2  4              ff := pt[1];
00637      2  4              df := pt[1];
00638      2  4              FOR i := 2 TO n DO
00639      2  5                 BEGIN
00640      2  5                 ff := ff*x + pt[i];
00641      2  5                 df := df*x + ff;
00642      2  4                 END;
00643      2  4              ff := ff*x + pt[nn];
00644      2  4              dx := ff/df;
00645      2  4              x  := x - dx;
00646      2  3              END;
00647      2  3 
00648   C  2  3           {  Compute the derivative as the intial k polynomial and do 5   }
00649   C  2  3           {  steps with no shift.  Use scaled form of recurrence if value }
00650   C  2  3           {  of k at 0 is nonzero else use unscaled form of recurrence.   }
00651      2  3           bnd := x;
00652      2  3           FOR i := 2 TO n DO
00653      2  3              k[i] := (nn-i) * p[i] / n;
00654      2  3           k[1] := p[1];
00655      2  3 
00656      2  3           zerok := k[n] = 0;
00657      2  3           FOR jj := 1 TO 5 DO
00658      2  3              IF zerok 
00659      2  3               THEN
00660      2  4                BEGIN

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                  13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

-LINE-IDC-PL-SL-

00661      2  4                FOR i := 1 TO n-1 DO
00662      2  4                   k[nn-i] := k[nn-i-1];
00663      2  4                k[1] := 0;
00664      2  4                zerok := k[n] = 0;
00665      2  4                END
00666      2  3               ELSE
00667      2  4                BEGIN
00668      2  4                t := -p[nn]/k[n];
00669      2  4                FOR i := 1 TO n-1 DO
00670      2  4                   k[nn-i] := t*k[nn-i-1] + p[nn-i];
00671      2  4                k[1] := p[1];
00672      2  4                zerok := abs(k[n]) <= abs(p[n])*eta*10;
00673      2  3                END;
00674      2  3 
00675   C  2  3           {  Save k for restarts with new shifts.  }
00676      2  3           temp := k;
00677      2  3 
00678   C  2  3           {  Loop to select the quadratic corresponding to each new shift   }
00679   C  2  3           {  quadratic corresponds to a double shift to a non-real point    }
00680   C  2  3           {  and its complex conjugrate.  The point has modulus bnd and     }
00681   C  2  3           {  amplitude rotated by 94 degrees from the previous shift.       }
00682      2  3           cnt := 0;
00683      2  4           REPEAT
00684      2  4              cnt := cnt + 1;
00685      2  4              xxx := cosr*xx - sinr*yy;
00686      2  4              yy := sinr*xx + cosr*yy;
00687      2  4              xx := xxx;
00688      2  4              sr := bnd*xx;
00689      2  4              si := bnd*yy;
00690      2  4              u := -2*sr;
00691      2  4              v := bnd*bnd;         { This change made from examining polyrt }
00692      2  4              fxshfr(20*cnt, nz);
00693      2  4              IF nz = 0 THEN k := temp;
00694      2  4              IF cnt > 20 
00695      2  4               THEN raise ('JENKINS ROOTER : Convergence unsuccessful');
00696      2  3              UNTIL nz <> 0;
00697      2  3 
00698   C  2  3           {  Deflate the polynomial, store the zero or zeros and repeat    }
00699   C  2  3           {  the main algorithm.                                           }
00700      2  3           p := qp;
00701      2  3           IF nz >= 2 THEN addzero (lzr,lzi);
00702      2  3           IF nz >= 1 THEN addzero (szr,szi);
00703      2  2           END;
00704      2  1        END;
00705      1  0 END;
00706   C  1  0 {------------------------------}
00707      1  1 BEGIN
00708      1  1 main;
00709      0  0 END;
00710   C  0  0 {=============================================================================}
00711      0  0 END.

JENKINS                                                         23-Dec-1988 10:41:37    VAX Pascal V3.7-254                Page   14
INCA                            Pascal Compilation Statistics   13-Nov-1987 16:18:24    DUA1:[QPLOT.INCA.SOURCE]JENKINS.PAS;78 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                6875  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        27        22
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         6        10
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         0         0
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        20        12



QZ                                                              23-Dec-1988 10:43:01    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  25-Jan-1988 11:05:24    DUA1:[QPLOT.INCA.SOURCE]QZ.PAS;79 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:MATH',
00004      0  0                'QLIBHOME:COMPLEX',
00005      0  0                'LONGREAL','POLYMATH'),
00006      0  0   ENVIRONMENT ('QZ') ]
00007      0  0 MODULE qz;
00008   C  0  0 {=============================================================================}
00009      0  0 [ HIDDEN ] TYPE
00010      0  0    qzinputitem_type = RECORD
00011      0  0                       base    : integer;
00012      0  0                       last    : integer;
00013      0  0                       nu      : ^upoly;
00014      0  0                       de      : ^upoly;
00015      0  0                       END;
00016      0  0 [ HIDDEN ] VAR
00017      0  0    qzinput          : RECORD
00018      0  0                       count   : integer;
00019      0  0                       denom   : ^cpoly;
00020      0  0                       data    : ARRAY [1..MAXDEG] OF qzinputitem_type;
00021      0  0                       END
00022      0  0                     := (0,NIL,(MAXDEG OF (0,0,NIL,NIL)));
00023   C  0  0 {=============================================================================}
00024      1  0 PROCEDURE QZclear;
00025      1  0 VAR
00026      1  0    i : integer;
00027      1  1 BEGIN
00028      1  1 FOR i := 1 TO qzinput.count DO WITH qzinput.data[i] DO
00029      1  2    BEGIN
00030      1  2    base := 0;
00031      1  2    last := 0;
00032      1  2    dispose (nu);
00033      1  2    dispose (de);
00034      1  1    END;
00035      1  1 qzinput.count := 0;
00036      1  1 IF qzinput.denom = NIL THEN new (qzinput.denom);
00037      1  1 qzinput.denom^.deg := 0;
00038      0  0 END;
00039   C  0  0 {-----------------------------------------------------------------------------}
00040      1  0 PROCEDURE QZadd (VAR un : upoly;  fd : cpoly);
00041      1  1 BEGIN
00042      1  1 qzinput.count := qzinput.count + 1;
00043      1  1 WITH qzinput.data[qzinput.count] DO
00044      1  2    BEGIN
00045      1  2    IF qzinput.count = 1
00046      1  2     THEN base := 0
00047      1  2     ELSE base := qzinput.data[qzinput.count-1].last;
00048      1  2    new (nu);  nu^ := un;
00049      1  2    new (de);  upolyfromcpoly (de^,fd,1);
00050      1  2    IF de^.deg > rootmax
00051      1  2     THEN raise ('QZ: Attempt to use QZ algorith with high degree input');
00052      1  2    last := base + imax (de^.deg,1);
00053      1  2    qzinput.denom^ := cpolymul (qzinput.denom^,fd);
00054      1  1    END;
00055      0  0 END;

QZ                                                              23-Dec-1988 10:43:01    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  25-Jan-1988 11:05:24    DUA1:[QPLOT.INCA.SOURCE]QZ.PAS;79 (1)

-LINE-IDC-PL-SL-

00056   C  0  0 {-----------------------------------------------------------------------------}
00057      1  0 PROCEDURE QZresult (VAR gain : longreal;  VAR fn,fd : cpoly);
00058      1  0 CONST
00059      1  0    NM  = 100;
00060      1  0 TYPE
00061      1  0    eigenmatrix = ARRAY [1..NM,1..NM] OF real;
00062      1  0    eigenvector = ARRAY [1..NM] OF real;
00063      1  0    eigenwork   = ARRAY [1..6,1..NM] OF real;
00064      1  0 VAR
00065      1  0    i,j,k,row      : integer;
00066      1  0    n,ierr         : integer;
00067      1  0    eps1,s,high    : real;
00068      1  0    oldgain,dif    : longreal;
00069      1  0    temp           : longreal;
00070      1  0    a,b            : eigenmatrix;
00071      1  0    alfr,alfi,beta : eigenvector;
00072      1  0    rwk1,rwk2      : eigenvector;
00073      1  0    rwk3           : eigenwork;
00074      1  0    un             : upoly;
00075      1  0    cd             : cpoly;
00076   C  1  0 {------------------------------}
00077      2  0 PROCEDURE ezgval (    nm    : integer;
00078      2  0                       n     : integer;
00079      2  0                   VAR a     : eigenmatrix;
00080      2  0                   VAR b     : eigenmatrix;
00081      2  0                       eps1  : real;
00082      2  0                   VAR alfr  : eigenvector;
00083      2  0                   VAR alfi  : eigenvector;
00084      2  0                   VAR beta  : eigenvector;
00085      2  0                   VAR rwk1  : eigenvector;
00086      2  0                   VAR rwk2  : eigenvector;
00087      2  0                   VAR rwk3  : eigenwork;
00088      1  0                   VAR ierr  : integer);    EXTERN;
00089   C  1  0 {------------------------------}
00090      2  0 PROCEDURE addinupoly (VAR u : upoly; row,colbase,last,base : integer);
00091      2  0 VAR
00092      2  0    k : integer;
00093      2  1 BEGIN
00094   C  2  1 { NOTE TO SWITCH INDEX ORDER FOR FORTRAN }
00095      2  1 FOR k := 0 TO u.deg DO
00096      2  1    IF k+1 <= last-base
00097      2  1     THEN a[colbase+k+1,row] := u.c[k]
00098      2  1     ELSE b[colbase+k,row] := u.c[k];
00099      1  0 END;
00100   C  1  0 {------------------------------}
00101      1  1 BEGIN
00102   C  1  1 { FINISH OFF MATRICES }
00103      1  1 un.deg := 0;
00104      1  1 un.c[0] := 0;
00105      1  1 cd.deg := 0;
00106      1  1 QZadd (un,cd);
00107      1  1 
00108   C  1  1 { PREPARE a AND b MATRICES, AND n, in ROW-COLUMN order }
00109      1  1 FOR i := 1 TO NM DO
00110      1  1    FOR j := 1 TO NM DO

QZ                                                              23-Dec-1988 10:43:01    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  25-Jan-1988 11:05:24    DUA1:[QPLOT.INCA.SOURCE]QZ.PAS;79 (1)

-LINE-IDC-PL-SL-

00111      1  1       BEGIN  a[i,j] := 0;  b[i,j] := 0;  END;
00112      1  1 
00113      1  1 WITH qzinput DO
00114      1  1    FOR i := 1 TO qzinput.count DO 
00115      1  2       BEGIN
00116      1  2       FOR k := 1 TO data[i].de^.deg-1 DO
00117      1  3          BEGIN
00118   C  1  3          { NOTE TO SWITCH INDEX ORDER FOR FORTRAN }
00119      1  3          b[data[i].base+k, data[i].base+k] := -1;
00120      1  3          a[data[i].base+k+1, data[i].base+k] := 1;
00121      1  2          END;
00122      1  2       FOR j := 1 TO count DO
00123      1  2          IF i = j
00124      1  2           THEN
00125      1  2          ELSE IF i = count 
00126      1  2           THEN addinupoly (data[j].nu^, data[i].last, data[j].base,
00127      1  2                                         data[j].last, data[j].base)
00128      1  2           ELSE addinupoly (data[j].de^, data[i].last, data[j].base,
00129      1  2                                         data[j].last, data[j].base);
00130      1  1       END;
00131      1  1 n := qzinput.data[qzinput.count].last;
00132      1  1 eps1 := 0;
00133      1  1 
00134   C  1  1 { USE SAMSAN QZ ROUTINE }
00135      1  1 ezgval (NM,n,a,b,eps1,alfr,alfi,beta,rwk1,rwk2,rwk3,ierr);
00136      1  1 
00137      1  1 fd := qzinput.denom^;
00138      1  1 high := 0;
00139      1  1 FOR i := 1 TO fd.deg DO
00140      1  1    high := rmax (high, cabs(fd.f[i]));
00141      1  1 IF high = 0 THEN high := BIG * nearness;
00142      1  1 
00143   C  1  1 { STORE RESULTS IN FN }
00144      1  1 IF ierr <> 0 THEN raise ('QZ: Algorithm failed');
00145      1  1 fn.deg := 0;
00146      1  1 FOR i := 1 TO n DO
00147      1  1    IF beta[i] <> 0
00148      1  1     THEN
00149      1  2      BEGIN
00150      1  2      fn.deg := fn.deg + 1;
00151      1  2      fn.f[fn.deg].re := alfr[i]/beta[i];
00152      1  2      fn.f[fn.deg].im := alfi[i]/beta[i];
00153      1  2      fn.p[fn.deg] := 1;
00154      1  2      IF cabs(fn.f[fn.deg]) > high / nearness THEN fn.deg := fn.deg - 1;
00155      1  1      END;
00156      1  1 cpolynorm (fn);
00157      1  1 
00158   C  1  1 { CALCULATE GAIN }
00159      1  1 k := 0;
00160      1  1 s := 1;
00161      1  1 FOR i := 1 TO fn.deg DO
00162      1  2    BEGIN
00163      1  2    k := k + 1;
00164      1  2    s := s + abs (fn.f[i].re);
00165      1  1    END;

QZ                                                              23-Dec-1988 10:43:01    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  25-Jan-1988 11:05:24    DUA1:[QPLOT.INCA.SOURCE]QZ.PAS;79 (1)

-LINE-IDC-PL-SL-

00166      1  1 IF k = 0
00167      1  1  THEN s := PI
00168      1  1  ELSE s := s / k;
00169      1  1 IF s = 0 THEN s := 1;
00170      1  1 oldgain := 0;
00171      1  1 k := 0;
00172      1  2 REPEAT
00173      1  2    k := k + 1;
00174      1  2    gain := 0;
00175      1  2    WITH qzinput DO
00176      1  2       FOR i := 1 TO qzinput.count-1 DO 
00177      1  3          BEGIN
00178      1  3          temp := upolyeval (data[i].de^,s);
00179      1  3          IF temp <> 0
00180      1  3           THEN gain := gain + upolyeval (data[i].nu^,s) / temp
00181      1  3           ELSE gain := UNDEFINED_LONGREAL;
00182      1  2          END;
00183      1  2    gain := gain / (cpolyeval (fn,s) / cpolyeval (fd,s));
00184      1  2    dif := gain - oldgain;
00185      1  2    s := - s * PI / 2;
00186      1  2    IF abs(s) > 1E15 THEN raise ('QZRESULT: Unable to determine gain');
00187      1  2    oldgain := gain;
00188      1  1    UNTIL (k >= 2) AND (dif < nearness) AND (gain <> UNDEFINED_LONGREAL);
00189      0  0 END;
00190   C  0  0 {=============================================================================}
00191      0  0 END.

QZ                                                              23-Dec-1988 10:43:01    VAX Pascal V3.7-254                Page    5
INCA                            Pascal Compilation Statistics   25-Jan-1988 11:05:24    DUA1:[QPLOT.INCA.SOURCE]QZ.PAS;79 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                2150  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               1928  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        31        25
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         6        10
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         6        10
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         3         4
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        40        25



FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:GENERAL',
00005      0  0                'QLIBHOME:IO',
00006      0  0                'QLIBHOME:MATH',
00007      0  0                'QLIBHOME:STRING',
00008      0  0                'QLIBHOME:COMPLEX',
00009      0  0                'QZ','POLYMATH','LONGREAL'), 
00010      0  0   ENVIRONMENT ('FCN')]
00011      0  0 MODULE fcnmath;
00012   C  0  0 { Purpose -- This module defines the fcn and project data types.  }
00013      0  0 CONST
00014      0  0    DYN_LENGTH   = 500;
00015      0  0    MAXPFEDEG    = 60;
00016      0  0 TYPE
00017      0  0    pfe_term     = RECORD
00018      0  0                   v       : complex;
00019      0  0                   f       : complex;
00020      0  0                   p       : integer;
00021      0  0                   END;
00022      0  0    pfepoly      = RECORD
00023      0  0                   deg     : integer;
00024      0  0                   t       : ARRAY [1..MAXPFEDEG] OF pfe_term;
00025      0  0                   END;
00026      0  0 TYPE
00027      0  0    fcntype_type = (FCT,DYN,PAR);
00028      0  0    fcnlink      = ^fcn;
00029      0  0    fcn          = RECORD
00030      0  0                   storage : integer;               { SPACE ALLOCATED }
00031      0  0                   nextfcn : fcnlink;               { NEXT FUNCTION   }
00032      0  0                   name    : logicalname;           { FUNCTION NAME   }
00033      0  0                   time    : VARYING [24] OF char;  { LAST MODIFIED   }
00034      0  0                   comment : VARYING [80] OF char;  { DOCUMENTATION   }
00035   C  0  0                   {---------------------------------------------------------}
00036      0  0                   CASE fcntype : fcntype_type OF
00037      0  0                      FCT:  (plane   : char;       { K,S,Z,W; PLANE OF FUNCTION }
00038      0  0                             tau     : real;       { SAMPLING PERIOD (Z,W ONLY) }
00039      0  0                             gain    : longreal;   { GAIN OF FUNCTION (QUAD PREC}
00040      0  0                             ro      : cspoly);    { NUMERATOR & DENOMINATOR    }
00041      0  0                      PAR:  (filler  : ARRAY [1..9] OF char;    { SAME AS FCT:  }
00042      0  0                             pfe     : pfepoly);   { PARTIAL FRACTION EXPANSION }
00043      0  0                      DYN:  (val     : VARYING [DYN_LENGTH] OF char);
00044      0  0                   END;
00045      0  0 
00046      0  0 VAR
00047      0  0    goodplanes   : VARYING [4] OF char := 'KSZW';
00048      0  0 
00049      0  0    onefcn       : fcn     := (size(fcn),NIL,
00050      0  0                               '1','00:00:00.00  JAN  1 1901','',
00051      0  0                               FCT,'K',UNDEFINED_REAL,1,
00052      0  0                               (0,(MAXDEG OF ((0,0),0))));
00053      0  0    sfcn         : fcn     := (size(fcn),NIL,
00054      0  0                               'S','00:00:00.00  JAN  1 1901','',
00055      0  0                               FCT,'S',UNDEFINED_REAL,1,

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00056      0  0                               (1,(((0,0),1), MAXDEG-1 OF ((0,0),0))));
00057      0  0    zfcn         : fcn     := (size(fcn),NIL,
00058      0  0                               'Z','00:00:00.00  JAN  1 1901','',
00059      0  0                               FCT,'Z',UNDEFINED_REAL,1,
00060      0  0                               (1,(((0,0),1), MAXDEG-1 OF ((0,0),0))));
00061      0  0    wfcn         : fcn     := (size(fcn),NIL,
00062      0  0                               'W','00:00:00.00  JAN  1 1901','',
00063      0  0                               FCT,'W',UNDEFINED_REAL,1,
00064      0  0                               (1,(((0,0),1), MAXDEG-1 OF ((0,0),0))));
00065      0  0 
00066      0  0 VAR
00067      0  0    project      : logicalname := 'BLANK';
00068      0  0    endoffcnget  : boolean;
00069      0  0    endoftrashget: boolean;
00070      0  0 
00071      0  0 [ HIDDEN ] CONST
00072      0  0    LISTLIM      = 500;
00073      0  0    TRASHLIM     = 10;
00074      0  0 [ HIDDEN ] VAR
00075      0  0    list         : RECORD
00076      0  0                   count     : integer;
00077      0  0                   ptr       : integer;
00078      0  0                   data      : ARRAY [1..LISTLIM] OF fcnlink;
00079      0  0                   END
00080      0  0                   := (0,0,(LISTLIM OF NIL));
00081      0  0    trash        : RECORD
00082      0  0                   count     : integer;
00083      0  0                   ptr       : integer;
00084      0  0                   data      : ARRAY [1..TRASHLIM] OF fcnlink;
00085      0  0                   END
00086      0  0                   := (0,0,(TRASHLIM OF NIL));
00087      0  0 
00088      0  0 VAR
00089      0  0    QZaddcutoff  : integer  := 5;
00090      0  0 [ HIDDEN ] VAR
00091      0  0    fcnqzinput   : RECORD
00092      0  0                   plane    : char;
00093      0  0                   tau      : real;
00094      0  0                   END;
00095   C  0  0 {=============================================================================}
00096      0  0 [ EXTERNAL ]
00097      1  0 FUNCTION evalfcn (string : VARYING [l1] OF char) : fcn;
00098      0  0 EXTERN;
00099   C  0  0 {=============================================================================}
00100   C  0  0 {-- FUNCTION MATH SUBMODULE --------------------------------------------------}
00101   C  0  0 {=============================================================================}
00102      1  0 FUNCTION addplane (plane1,plane2 : char) : char;
00103   C  1  0 { Purpose -- "Add" two planes and generate error if inconsistent }
00104      1  0 VAR
00105      1  0    plane : char;
00106      1  1 BEGIN
00107      1  1 IF (index (goodplanes,plane1) = 0) OR (index (goodplanes,plane2) = 0)
00108      1  1  THEN plane := 'E'
00109      1  1 ELSE IF plane1='K'
00110      1  1  THEN plane := plane2

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00111      1  1 ELSE IF plane2='K'
00112      1  1  THEN plane := plane1
00113      1  1 ELSE IF plane1 = plane2
00114      1  1  THEN plane := plane1
00115      1  1  ELSE plane := 'E';
00116      1  1 IF plane = 'E' THEN raise ('FCN : Mixed plane operation');
00117      1  1 addplane := plane;
00118      0  0 END;
00119   C  0  0 {-----------------------------------------------------------------------------}
00120      1  0 FUNCTION addtau (tau1,tau2 : real) : real;
00121   C  1  0 { Purpose -- "Add" two tau values and generate error if inconsistent }
00122      1  0 VAR
00123      1  0    tau : real;
00124      1  1 BEGIN
00125      1  1 IF tau1 = UNDEFINED_REAL
00126      1  1  THEN tau := tau2
00127      1  1 ELSE IF tau2 = UNDEFINED_REAL
00128      1  1  THEN tau := tau1
00129      1  1 ELSE IF (tau1 - tau2) / (tau1 + tau2) < nearness
00130      1  1  THEN tau := tau1
00131      1  1  ELSE raise ('FCN : "Z" or "W" plane functions have different sampling period');
00132      1  1 addtau := tau;
00133      0  0 END;
00134   C  0  0 {-----------------------------------------------------------------------------}
00135      1  0 PROCEDURE fcnnorm (VAR fn : fcn);
00136   C  1  0 { Purpose -- Normalize a function by collecting and canceling like factors. }
00137      1  0 VAR
00138      1  0    i,j             : integer;
00139      1  0    biggest,nextbig : real;
00140      1  0    cgain           : complex;
00141      1  0    l               : longreal;
00142      1  0    temp            : logicalname;
00143      1  1 BEGIN
00144      1  1 IF length (fn.time) <> 24 THEN fn.time := strtime;
00145      1  1 
00146      1  2 CASE fn.fcntype OF
00147      1  3    FCT:  BEGIN
00148   C  1  3          { CHECK FOR VERY LARGE ROOTS }
00149      1  3          biggest := 0;
00150      1  3          nextbig := 0;
00151      1  3          FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00152      1  3          IF cabs (v) >= biggest THEN biggest := cabs(v);  
00153      1  3          FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00154      1  3             IF (cabs(v) >= nextbig) AND (cabs(v) <> biggest) 
00155      1  3              THEN nextbig := cabs(v);  
00156      1  3  
00157      1  3          IF nextbig <> 0 THEN IF biggest/nextbig > 1/nearness
00158      1  3           THEN
00159      1  3            FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00160      1  3               IF cabs(v) = biggest 
00161      1  3                THEN 
00162      1  4                 BEGIN
00163      1  4                 IF v.im = 0
00164      1  4                  THEN l := v.re
00165      1  4                  ELSE l := cabssq (v);

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00166      1  4                 fn.gain := fn.gain * l ** p;
00167      1  4                 p := 0;
00168      1  3                 END;   
00169      1  3 
00170   C  1  3          { NOW WE EXAMINE POLYNOMIALS FOR BAD PAIRS }
00171      1  3          cspolynorm (fn.ro);
00172      1  3 
00173   C  1  3          { NOW WE EXAMINE PLANE OF FUNCTION }
00174      1  3          fn.plane := addplane (fn.plane,'K');
00175      1  3          IF fn.gain = 0           THEN fn.ro.deg := 0;
00176      1  3          IF fn.ro.deg = 0         THEN fn.plane := 'K';
00177      1  3          IF (fn.plane = 'K') AND (fn.ro.deg <> 0) THEN fn.plane := 'S';
00178      1  3          IF fn.plane IN ['K','S'] THEN fn.tau := UNDEFINED_REAL;
00179      1  3          fn.storage := size(fcn,FCT) 
00180      1  3                            - (MAXDEG - fn.ro.deg) * size(cspolyfactor);
00181      1  2          END;
00182      1  3    PAR:  BEGIN
00183      1  3          fn.storage := size(fcn,PAR) 
00184      1  3                            - (MAXPFEDEG - fn.pfe.deg) * size(pfe_term);
00185      1  3          fn.plane := addplane (fn.plane,'K');
00186      1  3          IF fn.gain = 0           THEN fn.ro.deg := 0;
00187      1  3          IF fn.pfe.deg = 0        THEN fn.plane := 'K';
00188      1  3          IF (fn.plane = 'K') AND (fn.pfe.deg <> 0) THEN fn.plane := 'S';
00189      1  3          IF fn.plane IN ['K','S'] THEN fn.tau := UNDEFINED_REAL;
00190      1  2          END;
00191      1  2    DYN:  fn.storage := size(fcn,DYN) - (DYN_LENGTH - length (fn.val));
00192      1  2    OTHERWISE fn.storage := size(fcn);
00193      1  1    END;
00194      0  0 END;
00195   C  0  0 {-----------------------------------------------------------------------------}
00196      1  0 PROCEDURE fcnmakeheader (VAR fn : fcn);
00197   C  1  0 { Purpose -- Give a function a dummy header }
00198      1  1 BEGIN
00199      1  1 fn.nextfcn := NIL;
00200      1  1 fn.time    := strtime;
00201      1  1 fn.name    := 'TEMP';
00202      1  1 fn.comment := '';
00203      1  1 fn.fcntype := FCT;
00204      0  0 END;
00205   C  0  0 {-----------------------------------------------------------------------------}
00206      1  0 FUNCTION numord (VAR fn : fcn) : integer;
00207      1  0 VAR
00208      1  0    i,fout : integer;
00209      1  1 BEGIN
00210      1  1 IF fn.fcntype <> FCT THEN raise ('NUMORD: Function not of factored type');
00211      1  1 fout := 0;
00212      1  1 FOR i := 1 TO fn.ro.deg DO
00213      1  1    WITH fn.ro.f[i] DO
00214      1  1       IF p <= 0
00215      1  1        THEN
00216      1  1       ELSE IF v.im = 0
00217      1  1        THEN fout := fout + p
00218      1  1        ELSE fout := fout + p*2;
00219      1  1 numord := fout;
00220      0  0 END;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00221   C  0  0 {-----------------------------------------------------------------------------}
00222      1  0 FUNCTION denord (VAR fn : fcn) : integer;
00223      1  0 VAR
00224      1  0    i,fout : integer;
00225      1  1 BEGIN
00226      1  1 IF fn.fcntype <> FCT THEN raise ('DENORD: Function not of factored type');
00227      1  1 fout := 0;
00228      1  1 FOR i := 1 TO fn.ro.deg DO
00229      1  1    WITH fn.ro.f[i] DO
00230      1  1       IF p >= 0
00231      1  1        THEN
00232      1  1       ELSE IF v.im = 0
00233      1  1        THEN fout := fout - p
00234      1  1        ELSE fout := fout - p*2;
00235      1  1 denord := fout;
00236      0  0 END;
00237   C  0  0 {-----------------------------------------------------------------------------}
00238      1  0 FUNCTION fcnofr (r : real) : fcn;
00239   C  1  0 { Purpose -- Make constant fcn from real number }
00240      1  0 VAR
00241      1  0    fout     : fcn;
00242      1  1 BEGIN
00243      1  1 fout := onefcn;
00244      1  1 fout.gain := r;
00245      1  1 fcnmakeheader (fout);
00246      1  1 fcnofr := fout;
00247      0  0 END;
00248   C  0  0 {-----------------------------------------------------------------------------}
00249      1  0 FUNCTION roffcn (fn : fcn) : real;
00250   C  1  0 { Purpose -- real number form constant fcn }
00251      1  1 BEGIN
00252      1  1 IF fn.fcntype <> FCT THEN raise ('ROFFCN : Function not of factored type');
00253      1  1 IF fn.plane <> 'K' THEN raise ('ROFFCN : Function not a constant function');
00254      1  1 roffcn := dble (fn.gain);
00255      0  0 END;
00256   C  0  0 {=============================================================================}
00257   C  0  0 {-- FUNCTION ARITHMETIC PROCEDURES -------------------------------------------}
00258   C  0  0 {=============================================================================}
00259      1  0 FUNCTION fcnadd (f1,f2 : fcn) : fcn;
00260   C  1  0 { Purpose -- Add two functions }
00261      1  0 VAR
00262      1  0    n,n1,n2  : cpoly;
00263      1  0    d,d1,d2  : cpoly;
00264      1  0    u1,u2    : upoly;
00265      1  0    fout     : fcn;
00266      1  1 BEGIN
00267      1  1 IF f1.fcntype <> FCT THEN raise ('FCNADD: Function 1 not in factored form');
00268      1  1 IF f2.fcntype <> FCT THEN raise ('FCNADD: Function 2 not in factored form');
00269      1  1 IF f1.gain = 0
00270      1  1  THEN fout := f2
00271      1  1 ELSE IF f2.gain = 0
00272      1  1  THEN fout := f1
00273      1  1  ELSE
00274      1  2   BEGIN
00275      1  2   cpolysfromcspoly (n1,d1,f1.ro);

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00276      1  2   cpolysfromcspoly (n2,d2,f2.ro);
00277      1  2   d := cpolymul (d1,d2);
00278      1  2   upolyfromcpoly (u1,cpolymul (n1,d2),f1.gain);
00279      1  2   upolyfromcpoly (u2,cpolymul (n2,d1),f2.gain);
00280      1  2   cpolyfromupoly (n,fout.gain,upolyadd (u1,u2));
00281      1  2   cspolyfromcpolys (fout.ro,n,d);
00282      1  1   END;
00283      1  1 fout.plane := addplane (f1.plane,f2.plane);
00284      1  1 fout.tau   := addtau   (f1.tau,f2.tau);
00285      1  1 fcnmakeheader (fout);
00286      1  1 fcnnorm (fout);
00287      1  1 fcnadd := fout;
00288      0  0 END;
00289   C  0  0 {-----------------------------------------------------------------------------}
00290      1  0 FUNCTION fcnsub (f1,f2 : fcn) : fcn;
00291   C  1  0 { Purpose -- Subtract two functions }
00292      1  1 BEGIN
00293      1  1 IF f1.fcntype <> FCT THEN raise ('FCNSUB: Function 1 not in factored form');
00294      1  1 IF f2.fcntype <> FCT THEN raise ('FCNSUB: Function 2 not in factored form');
00295      1  1 f2.gain := -f2.gain;
00296      1  1 fcnsub := fcnadd (f1,f2);
00297      0  0 END;
00298   C  0  0 {-----------------------------------------------------------------------------}
00299      1  0 FUNCTION fcnmul (f1,f2 : fcn) : fcn;
00300   C  1  0 { Purpose -- Multiply two functions }
00301      1  0 VAR
00302      1  0    fout : fcn;
00303      1  1 BEGIN
00304      1  1 IF f1.fcntype <> FCT THEN raise ('FCNMUL: Function 1 not in factored form');
00305      1  1 IF f2.fcntype <> FCT THEN raise ('FCNMUL: Function 2 not in factored form');
00306      1  1 fout.ro      := cspolymul (f1.ro,f2.ro);
00307      1  1 fout.gain := f1.gain * f2.gain;
00308      1  1 fout.plane := addplane (f1.plane,f2.plane);
00309      1  1 fout.tau   := addtau   (f1.tau,f2.tau);
00310      1  1 fcnmakeheader (fout);
00311      1  1 fcnnorm (fout);
00312      1  1 fcnmul := fout;
00313      0  0 END;
00314   C  0  0 {-----------------------------------------------------------------------------}
00315      1  0 FUNCTION fcndiv (f1,f2 : fcn) : fcn;
00316   C  1  0 { Purpose -- Divide two functions }
00317      1  0 VAR
00318      1  0    fout : fcn;
00319      1  1 BEGIN
00320      1  1 IF f1.fcntype <> FCT THEN raise ('FCNDIV: Function 1 not in factored form');
00321      1  1 IF f2.fcntype <> FCT THEN raise ('FCNDIV: Function 2 not in factored form');
00322      1  1 fout.ro    := cspolydiv (f1.ro,f2.ro);
00323      1  1 fout.gain  := f1.gain / f2.gain;
00324      1  1 fout.plane := addplane (f1.plane,f2.plane);
00325      1  1 fout.tau   := addtau   (f1.tau,f2.tau);
00326      1  1 fcnmakeheader (fout);
00327      1  1 fcnnorm (fout);
00328      1  1 fcndiv := fout;
00329      0  0 END;
00330   C  0  0 {-----------------------------------------------------------------------------}

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00331      1  0 FUNCTION fcncloop (fc,fp,ff : fcn) : fcn;
00332   C  1  0 { Purpose -- Computation of closed loop transfer function:               }
00333   C  1  0 {            fout := (fc * fp) / (1 + (fc * fp * ff) )                   }
00334   C  1  0 {                                                                        }
00335   C  1  0 {                           (fc.nu * fp.nu * ff.de)                      }
00336   C  1  0 {  fout =     -------------------------------------------------          }
00337   C  1  0 {             (fc.de * fp.de * ff.de) + (fc.nu * fp.nu * ff.nu)          }
00338      1  0 VAR
00339      1  0     fcnu,fcde    : cpoly;
00340      1  0     fpnu,fpde    : cpoly;
00341      1  0     ffnu,ffde    : cpoly;
00342      1  0     fonu,fode    : cpoly;
00343      1  0     u1,u2        : upoly;
00344      1  0     t1           : cpoly;
00345      1  0     nugain,degain: longreal;
00346      1  0     fout         : fcn;
00347      1  1 BEGIN
00348      1  1 IF fc.fcntype <> FCT THEN raise ('FCNCLOOP: Function c not in factored form');
00349      1  1 IF fp.fcntype <> FCT THEN raise ('FCNCLOOP: Function p not in factored form');
00350      1  1 IF ff.fcntype <> FCT THEN raise ('FCNCLOOP: Function f not in factored form');
00351   C  1  1 { CONSTRUCT CPOLYS }
00352      1  1 cpolysfromcspoly (fcnu,fcde,fc.ro);
00353      1  1 cpolysfromcspoly (fpnu,fpde,fp.ro);
00354      1  1 cpolysfromcspoly (ffnu,ffde,ff.ro);
00355      1  1 
00356   C  1  1 { CONSTRUCT NUMERATOR   }
00357      1  1 nugain := fc.gain * fp.gain;
00358      1  1 fonu := cpolymul (cpolymul (fcnu,fpnu), ffde);
00359      1  1 
00360   C  1  1 { CONSTRUCT DENOMINATOR }
00361      1  1 t1 := cpolymul (cpolymul (fcnu,fpnu), ffnu);
00362      1  1 upolyfromcpoly (u1,t1,fc.gain * fp.gain * ff.gain);
00363      1  1 t1 := cpolymul (cpolymul (fcde,fpde), ffde);
00364      1  1 upolyfromcpoly (u2,t1,1);
00365      1  1 cpolyfromupoly (fode, degain, upolyadd (u1,u2) );
00366      1  1   
00367      1  1 cspolyfromcpolys (fout.ro,fonu,fode);
00368      1  1 fout.gain := nugain / degain;
00369      1  1 fout.plane := addplane (addplane(fc.plane,fp.plane), ff.plane);
00370      1  1 fout.tau   := addtau   (addtau  (fc.tau  ,fp.tau  ), ff.tau  );
00371      1  1 fcnmakeheader (fout);
00372      1  1 fcnnorm (fout);
00373      1  1 fcncloop := fout;
00374      0  0 END;
00375   C  0  0 {-----------------------------------------------------------------------------}
00376      1  0 PROCEDURE fcnQZclear;
00377      1  1 BEGIN
00378      1  1 QZclear;
00379      1  1 WITH fcnqzinput DO
00380      1  2    BEGIN
00381      1  2    plane   := 'K';
00382      1  2    tau     := UNDEFINED_REAL;
00383      1  1    END;
00384      0  0 END;
00385   C  0  0 {-----------------------------------------------------------------------------}

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00386      1  0 PROCEDURE fcnQZadd (fn : fcn);
00387      1  0 VAR
00388      1  0    nu,de : cpoly;
00389      1  0    un,ud : upoly;
00390      1  1 BEGIN
00391      1  1 IF fn.fcntype <> FCT THEN raise ('FCNQZADD: Function not in factored form');
00392      1  1 cpolysfromcspoly (nu,de,fn.ro);
00393      1  1 upolyfromcpoly (un,nu,fn.gain);
00394      1  1 QZadd (un,de);
00395      1  1 WITH fcnqzinput DO
00396      1  2    BEGIN
00397      1  2    plane  := addplane (plane,fn.plane);
00398      1  2    tau    := addtau   (tau,fn.tau);
00399      1  1    END;
00400      0  0 END;
00401   C  0  0 {-----------------------------------------------------------------------------}
00402      1  0 FUNCTION fcnQZresult : fcn;
00403      1  0 VAR
00404      1  0    i     : integer;
00405      1  0    fout  : fcn;
00406      1  0    nu,de : cpoly;
00407      1  1 BEGIN
00408      1  1 WITH fcnqzinput DO
00409      1  2    BEGIN
00410      1  2    fout.gain  := 1;
00411      1  2    fout.plane := plane;
00412      1  2    fout.tau   := tau;
00413      1  2    QZresult (fout.gain,nu,de);
00414      1  2    cspolyfromcpolys (fout.ro,nu,de);
00415      1  1    END;
00416      1  1 fcnmakeheader (fout);
00417      1  1 fcnnorm (fout);
00418      1  1 fcnQZresult := fout;
00419      0  0 END;
00420   C  0  0 {=============================================================================}
00421   C  0  0 {-- CONVERSION SUBMODULE -----------------------------------------------------}
00422   C  0  0 {=============================================================================}
00423      1  0 FUNCTION bodefcnofnumfcn (fn : fcn) : fcn;
00424      1  0 VAR
00425      1  0    i   : integer;
00426      1  0    l   : longreal;
00427      1  1 BEGIN
00428      1  1 IF fn.fcntype <> FCT 
00429      1  1  THEN raise ('BODEFCNOFNUMFCN: Function not in factored form');
00430      1  1 l := 1;
00431      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00432      1  1    IF v.im <> 0
00433      1  1     THEN l := l * quad(cabssq(v)) ** p
00434      1  1    ELSE IF v.re <> 0
00435      1  1     THEN l := l * quad(v.re) ** p;
00436      1  1 fn.gain := fn.gain * l;
00437      1  1 bodefcnofnumfcn := fn;
00438      0  0 END;
00439   C  0  0 {-----------------------------------------------------------------------------}
00440      1  0 FUNCTION numfcnofbodefcn (fn : fcn) : fcn;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00441      1  0 VAR
00442      1  0    i   : integer;
00443      1  0    l   : longreal;
00444      1  1 BEGIN
00445      1  1 IF fn.fcntype <> FCT 
00446      1  1  THEN raise ('NUMFCNOFBODEFCN: Function not in factored form');
00447      1  1 l := 1;
00448      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00449      1  1    IF v.im <> 0
00450      1  1     THEN l := l * quad(cabssq(v)) ** p
00451      1  1    ELSE IF v.re <> 0
00452      1  1     THEN l := l * quad(v.re) ** p;
00453      1  1 fn.gain := fn.gain / l;
00454      1  1 numfcnofbodefcn := fn;
00455      0  0 END;
00456   C  0  0 {=============================================================================}
00457   C  0  0 {-- TYPE CONVERSION SUBMODULE ------------------------------------------------}
00458   C  0  0 {=============================================================================}
00459      1  0 FUNCTION fcnPARofFCT (fn : fcn) : fcn;
00460   C  1  0 { Purpose -- Compute partial fraction expansion of function FN.       }
00461   C  1  0 {            The numerators only are calculated.  The denominator     }
00462   C  1  0 {            is assumed to be in the standard form.                   }
00463      1  0 VAR
00464      1  0     jj,i,j,k   : integer;
00465      1  0     cnu,cde    : cpoly;
00466      1  0     cgain      : longreal;
00467      1  0     fnnu,fnde  : cpoly;
00468      1  0     g0,fk,fr,fl: cupoly;
00469      1  0     fout       : fcn;
00470      1  1 BEGIN
00471      1  1 IF fn.fcntype <> FCT 
00472      1  1  THEN raise ('FCNPAROFFCT: Function not in factored form');
00473      1  1 cpolysfromcspoly (fnnu,fnde,fn.ro);
00474      1  1 fout := fn;
00475      1  1 fout.fcntype := PAR;
00476      1  1 fout.pfe.deg := 0;
00477      1  1 IF (denord (fn) <= numord (fn)) AND (numord (fn) > 0)
00478      1  1  THEN raise ('FCNPAROFFCT: Numerator order >= denominator order');
00479      1  1 FOR jj := 1 TO fnde.deg DO
00480      1  2    BEGIN
00481      1  2    cgain := fn.gain;
00482      1  2    cnu := fnnu;
00483      1  2    cde := fnde;
00484      1  2    cde.p[jj] := 0;
00485      1  2    FOR i := 1 TO cnu.deg DO cnu.f[i] := csub (cnu.f[i],fnde.f[jj]);
00486      1  2    FOR i := 1 TO cde.deg DO cde.f[i] := csub (cde.f[i],fnde.f[jj]);
00487      1  2    cupolyfromcpoly (fk,cnu,cgain);
00488      1  2    cupolyfromcpoly (g0,cde,1.0);
00489      1  2    FOR k := 0 TO fnde.p[jj]-1 DO
00490      1  3       BEGIN
00491      1  3       fout.pfe.t[fout.pfe.deg+k+1].v := cdiv (fk.c[0], cpower (g0.c[0],k+1));
00492      1  3       fout.pfe.t[fout.pfe.deg+k+1].f := fnde.f[jj];
00493      1  3       fout.pfe.t[fout.pfe.deg+k+1].p := fnde.p[jj]-k;
00494      1  3       IF k <> fnde.p[jj]-1
00495      1  3        THEN

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00496      1  4         BEGIN
00497      1  4         fk.deg := imin (fk.deg,fnde.p[jj]-k-1);
00498      1  4         g0.deg := imin (g0.deg,fnde.p[jj]-k-1);
00499      1  4         fl := cupolymul (cupolyderiv(fk), g0);
00500      1  4         FOR i := 0 TO fl.deg DO fl.c[i] := cdiv (fl.c[i], cofi(k+1));
00501      1  4         fr := cupolymul (fk, cupolyderiv (g0));
00502      1  4         fk := cupolysub (fl,fr);
00503      1  3         END;
00504      1  2       END;
00505      1  2    fout.pfe.deg := fout.pfe.deg + fnde.p[jj];
00506      1  1    END;
00507      1  1 fcnnorm (fout);
00508      1  1 fcnPARofFCT := fout;
00509      0  0 END;
00510   C  0  0 {-----------------------------------------------------------------------------}
00511      1  0 FUNCTION fcnFCTofDYN (fn : fcn) : fcn;  
00512   C  1  0 { Purpose -- Convert a dynamic function to static form.  }
00513      1  0 VAR
00514      1  0    fout,temp : fcn;
00515      1  1 BEGIN
00516      1  1 IF fn.fcntype <> DYN THEN raise ('FCNFCTOFDYN: Function not dynamic');
00517      1  1 temp := evalfcn (fn.val);
00518      1  1 fout         := fn;
00519      1  1 fout.fcntype := FCT;
00520      1  1 fout.plane   := temp.plane;
00521      1  1 fout.gain    := temp.gain;
00522      1  1 fout.tau     := temp.tau;
00523      1  1 fout.ro      := temp.ro;
00524      1  1 fcnnorm (fout);
00525      1  1 fcnFCTofDYN := fout;
00526      0  0 END;
00527   C  0  0 {-----------------------------------------------------------------------------}
00528      1  0 FUNCTION fcnFCTofPAR (fn : fcn) : fcn;  
00529      1  0 VAR
00530      1  0    i,j        : integer;
00531      1  0    fout       : fcn;
00532      1  0    un,ut,ucd  : upoly;
00533      1  0    fd,ftemp   : cpoly;
00534      1  0    nu,de      : cpoly;
00535   C  1  0 {------------------------------}
00536      2  0 PROCEDURE addfactortofd (f : complex;  p : integer);
00537      2  1 BEGIN
00538      2  1 fd.deg := fd.deg + 1;
00539      2  1 fd.f[fd.deg] := f;
00540      2  1 fd.p[fd.deg] := p;
00541      1  0 END;
00542   C  1  0 {------------------------------}
00543      1  1 BEGIN
00544      1  1 IF fn.fcntype <> PAR THEN raise ('FCNFCTOFPAR: Function not PAR format');
00545      1  1 
00546      1  1 QZclear;
00547      1  1 un.deg := 0;
00548      1  1 un.c[0] := 0;
00549      1  1 fd.deg := 0;
00550      1  1 FOR i := 1 TO fn.pfe.deg DO

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00551      1  1    WITH fn.pfe.t[i] DO
00552      1  1       IF f.im >= 0
00553      1  1        THEN
00554      1  2         BEGIN
00555      1  2 
00556   C  1  2         { LOAD DENOMINATOR IF FIRST OF GROUP }
00557      1  2         IF fd.deg = 0
00558      1  2          THEN 
00559      1  3           BEGIN  
00560      1  3           addfactortofd (f,p);
00561      1  3           IF f.im > 0 THEN addfactortofd (ccnj(f),p);
00562      1  2           END;
00563      1  2 
00564   C  1  2         { INCREMENT NUMERATOR }
00565      1  2         ftemp := fd;
00566      1  2         FOR j := 1 TO ftemp.deg DO ftemp.p[j] := ftemp.p[j] - p;
00567      1  2         upolyfromcpoly (ucd,ftemp,1);
00568      1  3         CASE fd.deg OF
00569      1  4            1:  BEGIN
00570      1  4                ut.deg := 0;
00571      1  4                ut.c[0] := v.re;
00572      1  3                END;
00573      1  4            2:  BEGIN
00574      1  4                ut.deg := 1;
00575      1  4                ut.c[1] := 2 * v.re;
00576      1  4                ut.c[0] := 2 * (v.re * f.re + v.im * f.im);
00577      1  3                END;
00578      1  2            END;
00579      1  2         un := upolyadd (un, upolymul (ut,ucd));
00580      1  2 
00581   C  1  2         { CALL QZadd IF LAST OF GROUP }
00582      1  2         IF p = 1 
00583      1  2          THEN 
00584      1  3           BEGIN
00585      1  3           QZadd (un,fd);
00586      1  3           un.deg := 0;
00587      1  3           un.c[0] := 0;
00588      1  3           fd.deg := 0;
00589      1  2           END;
00590      1  1         END;
00591      1  1 
00592      1  1 fout         := fn;
00593      1  1 fout.fcntype := FCT;
00594      1  1 QZresult (fout.gain,nu,de);
00595      1  1 cspolyfromcpolys (fout.ro,nu,de);
00596      1  1 fcnnorm (fout);
00597      1  1 
00598      1  1 fcnFCTofPAR := fout;
00599      0  0 END;
00600   C  0  0 {-----------------------------------------------------------------------------}
00601      1  0 FUNCTION fcnFCTofany (fn : fcn) : fcn;  
00602   C  1  0 { Purpose -- Convert a function to static form.  }
00603      1  1 BEGIN
00604      1  2 CASE fn.fcntype OF
00605      1  2    FCT:  fcnFCTofany := fn;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00606      1  2    PAR:  fcnFCTofany := fcnFCTofPAR (fn);
00607      1  2    DYN:  fcnFCTofany := fcnFCTofDYN (fn);
00608      1  1    END;
00609      0  0 END;
00610   C  0  0 {=============================================================================}
00611   C  0  0 {-- PLANE CONVERSION SUBMODULE -----------------------------------------------}
00612   C  0  0 {=============================================================================}
00613      1  0 FUNCTION fcnzoffcns (fcns : fcn;  t: real;  zoh: boolean;  delta : real) : fcn;
00614   C  1  0 { Purpose -- Convert function from S plane to Z plane.              }
00615   C  1  0 {            Parameter definitions :                                }
00616   C  1  0 {                t     :  sampling period                           }
00617   C  1  0 {                zoh   :  True if ZOH is required                   }
00618   C  1  0 {                delta :  Advance factor, used for                  }
00619   C  1  0 {                         computational delay                       }
00620      1  0 VAR
00621      1  0    count                        : integer;
00622      1  0    sumn,sumd,termn,termd,cutemp : cupoly;
00623      1  0    i,j,k,kk                     : integer;
00624      1  0    cij,cijk                     : complex;
00625      1  0    fcnsnu,fcnsde                : cpoly;
00626      1  0    fcnznu,fcnzde                : cpoly;
00627      1  0    p,u                          : upoly;
00628      1  0    fcnz,fcnsPAR                 : fcn;
00629   C  1  0 {----------------------------------}
00630      2  0 FUNCTION pjdelta (j : integer;  delta : real) : UPOLY;
00631      2  0 VAR
00632      2  0     jj,k    : integer;
00633      2  0     g       : real;
00634      2  0     p,pold  : upoly;
00635      2  1 BEGIN
00636      2  1 FOR k := 1 TO MAXDEG DO p.c[k] := 0;
00637      2  1 p.c[1] := 1;
00638      2  1 FOR jj := 2 TO j DO
00639      2  2    BEGIN
00640      2  2    pold := p;
00641      2  2    FOR k := 1 TO MAXDEG DO p.c[k] := 0;
00642      2  2    FOR k := 1 TO j-1 DO
00643      2  3       BEGIN
00644      2  3       p.c[k] := p.c[k] + pold.c[k]*(k+delta-1);
00645      2  3       p.c[k+1] := p.c[k+1] + pold.c[k]*k;
00646      2  2       END;
00647      2  1    END;
00648      2  1 pjdelta := p;
00649      1  0 END;
00650   C  1  0 {----------------------------------}
00651      1  1 BEGIN 
00652      1  1 IF fcns.fcntype <> FCT THEN raise ('FCNZOFFCNS: Function not in factored form');
00653      1  1 IF zoh THEN fcns := fcndiv (fcns,sfcn);
00654      1  1 
00655   C  1  1 { INITIALIZE SUM }
00656      1  1 sumn.deg := 0;
00657      1  1 sumn.c[0] := complex(0,0);
00658      1  1 sumd.deg := 0;
00659      1  1 sumd.c[0] := complex(1,0);
00660      1  1 

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00661      1  1 fcnsPAR := fcnPARofFCT (fcns);
00662      1  1 cpolysfromcspoly (fcnsnu,fcnsde,fcns.ro);
00663      1  1 count := 0;
00664      1  1 fcnzde.deg := fcnsde.deg;
00665      1  1 FOR i := 1 TO fcnsde.deg DO
00666      1  2    BEGIN
00667   C  1  2    { COMPUTE fcnzde.f[i] = -exp(-fcnsde.f[i] * t)  }
00668      1  2    fcnzde.f[i] := cneg (cexp ( cmul(cofr(-t),fcnsde.f[i]) ) );
00669      1  2    fcnzde.p[i] := fcnsde.p[i];
00670      1  2 
00671   C  1  2    { COMPUTE termd = (z+fcnzde.f[i])**fcnzde.p[i]  }
00672      1  2    termd := cupolybinomex (fcnzde.f[i],fcnzde.p[i]);
00673      1  2 
00674   C  1  2    { COMPUTE termn = 0  }
00675      1  2    termn.deg := 0;
00676      1  2    termn.c[0] := complex(0,0);
00677      1  2 
00678      1  2    count := count + fcnsde.p[i];
00679      1  2    FOR j := 1 TO fcnsde.p[i] DO
00680      1  3       BEGIN
00681   C  1  3       { COMPUTE Cij = Aij * exp(-fcnsde.f[i]*delta*t) * t**(j-1)/(j-1)!  }
00682      1  3       cij := cexp (cmul (cofr(-delta * t),fcnsde.f[i]) );
00683      1  3       cij := cmul (cij,fcnsPAR.pfe.t[count+1-j].v);
00684      1  3       FOR k := 1 TO j-1 DO 
00685      1  3          cij := cmul (cij,cofr(t/k));
00686      1  3 
00687   C  1  3       { COMPUTE cutemp AND add to termn.  FORMAT IS DIFFERENT WHEN j=1  }
00688      1  3       p := pjdelta (j,delta);
00689      1  3       FOR k := 1 TO j DO
00690      1  4          BEGIN
00691      1  4          cijk := cmul (cofr(p.c[k]),cij);
00692      1  4          FOR kk := 1 TO k-1 DO cijk := cmul (cijk,cneg(fcnzde.f[i]));
00693      1  4          cutemp := cupolybinomex (fcnzde.f[i],fcnzde.p[i]-k);
00694      1  4          FOR kk := 0 TO cutemp.deg DO 
00695      1  4             cutemp.c[kk] := cmul (cutemp.c[kk],cijk);
00696      1  4          termn := cupolyadd (termn,cutemp);
00697      1  3          END;
00698      1  2       END;
00699      1  2    cupolyfractadd (sumn,sumd,sumn,sumd,termn,termd);
00700      1  1    END;
00701      1  1 
00702   C  1  1 { COPY INTO REAL POLYNOMIAL, AS IMAGINARY PARTS SHOULD HAVE VANISHED }
00703      1  1 u.deg := sumn.deg;
00704      1  1 FOR i := 0 TO u.deg DO u.c[i] := sumn.c[i].re;
00705      1  1 
00706      1  1 fcnz.plane := 'Z';
00707      1  1 fcnz.tau   := t;
00708      1  1 cpolyfromupoly (fcnznu, fcnz.gain, u);
00709      1  1 cspolyfromcpolys (fcnz.ro,fcnznu,fcnzde);
00710      1  1 fcnz := fcnmul (fcnz,zfcn);
00711   C  1  1 {  IF WE WANT A ZERO ORDER HOLD, MULTIPLY FCNZ BY (Z-1)/Z  }
00712      1  1 IF zoh
00713      1  1  THEN fcnz := fcnmul (fcnz,fcndiv (fcnsub (zfcn,onefcn),zfcn));
00714      1  1 fcnmakeheader (fcnz);
00715      1  1 fcnnorm (fcnz);

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   14
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00716      1  1 fcnzoffcns := fcnz;
00717      0  0 END;
00718   C  0  0 {-----------------------------------------------------------------------------}
00719      1  0 FUNCTION fcnwoffcnz (fcnz : fcn) : fcn;
00720   C  1  0 { Purpose -- Convert function from Z plane to W plane.              }
00721   C  1  0 {            z = (1+wT/2) / (1-wt/2)                                }
00722      1  0 VAR
00723      1  0    i,j,specord  : integer;
00724      1  0    g            : real;
00725      1  0    l            : longreal;
00726      1  0    fcnw         : fcn;
00727   C  1  0 {------------------------------}
00728      2  0 PROCEDURE getnum (VAR fnew : complex;  VAR pnew : integer;  VAR g : real; 
00729      2  0    f : complex;  p : integer;  tau : real);
00730      2  1 BEGIN
00731      2  1 IF cabs (csub (f,cofi(1))) <> 0
00732      2  1  THEN
00733      2  2   BEGIN
00734      2  2   fnew := cdiv (cmul (cofr(-2d0/tau),cadd (f,cofi(1))), csub (f,cofi(1)));
00735      2  2   fnew.im := abs (fnew.im);
00736      2  2   pnew := p;
00737      2  2   IF fnew.im = 0
00738      2  2    THEN g := f.re - 1
00739      2  2    ELSE g := cabssq (csub (f,cofi(1)));
00740      2  2   END
00741      2  1  ELSE 
00742      2  2   BEGIN
00743      2  2   fnew := cofi(0);
00744      2  2   pnew := 0;
00745      2  2   g := -4/tau;
00746      2  1   END;
00747      1  0 END;
00748   C  1  0 {------------------------------}
00749      1  1 BEGIN 
00750      1  1 IF fcnz.fcntype <> FCT THEN raise ('FCNWOFFCNZ: Function not in factored form');
00751      1  1 l := fcnz.gain;
00752      1  1 specord := 0;
00753      1  1 
00754   C  1  1 { DO ROOTS }
00755      1  1 fcnw.ro.deg := fcnz.ro.deg;
00756      1  1 FOR i := 1 TO fcnz.ro.deg DO 
00757      1  2    BEGIN
00758      1  2    getnum (fcnw.ro.f[i].v,fcnw.ro.f[i].p,g,
00759      1  2            fcnz.ro.f[i].v,fcnz.ro.f[i].p,fcnz.tau);
00760      1  2    l := l * quad(g) ** fcnz.ro.f[i].p;
00761      1  2    specord := specord - fcnz.ro.f[i].p;
00762      1  1    END;
00763      1  1 
00764   C  1  1 { NOW INSERT SPECIAL TERM }
00765      1  1 IF specord <> 0
00766      1  1  THEN
00767      1  2   BEGIN
00768      1  2   fcnw.ro.deg := fcnw.ro.deg + 1;
00769      1  2   fcnw.ro.f[fcnw.ro.deg].v := cofr(- 2d0 / fcnz.tau);
00770      1  2   fcnw.ro.f[fcnw.ro.deg].p := specord;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   15
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00771      1  1   END;
00772      1  1 
00773   C  1  1 { NOW FIX UP REST OF FCN }
00774      1  1 fcnw.gain  := l;
00775      1  1 fcnw.plane := 'W';
00776      1  1 fcnw.tau   := fcnz.tau;
00777      1  1 fcnmakeheader (fcnw);
00778      1  1 fcnnorm (fcnw);
00779      1  1 fcnwoffcnz := fcnw;
00780      0  0 END;
00781   C  0  0 {-----------------------------------------------------------------------------}
00782      1  0 FUNCTION fcnzoffcnw (fcnw : fcn) : fcn;
00783   C  1  0 { Purpose -- Convert function from W plane to Z plane.              }
00784   C  1  0 {            w = (2/T) * (z-1) / (z+1)                              }
00785      1  0 VAR
00786      1  0    i,j,specord  : integer;
00787      1  0    g            : real;
00788      1  0    l            : longreal;
00789      1  0    fcnz         : fcn;
00790   C  1  0 {------------------------------}
00791      2  0 PROCEDURE getnum (VAR fnew : complex;  VAR pnew : integer;  VAR g : real; 
00792      2  0    f : complex;  p : integer;  tau : real);
00793      2  1 BEGIN
00794      2  1 f := cmul (f,cofr(tau/2d0));
00795      2  1 IF cabs (cadd (f,cofi(1))) <> 0
00796      2  1  THEN
00797      2  2   BEGIN
00798      2  2   fnew := cdiv (csub (f,cofi(1)), cadd (f,cofi(1)));
00799      2  2   fnew.im := abs (fnew.im);
00800      2  2   pnew := p;
00801      2  2   IF fnew.im = 0
00802      2  2    THEN g := (f.re+1) * 2/tau
00803      2  2    ELSE g := cabssq (cadd (f,cofi(1))) * 2/tau;
00804      2  2   END
00805      2  1  ELSE 
00806      2  2   BEGIN
00807      2  2   fnew := cofi(0);
00808      2  2   pnew := 0;
00809      2  2   g := -4/tau;
00810      2  1   END;
00811      1  0 END;
00812   C  1  0 {------------------------------}
00813      1  1 BEGIN 
00814      1  1 IF fcnw.fcntype <> FCT THEN raise ('FCNZOFFCNW: Function not in factored form');
00815      1  1 l := fcnw.gain;
00816      1  1 specord := 0;
00817      1  1 
00818   C  1  1 { DO NUMERATOR }
00819      1  1 fcnz.ro.deg := fcnw.ro.deg;
00820      1  1 FOR i := 1 TO fcnw.ro.deg DO
00821      1  2    BEGIN
00822      1  2    getnum (fcnz.ro.f[i].v,fcnz.ro.f[i].p,g,
00823      1  2            fcnw.ro.f[i].v,fcnw.ro.f[i].p,fcnw.tau);
00824      1  2    l := l * quad(g) ** fcnw.ro.f[i].p;
00825      1  2    specord := specord - fcnw.ro.f[i].p;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   16
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00826      1  1    END;
00827      1  1 
00828   C  1  1 { NOW INSERT SPECIAL TERM }
00829      1  1 IF specord <> 0
00830      1  1  THEN
00831      1  2   BEGIN
00832      1  2   fcnz.ro.deg := fcnz.ro.deg + 1;
00833      1  2   fcnz.ro.f[fcnz.ro.deg].v := cofi(1);
00834      1  2   fcnz.ro.f[fcnz.ro.deg].p := specord;
00835      1  1   END;
00836      1  1 
00837   C  1  1 { NOW FIX UP REST OF FCN }
00838      1  1 fcnz.gain  := l;
00839      1  1 fcnz.plane := 'Z';
00840      1  1 fcnz.tau   := fcnw.tau;
00841      1  1 fcnmakeheader (fcnz);
00842      1  1 fcnnorm (fcnz);
00843      1  1 fcnzoffcnw := fcnz;
00844      0  0 END;
00845   C  0  0 {=============================================================================}
00846   C  0  0 {-- HIDDEN SUBMODULE:  LOW LEVEL OPERATIONS ON FUNCTIONS LIST ----------------}
00847   C  0  0 {=============================================================================}
00848      0  0 [ HIDDEN ]
00849      1  0 PROCEDURE movefcn (VAR fn1,fn2 : fcn);
00850      1  0 TYPE
00851      1  0    byteblock = ARRAY [1..size(fcn)] OF char;
00852      1  0 VAR
00853      1  0    i         : integer;
00854      1  1 BEGIN
00855      1  1 FOR i := 1 TO fn1.storage DO
00856      1  1    fn2::byteblock[i] := fn1::byteblock[i];
00857      0  0 END;
00858   C  0  0 {-----------------------------------------------------------------------------}
00859      0  0 [ HIDDEN ]
00860      1  0 PROCEDURE newfcn (VAR ptr : fcnlink;  VAR fn : fcn);
00861      1  1 BEGIN
00862      1  1 LIB$GET_VM (fn.storage,ptr::$POINTER);
00863      1  1 movefcn (fn,ptr^);
00864      0  0 END;
00865   C  0  0 {-----------------------------------------------------------------------------}
00866      0  0 [ HIDDEN ]
00867      1  0 PROCEDURE disposefcn (VAR ptr : fcnlink);
00868      1  1 BEGIN
00869      1  1 LIB$FREE_VM (ptr^.storage,ptr::$POINTER);
00870      1  1 ptr := NIL;
00871      0  0 END;
00872   C  0  0 {=============================================================================}
00873   C  0  0 {-- TRASH SUBMODULE:  OPERATIONS ON TRASHED FUNCTION LIST --------------------}
00874   C  0  0 {=============================================================================}
00875      1  0 PROCEDURE starttrashget;
00876      1  1 BEGIN
00877      1  1 trash.ptr := 0;
00878      1  1 endoftrashget := trash.ptr = trash.count;
00879      0  0 END;
00880   C  0  0 {-----------------------------------------------------------------------------}

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   17
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00881      1  0 PROCEDURE trashget (VAR fn : fcn);
00882      1  1 BEGIN
00883      1  1 trash.ptr := trash.ptr + 1;
00884      1  1 movefcn (trash.data[trash.ptr]^,fn);
00885      1  1 endoftrashget := trash.ptr = trash.count;
00886      0  0 END;
00887   C  0  0 {-----------------------------------------------------------------------------}
00888      1  0 PROCEDURE trashsearch (VAR fn : fcn;  name : logicalname);
00889      1  0 VAR
00890      1  0    i : integer;
00891      1  1 BEGIN
00892      1  1 fn := onefcn;
00893      1  1 fn.name := '';
00894      1  1 FOR i := 1 TO trash.count DO
00895      1  1    IF trash.data[i]^.name = name THEN movefcn (trash.data[i]^,fn);
00896      0  0 END;
00897   C  0  0 {-----------------------------------------------------------------------------}
00898      1  0 PROCEDURE trashinsert (VAR fn : fcn);
00899   C  1  0 { Purpose -- Insert the function (fn) into the project function list.  }
00900      1  0 VAR
00901      1  0    i,j : integer;
00902      1  1 BEGIN
00903      1  1 writeline (out,'Old function ' + fn.name + ' placed in trash');
00904      1  1 IF trash.count = TRASHLIM 
00905      1  1  THEN 
00906      1  2   BEGIN
00907      1  2   disposefcn (trash.data[TRASHLIM]);
00908      1  2   trash.count := trash.count - 1;
00909      1  1   END;
00910      1  1 FOR i := trash.count DOWNTO 1 DO trash.data[i+1] := trash.data[i];
00911      1  1 newfcn (trash.data[1],fn);
00912      1  1 trash.count := trash.count + 1;
00913      0  0 END;
00914   C  0  0 {=============================================================================}
00915   C  0  0 {-- FCN LIST SUBMODULE:  OPERATIONS ON GLOBAL FUNCTION LIST ------------------}
00916   C  0  0 {=============================================================================}
00917      1  0 PROCEDURE startfcnget;
00918      1  1 BEGIN
00919      1  1 list.ptr := 0;
00920      1  1 endoffcnget := list.ptr = list.count;
00921      0  0 END;
00922   C  0  0 {-----------------------------------------------------------------------------}
00923      1  0 PROCEDURE fcnget (VAR fn : fcn);
00924      1  1 BEGIN
00925      1  1 list.ptr := list.ptr + 1;
00926      1  1 movefcn (list.data[list.ptr]^,fn);
00927      1  1 endoffcnget := list.ptr = list.count;
00928      0  0 END;
00929   C  0  0 {-----------------------------------------------------------------------------}
00930      1  0 FUNCTION fcnexist (name : logicalname) : boolean;
00931      1  0 VAR
00932      1  0    found : boolean;
00933      1  0    i     : integer;
00934      1  1 BEGIN
00935      1  1 found := false;

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   18
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00936      1  1 FOR i := 1 TO list.count DO
00937      1  1    IF list.data[i]^.name = name THEN found := true;
00938      1  1 fcnexist := found;
00939      0  0 END;
00940   C  0  0 {-----------------------------------------------------------------------------}
00941      1  0 PROCEDURE fcnsearch (VAR fn : fcn;  name : logicalname);
00942      1  0 VAR
00943      1  0    i : integer;
00944      1  1 BEGIN
00945      1  1 fn := onefcn;
00946      1  1 fn.name := '';
00947      1  1 FOR i := 1 TO list.count DO
00948      1  1    IF list.data[i]^.name = name THEN movefcn (list.data[i]^,fn);
00949      0  0 END;
00950   C  0  0 {-----------------------------------------------------------------------------}
00951      1  0 PROCEDURE deletefcn (name : logicalname);
00952      1  0 VAR
00953      1  0    i,j     : integer;
00954      1  1 BEGIN
00955      1  1 FOR i := 1 TO list.count DO
00956      1  1    IF list.data[i]^.name = name 
00957      1  1     THEN 
00958      1  2      BEGIN
00959      1  2      trashinsert (list.data[i]^);
00960      1  2      disposefcn (list.data[i]);
00961      1  2      list.data[i] := NIL;
00962      1  1      END;
00963      1  1 j := 0;
00964      1  1 FOR i := 1 TO list.count DO
00965      1  1    IF list.data[i] <> NIL
00966      1  1     THEN
00967      1  2      BEGIN
00968      1  2      j := j + 1;
00969      1  2      list.data[j] := list.data[i];
00970      1  1      END;
00971      1  1 list.count := j;
00972      1  1 list.ptr := 0;
00973      0  0 END;
00974   C  0  0 {-----------------------------------------------------------------------------}
00975      1  0 PROCEDURE clearfcns;
00976      1  0 VAR
00977      1  0    i        : integer;
00978      1  1 BEGIN
00979      1  1 IF list.count <> 0
00980      1  1  THEN 
00981      1  1   IF readyes ('PLEASE CONFIRM DELETION OF ALL FUNCTIONS BY ENTERING "Y": ')
00982      1  1    THEN
00983      1  2     BEGIN
00984      1  2     WHILE list.count <> 0 DO deletefcn (list.data[1]^.name);
00985      1  2     list.count := 0;
00986      1  2     list.ptr   := 0;
00987      1  1     END;
00988      0  0 END;
00989   C  0  0 {-----------------------------------------------------------------------------}
00990      1  0 PROCEDURE fcninsert (VAR fn : fcn);

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   19
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

00991   C  1  0 { Purpose -- Insert the function (fn) into the project function list.  }
00992      1  0 VAR
00993      1  0    i,j : integer;
00994      1  1 BEGIN
00995      1  1 IF fcnexist (fn.name) THEN deletefcn (fn.name);
00996      1  1 IF list.count = LISTLIM THEN raise ('Project function list limit exceeded');
00997      1  1 j := 1;
00998      1  1 FOR i := 1 TO list.count DO
00999      1  1    IF fn.name > list.data[i]^.name THEN j := i + 1;
01000      1  1 FOR i := list.count DOWNTO j DO
01001      1  1    list.data[i+1] := list.data[i];
01002      1  1 newfcn (list.data[j],fn);
01003      1  1 list.count := list.count + 1;
01004      0  0 END;
01005   C  0  0 {=============================================================================}
01006   C  0  0 {-- PROJECT SUBMODULE --------------------------------------------------------}
01007   C  0  0 {=============================================================================}
01008      1  0 PROCEDURE writeproject (filename : anystring);
01009   C  1  0 { Purpose -- Save all functions in binary format }
01010      1  0 TYPE
01011      1  0    patype = PACKED ARRAY [1..size(fcn)] OF char;
01012      1  0    v_type = VARYING [size(fcn)] OF char;
01013      1  0 VAR
01014      1  0    fn : fcn;
01015      1  0    v  : v_type;
01016      1  1 BEGIN
01017      1  1 close (textfile,ERROR:=CONTINUE);
01018      1  1 IF index (filename,'.') = 0 THEN filename := filename + '.PRO';
01019      1  1 writeline (both,'Project ' 
01020      1  1                       + substr (filename,1,length(filename)-4) + ' written');
01021      1  1 IF exist (filename)
01022      1  1  THEN open (textfile,filename,OLD,size(fcn))
01023      1  1  ELSE open (textfile,filename,NEW,size(fcn));
01024      1  1 rewrite (textfile);
01025      1  1 startfcnget;
01026      1  1 WHILE NOT endoffcnget DO
01027      1  2    BEGIN
01028      1  2    fcnget (fn);
01029      1  2    v.length := fn.storage;
01030      1  2    movefcn (fn,v.body::fcn);
01031      1  2    writeln (textfile,v);
01032      1  1    END;
01033      1  1 close (textfile);
01034      0  0 END;
01035   C  0  0 {-----------------------------------------------------------------------------}
01036      1  0 PROCEDURE loadproject (filename : anystring);
01037   C  1  0 { Purpose -- Read a binary function file and add to current functions }
01038      1  0 TYPE
01039      1  0    patype = PACKED ARRAY [1..size(fcn)] OF char;
01040      1  0    v_type = VARYING [size(fcn)] OF char;
01041      1  0 VAR
01042      1  0    fn : fcn;
01043      1  0    v  : v_type;
01044      1  1 BEGIN
01045      1  1 close (textfile,ERROR:=CONTINUE);

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   20
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

01046      1  1 IF index (filename,'.') = 0 THEN filename := filename + '.PRO';
01047      1  1 IF NOT exist (filename)
01048      1  1  THEN writeline (both,'Cannot find project "' + filename + '"')
01049      1  1  ELSE
01050      1  2   BEGIN
01051      1  2   clearfcns;
01052      1  2   writeline (both,'Project ' 
01053      1  2                       + substr (filename,1,length(filename)-4) + ' loaded');
01054      1  2   open (textfile,filename,OLD,size(fcn));
01055      1  2   reset (textfile);
01056      1  2   WHILE NOT eof(textfile) DO
01057      1  3      BEGIN
01058      1  3      readln (textfile,v);
01059      1  3      movefcn (v.body::fcn,fn);
01060      1  3      fcnnorm (fn);
01061      1  3      fcninsert (fn);
01062      1  2      END;
01063      1  2   close (textfile);
01064      1  2   wait (1);
01065      1  1   END;
01066      0  0 END;
01067   C  0  0 {=============================================================================}
01068   C  0  0 {-- FCNLIST MANIPULATION SUBMODULE -------------------------------------------}
01069   C  0  0 {=============================================================================}
01070      1  0 FUNCTION fcnlistlength (ptr : fcnlink) : integer;
01071   C  1  0 { Purpose -- Determine length of a linked list of functions }
01072      1  0 VAR
01073      1  0    i   : integer;
01074      1  1 BEGIN
01075      1  1 i  := 0;
01076      1  1 WHILE ptr <> NIL DO  BEGIN  i := i+1;  ptr := ptr^.nextfcn;  END;
01077      1  1 fcnlistlength := i;
01078      0  0 END;
01079   C  0  0 {-----------------------------------------------------------------------------}
01080      1  0 PROCEDURE fcnlistinsert (VAR head : fcnlink;  ptr : fcnlink);
01081   C  1  0 { Purpose -- Insert the function (ptr) at the tail of a function list. }
01082      1  0 VAR
01083      1  0     p1 : fcnlink;
01084      1  1 BEGIN
01085      1  1 IF head = NIL
01086      1  1  THEN head := ptr
01087      1  1  ELSE
01088      1  2   BEGIN
01089      1  2   p1 := head;
01090      1  2   WHILE p1^.nextfcn <> NIL DO p1 := p1^.nextfcn;
01091      1  2   p1^.nextfcn := ptr;
01092      1  1   END;
01093      1  1   ptr^.nextfcn := NIL;
01094      0  0 END;
01095   C  0  0 {-----------------------------------------------------------------------------}
01096      1  0 PROCEDURE fcnlistclear (VAR head : fcnlink);
01097   C  1  0 { Purpose -- Remove all functions and dispose }
01098      1  0 VAR
01099      1  0    ptr : fcnlink;
01100      1  1 BEGIN

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   21
INCA                            Source Listing                  25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

-LINE-IDC-PL-SL-

01101      1  1 WHILE head <> NIL DO
01102      1  2    BEGIN
01103      1  2    ptr := head;
01104      1  2    head := head^.nextfcn;
01105      1  2    dispose (ptr);
01106      1  1    END;
01107      0  0 END;
01108   C  0  0 {=============================================================================}
01109      0  0 END.

FCNMATH                                                         23-Dec-1988 10:43:22    VAX Pascal V3.7-254                Page   22
INCA                            Pascal Compilation Statistics   25-Jan-1988 13:19:28    DUA1:[QPLOT.INCA.SOURCE]FCN.PAS;142 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               17074  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                              12373  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260        11         4
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        40        32
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20         9        45
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        24        12
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         3         5
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72         6         8
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        45        73
DUA1:[QPLOT.INCA.SOURCE]QZ.PEN;1                          44        24        55
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163       105        64
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         1         1



FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:IO',
00004      0  0                'QLIBHOME:MATH',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:COMPLEX',
00007      0  0                'FCN','POLYMATH','LONGREAL'), 
00008      0  0   ENVIRONMENT ('FCNOPER')]
00009      0  0 MODULE fcnoper;
00010   C  0  0 {=============================================================================}
00011   C  0  0 {-- OPERATOR/FILTER EVALUATION SUBMODULE -------------------------------------}
00012   C  0  0 {=============================================================================}
00013      1  0 FUNCTION ptroffcns (fcnx : [ LIST ] fcn) : fcnlink;
00014      1  0 VAR
00015      1  0    i         : integer;
00016      1  0    p1,ptrout : fcnlink;
00017      1  1 BEGIN
00018      1  1 ptrout := NIL;
00019      1  1 
00020      1  1 FOR i := argument_list_length (fcnx) DOWNTO 1 DO
00021      1  2    BEGIN
00022      1  2    new (p1);
00023      1  2    p1^ := argument (fcnx,i);
00024      1  2    p1^.nextfcn := ptrout;
00025      1  2    ptrout := p1;
00026      1  1    END;
00027      1  1 
00028      1  1 ptroffcns := ptrout;
00029      0  0 END;
00030   C  0  0 {-----------------------------------------------------------------------------}
00031      1  0 PROCEDURE disposefcnlist (VAR ptr : fcnlink);
00032      1  0 VAR
00033      1  0    p1 : fcnlink;
00034      1  1 BEGIN
00035      1  1 WHILE ptr <> NIL DO
00036      1  2    BEGIN
00037      1  2    p1 := ptr^.nextfcn;
00038      1  2    dispose (ptr);
00039      1  2    ptr := p1;
00040      1  1    END;
00041      0  0 END;
00042   C  0  0 {-----------------------------------------------------------------------------}
00043      0  0 [ HIDDEN ]
00044      1  0 PROCEDURE addroot (VAR c : cpoly;  re,im : real;  ord : integer);
00045      1  1 BEGIN
00046      1  1 c.deg := c.deg + 1;
00047      1  1 c.f[c.deg].re := re;
00048      1  1 c.f[c.deg].im := im;
00049      1  1 c.p[c.deg]    := ord;
00050      0  0 END;
00051   C  0  0 {=============================================================================}
00052      0  0 [ HIDDEN ]
00053      1  0 PROCEDURE oper_$CLOOP (VAR fout : fcnlink;  ptr : fcnlink);
00054   C  1  0 { Purpose -- Do $CLOOP in function expressions }
00055      1  0 VAR

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00056      1  0    compf,plntf,feedf  : fcnlink;
00057      1  0    fn                 : fcn;
00058      1  1 BEGIN
00059      1  1 IF fcnlistlength (ptr)<>3 THEN raise ('$CLOOP : Wrong number of arguments');
00060      1  1 fn := fcncloop (ptr^,ptr^.nextfcn^,ptr^.nextfcn^.nextfcn^);
00061      1  1 disposefcnlist (ptr);
00062      1  1 
00063      1  1 fcnmakeheader (fn);
00064      1  1 fcnnorm (fn);
00065      1  1 new (fout);
00066      1  1 fout^ := fn;
00067      0  0 END;
00068   C  0  0 {-----------------------------------------------------------------------------}
00069      0  0 [ HIDDEN ]
00070      1  0 PROCEDURE oper_$EXPX (VAR fout : fcnlink;  ptr : fcnlink);
00071   C  1  0 { Purpose -- Do $EXPX in function expressions }
00072      1  0 VAR
00073      1  0    a     : fcn;
00074      1  0    i,n   : integer;
00075      1  1 BEGIN
00076      1  1 IF (fcnlistlength (ptr) <> 2)
00077      1  1  THEN raise ('$EXPX : Wrong number of arguments');
00078      1  1 
00079      1  1 a     := ptr^;
00080      1  1 n     := round (roffcn(ptr^.nextfcn^));
00081      1  1 disposefcnlist (ptr);
00082      1  1 
00083      1  1 new (fout);
00084      1  1 fout^ := fcnofr (1);
00085      1  1 FOR i := n DOWNTO 1 DO
00086      1  2    BEGIN
00087      1  2    fout^ := fcnmul (fout^,a);
00088      1  2    fout^.gain := fout^.gain / i;
00089      1  2    fout^ := fcnadd (fout^,fcnofr(1));
00090      1  1    END;
00091      1  1 
00092      1  1 fcnmakeheader (fout^);
00093      1  1 fcnnorm (fout^);
00094      0  0 END;
00095   C  0  0 {-----------------------------------------------------------------------------}
00096      0  0 [ HIDDEN ]
00097      1  0 PROCEDURE oper_$Z_$ZH (VAR fout : fcnlink;  ptr : fcnlink;  zoh : boolean);
00098   C  1  0 { Purpose -- Do $Z and $ZH in function expressions }
00099      1  0 VAR
00100      1  0    fn               : fcn;
00101      1  0    time,delta       : fcnlink;
00102      1  1 BEGIN
00103      1  2 CASE ptr^.plane OF
00104      1  2    'K':  IF zoh
00105      1  2           THEN raise ('$ZH : Zero order hold illegal on constant function')
00106      1  2           ELSE fn := ptr^;
00107      1  3    'S':  BEGIN
00108      1  3          IF NOT (fcnlistlength(ptr) IN [2,3])
00109      1  3           THEN raise ('$Z : Wrong number of arguments');
00110      1  3          time  := ptr^.nextfcn;

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00111      1  3          IF time^.nextfcn <> NIL
00112      1  3           THEN delta := time^.nextfcn
00113      1  3           ELSE BEGIN new (delta); delta^ := fcnofr (0);  END;
00114      1  3          fn := fcnzoffcns (ptr^,roffcn (time^),zoh,roffcn (delta^));
00115      1  3          dispose (time);
00116      1  3          dispose (delta);
00117      1  2          END;
00118      1  2    'Z':  IF zoh 
00119      1  2           THEN raise ('$ZH: Zero order hold not allowed')
00120      1  2          ELSE IF fcnlistlength(ptr) <> 2
00121      1  2           THEN raise ('$Z : Wrong number of arguments')
00122      1  2           ELSE 
00123      1  3            BEGIN
00124      1  3            time  := ptr^.nextfcn;
00125      1  3            fn := ptr^;
00126      1  3            fn.tau := roffcn (time^);
00127      1  3            fcnmakeheader (fn);
00128      1  3            dispose (time);
00129      1  2            END;
00130      1  3    'W':  CASE fcnlistlength(ptr) OF
00131      1  4             1:  BEGIN
00132      1  4                 IF ptr^.tau = UNDEFINED_REAL
00133      1  4                  THEN raise 
00134      1  4                        ('$Z : Unable to convert with undefined sample period');
00135      1  4                 IF zoh THEN raise ('$ZH : Zero order hold not allowed');
00136      1  4                 fn := fcnzoffcnw (ptr^);
00137      1  3                 END;
00138      1  4             2:  BEGIN
00139      1  4                 ptr^.tau := roffcn (ptr^.nextfcn^);
00140      1  4                 IF zoh THEN raise ('$ZH : Zero order hold not allowed');
00141      1  4                 fn := fcnzoffcnw (ptr^);
00142      1  3                 END;
00143      1  3             OTHERWISE raise ('$W : Wrong number of arguments');
00144      1  2             END;
00145      1  1    END;
00146      1  1 dispose (ptr);
00147      1  1 new (fout);
00148      1  1 fout^ := fn;
00149      0  0 END;
00150   C  0  0 {-----------------------------------------------------------------------------}
00151      0  0 [ HIDDEN ]
00152      1  0 PROCEDURE oper_$W_$WH (VAR fout : fcnlink;  ptr : fcnlink;  zoh : boolean);
00153   C  1  0 { Purpose -- Do $W and $WH in function expressions }
00154      1  0 VAR
00155      1  0    fn           : fcn;
00156      1  0    time,delta   : fcnlink;
00157      1  1 BEGIN
00158      1  2 CASE ptr^.plane OF
00159      1  2    'K':  fout^ := ptr^;
00160      1  3    'S':  BEGIN
00161      1  3          IF NOT (fcnlistlength(ptr) IN [2,3])
00162      1  3           THEN raise ('$W : Wrong number of arguments');
00163      1  3          time  := ptr^.nextfcn;
00164      1  3          IF time^.nextfcn <> NIL 
00165      1  3           THEN delta := time^.nextfcn

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00166      1  3           ELSE BEGIN new (delta); delta^ := fcnofr (0);  END;
00167      1  3          fn := fcnwoffcnz 
00168      1  3                         (fcnzoffcns (ptr^,roffcn (time^),zoh,roffcn (delta^)));
00169      1  3          dispose (time);
00170      1  3          dispose (delta);
00171      1  2          END;
00172      1  3    'Z':  CASE fcnlistlength(ptr) OF
00173      1  4             1:  BEGIN
00174      1  4                 IF ptr^.tau = UNDEFINED_REAL
00175      1  4                  THEN raise 
00176      1  4                        ('$W : Unable to convert with undefined sample period');
00177      1  4                 IF zoh THEN raise ('$WH : Zero order hold not allowed');
00178      1  4                 fn := fcnwoffcnz (ptr^);
00179      1  3                 END;
00180      1  4             2:  BEGIN
00181      1  4                 ptr^.tau := roffcn (ptr^.nextfcn^);
00182      1  4                 IF zoh THEN raise ('$WH : Zero order hold not allowed');
00183      1  4                 fn := fcnwoffcnz (ptr^);
00184      1  3                 END;
00185      1  3             OTHERWISE raise ('$W : Wrong number of arguments');
00186      1  2             END;
00187      1  2    'W':  IF zoh 
00188      1  2           THEN raise ('$WH : Zero order hold not allowed')
00189      1  2          ELSE IF fcnlistlength(ptr) <> 2
00190      1  2           THEN raise ('Wrong number of arguments')
00191      1  2           ELSE 
00192      1  3            BEGIN
00193      1  3            time  := ptr^.nextfcn;
00194      1  3            fn := ptr^;
00195      1  3            fn.tau := roffcn (time^);
00196      1  3            fcnmakeheader (fn);
00197      1  3            dispose (time);
00198      1  2            END;
00199      1  1    END;
00200      1  1 disposefcnlist (ptr);
00201      1  1 new (fout);
00202      1  1 fout^ := fn;
00203      0  0 END;
00204   C  0  0 {-----------------------------------------------------------------------------}
00205      0  0 [ HIDDEN ]
00206      1  0 PROCEDURE oper_$SRA (VAR fout : fcnlink;  ptr : fcnlink);
00207   C  1  0 { Purpose -- Do $SRA in function expressions }
00208      1  0 VAR
00209      1  0    i      : integer;
00210      1  0    p1     : fcnlink;
00211      1  0    u      : upoly;
00212      1  0    nu,de  : cpoly;
00213      1  1 BEGIN
00214      1  1 IF ptr = NIL THEN raise ('$SRA : Incorrect number of arguments');
00215      1  1 u.deg := fcnlistlength(ptr) - 1;
00216      1  1 FOR i := u.deg DOWNTO 0 DO
00217      1  2    BEGIN
00218      1  2    u.c[i] := roffcn (ptr^);
00219      1  2    p1 := ptr;
00220      1  2    ptr := ptr^.nextfcn;

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00221      1  2    dispose (p1);
00222      1  1    END;
00223      1  1 
00224      1  1 de.deg := 1;
00225      1  1 de.f[1] := complex(0,0);
00226      1  1 de.p[1] := u.deg + 1;
00227      1  1 
00228      1  1 WHILE (u.c[u.deg] = 0) AND (u.deg <> 0) DO 
00229      1  1    u.deg := u.deg - 1;
00230      1  1 new (fout);
00231      1  1 fout^.plane := 'S';
00232      1  1 fout^.tau   := UNDEFINED_REAL;
00233      1  1 cpolyfromupoly (nu,fout^.gain,u);
00234      1  1 cspolyfromcpolys (fout^.ro,nu,de);
00235      1  1 fcnmakeheader (fout^);
00236      1  1 fcnnorm (fout^);
00237      0  0 END;
00238   C  0  0 {-----------------------------------------------------------------------------}
00239      0  0 [ HIDDEN ]
00240      1  0 PROCEDURE oper_$sra1 (VAR fout : fcnlink;  ptr : fcnlink;  order : integer);
00241   C  1  0 { Purpose -- Do $STEP, $RAMP, $ACC in function expressions }
00242      1  0 VAR
00243      1  0    p1     : fcnlink;
00244      1  0    i      : integer;
00245      1  1 BEGIN
00246      1  1 IF fcnlistlength (ptr) <> 1 
00247      1  1  THEN raise ('$STEP etc. : Incorrect number of arguments');
00248      1  1 IF ptr^.plane <> 'K' 
00249      1  1  THEN raise ('$STEP etc. : Constant function not found where expected');
00250      1  1 FOR i := 2 TO order DO
00251      1  2    BEGIN
00252      1  2    new (p1);
00253      1  2    p1^ := fcnofr(0);
00254      1  2    p1^.nextfcn := ptr;
00255      1  2    ptr := p1;
00256      1  1    END;
00257      1  1 oper_$SRA (fout,ptr);
00258      0  0 END;
00259   C  0  0 {-----------------------------------------------------------------------------}
00260      0  0 [ HIDDEN ]
00261      1  0 PROCEDURE oper_$DOSC (VAR fout : fcnlink;  ptr : fcnlink;  degree : boolean);
00262   C  1  0 { Purpose -- Do $DOSC,$DOSCD in function expressions }
00263      1  0 VAR
00264      1  0    th            : real;
00265      1  0    w,a,spa,thfcn : fcn;
00266      1  0    p1            : fcnlink;
00267      1  1 BEGIN
00268      1  1 IF (fcnlistlength (ptr) > 3) OR (ptr = NIL)
00269      1  1  THEN raise ('$DOSC : Wrong number of arguments');
00270      1  1 w     := ptr^;
00271      1  1 thfcn := fcnofr(0);
00272      1  1 a     := fcnofr(0);
00273      1  1 IF fcnlistlength (ptr) >= 2 THEN thfcn := ptr^.nextfcn^;
00274      1  1 IF fcnlistlength (ptr) >= 3 THEN a  := ptr^.nextfcn^.nextfcn^;
00275      1  1 disposefcnlist (ptr);

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00276      1  1 
00277      1  1 th := roffcn (thfcn);
00278      1  1 IF degree THEN th := th * PI / 180d0;
00279      1  1 spa := fcnadd (sfcn,a);
00280      1  1 
00281      1  1 new (fout);
00282      1  1 fout^ := fcndiv (fcnsub (fcnmul (fcnofr (cos(th)),spa), 
00283      1  1                          fcnmul (fcnofr (sin(th)),w)),
00284      1  1                  fcnadd (fcnmul (spa,spa), fcnmul (w,w)));
00285      1  1 fcnmakeheader (fout^);
00286      1  1 fcnnorm (fout^);
00287      0  0 END;
00288   C  0  0 {-----------------------------------------------------------------------------}
00289      0  0 [ HIDDEN ]
00290      1  0 PROCEDURE oper_$BUTTER (VAR fout : fcnlink;  ptr : fcnlink);
00291      1  0 VAR
00292      1  0    w,theta : real;
00293      1  0    i,n     : integer;
00294      1  0    nu,de   : cpoly;
00295      1  1 BEGIN
00296      1  1 IF (fcnlistlength (ptr) <> 2) 
00297      1  1  THEN raise ('$BUTTER : Wrong number of arguments');
00298      1  1 w := roffcn (ptr^);
00299      1  1 n := round (roffcn (ptr^.nextfcn^));
00300      1  1 disposefcnlist (ptr);
00301      1  1 
00302      1  1 new (fout);
00303      1  1 fcnmakeheader (fout^);
00304      1  1 fout^.gain  := 1;
00305      1  1 fout^.plane := 'S';
00306      1  1 fout^.tau   := UNDEFINED_REAL;
00307      1  1 nu.deg := 0;
00308      1  1 de.deg := 0;
00309      1  1 FOR i := 1 TO n DO
00310      1  2    BEGIN
00311      1  2    theta := (PI/2/n) * (i*2 - n - 1);
00312      1  2    addroot (de, w * cos (theta), w * sin (theta), 1);
00313      1  2    fout^.gain := fout^.gain * w;
00314      1  1    END;
00315      1  1 cpolynorm (de);
00316      1  1 cspolyfromcpolys (fout^.ro,nu,de);
00317      1  1 fcnnorm (fout^);
00318      0  0 END;
00319   C  0  0 {-----------------------------------------------------------------------------}
00320      0  0 [ HIDDEN ]
00321      1  0 PROCEDURE oper_$ITAE (VAR fout : fcnlink;  ptr : fcnlink);
00322      1  0 VAR
00323      1  0    w     : real;
00324      1  0    i,n   : integer;
00325      1  0    nu,de : cpoly;
00326      1  0    d     : upoly;
00327      1  1 BEGIN
00328      1  1 IF (fcnlistlength (ptr) <> 2) THEN raise ('$ITAE : Wrong number of arguments');
00329      1  1 w := roffcn (ptr^);
00330      1  1 n := round (roffcn (ptr^.nextfcn^));

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00331      1  1 disposefcnlist (ptr);
00332      1  1 
00333      1  1 new (fout);
00334      1  1 fcnmakeheader (fout^);
00335      1  1 nu.deg := 0;
00336      1  1 de.deg := 0;
00337      1  2 CASE n OF
00338      1  2    1:  addroot (de,w,0,1);
00339      1  3    2:  BEGIN
00340      1  3        addroot (de,0.707d0*w, 0.707d0*w,1);
00341      1  3        addroot (de,0.707d0*w,-0.707d0*w,1);
00342      1  2        END;
00343      1  3    3:  BEGIN
00344      1  3        addroot (de,0.7081d0*w,0,1);
00345      1  3        addroot (de,0.521d0*w, 1.068d0*w,1);
00346      1  3        addroot (de,0.521d0*w,-1.068d0*w,1);
00347      1  2        END;
00348      1  3    4:  BEGIN
00349      1  3        addroot (de,0.424d0*w, 1.263d0*w,1);
00350      1  3        addroot (de,0.424d0*w,-1.263d0*w,1);
00351      1  3        addroot (de,0.626d0*w, 0.4141d0*w,1);
00352      1  3        addroot (de,0.626d0*w,-0.4141d0*w,1);
00353      1  2        END;
00354      1  3    5:  BEGIN
00355      1  3        addroot (de,0.8955d0*w,0,1);
00356      1  3        addroot (de,0.376d0*w, 1.292d0*w,1);
00357      1  3        addroot (de,0.376d0*w,-1.292d0*w,1);
00358      1  3        addroot (de,0.5758d0*w, 0.5339d0*w,1);
00359      1  3        addroot (de,0.5758d0*w,-0.5339d0*w,1);
00360      1  2        END;
00361      1  3    6:  BEGIN
00362      1  3        addroot (de,0.3099d0*w, 1.263d0*w,1);
00363      1  3        addroot (de,0.3099d0*w,-1.263d0*w,1);
00364      1  3        addroot (de,0.5805d0*w, 0.7828d0*w,1);
00365      1  3        addroot (de,0.5805d0*w,-0.7828d0*w,1);
00366      1  3        addroot (de,0.7346d0*w, 0.2873d0*w,1);
00367      1  3        addroot (de,0.7346d0*w,-0.2873d0*w,1);
00368      1  2        END;
00369      1  3    7:  BEGIN
00370      1  3        d.deg := 7;
00371      1  3        d.c[7] := 1;
00372      1  3        d.c[6] := 4.475*w;
00373      1  3        d.c[5] := 10.42*w**2;
00374      1  3        d.c[4] := 15.08*w**3;
00375      1  3        d.c[3] := 15.54*w**4;
00376      1  3        d.c[2] := 10.64*w**5;
00377      1  3        d.c[1] := 4.58*w**6;
00378      1  3        d.c[0] := w**7;
00379      1  3        cpolyfromupoly (de,fout^.gain,d);
00380      1  2        END;
00381      1  3    8:  BEGIN
00382      1  3        d.deg := 8;
00383      1  3        d.c[8] := 1;
00384      1  3        d.c[7] := 5.20*w;
00385      1  3        d.c[6] := 12.80*w**2;

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00386      1  3        d.c[5] := 21.60*w**3;
00387      1  3        d.c[4] := 25.75*w**4;
00388      1  3        d.c[3] := 22.20*w**5;
00389      1  3        d.c[2] := 13.30*w**6;
00390      1  3        d.c[1] := 5.15*w**7;
00391      1  3        d.c[0] := w**8;
00392      1  3        cpolyfromupoly (de,fout^.gain,d);
00393      1  2        END;
00394      1  2    OTHERWISE raise ('$ITAE : Order too large');
00395      1  1    END;
00396      1  1 fout^.gain  := 1;
00397      1  1 fout^.plane := 'S';
00398      1  1 fout^.tau   := UNDEFINED_REAL;
00399      1  1 FOR i := 1 TO de.deg DO fout^.gain := fout^.gain * w;
00400      1  1 cspolyfromcpolys (fout^.ro,nu,de);
00401      1  1 fcnnorm (fout^);
00402      0  0 END;
00403   C  0  0 {-----------------------------------------------------------------------------}
00404      0  0 [ HIDDEN ]
00405      1  0 PROCEDURE oper_$CHEBYS (VAR fout : fcnlink;  ptr : fcnlink);
00406      1  0 VAR
00407      1  0    w,rip   : real;
00408      1  0    e,b     : real;
00409      1  0    i,n     : integer;
00410      1  0    nu,de   : cpoly;
00411      1  1 BEGIN
00412      1  1 IF (fcnlistlength (ptr) <> 3) 
00413      1  1  THEN raise ('$CHEBYS : Wrong number of arguments');
00414      1  1 w   := roffcn (ptr^);
00415      1  1 rip := roffcn (ptr^.nextfcn^);
00416      1  1 n   := round (roffcn (ptr^.nextfcn^.nextfcn^));
00417      1  1 
00418      1  1 disposefcnlist (ptr);
00419      1  1 
00420      1  1 new (fout);
00421      1  1 fcnmakeheader (fout^);
00422      1  1 fout^.gain  := 1;
00423      1  1 fout^.plane := 'S';
00424      1  1 fout^.tau   := UNDEFINED_REAL;
00425      1  1 
00426      1  1 nu.deg := 0;
00427      1  1 de.deg := 0;
00428      1  1 e := sqrt (exp10 (rip/10) - 1);
00429      1  1 b := arcsinh (1/e)/n;
00430      1  1 FOR i := 1 TO n DO
00431      1  1    addroot (de,w * (sinh (b) * sin ((2*i-1)*PI/(2*n))),
00432      1  1                w * (cosh (b) * cos ((2*i-1)*PI/(2*n))),1);
00433      1  1 cpolynorm (de);
00434      1  1 cspolyfromcpolys (fout^.ro,nu,de);
00435      1  1 fout^ := numfcnofbodefcn (fout^);
00436      1  1 fcnnorm (fout^);
00437      0  0 END;
00438   C  0  0 {-----------------------------------------------------------------------------}
00439      0  0 [ HIDDEN ]
00440      1  0 PROCEDURE oper_$BESSEL (VAR fout : fcnlink;  ptr : fcnlink);

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00441      1  0 VAR
00442      1  0    w,theta : real;
00443      1  0    temp    : real;
00444      1  0    g       : longreal;
00445      1  0    i,j,n   : integer;
00446      1  0    nu,de   : cpoly;
00447      1  0    u       : upoly;
00448      1  1 BEGIN
00449      1  1 IF (fcnlistlength (ptr) <> 2) 
00450      1  1  THEN raise ('$BESSEL : Wrong number of arguments');
00451      1  1 w := roffcn (ptr^);
00452      1  1 n := round (roffcn (ptr^.nextfcn^));
00453      1  1 disposefcnlist (ptr);
00454      1  1 
00455      1  1 new (fout);
00456      1  1 fcnmakeheader (fout^);
00457   C  1  1 { CALCULATE  (2*N)! / N! * (W/2)^N  }
00458      1  1 fout^.gain := 1;
00459      1  1 FOR j := 1 TO n DO fout^.gain := fout^.gain * (n+j) * (w/2);
00460      1  1 fout^.plane := 'S';
00461      1  1 fout^.tau   := UNDEFINED_REAL;
00462      1  1 nu.deg := 0;
00463      1  1 u.deg  := n;
00464      1  1 FOR i := 0 TO n DO
00465      1  2    BEGIN
00466   C  1  2    { CALCULATE  (2*N-I)! / (N-I)! /I!  }
00467      1  2    temp := 1;
00468      1  2    FOR j := 1 TO n DO
00469      1  3       BEGIN
00470      1  3       temp := temp * (n-i+j);
00471      1  3       IF j <= i THEN temp := temp / j;
00472      1  2       END;
00473      1  2    u.c[i] := temp * (w/2) ** (n-i);
00474      1  1    END;
00475      1  1 cpolyfromupoly (de,g,u);
00476      1  1 cspolyfromcpolys (fout^.ro,nu,de);
00477      1  1 fcnnorm (fout^);
00478      0  0 END;
00479   C  0  0 {-----------------------------------------------------------------------------}
00480      0  0 [ HIDDEN ]
00481      1  0 PROCEDURE oper_$PID (VAR fout : fcnlink;  ptr : fcnlink);
00482      1  0 VAR
00483      1  0    w,zeta,I1,d   : real;
00484      1  0    kr,kp,ki      : fcn;
00485      1  1 BEGIN
00486      1  1 IF NOT (fcnlistlength (ptr) IN [3,4])
00487      1  1  THEN raise ('$PID : Wrong number of arguments');
00488      1  1 w    := roffcn (ptr^);
00489      1  1 zeta := roffcn (ptr^.nextfcn^);
00490      1  1 i1   := roffcn (ptr^.nextfcn^.nextfcn^);
00491      1  1 IF fcnlistlength (ptr) = 4
00492      1  1  THEN d := roffcn (ptr^.nextfcn^.nextfcn^.nextfcn^)
00493      1  1  ELSE d := 0;
00494      1  1 disposefcnlist (ptr);
00495      1  1 

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00496      1  1 new (fout);
00497      1  1 kr := fcnofr (2 * zeta * w / i1);
00498      1  1 kp := fcnofr (w ** 2 / i1);
00499      1  1 ki := fcnofr (d * w ** 3 /i1);
00500      1  1 
00501      1  1 fout^ := fcnadd (fcnadd (fcnmul (kr,sfcn), kp), fcndiv (ki,sfcn));
00502      1  1 fcnmakeheader (fout^);
00503      1  1 fcnnorm (fout^);
00504      0  0 END;
00505   C  0  0 {-----------------------------------------------------------------------------}
00506      0  0 [ HIDDEN ]
00507      1  0 PROCEDURE oper_$math (VAR fout : fcnlink;  ptr : fcnlink;
00508      1  0    funct : VARYING [l3] OF char);
00509   C  1  0 { Purpose -- Do $funct in function expressions }
00510      1  0 VAR
00511      1  0    p1     : fcnlink;
00512      1  0    r      : real;
00513      1  1 BEGIN
00514      1  1 IF fcnlistlength(ptr) <> 1
00515      1  1  THEN raise ('$function : Incorrect number of arguments');
00516      1  1 r := roffcn (ptr^);
00517      1  1 disposefcnlist (ptr);
00518      1  1 new (fout);
00519      1  1 IF      funct = 'SIN'   THEN fout^ := fcnofr (sin (r))
00520      1  1 ELSE IF funct = 'COS'   THEN fout^ := fcnofr (cos (r))
00521      1  1 ELSE IF funct = 'SIND'  THEN fout^ := fcnofr (sin (r/180d0*PI))
00522      1  1 ELSE IF funct = 'COSD'  THEN fout^ := fcnofr (cos (r/180d0*PI))
00523      1  1 ELSE IF funct = 'SQRT'  THEN fout^ := fcnofr (sqrt(r))
00524      1  1 ELSE IF funct = 'EXP'   THEN fout^ := fcnofr (exp (r))
00525      1  1 ELSE IF funct = 'EXP10' THEN fout^ := fcnofr (10**(r))
00526      1  1 ELSE IF funct = 'LOG'   THEN fout^ := fcnofr (ln (r))
00527      1  1 ELSE IF funct = 'LOG10' THEN fout^ := fcnofr (log10 (r));
00528      1  1 fcnnorm (fout^);
00529      0  0 END;
00530   C  0  0 {-----------------------------------------------------------------------------}
00531      0  0 [ HIDDEN ]
00532      1  0 PROCEDURE oper_$SCALE (VAR fout : fcnlink;  ptr : fcnlink);
00533      1  0 VAR
00534      1  0    i  : integer;
00535      1  0    s  : real;
00536      1  0    fn : fcn;
00537      1  1 BEGIN
00538      1  1 IF (fcnlistlength (ptr) <> 2) 
00539      1  1  THEN raise ('$SCALE : Wrong number of arguments');
00540      1  1 fn := bodefcnofnumfcn (ptr^);
00541      1  1 s  := roffcn (ptr^.nextfcn^);
00542      1  1 disposefcnlist (ptr);
00543      1  1 
00544      1  1 FOR i := 1 TO fn.ro.deg DO
00545      1  2    BEGIN
00546      1  2    fn.ro.f[i].v.re := fn.ro.f[i].v.re * s;
00547      1  2    fn.ro.f[i].v.im := fn.ro.f[i].v.im * s;
00548      1  1    END;
00549      1  1 
00550      1  1 new (fout);

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00551      1  1 fout^ := numfcnofbodefcn (fn);
00552      1  1 fcnnorm (fout^);
00553      0  0 END;
00554   C  0  0 {-----------------------------------------------------------------------------}
00555      0  0 [ HIDDEN ]
00556      1  0 PROCEDURE oper_$PLACAN (VAR fout : fcnlink;  ptr : fcnlink);
00557      1  0 VAR
00558      1  0    i,n  : integer;
00559      1  0    fn   : fcn;
00560   C  1  0 {------------------------------}
00561      2  0 PROCEDURE addroot (z : complex);
00562      2  0 VAR
00563      2  0    j : integer;
00564      2  0    zz: complex;
00565      2  1 BEGIN
00566      2  1 z.re := z.re / n;
00567      2  1 z.im := z.im / n;
00568      2  1 FOR j := 0 TO n-1 DO
00569      2  2    BEGIN
00570      2  2    zz := cexp (z);
00571      2  2    IF zz.im >= 0
00572      2  2     THEN
00573      2  3      BEGIN
00574      2  3      fout^.ro.deg := fout^.ro.deg + 1;
00575      2  3      fout^.ro.f[fout^.ro.deg].v := zz;
00576      2  3      fout^.ro.f[fout^.ro.deg].p := fn.ro.f[i].p;
00577      2  2      END;
00578      2  2    z.im := z.im + 2 * PI / n;
00579      2  1    END;
00580      1  0 END;
00581   C  1  0 {------------------------------}
00582      1  1 BEGIN
00583      1  1 IF (fcnlistlength (ptr) <> 2) 
00584      1  1  THEN raise ('$PLACANICA : Wrong number of arguments');
00585      1  1 fn := bodefcnofnumfcn (ptr^);
00586      1  1 n  := round (roffcn (ptr^.nextfcn^));
00587      1  1 disposefcnlist (ptr);
00588      1  1 
00589      1  1 new (fout);
00590      1  1 fout^ := fn;
00591      1  1 fout^.ro.deg := 0;
00592      1  1 fout^.tau := fout^.tau / n;
00593      1  1 FOR i := 1 TO fn.ro.deg DO
00594      1  2    BEGIN
00595      1  2    addroot (clog (fn.ro.f[i].v));
00596      1  2    IF fn.ro.f[i].v.im > 0 THEN addroot (clog (ccnj (fn.ro.f[i].v)));
00597      1  1    END;
00598      1  1 
00599      1  1 fout^ := numfcnofbodefcn (fout^);
00600      1  1 fcnnorm (fout^);
00601      0  0 END;
00602   C  0  0 {-----------------------------------------------------------------------------}
00603      0  0 [ HIDDEN ]
00604      1  0 PROCEDURE oper_$example (VAR fout : fcnlink;  ptr : fcnlink);
00605      1  1 BEGIN

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                  18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

-LINE-IDC-PL-SL-

00606      1  1 IF (fcnlistlength (ptr) <> 2) 
00607      1  1  THEN raise ('$EXAMPLE : Wrong number of arguments');
00608      1  1 disposefcnlist (ptr);
00609      1  1 
00610      1  1 new (fout);
00611      1  1 fout^ := fcnofr (0);
00612      1  1 fcnmakeheader (fout^);
00613      1  1 fcnnorm (fout^);
00614      0  0 END;
00615   C  0  0 {-----------------------------------------------------------------------------}
00616      1  0 PROCEDURE oper_$eval (VAR fout : fcnlink;  ptr : fcnlink;
00617      1  0    funct : VARYING [l3] OF char);
00618      1  1 BEGIN
00619      1  1 IF      funct = 'CLOOP'  THEN oper_$CLOOP  (fout,ptr)
00620      1  1 ELSE IF funct = 'EXPX'   THEN oper_$EXPX   (fout,ptr)
00621      1  1 ELSE IF funct = 'Z'      THEN oper_$Z_$ZH  (fout,ptr,false)
00622      1  1 ELSE IF funct = 'ZH'     THEN oper_$Z_$ZH  (fout,ptr,true)
00623      1  1 ELSE IF funct = 'W'      THEN oper_$W_$WH  (fout,ptr,false)
00624      1  1 ELSE IF funct = 'WH'     THEN oper_$W_$WH  (fout,ptr,true)
00625      1  1 ELSE IF funct = 'SRA'    THEN oper_$SRA    (fout,ptr)
00626      1  1 ELSE IF funct = 'STEP'   THEN oper_$sra1   (fout,ptr,1)
00627      1  1 ELSE IF funct = 'RAMP'   THEN oper_$sra1   (fout,ptr,2)
00628      1  1 ELSE IF funct = 'ACC'    THEN oper_$sra1   (fout,ptr,3)
00629      1  1 ELSE IF funct = 'DOSC'   THEN oper_$DOSC   (fout,ptr,false)
00630      1  1 ELSE IF funct = 'DOSCD'  THEN oper_$DOSC   (fout,ptr,true)
00631      1  1 ELSE IF funct = 'BESSEL' THEN oper_$BESSEL (fout,ptr)
00632      1  1 ELSE IF funct = 'BUTTER' THEN oper_$BUTTER (fout,ptr)
00633      1  1 ELSE IF funct = 'CHEBYS' THEN oper_$CHEBYS (fout,ptr)
00634      1  1 ELSE IF funct = 'ITAE'   THEN oper_$ITAE   (fout,ptr)
00635      1  1 ELSE IF funct = 'PD'     THEN oper_$PID    (fout,ptr)
00636      1  1 ELSE IF funct = 'PID'    THEN oper_$PID    (fout,ptr)
00637      1  1 ELSE IF funct = 'SCALE'  THEN oper_$SCALE  (fout,ptr)
00638      1  1 ELSE IF funct = 'PLACAN' THEN oper_$PLACAN (fout,ptr)
00639      1  1 ELSE IF funct = 'SIN'    THEN oper_$math   (fout,ptr,funct)
00640      1  1 ELSE IF funct = 'COS'    THEN oper_$math   (fout,ptr,funct)
00641      1  1 ELSE IF funct = 'SIND'   THEN oper_$math   (fout,ptr,funct)
00642      1  1 ELSE IF funct = 'COSD'   THEN oper_$math   (fout,ptr,funct)
00643      1  1 ELSE IF funct = 'SQRT'   THEN oper_$math   (fout,ptr,funct)
00644      1  1 ELSE IF funct = 'EXP'    THEN oper_$math   (fout,ptr,funct)
00645      1  1 ELSE IF funct = 'EXP10'  THEN oper_$math   (fout,ptr,funct)
00646      1  1 ELSE IF funct = 'LOG'    THEN oper_$math   (fout,ptr,funct)
00647      1  1 ELSE IF funct = 'LOG10'  THEN oper_$math   (fout,ptr,funct)
00648      1  1 ELSE raise ('Illegal operator name after "$"');
00649      0  0 END;
00650   C  0  0 {=============================================================================}
00651      0  0 END.

FCNOPER                                                         23-Dec-1988 10:45:21    VAX Pascal V3.7-254                Page   13
INCA                            Pascal Compilation Statistics   18-Oct-1988 16:55:22    DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PAS;64 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               12119  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        31        25
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        10         5
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59        15        25
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72         0         0
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        13        21
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248       126        51
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        36        22
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         1         1



FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:IO',
00004      0  0                'QLIBHOME:MATH',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:COMPLEX',
00007      0  0                'FCNOPER','FCN','POLYMATH','LONGREAL'), 
00008      0  0   ENVIRONMENT ('FCNEVAL')]
00009      0  0 MODULE fcneval;
00010      0  0 VAR
00011      0  0    special      : RECORD
00012      0  0                   name : logicalname;
00013      0  0                   val  : real;
00014      0  0                   END;
00015   C  0  0 {=============================================================================}
00016      1  0 FUNCTION fcnevallogabs (VAR fn : fcn;  spt : complex) : real;
00017   C  1  0 { Purpose -- Find logarithm of absolute value of function FN at point SPT.  }
00018      1  0 VAR
00019      1  0     i      : integer;
00020      1  0     fval   : real;
00021      1  1 BEGIN
00022      1  1 IF fn.fcntype <> FCT 
00023      1  1  THEN raise ('FCNEVALLOGABS: Function not in factored form');
00024      1  1 fval := llog10 (abs (fn.gain));
00025      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00026      1  2    BEGIN
00027      1  2    fval := fval + p * log10 (cabs (cadd (spt,v)));
00028      1  2    IF v.im <> 0
00029      1  2     THEN fval := fval + p * log10 (cabs (cadd (spt,ccnj(v))));
00030      1  1    END;
00031      1  1 fcnevallogabs := fval;
00032      0  0 END;
00033   C  0  0 {-----------------------------------------------------------------------------}
00034      1  0 FUNCTION fcnevalph (VAR fn : fcn; spt : complex;  base : real) : real;
00035   C  1  0 { Purpose -- Find phase (in degrees) of function FN at point SPT.   }
00036      1  0 VAR
00037      1  0     i      : integer;
00038      1  0     phase  : real;
00039      1  1 BEGIN
00040      1  1 IF fn.fcntype <> FCT  THEN raise ('FCNEVALPH: Function not in factored form');
00041      1  1 phase := base * PI / 180d0;
00042      1  1 IF fn.gain < 0 THEN phase := phase + PI;
00043      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00044      1  2    BEGIN
00045      1  2    phase := phase + p * angle (cadd (spt,v));
00046      1  2    IF v.im <> 0 
00047      1  2     THEN phase := phase + p * angle (cadd (spt,ccnj(v)));
00048      1  1    END;
00049      1  1 WHILE phase >= PI DO phase := phase - 2*PI;
00050      1  1 WHILE phase < -PI DO phase := phase + 2*PI;
00051      1  1 fcnevalph := phase * 180d0/PI;
00052      0  0 END;
00053   C  0  0 {-----------------------------------------------------------------------------}
00054      1  0 FUNCTION fcnevallogderiv (VAR phase : real;  VAR fn : fcn;  spt : complex) 
00055      1  0    : real;  

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00056   C  1  0 { Purpose -- Find logarithmic derivative of function FN at point SPT.  }
00057      1  0 VAR
00058      1  0     i      : integer;
00059      1  0     z,cval : complex;
00060      1  1 BEGIN
00061      1  1 IF fn.fcntype <> FCT 
00062      1  1  THEN raise ('FCNEVALLOGDERIV: Function not in factored form');
00063      1  1 cval := complex(0,0);
00064      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00065      1  2    BEGIN
00066      1  2    z := cadd (spt,v);
00067      1  2    IF ceq(z,complex(0,0))
00068      1  2     THEN z := cofr(1d35)
00069      1  2     ELSE z := cinv(z);
00070      1  2    cval := cadd (cval, cmul (z,cofi(p)));
00071      1  2    IF v.im <> 0
00072      1  2     THEN
00073      1  3      BEGIN
00074      1  3      z := cadd (spt,ccnj(v));
00075      1  3      IF ceq(z,complex(0,0))
00076      1  3       THEN z := cofr(1d35)
00077      1  3       ELSE z := cinv(z);
00078      1  3      cval := cadd (cval, cmul (z,cofi(p)));
00079      1  2      END;
00080      1  1    END;
00081      1  1 cval.re := -cval.re;
00082      1  1 fcnevallogderiv := cabs(cval);
00083      1  1 phase := angle (cval) * 180d0/PI;
00084      0  0 END;
00085   C  0  0 {-----------------------------------------------------------------------------}
00086      1  0 FUNCTION fcnevalnearroot (VAR root : complex;  VAR fn : fcn;  spt : complex) 
00087      1  0    : real;
00088   C  1  0 { Purpose -- Find distance to nearest root or pole. }
00089      1  0 VAR
00090      1  0     i      : integer;
00091      1  0     t,dist : real;
00092      1  1 BEGIN
00093      1  1 IF fn.fcntype <> FCT 
00094      1  1  THEN raise ('FCNEVALNEARROOT: Function not in factored form');
00095      1  1 dist := BIG;
00096      1  1 root := complex(0,0);
00097      1  1 FOR i := 1 TO fn.ro.deg DO WITH fn.ro.f[i] DO
00098      1  2    BEGIN
00099      1  2    t := cabs (cadd (spt,v) );
00100      1  2    IF (t<dist) AND (t<>0d0) 
00101      1  2     THEN BEGIN dist := t;  root := cneg(v);  END;
00102      1  2    IF v.im <> 0
00103      1  2     THEN
00104      1  3      BEGIN
00105      1  3      t := cabs (cadd (spt,ccnj(v)) );
00106      1  3      IF (t<dist) AND (t<>0d0) 
00107      1  3       THEN BEGIN dist := t;  root := cneg(ccnj(v));  END;
00108      1  2      END;
00109      1  1    END;
00110      1  1 fcnevalnearroot := dist;

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00111      0  0 END;
00112   C  0  0 {-----------------------------------------------------------------------------}
00113      0  0 [ HIDDEN ]
00114      1  0 PROCEDURE gettoken (VAR token: VARYING [tokenmax] OF CHAR;  
00115      1  0    line : VARYING [linemax] OF CHAR;  VAR idx: integer);
00116   C  1  0 { Purpose -- Parse expression                                    }
00117   C  1  0 {            Parameter definitions :                             }
00118   C  1  0 {                 token  : output token, truncated if necessary. }
00119   C  1  0 {                 line   : string containing expression.         }
00120   C  1  0 {                 idx    : index in line.                        }
00121   C  1  0 {                                                                }
00122   C  1  0 {            A token consist of a                                }
00123   C  1  0 {                 NUL if at end of line                          }
00124   C  1  0 {                 A group of characters, all in alphanum + '.'   }
00125   C  1  0 {                 A number,folled by a 'D',etc,+1 or more char   }
00126   C  1  0 {                 A single character not in alphanum + '.'       }
00127      1  0 CONST
00128      1  0    alpha     = ['A'..'Z','_'];
00129      1  0    alphanum  = alpha + ['0'..'9'];
00130   C  1  0 {------------------------------}
00131      2  0 FUNCTION linechar (idx : integer) : char;
00132      2  1 BEGIN
00133      2  1 IF idx <= length(line)
00134      2  1  THEN linechar := line[idx]
00135      2  1  ELSE linechar := NUL;
00136      1  0 END;
00137   C  1  0 {------------------------------}
00138      2  0 FUNCTION getchar (VAR idx : integer) : char;
00139      2  1 BEGIN
00140      2  1 getchar := linechar(idx);
00141      2  1 idx := idx + 1;
00142      1  0 END;
00143   C  1  0 {------------------------------}
00144      1  1 BEGIN
00145      1  1 token := '';
00146      1  1 IF length(line) <> 0
00147      1  1  THEN
00148      1  1   WHILE linechar(idx) = ' ' DO getchar(idx);
00149      1  1 IF linechar(idx) IN (alphanum + ['.'])
00150      1  1  THEN
00151      1  2   BEGIN
00152      1  3   REPEAT
00153      1  3      token := token + getchar(idx);
00154      1  2      UNTIL NOT (linechar(idx) IN (alphanum + ['.']));
00155      1  2   IF (token[1] IN ['0'..'9','.']) 
00156      1  2        AND (token[length(token)] IN ['D','E','d','e'])
00157      1  2    THEN
00158      1  3     BEGIN
00159      1  3     IF linechar(idx) IN ['+','-'] THEN token := token + getchar(idx);  
00160      1  4     REPEAT
00161      1  4        token := token + getchar(idx);
00162      1  4        UNTIL NOT (linechar(idx) IN alphanum)
00163      1  2     END;
00164      1  2   END
00165      1  1  ELSE token := getchar(idx);

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00166      0  0 END;
00167   C  0  0 {-----------------------------------------------------------------------------}
00168      1  0 PROCEDURE evalfcnlist (VAR outlist : fcnlink;  
00169      1  0    string : VARYING [l1] OF char);
00170   C  1  0 { Purpose -- Evaluate a group of expressions separated by commas   }
00171   C  1  0 {            Results are returned as a linked list.                }
00172      1  0 CONST
00173      1  0    STACKSIZE         = 20;
00174      1  0 VAR
00175      1  0    i                 : integer;
00176      1  0    r                 : real;
00177      1  0    ipos,depth        : integer;
00178      1  0    token,funct       : anystring;
00179      1  0    substring         : VARYING [500] OF char;
00180      1  0    namestring        : VARYING [500] OF char;
00181      1  0    ptr,p1            : fcnlink;
00182      1  0    fn                : fcn;
00183      1  0    ptridx,opidx      : integer;
00184      1  0    ptrstack          : ARRAY [1..STACKSIZE] OF fcnlink;
00185      1  0    opstack           : ARRAY [0..STACKSIZE] OF char;
00186   C  1  0 {------------------------------------}
00187      2  0 PROCEDURE pushptr (ptrx : fcnlink);
00188   C  2  0 { Purpose -- Push function onto ptrstack }
00189      2  1 BEGIN
00190      2  1 IF ptridx >= STACKSIZE THEN raise ('Expression too complicated');
00191      2  1 ptridx := ptridx + 1;
00192      2  1 ptrstack[ptridx] := ptrx;
00193      1  0 END;
00194   C  1  0 {------------------------------------}
00195      2  0 PROCEDURE popptr (VAR ptrx : fcnlink);
00196   C  2  0 { Purpose -- Pop function from ptrstack }
00197      2  1 BEGIN
00198      2  1 IF ptridx = 0 
00199      2  1  THEN raise ('Evaluation stack underflow, probable syntax error');
00200      2  1 ptrx := ptrstack[ptridx];
00201      2  1 ptridx := ptridx - 1;
00202      1  0 END;
00203   C  1  0 {------------------------------------}
00204      2  0 PROCEDURE pushop (opx : char);
00205   C  2  0 { Purpose -- Push operator onto opstack }
00206      2  1 BEGIN
00207      2  1 IF opidx >= STACKSIZE THEN raise ('Expression too complicated');
00208      2  1 opidx := opidx + 1;
00209      2  1 opstack[opidx] := opx;
00210      1  0 END;
00211   C  1  0 {------------------------------------}
00212      2  0 PROCEDURE popop (VAR opx : char);
00213   C  2  0 { Purpose -- Pop operator from opstack }
00214      2  1 BEGIN
00215      2  1 IF opidx = 0 
00216      2  1  THEN raise ('Evaluation stack underflow, probable syntax error');
00217      2  1 opx := opstack[opidx];
00218      2  1 opidx := opidx - 1;
00219      1  0 END;
00220   C  1  0 {------------------------------------}

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00221      2  0 FUNCTION precidence (opx : char) : integer;
00222      2  1 BEGIN
00223   C  2  1 { Purpose -- Determine precidenc number of operator }
00224      2  2 CASE opx OF
00225      2  2    '^':      precidence := 3;
00226      2  2    '*','/':  precidence := 2;
00227      2  2    '+','-':  precidence := 1;
00228      2  2    ',',NUL:  precidence := 0;
00229      2  2    '_':      precidence := -1;
00230      2  2    OTHERWISE raise ('Illegal opcode, call program maintenance');
00231      2  1    END;
00232      1  0 END;
00233   C  1  0 {------------------------------------}
00234      2  0 PROCEDURE doop;
00235   C  2  0 { Purpose -- Execute operation, by popping two functions from    }
00236   C  2  0 {            ptrstack, one operator from opstack, and pushing    }
00237   C  2  0 {            result function onto ptrstack.  Except Add, in      }
00238   C  2  0 {            we do a whole mess, as many as we have.             }
00239   C  2  0 {--------------------}
00240      3  0 PROCEDURE doopplusminus;
00241      3  0 VAR
00242      3  0    ptrs          : ARRAY [1..20] OF fcnlink;
00243      3  0    op            : char;
00244      3  0    i,count,den   : integer;
00245      3  0    numgreater    : boolean;
00246      3  0    ptrout        : fcnlink;
00247   C  3  0 {---------------}
00248      4  0 PROCEDURE stackem;
00249      4  1 BEGIN
00250      4  1 count := count + 1;
00251      4  1 popptr (ptrs[count]);
00252      4  1 popop  (op);
00253      4  1 IF op = '-' THEN ptrs[count]^.gain := -ptrs[count]^.gain;
00254      4  1 IF ptrs[count]^.gain = 0 THEN count := count - 1;
00255      3  0 END;
00256   C  3  0 {---------------}
00257      3  1 BEGIN
00258   C  3  1 { UNLOAD STACK INTO ARRAYS }
00259      3  1 count := 0;
00260      3  2 REPEAT
00261      3  2    stackem;
00262      3  1    UNTIL NOT (opstack[opidx] IN ['+','-']);
00263      3  1 pushop ('+');
00264      3  1 stackem;
00265      3  1 
00266   C  3  1 { CHECK FOR DOING QZ }
00267      3  1 den := 0;
00268      3  1 numgreater := false;
00269      3  1 FOR i := 1 TO count DO
00270      3  2    BEGIN
00271      3  2    fcnnorm (ptrs[i]^);
00272      3  2    IF numord (ptrs[i]^) > denord (ptrs[i]^) THEN numgreater := true;
00273      3  2    den := den + denord (ptrs[i]^);
00274      3  1    END;
00275      3  1 

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00276   C  3  1 { DO ADDITION IN PROPER MANNER, THEN DISPOSE }
00277      3  1 new (ptrout);
00278      3  1 IF count = 1
00279      3  1  THEN
00280      3  2   BEGIN
00281      3  2   ptrout^ := ptrs[1]^;
00282      3  2   fcnnorm (ptrout^);
00283      3  2   END
00284      3  1 ELSE IF numgreater OR (den < QZaddcutoff)
00285      3  1  THEN
00286      3  2   BEGIN
00287      3  2   ptrout^ := fcnadd (ptrs[1]^,ptrs[2]^);
00288      3  2   FOR i := 3 TO count DO 
00289      3  2      ptrout^ := fcnadd (ptrout^,ptrs[i]^);
00290      3  2   fcnnorm (ptrout^);
00291      3  2   END
00292      3  1  ELSE 
00293      3  2   BEGIN
00294      3  2   fcnQZclear;
00295      3  2   FOR i := 1 TO count DO fcnQZadd (ptrs[i]^);
00296      3  2   ptrout^ := fcnQZresult;
00297      3  1   END;
00298      3  1 pushptr (ptrout);
00299      3  1 FOR i := 1 TO count DO dispose (ptrs[i]);
00300      2  0 END;
00301   C  2  0 {--------------------}
00302      3  0 PROCEDURE doopstarslash;
00303      3  0 VAR
00304      3  0    ptrout,ptr1,ptr2 : fcnlink;
00305      3  0    opx              : char;
00306      3  1 BEGIN
00307      3  1 popop (opx);
00308      3  1 popptr (ptr2);
00309      3  1 popptr (ptr1);
00310      3  1 new (ptrout);
00311      3  2 CASE opx OF
00312      3  2    '*':  ptrout^ := fcnmul (ptr1^,ptr2^);
00313      3  2    '/':  ptrout^ := fcndiv (ptr1^,ptr2^);
00314      3  1    END;
00315      3  1 pushptr (ptrout);
00316      3  1 dispose (ptr1);
00317      3  1 dispose (ptr2);
00318      2  0 END;
00319   C  2  0 {--------------------}
00320      3  0 PROCEDURE doopcaret;
00321      3  0 VAR
00322      3  0    i                : integer;
00323      3  0    ptrout,ptr1,ptr2 : fcnlink;
00324      3  0    opx              : char;
00325      3  1 BEGIN
00326      3  1 popop (opx);
00327      3  1 popptr (ptr2);
00328      3  1 popptr (ptr1);
00329      3  1 new (ptrout);
00330      3  1 IF ptr2^.plane <> 'K' 

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00331      3  1  THEN raise ('Constant function not found where expected');
00332      3  1 IF ptr2^.gain < 0 
00333      3  1  THEN raise ('Exponentiation to negative quantity');
00334      3  1 IF abs (roffcn(ptr2^) - round(roffcn(ptr2^))) > 0.01
00335      3  1  THEN raise ('Exponentiation to non-integer quantity');
00336      3  1 ptrout^ := onefcn;
00337      3  1 FOR i := 1 TO round(roffcn(ptr2^)) DO
00338      3  1    ptrout^ := fcnmul (ptrout^,ptr1^);
00339      3  1 pushptr (ptrout);
00340      3  1 dispose (ptr1);
00341      3  1 dispose (ptr2);
00342      2  0 END;
00343   C  2  0 {--------------------}
00344      2  1 BEGIN
00345      2  2 CASE opstack[opidx] OF
00346      2  2    '+',
00347      2  2    '-':  doopplusminus;
00348      2  2    '*',
00349      2  2    '/':  doopstarslash;
00350      2  2    '^':  doopcaret;
00351      2  2    OTHERWISE raise ('Illegal operator in expression');
00352      2  1    END;
00353      1  0 END;
00354   C  1  0 {------------------------------------}
00355      2  0 PROCEDURE gettok (VAR token: VARYING [tokenmax] OF CHAR);
00356      2  1 BEGIN
00357      2  1 gettoken (token,string,ipos);
00358      2  1 token := upcasestr (token);
00359      2  1 namestring := namestring + token;
00360      1  0 END;
00361   C  1  0 {------------------------------------}
00362      1  1 BEGIN
00363      1  1 ipos   := 1;
00364      1  1 ptridx := 0;
00365      1  1 opidx  := 0;
00366      1  1 opstack[0] := '_';
00367      1  1 outlist := NIL;
00368      1  1 namestring := '';
00369      1  2 REPEAT
00370      1  2    gettok (token);
00371      1  3    CASE token[1] OF
00372      1  4       '(':  BEGIN
00373      1  4             substring := '';
00374      1  4             depth := 1;
00375      1  5             REPEAT
00376      1  5                gettok (token);
00377      1  6                CASE token[1] OF
00378      1  6                   '(':  depth := depth+1;
00379      1  6                   ')':  depth := depth-1;
00380      1  6                   NUL:  raise ('")" not found, unbalanced parentheses');
00381      1  5                   END;
00382      1  5                IF depth > 0 THEN substring := substring + token;
00383      1  4                UNTIL depth = 0;
00384      1  4             evalfcnlist (ptr,substring);
00385      1  4             pushptr (ptr);

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00386      1  3             END;
00387      1  4       '$':  BEGIN
00388      1  4             gettok (funct);
00389      1  4             gettok (token);
00390      1  4             IF token[1] <> '(' THEN raise ('"(" not found where expected');
00391      1  4             substring := '';
00392      1  4             depth := 1;
00393      1  5             REPEAT
00394      1  5                gettok (token);
00395      1  6                CASE token[1] OF
00396      1  6                   '(':  depth := depth+1;
00397      1  6                   ')':  depth := depth-1;
00398      1  6                   NUL:  raise ('")" not found, unbalanced parentheses');
00399      1  5                   END;
00400      1  5                IF depth > 0 THEN substring := substring + token;
00401      1  4                UNTIL depth = 0;
00402      1  4             evalfcnlist (ptr,substring);
00403      1  4             oper_$eval (ptr,ptr,funct);
00404      1  4             pushptr (ptr);
00405      1  3             END;
00406      1  3       ')':  raise ('Syntax error');
00407      1  3       '+',
00408      1  4       '-':  BEGIN
00409      1  4             IF ptridx = 0 
00410      1  4              THEN  BEGIN  new(p1);  p1^ := fcnofr(0);  pushptr (p1);  END;
00411      1  4             WHILE precidence (opstack[opidx]) > precidence (token[1]) DO doop;
00412      1  4             pushop (token[1]);
00413      1  3             END;
00414      1  3       '*',
00415      1  3       '/',
00416      1  4       '^':  BEGIN
00417      1  4             WHILE precidence (opstack[opidx]) >= precidence (token[1]) DO doop;
00418      1  4             pushop (token[1]);
00419      1  3             END;
00420      1  3       NUL,
00421      1  4       ',':  BEGIN
00422      1  4             WHILE precidence (opstack[opidx]) >= precidence (token[1]) DO doop;
00423      1  4             IF ptridx <> 1 THEN raise ('Syntax error'); 
00424      1  4             popptr (ptr);
00425      1  4             ptr^.name := substr (namestring,1,
00426      1  4                                   imin(LOGICALNAMESIZE,length(namestring)-1));
00427      1  4             namestring := '';
00428      1  4             fcnlistinsert (outlist,ptr);
00429      1  3             END;
00430      1  3       OTHERWISE 
00431      1  4             BEGIN            
00432      1  4             new (ptr);
00433      1  4             r := rofstr ((token));
00434      1  4             IF      token = 'S'          THEN ptr^ := sfcn            
00435      1  4             ELSE IF token = 'Z'          THEN ptr^ := zfcn            
00436      1  4             ELSE IF token = 'W'          THEN ptr^ := wfcn            
00437      1  4             ELSE IF token = special.name THEN ptr^ := fcnofr(special.val)
00438      1  4             ELSE IF fcnexist (token)     THEN fcnsearch (ptr^,token)
00439      1  4             ELSE IF goodconvert          THEN ptr^ := fcnofr (r)
00440      1  4             ELSE raise ('Function "' + token + '" not found');

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

-LINE-IDC-PL-SL-

00441      1  4             IF ptr^.fcntype = DYN
00442      1  4              THEN
00443      1  5               BEGIN
00444      1  5               evalfcnlist (ptr,ptr^.val);
00445      1  5               IF fcnlistlength(ptr) > 1 
00446      1  5                THEN raise ('Unexpected comma found in dynamic function');
00447      1  4               END;
00448      1  4             pushptr (ptr);
00449      1  3             END;
00450      1  2       END;
00451      1  1    UNTIL token = NUL;
00452      0  0 END;
00453   C  0  0 {-----------------------------------------------------------------------------}
00454      0  0 [ GLOBAL ]
00455      1  0 FUNCTION evalfcn (string : VARYING [l1] OF char) : fcn;
00456   C  1  0 { Purpose -- Evaluate an expression                                }
00457   C  1  0 {            Result is returned as a newly defined function.       }
00458      1  0 VAR
00459      1  0    ptr : fcnlink;
00460      1  1 BEGIN
00461      1  1 evalfcnlist (ptr,string);
00462      1  1 IF ptr = NIL THEN raise ('No function name found where expected');
00463      1  1 IF fcnlistlength(ptr) > 1 THEN raise ('Comma found where not expected');
00464      1  1 evalfcn := ptr^;
00465      1  1 dispose (ptr);
00466      0  0 END;
00467   C  0  0 {=============================================================================}
00468      0  0 END.

FCNEVAL                                                         23-Dec-1988 10:47:00    VAX Pascal V3.7-254                Page   10
INCA                            Pascal Compilation Statistics   29-Mar-1988 15:20:09    DUA1:[QPLOT.INCA.SOURCE]FCNEVAL.PAS;20 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                8463  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                                 30  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        46        37
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        10         5
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         6        10
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        10        14
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        37        60
DUA1:[QPLOT.INCA.SOURCE]FCNOPER.PEN;1                    114        79        69
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248       120        48
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163         0         0
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         3         4



FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:DIRECTORY',
00004      0  0                'QLIBHOME:IO',
00005      0  0                'QLIBHOME:MATH',
00006      0  0                'QLIBHOME:STRING',
00007      0  0                'QLIBHOME:COMPLEX',
00008      0  0                'QLIBHOME:IOBASE',
00009      0  0                'FCN','POLYMATH','LONGREAL'), 
00010      0  0   ENVIRONMENT ('FCNIO')]
00011      0  0 MODULE fcnio;
00012   C  0  0 { Purpose -- This module provides I/O for the fcn data type.    }
00013   C  0  0 {=============================================================================}
00014      0  0 [ GLOBAL ]
00015      1  0 FUNCTION strofc (z : complex;  width : integer) : anystring;
00016   C  1  0 { Purpose -- Generate a string that represents an complex number.     }
00017   C  1  0 {            Default width is given by the global fieldwidth.         }
00018   C  1  0 {            But actual width is (width * 2) + 8                      }
00019      1  0 VAR
00020      1  0    out    : anystring;
00021      1  1 BEGIN
00022      1  1 IF width = 0 THEN width := fieldwidth;
00023      1  1 IF z.re >= 0
00024      1  1  THEN out := '+'
00025      1  1  ELSE out := '-';
00026      1  1 out := out + strofr (abs(z.re),width);
00027      1  1 IF z.im = 0
00028      1  1  THEN out := out + pad ('',' ',width+5)
00029      1  1 ELSE IF z.im < 0
00030      1  1  THEN out := out + ' - j*' + strofr (-z.im,width)
00031      1  1  ELSE out := out + ' + j*' + strofr ( z.im,width);
00032      1  1 strofc := out;
00033      0  0 END;
00034   C  0  0 {=============================================================================}
00035   C  0  0 {-- FUNCTION READ PROCEDURES -------------------------------------------------}
00036   C  0  0 {=============================================================================}
00037      1  0 PROCEDURE readfcn (VAR filein : text;  VAR fn : fcn);
00038      1  0 VAR
00039      1  0    string : VARYING [132] OF char;
00040   C  1  0 {-------------------------------------}
00041      2  0 PROCEDURE readcspoly (VAR c : cspoly;  numerator : boolean);
00042      2  0 VAR
00043      2  0    j,width : integer;
00044      2  0    cnt     : integer;
00045      2  0    z       : complex;
00046      2  1 BEGIN
00047      2  1 readline (filein,string);  
00048      2  1 cnt := iofstr (substr(string,16,3));
00049      2  1 FOR j := c.deg + 1 TO c.deg + cnt DO 
00050      2  2    BEGIN
00051      2  2    readline (filein,string);  
00052      2  2    width := (index (string,'O') - 18) DIV 2;
00053      2  2    z.re := rofstr (substr(string,8,width));
00054      2  2    z.im := rofstr (substr(string,width+13,width));
00055      2  2    IF string[7]       = '-' THEN z.re := -z.re;

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00056      2  2    IF string[9+width] = '-' THEN z.im := -z.im;
00057      2  2    z := cneg (z);
00058      2  2    IF z.im >= 0
00059      2  2     THEN
00060      2  3      BEGIN
00061      2  3      c.deg := c.deg + 1;
00062      2  3      WITH c.f[c.deg] DO
00063      2  4         BEGIN
00064      2  4         v := z;
00065      2  4         IF numerator
00066      2  4          THEN p := iofstr (substr(string,2*width+25,3))
00067      2  4          ELSE p :=-iofstr (substr(string,2*width+25,3));
00068      2  3         END;
00069      2  2      END;
00070      2  1    END;
00071      2  1 readline (filein,string);
00072      1  0 END;   
00073   C  1  0 {-------------------------------------}
00074      1  1 BEGIN
00075      1  1 readline (filein,string);
00076      1  1 readline (filein,string);
00077      1  1 readline (filein,string);
00078      1  1 fn.name := substr (string,18,length(string)-17);
00079      1  1 readline (filein,string);
00080      1  1 readline (filein,string);
00081      1  1 fn.time    := substr(string,32,24);
00082      1  1 readline (filein,string);
00083      1  1 fn.comment := substr(string,10,length(string)-9);
00084      1  1 readline (filein,string);
00085      1  1 readline (filein,string);
00086      1  2 CASE string[1] OF
00087      1  3    'R':  BEGIN
00088      1  3          fn.fcntype := FCT;
00089      1  3          readline (filein,string);
00090      1  3          fn.plane := string[18];
00091      1  3          readline (filein,string);
00092      1  3          fn.gain := lofstr (substr(string,8,length(string)-7));
00093      1  3          IF fn.plane IN ['Z','W']
00094      1  3           THEN
00095      1  4            BEGIN
00096      1  4            readline (filein,string);
00097      1  4            fn.tau := rofstr (substr(string,17,length(string)-16));
00098      1  3            END;
00099      1  3          readline (filein,string);
00100      1  3          fn.ro.deg := 0;
00101      1  3          readcspoly (fn.ro,true);
00102      1  3          readcspoly (fn.ro,false);
00103      1  3          readline (filein,string);
00104      1  2          END;
00105      1  3    'D':  BEGIN
00106      1  3          fn.fcntype := DYN;
00107      1  3          readline (filein,string);
00108      1  3          fn.val := '';
00109      1  4          REPEAT
00110      1  4             readline (filein,string);

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00111      1  4             fn.val := fn.val + string;
00112      1  3             UNTIL string = '';
00113      1  3          readline (filein,string);
00114      1  2          END;
00115      1  1    END;
00116      1  1 fcnnorm (fn);
00117      0  0 END;
00118   C  0  0 {=============================================================================}
00119   C  0  0 {-- FUNCTION PRINT PROCEDURES ------------------------------------------------}
00120   C  0  0 {=============================================================================}
00121      1  0 PROCEDURE writesumfcn (dest : destination;  VAR fn : fcn);
00122      1  0 VAR
00123      1  0    i,nr,dr,nc,dc  : integer;
00124      1  0    st             : anystring;
00125      1  1 BEGIN
00126      1  1 st := strfix (fn.name,10);
00127      1  1 
00128      1  2 CASE fn.fcntype OF
00129      1  3    FCT:  BEGIN
00130      1  3          nr := 0;  nc := 0;  dr := 0;  dc := 0;
00131      1  3          FOR i := 1 TO fn.ro.deg DO 
00132      1  3             WITH fn.ro.f[i] DO
00133      1  3                IF p > 0
00134      1  3                 THEN IF v.im=0 THEN nr:=nr+p ELSE nc := nc+2*p
00135      1  3                 ELSE IF v.im=0 THEN dr:=dr-p ELSE dc := dc-2*p;
00136      1  3          st := st + ' ' + fn.plane + ' ' + strofl (fn.gain,15);
00137      1  3          IF fn.plane = 'K'
00138      1  3           THEN st := st + '                 '
00139      1  3           ELSE st := st + '  <' + strofi (nr,2) 
00140      1  3                         + '+'   + strfix (stripblank (strofi(nc,2)),2)
00141      1  3                         + '/'   + strofi (dr,2) 
00142      1  3                         + '+'   + strfix (stripblank (strofi(dc,2)),2)
00143      1  3                         + '>  ';
00144      1  3          st := st + '"' + fn.comment + '"';
00145      1  2          END;
00146      1  3    DYN:  BEGIN
00147      1  3          st := strtrunc (st + ' := ' + fn.val,255);
00148      1  4          CASE dest OF
00149      1  4             both,
00150      1  4             temp,
00151      1  4             out:  IF length(st) > 80 THEN st := strfix (st,77) + '...';
00152      1  4             aud:  IF length(st) > 132 THEN st := strfix (st,129) + '...';
00153      1  3             END;
00154      1  2          END;
00155      1  1    END;
00156      1  1 writeline (dest,strtrunc (st,79));
00157      0  0 END;
00158   C  0  0 {-----------------------------------------------------------------------------}
00159      1  0 PROCEDURE writecpolyfactor (dest : destination;  plane : char;  
00160      1  0    v : cpoly;  i : integer;  format : char);
00161      1  0 VAR
00162      1  0    strre,strim : VARYING  [8] OF char;
00163      1  0    str12       : VARYING [12] OF char;
00164      1  0    zeta,omega  : real;
00165      1  1 BEGIN

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00166      1  2 CASE format OF
00167      1  2    'R':  writeline (dest,'  ' + plane + '=  ' + strofc(cneg(v.f[i]),0) 
00168      1  2            + '     Order = ' + strofi(v.p[i],2));
00169      1  3    'G':  BEGIN
00170      1  3          str12 := strofr (-v.f[i].re,12);
00171      1  3          IF str12[9] = ' ' 
00172      1  3           THEN strre := substr (str12,1,8)
00173      1  3           ELSE strre := strofr (-v.f[i].re,8);
00174      1  3          str12 := strofr (-v.f[i].im,12);
00175      1  3          IF v.f[i].im = 0
00176      1  3           THEN strim := '        '
00177      1  3          ELSE IF str12[9] = ' '
00178      1  3           THEN strim := substr (str12,1,8)
00179      1  3           ELSE strim := strofr (-v.f[i].im,8);
00180      1  3          writeline (dest,strre + ' ' + strim + strofi(v.p[i],3));
00181      1  2          END;
00182      1  2    'F':  writeline (dest,'  (' + plane + strofc(v.f[i],0) 
00183      1  2            + ')  **  ' + strofi(v.p[i],2));
00184      1  2    'B':  IF cabs (v.f[i]) <> 0
00185      1  2           THEN writeline (dest,'  (1 + ' + plane + ' / (' + strofc(v.f[i],0)
00186      1  2               + ')  **  ' + strofi(v.p[i],2))
00187      1  2           ELSE writeline (dest,'  (' + plane + '        ' + strofc(v.f[i],0) 
00188      1  2               + ')  **  ' + strofi(v.p[i],2));
00189      1  2    'Z':  IF v.f[i].im = 0
00190      1  2           THEN writeline (dest,'  Lam. =' + strofr(v.f[i].re,0) 
00191      1  2                  + pad('',' ',fieldwidth+9) + 'Order = ' + strofi(v.p[i],6))
00192      1  2           ELSE
00193      1  3            BEGIN
00194      1  3            omega := cabs(v.f[i]);
00195      1  3            zeta  := v.f[i].re / omega;
00196      1  3            writeline (dest,'  Zeta =' + strofr(zeta,0) 
00197      1  3              + ' Omega =' + strofr(omega,0)
00198      1  3              + ' Order = ' + strofi(v.p[i],6));
00199      1  2            END;
00200      1  2    'P':  writeline (dest,'  Mag. =' + strofr(cabs(v.f[i]),0) 
00201      1  2            + ' Rad. =' + strofr(angle(cneg(v.f[i])),0)
00202      1  2            + ' Order = ' + strofi(v.p[i],6));
00203      1  2    'D':  writeline (dest,'  Mag. =' + strofr(cabs(v.f[i]),0) 
00204      1  2            + ' Deg. =' + strofr(angle(cneg(v.f[i]))*180/PI,0)
00205      1  2            + ' Order = ' + strofi(v.p[i],6));
00206      1  1    END;
00207      0  0 END;
00208   C  0  0 {-----------------------------------------------------------------------------}
00209      1  0 PROCEDURE writecpoly (dest : destination;  nstr : VARYING [l2] OF char;
00210      1  0    plane : char;  v : cpoly;  format : char);
00211      1  0 VAR
00212      1  0    i       : integer;
00213      1  1 BEGIN
00214      1  1 writeline (dest,'');
00215      1  1 IF format = 'G' 
00216      1  1  THEN 
00217      1  2   BEGIN
00218      1  2   writeline (dest,nstr + ' roots');
00219      1  2   writeline (dest,'  REAL     IMAG  ORD');
00220      1  2   END

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00221      1  1 ELSE IF format IN ['B','F']
00222      1  1  THEN writeline (dest,nstr + ' has ' + strofi(v.deg,2) + ' distinct factors:')
00223      1  1  ELSE writeline (dest,nstr + ' has ' + strofi(v.deg,2) + ' distinct roots:');
00224      1  1 FOR i := 1 TO v.deg DO
00225      1  1    writecpolyfactor (dest,plane,v,i,format);
00226      0  0 END;
00227   C  0  0 {-----------------------------------------------------------------------------}
00228      1  0 PROCEDURE writeupolycoef (dest : destination;  plane : char;  
00229      1  0    u : upoly;  i : integer);
00230      1  1 BEGIN
00231      1  1 writestring (dest,'  ' + strofr(u.c[i],0));
00232      1  1 IF i = 0
00233      1  1  THEN 
00234      1  1 ELSE IF i = 1
00235      1  1  THEN writestring (dest,' * ' + plane)
00236      1  1  ELSE writestring (dest,' * ' + plane + ' ** ' + strofi(i,2));
00237      1  1 writeline (dest,'');
00238      0  0 END;
00239   C  0  0 {-----------------------------------------------------------------------------}
00240      1  0 PROCEDURE writeupoly (dest : destination;  nstr : VARYING [l2] OF char;
00241      1  0    plane : char;  u : upoly);
00242      1  0 VAR
00243      1  0    i       : integer;
00244      1  1 BEGIN
00245      1  1 writeline (dest,'');
00246      1  1 writeline (dest,'The degree of the ' + nstr + ' is ' + strofi(u.deg,2));
00247      1  1 FOR i := u.deg DOWNTO 0 DO
00248      1  1    writeupolycoef (dest,plane,u,i);
00249      0  0 END;
00250   C  0  0 {-----------------------------------------------------------------------------}
00251      0  0 [ HIDDEN ]
00252      1  0 PROCEDURE writepfepoly (dest : destination;  VAR pfe : pfepoly;  plane : char;
00253      1  0    planeinnum : boolean);
00254      1  0 VAR
00255      1  0    i      : integer;
00256      1  1 BEGIN
00257      1  1 writeline (dest,pad('','*',fieldwidth*2+16));
00258      1  1 FOR i := 1 TO pfe.deg DO
00259      1  2    BEGIN
00260      1  2    writeline (dest,'');
00261      1  2    IF planeinnum
00262      1  2     THEN writeline (dest,'   ' + strofc(pfe.t[i].v,0) + ' * ' + plane)
00263      1  2     ELSE writeline (dest,'     ' + strofc(pfe.t[i].v,0));
00264      1  2    writeline (dest,pad('','-',fieldwidth*2+16));
00265      1  2    writeline (dest,'(' + plane + '   ' + strofc(pfe.t[i].f,0)  
00266      1  2       + ')**' + strofi(pfe.t[i].p,2));
00267      1  2    writeline (dest,'');
00268      1  2    writeline (dest,pad('','*',fieldwidth*2+16));
00269      1  1    END;
00270      0  0 END;
00271   C  0  0 {-----------------------------------------------------------------------------}
00272      1  0 PROCEDURE writefcn (dest : destination;  fn : fcn;  format : char);
00273      1  0 VAR
00274      1  0    i      : integer;
00275      1  0    nu,de  : cpoly;

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00276      1  0    u      : upoly;
00277      1  1 BEGIN
00278   C  1  1 { FIX UP FUNCTION }
00279      1  1 fcnnorm (fn);
00280      1  1 IF format = 'B'  THEN fn := bodefcnofnumfcn (fn);
00281      1  1 
00282   C  1  1 { WRITE TOP SPACER }
00283      1  1 IF format <> 'G' THEN writeline (dest,pad('','-',78));
00284      1  1 writeline (dest,'');
00285      1  1 
00286   C  1  1 { WRITE HEADING }
00287      1  1 IF format = 'G'
00288      1  1  THEN writeline (dest,'FCN=' + fn.name)
00289      1  1  ELSE
00290      1  2   BEGIN
00291      1  2   writeline (dest,'Function name  = ' + fn.name);
00292      1  2   writeline (dest,'Storage requirements           ' + strofi (fn.storage,6));
00293      1  2   writeline (dest,'Function last modified on      ' + fn.time);
00294      1  2   writeline (dest,'Comment: ' + fn.comment);
00295      1  1   END;
00296      1  1 IF format <> 'G' THEN writeline (dest,'');
00297      1  1 
00298   C  1  1 { WRITE FUNCTION BODY }
00299      1  2 CASE fn.fcntype OF
00300      1  3    FCT:  BEGIN
00301      1  4          CASE format OF
00302      1  4             'R':  writeline (dest,'ROOTED FORM');
00303      1  4             'G':  ;
00304      1  4             'F':  writeline (dest,'FACTORED FORM');
00305      1  4             'B':  writeline (dest,'BODEGAIN_FACTORED FORM');
00306      1  4             'Z':  writeline (dest,'ZETA_OMEGA FORM');
00307      1  4             'P':  writeline (dest,'POLAR FORM');
00308      1  4             'D':  writeline (dest,'DEGREE_POLAR FORM');
00309      1  4             'U':  writeline (dest,'UNFACTORED FORM');
00310      1  4             'E':  writeline (dest,'PARTIAL FRACTION FORM');
00311      1  3             END;
00312      1  3          IF format = 'G'
00313      1  3           THEN writeline (dest,'Plane = ' + fn.plane)
00314      1  3           ELSE writeline (dest,'Function plane = ' + fn.plane);
00315      1  4          CASE format OF
00316      1  4             'R','F','Z','P','B',
00317      1  4             'D':  writeline (dest,'Gain = ' + strofl (fn.gain,0));
00318      1  4             'G':  writeline (dest,'Gain = ' + strofl (fn.gain,15));
00319      1  3             END;
00320      1  4          CASE fn.plane OF
00321      1  4             'K','S':  ;
00322      1  4             'Z','W':  IF format = 'G'
00323      1  4                        THEN writeline (dest,'S.P. = ' + strofr(fn.tau,13))
00324      1  4                        ELSE writeline (dest,'Sample Period = '+strofr(fn.tau,0));
00325      1  3             END;
00326      1  4          CASE format OF
00327      1  4             'R','F','Z','P','B','D',
00328      1  5             'G':  BEGIN
00329      1  5                   cpolysfromcspoly (nu,de,fn.ro);
00330      1  5                   writecpoly (dest,'Numerator  ',fn.plane,nu,format);

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00331      1  5                   writecpoly (dest,'Denominator',fn.plane,de,format);
00332      1  4                   END;
00333      1  5             'U':  BEGIN
00334      1  5                   cpolysfromcspoly (nu,de,fn.ro);
00335      1  5                   upolyfromcpoly (u,nu,fn.gain);
00336      1  5                   writeupoly (dest,'numerator',fn.plane,u);
00337      1  5                   upolyfromcpoly (u,de,1);
00338      1  5                   writeupoly (dest,'denominator',fn.plane,u);
00339      1  4                   END;
00340      1  5             'E':  CASE fn.plane OF
00341      1  6                      'K','S','W':  BEGIN
00342      1  6                                    fn := fcnPARofFCT (fn);
00343      1  6                                    writepfepoly (dest,fn.pfe,fn.plane,false);
00344      1  5                                    END;
00345      1  6                      'Z':          BEGIN
00346      1  6                                    fn := fcnPARofFCT (fcndiv (fn,zfcn));
00347      1  6                                    writepfepoly (dest,fn.pfe,fn.plane,true);
00348      1  5                                    END;
00349      1  4                      END;
00350      1  3             END;
00351      1  2          END;
00352      1  3    DYN:  BEGIN
00353      1  3          writeline (dest,'DYNAMIC FUNCTION');
00354      1  3          writeline (dest,'');
00355      1  3          i := 0;
00356      1  3          WHILE i < length(fn.val) DO
00357      1  4             BEGIN
00358      1  4             writeline (dest,substr (fn.val,i+1,imin (78,length(fn.val)-i)));
00359      1  4             i := i + 78;
00360      1  3             END;
00361      1  2          END;
00362      1  1    END;
00363      1  1 
00364   C  1  1 { WRITE BOTTOM SPACER }
00365      1  1 writeline (dest,'');
00366      1  1 IF format <> 'G' THEN writeline (dest,pad('','-',78));
00367      0  0 END;
00368   C  0  0 {-----------------------------------------------------------------------------}
00369      1  0 PROCEDURE checkandinsertfunction (VAR fn : fcn);
00370      1  1 BEGIN
00371      1  1 fcnnorm (fn);
00372      1  1 writefcn (aud,fn,'F');
00373      1  1 IF fcnexist (fn.name) THEN deletefcn (fn.name);
00374      1  1 fcninsert (fn);
00375      1  1 IF source = 0 THEN writeproject (project);
00376      0  0 END;
00377   C  0  0 {-----------------------------------------------------------------------------}
00378      1  0 PROCEDURE selectfunction (VAR sel : command_type;  allispossible : boolean;
00379      1  0    newispossible : boolean);
00380      1  0 VAR
00381      1  0    fn : fcn;
00382      1  1 BEGIN
00383      1  1 startfcnget;
00384      1  1 IF endoffcnget AND NOT newispossible
00385      1  1  THEN 

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00386      1  2   BEGIN
00387      1  2   sel := '';
00388      1  2   writeline (out,'No functions currently exist');
00389      1  2   pause;
00390      1  2   END
00391      1  1  ELSE
00392      1  2   BEGIN
00393      1  2   startcommand ('Function Selection',false);
00394      1  2   IF allispossible THEN setcommand ('All');
00395      1  2   IF newispossible THEN setcommand ('New');
00396      1  2   WHILE NOT endoffcnget DO
00397      1  3      BEGIN
00398      1  3      fcnget (fn);
00399      1  3      setcommand (fn.name);
00400      1  2      END;
00401      1  2   readcommand (sel,ESC,false,'FUNCTION');
00402      1  2   IF (sel = ESC) OR (sel = ' ') THEN sel := '';
00403      1  1   END;
00404      0  0 END;
00405   C  0  0 {-----------------------------------------------------------------------------}
00406      1  0 PROCEDURE selectproject (VAR sel : command_type;  newispossible : boolean);
00407      1  0 VAR
00408      1  0    st : anystring;
00409      1  1 BEGIN
00410      1  1 startfilesearch ('*.PRO');
00411      1  1 IF endoffilesearch
00412      1  1  THEN
00413      1  2   BEGIN
00414      1  2   sel := '';
00415      1  2   writeline (out,'No projects currently exist');
00416      1  2   pause;
00417      1  2   END
00418      1  1  ELSE
00419      1  2   BEGIN
00420      1  2   startcommand ('Project Selection',false);
00421      1  2   IF newispossible THEN setcommand ('New');
00422      1  2   WHILE NOT endoffilesearch DO
00423      1  3      BEGIN
00424      1  3      filesearch (st);
00425      1  3      setcommand (fs.name);
00426      1  2      END;
00427      1  2   readcommand (sel,ESC,false,'PROJECT');
00428      1  2   IF (sel = ESC) OR (sel = ' ') THEN sel := '';
00429      1  1   END;
00430      0  0 END;
00431   C  0  0 {-----------------------------------------------------------------------------}
00432      1  0 PROCEDURE showproject (dest : destination);
00433      1  0 VAR
00434      1  0    arg     : anystring;
00435      1  0    count   : integer;
00436      1  0    fn      : fcn;
00437      1  1 BEGIN
00438      1  1 writeline (dest,'Project ' + project);
00439      1  1 writeline (dest,'');
00440      1  1 startfcnget;

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00441      1  1 count := 0;
00442      1  1 WHILE NOT endoffcnget DO
00443      1  2    BEGIN
00444      1  2    fcnget (fn);
00445      1  2    writesumfcn (dest,fn);
00446      1  2    count := count + 1;
00447      1  1    END;
00448      1  1 writeline (dest,'');
00449      1  1 writeline (dest,'There are ' + strofi(count,3) + ' Functions defined');
00450      0  0 END;
00451   C  0  0 {-----------------------------------------------------------------------------}
00452      1  0 PROCEDURE showfunction (dest : destination);
00453      1  0 VAR
00454      1  0    form    : command_type;
00455      1  0    sel     : command_type;
00456      1  0    arg     : anystring;
00457      1  0    found   : boolean;
00458      1  0    fn      : fcn;
00459      1  1 BEGIN
00460      1  1 startcommand ('FORMAT selection',true);
00461      1  1 setcommand ('Bodegain_Factored');
00462      1  1 setcommand ('Degree_Polar');
00463      1  1 setcommand ('Expand_Part_Fract');
00464      1  1 setcommand ('Factored');
00465      1  1 setcommand ('No_Evaluation');
00466      1  1 setcommand ('Polar');
00467      1  1 setcommand ('Roots');
00468      1  1 setcommand ('Summary');
00469      1  1 setcommand ('Unfactored');
00470      1  1 setcommand ('Zeta_Omega');
00471      1  1 readcommand (form,'N',false,'FUNCTION VIEW');
00472      1  1 
00473      1  1 IF form <> ESC
00474      1  1  THEN
00475      1  2   BEGIN
00476      1  2   selectfunction (sel,true,false);
00477      1  2   IF sel <> ''
00478      1  2    THEN
00479      1  3     BEGIN
00480      1  3     found := false;
00481      1  3     startfcnget;
00482      1  3     WHILE NOT endoffcnget DO
00483      1  4        BEGIN
00484      1  4        fcnget (fn);
00485      1  4        IF (sel = 'All') OR (sel = fn.name)
00486      1  4         THEN
00487      1  5          BEGIN
00488      1  6          CASE chofcom(form) OF
00489      1  6             'N':  writefcn (dest,fn,'R');
00490      1  6             'S':  writesumfcn (dest,fn);
00491      1  6             'R','F','B','Z','P','U','E',
00492      1  7             'D':  BEGIN
00493      1  7                   fn := fcnFCTofany (fn);
00494      1  7                   writefcn   (dest,fn,chofcom(form));
00495      1  6                   END;

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                  31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

-LINE-IDC-PL-SL-

00496      1  5             END;
00497      1  5          found := true;
00498      1  4          END;
00499      1  3        END;
00500      1  3     writeline (dest,'');
00501      1  3     IF NOT found THEN writeline (dest,'Function not found: ' + sel);
00502      1  3     IF dest = out THEN pause;
00503      1  2     END;
00504      1  1   END;
00505      0  0 END;
00506   C  0  0 {=============================================================================}
00507      0  0 END.

FCNIO                                                           23-Dec-1988 10:48:09    VAX Pascal V3.7-254                Page   11
INCA                            Pascal Compilation Statistics   31-Mar-1988 08:55:15    DUA1:[QPLOT.INCA.SOURCE]FCNIO.PAS;81 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               16127  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        36        29
DUA1:[QPLOT.QPLOT.SOURCE]DIRECTORY.PEN;1                  45        34        76
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        40        20
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         3         5
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        36        50
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62        13        21
DUA1:[QPLOT.QPLOT.SOURCE]IOBASE.PEN;1                    104         9         9
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248       107        43
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        35        21
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67        11        16



OLDFCN                                                          23-Dec-1988 10:49:42    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  29-Jul-1987 15:45:09    DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PAS;35 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:GENERAL',
00004      0  0                'QLIBHOME:IO',
00005      0  0                'QLIBHOME:STRING',
00006      0  0                'QLIBHOME:COMPLEX',
00007      0  0                'QLIBHOME:IOBASE',
00008      0  0                'LONGREAL','POLYMATH','FCN'),
00009      0  0   ENVIRONMENT ('OLDFCN')]
00010      0  0 MODULE oldfcn (fcnfile);
00011   C  0  0 {=============================================================================}
00012      0  0 TYPE
00013      0  0    name_type    = VARYING [30] OF char;
00014      0  0    oldcpoly     = RECORD
00015      0  0                   deg     : integer;
00016      0  0                   f       : ARRAY [1..100] OF complex;
00017      0  0                   p       : ARRAY [1..100] OF integer;
00018      0  0                   END;
00019      0  0    oldfcn       = RECORD
00020      0  0                   name    : name_type;     { NAME OF FUNCTION }
00021      0  0                   project : name_type;     { PROJECT NAME }
00022      0  0                   creation: RECORD         { DATE, TIME, METHOD OF CREATION }
00023      0  0                             date,time  : PACKED ARRAY [1..11] OF char;
00024      0  0                             method     : VARYING [40] OF char;
00025      0  0                             END;
00026      0  0                   modified: RECORD         { DATE, TIME, METHOD LAST MODIFIED }
00027      0  0                             date,time  : PACKED ARRAY [1..11] OF char;
00028      0  0                             method     : VARYING [40] OF char;
00029      0  0                             END;
00030      0  0                   comment : VARYING [80] OF char;
00031   C  0  0                   {---------------------------------------------------------}
00032      0  0                   plane   : char;          { K,S,Z,W; PLANE OF FUNCTION }
00033      0  0                   tau     : real;          { SAMPLING PERIOD (Z,W PLANE ONLY) }
00034      0  0                   gain    : real;          { GAIN OF FUNCTION }
00035   C  0  0                   {---------------------------------------------------------}
00036      0  0                   nu,de   : oldcpoly;      { NUMERATOR & DENOMINATOR }
00037      0  0                   nextfcn : integer;       { DUMMY LINK TO NEXT FUNCTION }
00038      0  0                   END;
00039      0  0 VAR
00040      0  0    fcnfile      : FILE of oldfcn;
00041   C  0  0 {=============================================================================}
00042   C  0  0 {-- OLDFCN CONVERSION PROCEDURES ---------------------------------------------}
00043   C  0  0 {=============================================================================}
00044      1  0 PROCEDURE readoldfcn (VAR filein : text;  VAR fn : oldfcn);
00045      1  0 VAR
00046      1  0    string : VARYING [132] OF char;
00047   C  1  0 {-------------------------------------}
00048      2  0 PROCEDURE readoldcpoly (VAR v : oldcpoly);
00049      2  0 VAR
00050      2  0    j,width : integer;
00051      2  1 BEGIN
00052      2  1 readline (filein,string);  
00053      2  1 v.deg := iofstr (substr(string,16,3));
00054      2  1 FOR j := 1 TO v.deg DO
00055      2  2    BEGIN

OLDFCN                                                          23-Dec-1988 10:49:42    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  29-Jul-1987 15:45:09    DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PAS;35 (1)

-LINE-IDC-PL-SL-

00056      2  2    readline (filein,string);  
00057      2  2    width := (index (string,'O') - 18) DIV 2;
00058      2  2    v.f[j].re := rofstr (substr(string,8,width));
00059      2  2    v.f[j].im := rofstr (substr(string,width+13,width));
00060      2  2    IF string[7]       = '-' THEN v.f[j].re := -v.f[j].re;
00061      2  2    IF string[9+width] = '-' THEN v.f[j].im := -v.f[j].im;
00062      2  2    v.f[j] := cneg (v.f[j]);
00063      2  2    v.p[j] := iofstr (substr(string,2*width+25,3));
00064      2  1    END;
00065      2  1 readline (filein,string);
00066      1  0 END;   
00067   C  1  0 {-------------------------------------}
00068      1  1 BEGIN
00069      1  1 readline (filein,string);
00070      1  1 readline (filein,string);
00071      1  1 readline (filein,string);
00072      1  1 fn.name := substr (string,18,length(string)-17);
00073      1  1 readline (filein,string);
00074      1  1 readline (filein,string);
00075      1  1 fn.project := substr(string,32,length(string)-31);
00076      1  1 readline (filein,string);
00077      1  1 fn.creation.date := substr(string,32,11);
00078      1  1 fn.creation.time := substr(string,45,11);
00079      1  1 readline (filein,string);
00080      1  1 fn.creation.method := substr(string,32,length(string)-31);
00081      1  1 readline (filein,string);
00082      1  1 fn.modified.date := substr(string,32,11);
00083      1  1 fn.modified.time := substr(string,45,11);
00084      1  1 readline (filein,string);
00085      1  1 fn.modified.method := substr(string,32,length(string)-31);
00086      1  1 readline (filein,string);
00087      1  1 fn.comment := substr(string,10,length(string)-9);
00088      1  1 readline (filein,string);
00089      1  1 readline (filein,string);
00090      1  1 readline (filein,string);
00091      1  1 fn.plane := string[18];
00092      1  1 readline (filein,string);
00093      1  1 fn.gain := rofstr (substr(string,8,length(string)-7));
00094      1  1 IF fn.plane IN ['Z','W']
00095      1  1  THEN
00096      1  2   BEGIN
00097      1  2   readline (filein,string);
00098      1  2   fn.tau := rofstr (substr(string,8,length(string)-7));
00099      1  1   END;
00100      1  1 readline (filein,string);
00101      1  1 readoldcpoly (fn.nu);
00102      1  1 readoldcpoly (fn.de);
00103      1  1 readline (filein,string);
00104      0  0 END;
00105   C  0  0 {-----------------------------------------------------------------------------}
00106      1  0 FUNCTION fcnofoldfcn (VAR old : oldfcn) : fcn;
00107      1  0 VAR
00108      1  0    i     : integer;
00109      1  0    nu,de : cpoly;
00110      1  0    out   : fcn;

OLDFCN                                                          23-Dec-1988 10:49:42    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  29-Jul-1987 15:45:09    DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PAS;35 (1)

-LINE-IDC-PL-SL-

00111      1  1 BEGIN
00112      1  1 out.name    := old.name;
00113      1  1 IF old.modified.time = '           '
00114      1  1  THEN out.time    := old.creation.date + '  ' + old.creation.time
00115      1  1  ELSE out.time    := old.modified.date + '  ' + old.modified.time;
00116      1  1 out.comment := old.comment;
00117      1  1 out.nextfcn := NIL;
00118      1  1 out.storage := size (fcn);
00119      1  1 out.fcntype := FCT;
00120      1  1 out.plane   := old.plane;
00121      1  1 out.gain    := old.gain;
00122      1  1 out.tau     := old.tau;
00123      1  1 nu.deg := old.nu.deg;
00124      1  1 FOR i := 1 TO nu.deg DO 
00125      1  2    BEGIN
00126      1  2    nu.f[i] := old.nu.f[i];
00127      1  2    nu.p[i] := old.nu.p[i];
00128      1  1    END;
00129      1  1 de.deg := old.de.deg;
00130      1  1 FOR i := 1 TO de.deg DO 
00131      1  2    BEGIN
00132      1  2    de.f[i] := old.de.f[i];
00133      1  2    de.p[i] := old.de.p[i];
00134      1  1    END;
00135      1  1 cspolyfromcpolys (out.ro,nu,de);
00136      1  1 fcnnorm (out);
00137      1  1 fcnofoldfcn := out;
00138      0  0 END;
00139   C  0  0 {-----------------------------------------------------------------------------}
00140      1  0 PROCEDURE workspaceload (filename : anystring);
00141      1  0 VAR
00142      1  0    old : oldfcn;
00143      1  0    fn  : fcn;
00144      1  1 BEGIN
00145      1  1 IF index (filename,'.') = 0 THEN filename := filename + '.WOR';
00146      1  1 IF NOT exist (filename)
00147      1  1  THEN writeline (both,'Cannot find workspace file "' + filename + '"')
00148      1  1  ELSE
00149      1  2   BEGIN
00150      1  2   clearfcns;
00151      1  2   close (fcnfile,ERROR:=CONTINUE);
00152      1  2   open (fcnfile,filename,OLD);
00153      1  2   reset (fcnfile);
00154      1  2   WHILE NOT eof (fcnfile) DO
00155      1  3      BEGIN
00156      1  3      read (fcnfile,old);
00157      1  3      fn := fcnofoldfcn (old);
00158      1  3      fcninsert (fn);
00159      1  2      END;
00160      1  2   close (fcnfile);
00161      1  2   writeline (both,'Workspace ' + filename + ' loaded');
00162      1  1   END;
00163      0  0 END;
00164   C  0  0 {=============================================================================}
00165      0  0 END.

OLDFCN                                                          23-Dec-1988 10:49:42    VAX Pascal V3.7-254                Page    4
INCA                            Pascal Compilation Statistics   29-Jul-1987 15:45:09    DUA1:[QPLOT.INCA.SOURCE]OLDFCN.PAS;35 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                3151  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               4319  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        26        21
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20         7        35
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        17         8
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        10        14
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         7        11
DUA1:[QPLOT.QPLOT.SOURCE]IOBASE.PEN;1                    104         7         7
DUA1:[QPLOT.INCA.SOURCE]LONGREAL.PEN;1                    67         0         0
DUA1:[QPLOT.INCA.SOURCE]POLYMATH.PEN;1                   163        24        15
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        77        31



BLOCK                                                           23-Dec-1988 10:50:18    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                  16-Nov-1987 14:20:43    DUA1:[QPLOT.INCA.SOURCE]BLOCK.PAS;19 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STANDARD',
00003      0  0                'QLIBHOME:IO',
00004      0  0                'QLIBHOME:PLOT'),
00005      0  0   ENVIRONMENT ('BLOCK')]
00006      0  0 MODULE block;
00007   C  0  0 {=============================================================================}
00008   C  0  0 {-- BLOCK DIAGRAM DRAWING PROCEDURES -----------------------------------------}
00009   C  0  0 {=============================================================================}
00010      0  0 CONST
00011      0  0    DARKGRAY     = 'DARK GRAY GRAY';
00012   C  0  0 {-----------------------------------------------------------------------------}
00013      1  0 PROCEDURE drb_input (ch : char;  ix,iy : integer;  str : anystring);
00014   C  1  0 {------------------------------}
00015      2  0 PROCEDURE drawinputblock (ymid,ywidth : integer;  str1,str2 : anystring;
00016      2  0    line_color : color_type;  box_color : color_type);
00017      2  1 BEGIN
00018      2  1 setcolor (line_color);
00019      2  1 position (ix+8000,iy+ymid);  draw (ix+10000,iy+ymid);  draw (ix+10000,iy);
00020      2  1 setcolor (box_color);
00021      2  1 drawbox  (ix, ix+8000, iy+ymid-ywidth, iy+ymid+ywidth);
00022      2  1 setcolor ('RED');
00023      2  1 position (ix+4000,iy+ymid+ywidth-1000);  centergrprint (str1);
00024      2  1 setcolor ('MAGENTA');
00025      2  1 position (ix+4000,iy+ymid-ywidth+1000);  centergrprint (str2);
00026      1  0 END;
00027   C  1  0 {------------------------------}
00028      1  1 BEGIN
00029      1  2 CASE ch OF
00030      1  3    ' ':  BEGIN
00031      1  3          setcolor ('WHITE');
00032      1  3          position (ix+4000,iy+14500);  centergrprint ('INPUT');
00033      1  3          position (ix+4000,iy+13000);  centergrprint ('FUNCTION');
00034      1  3          drawinputblock (10000,1000,'Impulse',    '',DARKGRAY,DARKGRAY);
00035      1  3          drawinputblock ( 6000,2000,'Step',       '',DARKGRAY,DARKGRAY);
00036      1  3          drawinputblock ( 1000,2000,'Ramp',       '',DARKGRAY,DARKGRAY);
00037      1  3          drawinputblock (-4000,2000,'Acc.',       '',DARKGRAY,DARKGRAY);
00038      1  3          drawinputblock (-9000,2000,'Combination','',DARKGRAY,DARKGRAY);
00039      1  3          drawinputblock(-14000,2000,'Oscillator', '',DARKGRAY,DARKGRAY);
00040      1  3          drawinputblock(-19000,2000,'User',       '',DARKGRAY,DARKGRAY);
00041      1  2          END;
00042      1  2    'I':  drawinputblock (10000,1000,'','' ,'GREEN','BLUE');
00043      1  2    'S':  drawinputblock ( 6000,2000,'',str,'GREEN','BLUE');
00044      1  2    'R':  drawinputblock ( 1000,2000,'',str,'GREEN','BLUE');
00045      1  2    'A':  drawinputblock (-4000,2000,'',str,'GREEN','BLUE');
00046      1  2    'C':  drawinputblock (-9000,2000,'',str,'GREEN','BLUE');
00047      1  2    'O':  drawinputblock(-14000,2000,'',str,'GREEN','BLUE');
00048      1  2    'U':  drawinputblock(-19000,2000,'',str,'GREEN','BLUE');
00049      1  1    END;
00050      1  1 finplot;
00051      0  0 END;
00052   C  0  0 {-----------------------------------------------------------------------------}
00053      1  0 PROCEDURE drb_summer (ix,iy : integer);
00054      1  1 BEGIN
00055      1  1 setcolor ('BLUE');

BLOCK                                                           23-Dec-1988 10:50:18    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                  16-Nov-1987 14:20:43    DUA1:[QPLOT.INCA.SOURCE]BLOCK.PAS;19 (1)

-LINE-IDC-PL-SL-

00056      1  1 position (ix+1000,iy-2000);   centergrprint ('-');
00057      1  1 position (ix-2000,iy+1000);   centergrprint ('+');
00058      1  1 circle (ix,iy,1000);
00059      1  1 setcolor ('GREEN');
00060      1  1 position (ix-5000,iy);  drawto (4000,0);  drawto (-1000,500);
00061      1  1     drawto  (0,-1000);  drawto (1000,500);   
00062      1  1 position (ix,iy-3000);  drawto (0,2000);  drawto (500,-1000);
00063      1  1     drawto  (-1000,0);  drawto (500,1000);
00064      1  1 position (ix+1000,iy);  drawto (1000,0);  
00065      1  1 finplot;
00066      0  0 END;
00067   C  0  0 {-----------------------------------------------------------------------------}
00068      1  0 PROCEDURE drb_sampler (ch : char;  ix,iy : integer;  str : anystring);
00069      1  0 VAR
00070      1  0    dir : integer;
00071      1  1 BEGIN
00072      1  2 CASE ch OF 
00073      1  2    'L':  dir := -1;  
00074      1  2    'R':  dir := 1;  
00075      1  1    END;
00076      1  1 setcolor ('GREEN');
00077      1  1 position (ix,iy);  drawto (1000*dir,0);     drawto (2000*dir,2000);
00078      1  1 position (ix,iy);  moveto (4000*dir,0);     drawto (1000*dir,0);
00079      1  1 position (ix,iy);  moveto (1500*dir,1300);  drawto (500*dir,-300);
00080      1  1                    drawto (300*dir,-500);   drawto (100*dir,-500);  
00081      1  1                    drawto (0*dir,-500);     drawto (200*dir,400);
00082      1  1                    drawto (-400*dir,0);     drawto (200*dir,-400);
00083      1  1 setcolor ('MAGENTA');
00084      1  1 moveto (0,-1500);  grprint (str);
00085      1  1 finplot;
00086      0  0 END;
00087   C  0  0 {-----------------------------------------------------------------------------}
00088      1  0 PROCEDURE drb_gain (ch : char;  ix,iy : integer;  str : anystring);
00089   C  1  0 {------------------------------}
00090      2  0 PROCEDURE drawgainblock (ymid,ywidth : integer;  str1,str2 : anystring;
00091      2  0    line_color : color_type;  box_color : color_type);
00092      2  1 BEGIN
00093      2  1 setcolor (line_color);
00094      2  1 position  (ix+1000,iy);   draw (ix+1000,iy+ymid);   draw (ix+3000,iy+ymid);
00095      2  1 position (ix+15000,iy);  draw (ix+15000,iy+ymid);  draw (ix+13000,iy+ymid);
00096      2  1 setcolor (box_color);
00097      2  1 drawbox (ix+3000, ix+13000, iy+ymid-ywidth, iy+ymid+ywidth);
00098      2  1 setcolor ('RED');
00099      2  1 position (ix+8000,iy+ymid+ywidth-1000);  centergrprint (str1);
00100      2  1 setcolor ('MAGENTA');
00101      2  1 position (ix+8000,iy+ymid-ywidth+1000);  centergrprint (str2);
00102      1  0 END;
00103   C  1  0 {------------------------------}
00104      1  1 BEGIN
00105      1  2 CASE ch OF
00106      1  3    ' ':  BEGIN
00107      1  3          setcolor ('GREEN');
00108      1  3          position (ix,iy);  drawto (1000,0);
00109      1  3          moveto (14000,0);  drawto (1000,0);
00110      1  3          drawgainblock  (3000,2000,'One Gain',    '',DARKGRAY,DARKGRAY);

BLOCK                                                           23-Dec-1988 10:50:18    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                  16-Nov-1987 14:20:43    DUA1:[QPLOT.INCA.SOURCE]BLOCK.PAS;19 (1)

-LINE-IDC-PL-SL-

00111      1  3          drawgainblock (-3000,2000,'Sensitivity', '',DARKGRAY,DARKGRAY);
00112      1  2          END;
00113      1  2    'O':  drawgainblock  (3000,2000,'',str,'GREEN','BLUE');
00114      1  2    'S':  drawgainblock (-3000,2000,'',str,'GREEN','BLUE');
00115      1  1    END;
00116      1  1 finplot;
00117      0  0 END;
00118   C  0  0 {-----------------------------------------------------------------------------}
00119      1  0 PROCEDURE drb_block (ch : char;  ix,iy,width : integer;  str1,str2 : anystring);
00120      1  0 VAR
00121      1  0    dirx,diry : integer;
00122      1  1 BEGIN
00123      1  2 CASE ch OF
00124      1  2    'L':  BEGIN  dirx := -1;  diry :=  0;  END;
00125      1  2    'R':  BEGIN  dirx :=  1;  diry :=  0;  END;
00126      1  2    'U':  BEGIN  dirx :=  0;  diry :=  1;  END;
00127      1  2    'D':  BEGIN  dirx :=  0;  diry := -1;  END;
00128      1  1    END;
00129      1  1 setcolor ('GREEN');
00130      1  1 position (ix,iy);  drawto (1000*dirx,1000*diry);
00131      1  1 moveto (width*2*dirx,4000*diry);  drawto (1000*dirx,1000*diry);
00132      1  1 setcolor ('BLUE');
00133      1  1 drawbox (ix + (1000+width)*dirx - width, ix + (1000+width)*dirx + width,
00134      1  1          iy + 3000*diry - 2000,iy + 3000*diry + 2000);
00135      1  1 setcolor ('RED');
00136      1  1 position (ix + 1000*dirx + width*dirx,iy + 3000*diry + 1000);
00137      1  1 centergrprint (str1);
00138      1  1 setcolor ('MAGENTA');
00139      1  1 position (ix + 1000*dirx + width*dirx,iy + 3000*diry - 1000);
00140      1  1 centergrprint (str2);
00141      1  1 finplot;
00142      0  0 END;
00143   C  0  0 {-----------------------------------------------------------------------------}
00144      1  0 PROCEDURE drb_line (ch : char;  ix,iy,len : integer);
00145      1  0 VAR
00146      1  0    dirx,diry : integer;
00147      1  1 BEGIN
00148      1  2 CASE ch OF
00149      1  2    'L':  BEGIN  dirx := -1;  diry :=  0;  END;
00150      1  2    'R':  BEGIN  dirx :=  1;  diry :=  0;  END;
00151      1  2    'U':  BEGIN  dirx :=  0;  diry :=  1;  END;
00152      1  2    'D':  BEGIN  dirx :=  0;  diry := -1;  END;
00153      1  1    END;
00154      1  1 setcolor ('GREEN');
00155      1  1 position (ix,iy);  drawto (len*dirx,len*diry);
00156      1  1 finplot;
00157      0  0 END;
00158   C  0  0 {-----------------------------------------------------------------------------}
00159      1  0 PROCEDURE drb_end (ix,iy,len : integer);
00160      1  1 BEGIN
00161      1  1 setcolor ('GREEN');
00162      1  1 circle (ix,iy,100);
00163      1  1 position (ix,iy);  drawto (len,0);    drawto (-1000,1000);
00164      1  1                    drawto (0,-2000);  drawto (1000,1000);
00165      1  1 finplot;

BLOCK                                                           23-Dec-1988 10:50:18    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                  16-Nov-1987 14:20:43    DUA1:[QPLOT.INCA.SOURCE]BLOCK.PAS;19 (1)

-LINE-IDC-PL-SL-

00166      0  0 END;
00167   C  0  0 {=============================================================================}
00168      0  0 END.

BLOCK                                                           23-Dec-1988 10:50:18    VAX Pascal V3.7-254                Page    5
INCA                            Pascal Compilation Statistics   16-Nov-1987 14:20:43    DUA1:[QPLOT.INCA.SOURCE]BLOCK.PAS;19 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                                6085  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        30        24
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        37        18
DUA1:[QPLOT.QPLOT.SOURCE]PLOT.PEN;1                      292         9         3



CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    1
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00001      0  0 [ IDENT       ('INCA'),
00002      0  0   INHERIT     ('QLIBHOME:STARLETQ',
00003      0  0                'QLIBHOME:STANDARD',
00004      0  0                'QLIBHOME:GENERAL',
00005      0  0                'QLIBHOME:DIRECTORY',
00006      0  0                'QLIBHOME:MATH',
00007      0  0                'QLIBHOME:COMPLEX',
00008      0  0                'QLIBHOME:STRING',
00009      0  0                'QLIBHOME:IO',
00010      0  0                'QLIBHOME:FIG',
00011      0  0                'FCN','FCNIO'),
00012      0  0   ENVIRONMENT ('CURVE')]
00013      0  0 MODULE curve;
00014   C  0  0 {=============================================================================}
00015   C  0  0 { CURVE DEFINITION }
00016      0  0 CONST
00017      0  0    CURVELIM        = 20;
00018      0  0 TYPE
00019      0  0    curveclass_type = (C_EMP,C_LOC,C_FRE,C_TIR);
00020   C  0  0 {------------------------------}
00021   C  0  0 {-- LOCUS CURVE DEFINITION ----}
00022   C  0  0 {------------------------------}
00023      0  0 CONST
00024      0  0    LOCBRASIZE      = 300;
00025      0  0    LOCARRSIZE      = 20000;
00026      0  0 TYPE
00027      0  0    locend_type     = (ok,breakpoint, zero_found, outside_reg, no_loci,
00028      0  0                       near_boundary, storage_full, numeric_prob, gain_decrease,
00029      0  0                       sharp_bend, near_root, deriv_gain);
00030      0  0 
00031      0  0    ltype_type      = (EVA,RCO);
00032      0  0 
00033      0  0    locuscalc_type  = RECORD
00034      0  0                      plane           : char;
00035      0  0                      lim             : plotlimits;
00036      0  0                      CASE ltype : ltype_type OF
00037      0  0                         EVA:   (locfcn          : fcn;
00038      0  0                                 phaseangle      : real;
00039      0  0                                 dr              : real;
00040      0  0                                 thbend          : real;
00041      0  0                                 window          : real);
00042      0  0                         RCO:   (project         : logicalname;
00043      0  0                                 expression      : anystring;
00044      0  0                                 independent     : logicalname;
00045      0  0                                 indmin          : real;
00046      0  0                                 indmax          : real;
00047      0  0                                 ds              : real);
00048      0  0                      END;
00049      0  0 
00050      0  0    locdat_type     = RECORD          { STORAGE FOR CALCULATED LOCUS POINTS }
00051      0  0                      pt              : complex;       { X-Y COORDINATES }
00052      0  0                      CASE ltype_type OF
00053      0  0                         EVA:  (lg    : real;          { LOG10 OF GAIN   }
00054      0  0                                dg    : real;          { dg/ds           }
00055      0  0                                th    : real);         { ANGLE OF LOCUS  }

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    2
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00056      0  0                         RCO:  (ind   : real);         { LOG10 OF GAIN   }
00057      0  0                      END;
00058      0  0 
00059      0  0    locbranch_type  = RECORD
00060      0  0                      locmin,locmax   : integer;     { INIDICES INTO LOC ARRAY }
00061      0  0                      locend          : locend_type; { COMPLETION STATUS }
00062      0  0                      END;
00063      0  0 
00064      0  0    loccurve_type   = RECORD
00065      0  0                      l               : locuscalc_type;
00066      0  0 
00067      0  0                      brmax           : integer;
00068      0  0                      branch          : ARRAY [1..LOCBRASIZE] OF locbranch_type;
00069      0  0                      dat             : ARRAY [1..LOCARRSIZE] OF locdat_type;
00070      0  0                      END;
00071   C  0  0 {------------------------------}
00072   C  0  0 {-- FREQR CURVE DEFINITION ----}
00073   C  0  0 {------------------------------}
00074      0  0 CONST
00075      0  0    FREARRSIZE      = 10000;
00076      0  0 TYPE
00077      0  0    ftype_type      = (SFR,NRA,DES,MNY);
00078      0  0 
00079      0  0    freqrcalc_type  = RECORD
00080      0  0                      dbdif         : real;
00081      0  0                      phdif         : real;
00082      0  0                      nyqdif        : real;
00083      0  0                      CASE ftype : ftype_type OF
00084      0  0                         SFR:   (wmin          : real;
00085      0  0                                 wmax          : real;
00086      0  0                                 bodsfcn       : fcn;
00087      0  0                                 bodzfcn       : fcn;
00088      0  0                                 tau           : real;
00089      0  0                                 level         : integer;
00090      0  0                                 zoh           : boolean;
00091      0  0                                 star          : boolean;
00092      0  0                                 compdelay     : real);
00093      0  0                         NRA:   ();
00094      0  0                         DES:   (amin          : real;
00095      0  0                                 amax          : real;
00096      0  0                                 dftype        : logicalname;
00097      0  0                                 count         : integer;
00098      0  0                                 p             : ARRAY [1..20] OF real;
00099      0  0  				ispwpf	      : boolean;
00100      0  0  				pwpf_omega    : real);
00101      0  0 			MNY:   (numname       : integer;
00102      0  0       				pwpftype      : logicalname);
00103      0  0                      END;
00104      0  0 
00105      0  0    fredat_type     = RECORD
00106      0  0                      db            : real;
00107      0  0                      phase         : real;
00108      0  0                      CASE ftype_type OF
00109      0  0                         SFR,
00110      0  0                         NRA:   (omega         : real);

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    3
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00111      0  0                         DES:   (amp           : real);
00112      0  0                      END;
00113      0  0 
00114      0  0    frecurve_type   = RECORD
00115      0  0                      f             : freqrcalc_type;
00116      0  0 
00117      0  0                      steps         : integer;
00118      0  0                      dat           : ARRAY [1..FREARRSIZE] OF fredat_type;
00119      0  0                      END;
00120   C  0  0 {------------------------------}
00121   C  0  0 {-- TIMER CURVE DEFINITION ----}
00122   C  0  0 {------------------------------}
00123      0  0 CONST
00124      0  0    TIRARRLIM       = 10;
00125      0  0    TIRARRSIZE      = 3000;
00126      0  0 TYPE
00127      0  0    tirdat_type     = RECORD
00128      0  0                      time          : real;
00129      0  0                      value         : ARRAY [1..TIRARRLIM] OF real;
00130      0  0                      END;
00131      0  0 
00132      0  0    tircurve_type   = RECORD
00133      0  0                      tmin          : real;
00134      0  0                      tmax          : real;
00135      0  0 
00136      0  0                      blocktype     : char;
00137      0  0                      workplane     : char;
00138      0  0                      continuous    : boolean;
00139      0  0                      plantfcn      : fcn;
00140      0  0                      feedbackfcn   : fcn;
00141      0  0                      samplerfcn    : fcn;
00142      0  0                      inputfcn      : fcn;
00143      0  0                      compgain      : ARRAY [1..TIRARRLIM] OF real;
00144      0  0                      compdelay     : real;
00145      0  0                      zoh           : boolean;
00146      0  0                      tau           : real;
00147      0  0                      dt            : real;
00148      0  0                      substeps      : integer;
00149      0  0                      count         : integer;
00150      0  0 
00151      0  0                      steps         : integer;
00152      0  0                      dat           : ARRAY [1..TIRARRSIZE] OF tirdat_type;
00153      0  0                      END;
00154   C  0  0 {------------------------------}
00155   C  0  0 {-- CURVE DEFINITION ----------}
00156   C  0  0 {------------------------------}
00157      0  0 TYPE
00158      0  0    curve_item_type = RECORD
00159      0  0                      name            : logicalname;
00160      0  0                      lable           : anystring;
00161      0  0                      CASE curveclass : curveclass_type OF
00162      0  0                         C_EMP:  (emptr : $POINTER);
00163      0  0                         C_LOC:  (lcptr : ^loccurve_type);
00164      0  0                         C_FRE:  (fcptr : ^frecurve_type);
00165      0  0                         C_TIR:  (tcptr : ^tircurve_type);

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    4
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00166      0  0                      END;
00167      0  0 VAR
00168      0  0    curve           : RECORD
00169      0  0                      count     : integer;
00170      0  0                      data      : ARRAY [1..CURVELIM] OF curve_item_type;
00171      0  0                      END;
00172   C  0  0 {=============================================================================}
00173   C  0  0 {-- CURVE LIST PROCEDURES ----------------------------------------------------}
00174   C  0  0 {=============================================================================}
00175      1  0 FUNCTION getcurveindex (name : logicalname) : integer;
00176      1  0 VAR
00177      1  0    i,j     : integer;
00178      1  1 BEGIN
00179      1  1 j := 0;
00180      1  1 FOR i := 1 TO curve.count DO
00181      1  1    IF curve.data[i].name = name THEN j := i;
00182      1  1 getcurveindex := j;
00183      0  0 END;
00184   C  0  0 {-----------------------------------------------------------------------------}
00185      1  0 FUNCTION curveexist (name : logicalname) : boolean;
00186      1  1 BEGIN
00187      1  1 curveexist := getcurveindex (name) <> 0;
00188      0  0 END;
00189   C  0  0 {-----------------------------------------------------------------------------}
00190      1  0 PROCEDURE deletecurve (name : logicalname);
00191      1  0 VAR
00192      1  0    i,j     : integer;
00193      1  1 BEGIN
00194      1  1 j := getcurveindex (name);
00195      1  1 IF j <> 0
00196      1  1  THEN
00197      1  2   BEGIN
00198      1  3   CASE curve.data[j].curveclass OF
00199      1  3      C_LOC:  dispose (curve.data[j].lcptr);
00200      1  3      C_FRE:  dispose (curve.data[j].fcptr);
00201      1  3      C_TIR:  dispose (curve.data[j].tcptr);
00202      1  2      END;
00203      1  2   FOR i := j+1 TO curve.count DO
00204      1  2      curve.data[i-1] := curve.data[i];
00205      1  2   curve.count := curve.count - 1;
00206      1  1   END;
00207      0  0 END;
00208   C  0  0 {-----------------------------------------------------------------------------}
00209      1  0 FUNCTION createcurve (curveclass : curveclass_type;  name : logicalname;
00210      1  0    lable : anystring) : integer;
00211      1  0 VAR
00212      1  0    i,j     : integer;
00213      1  1 BEGIN
00214      1  1 IF curveexist (name) THEN deletecurve (name);
00215      1  1 IF curve.count = CURVELIM THEN raise ('Curve limit exceeded');
00216      1  1 j := 1;
00217      1  1 FOR i := 1 TO curve.count DO
00218      1  1    IF name > curve.data[i].name THEN j := i + 1;
00219      1  1 FOR i := curve.count DOWNTO j DO
00220      1  1    curve.data[i+1] := curve.data[i];

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    5
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00221      1  1 curve.data[j].name         := name;
00222      1  1 curve.data[j].curveclass   := curveclass;
00223      1  1 curve.data[j].lable        := lable;
00224      1  2 CASE curveclass OF
00225      1  2    C_LOC:  new (curve.data[j].lcptr);
00226      1  2    C_FRE:  new (curve.data[j].fcptr);
00227      1  2    C_TIR:  new (curve.data[j].tcptr);
00228      1  1    END;
00229      1  1 curve.count := curve.count + 1;
00230      1  1 createcurve := j;
00231      0  0 END;
00232   C  0  0 {-----------------------------------------------------------------------------}
00233      1  0 PROCEDURE selectcurve (VAR sel : command_type;  allispossible : boolean;
00234      1  0    manyispossible : boolean);
00235      1  0 VAR
00236      1  0    i : integer;
00237      1  1 BEGIN
00238      1  1 IF curve.count = 0
00239      1  1  THEN
00240      1  2   BEGIN
00241      1  2   sel := '';
00242      1  2   writeline (out,'No curves currently exist');
00243      1  2   pause;
00244      1  2   END
00245      1  1  ELSE
00246      1  2   BEGIN
00247      1  2   startcommand ('Curve Selection',false);
00248      1  2   IF allispossible THEN setcommand ('All');
00249      1  2   IF manyispossible THEN setcommand ('Many');
00250      1  2   FOR i := 1 TO curve.count DO
00251      1  2      setcommand (curve.data[i].name);
00252      1  2   readcommand (sel,ESC,false,'');
00253      1  1   END;
00254      0  0 END;
00255   C  0  0 {=============================================================================}
00256   C  0  0 {-- CURVE FILE INPUT / OUTPUT PROCEDURES -------------------------------------}
00257   C  0  0 {=============================================================================}
00258      1  0 PROCEDURE loadcurve (filename : anystring;  verno : real);
00259      1  0 VAR
00260      1  0    j              : integer;
00261      1  0    ch             : char;
00262      1  0    string,line,st : anystring;
00263      1  0    p              : parse_type;
00264      1  0    goodcurve      : boolean;
00265   C  1  0 {------------------------------}
00266      2  0 PROCEDURE loadlocus (VAR lc : loccurve_type);
00267   C  2  0 {--------------------}
00268      3  0 PROCEDURE loadlocusbranch;
00269      3  1 BEGIN
00270      3  1 lc.brmax := lc.brmax + 1;
00271      3  1 WITH lc,l,branch[brmax] DO
00272      3  2    BEGIN
00273      3  2    IF lc.brmax = 1
00274      3  2     THEN locmin := 1
00275      3  2     ELSE locmin := branch[brmax-1].locmax+1;

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    6
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00276      3  2    locmax := locmin - 1;
00277      3  2    readv (substr(string,8,length(string)-7),locend);
00278      3  2    WHILE NOT eof(textfile) AND ((index(string,'BRANCH')<>1)
00279      3  2                                                        OR (locmin>locmax)) DO
00280      3  3       BEGIN
00281      3  3       readln (textfile,string);
00282      3  3       IF index(string,'BRANCH') <> 1
00283      3  3        THEN
00284      3  4         BEGIN
00285      3  4         locmax := locmax + 1;
00286      3  4         readv (string,dat[locmax].lg,dat[locmax].pt.re,dat[locmax].pt.im);
00287      3  3         END;
00288      3  2       END;
00289      3  1    END;
00290      2  0 END;
00291   C  2  0 {--------------------}
00292      2  1 BEGIN
00293      2  1 WITH lc,l DO
00294      2  2    BEGIN
00295      2  2    locfcn := onefcn;
00296      2  2    locfcn.name := 'LOCUS_FUNCTION';
00297      2  2    readln (textfile,string);
00298      2  3    CASE string[1] OF
00299      2  4       'S':  BEGIN
00300      2  4             ltype := EVA;
00301      2  4             readln (textfile,string);  phaseangle := rofstr (string);
00302      2  4             readln (textfile,string);  dr         := rofstr (string);
00303      2  4             readln (textfile,string);  thbend     := rofstr (string);
00304      2  4             readln (textfile,string);  window     := rofstr (string);
00305      2  4             readfcn (textfile,locfcn);
00306      2  3             END;
00307      2  4       'C':  BEGIN
00308      2  4             ltype := RCO;
00309      2  4             readln (textfile,project);
00310      2  4             readln (textfile,expression);
00311      2  4             readln (textfile,independent);
00312      2  4             readln (textfile,string);  indmin := rofstr (string);
00313      2  4             readln (textfile,string);  indmax := rofstr (string);
00314      2  4             readln (textfile,string);  ds     := rofstr (string);
00315      2  3             END;
00316      2  2       END;
00317      2  2    readln (textfile,string);
00318      2  2    readln (textfile,string);  plane := string[1];
00319      2  2    readln (textfile,string);  lim.min.x  := rofstr(string);
00320      2  2    readln (textfile,string);  lim.min.y  := rofstr(string);
00321      2  2    readln (textfile,string);  lim.max.x  := rofstr(string);
00322      2  2    readln (textfile,string);  lim.max.y  := rofstr(string);
00323      2  2 
00324      2  2    brmax := 0;
00325      2  2    readln (textfile,string);
00326      2  2    WHILE NOT eof(textfile) DO loadlocusbranch;
00327      2  1    END;
00328      1  0 END;
00329   C  1  0 {------------------------------}
00330      2  0 PROCEDURE loadfreqr (VAR fc : frecurve_type);

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    7
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00331      2  0 VAR
00332      2  0    i : integer;
00333      2  1 BEGIN
00334      2  1 WITH fc,f DO
00335      2  2    BEGIN
00336      2  2    ftype := SFR;
00337      2  2    bodsfcn := onefcn;
00338      2  2    bodzfcn := onefcn;
00339      2  2    steps := 0;
00340      2  2    level := 0;
00341      2  2    zoh   := false;
00342      2  2    compdelay := 0;
00343      2  2    tau   := UNDEFINED_REAL;
00344      2  2    readln (textfile,string);
00345      2  2    WHILE NOT eof(textfile) DO
00346      2  2       IF index (string,'S FUNCTION') = 1
00347      2  2        THEN
00348      2  3         BEGIN
00349      2  3         readfcn (textfile,bodsfcn);
00350      2  3         readln (textfile,string);
00351      2  3         END
00352      2  2       ELSE IF index (string,'Z FUNCTION') = 1
00353      2  2        THEN
00354      2  3         BEGIN
00355      2  3         readfcn (textfile,bodzfcn);
00356      2  3         readln (textfile,string);
00357      2  3         END
00358      2  2       ELSE IF index (string,'COMP DATA') = 1
00359      2  2        THEN
00360      2  3         BEGIN
00361      2  3         ftype := SFR;
00362      2  3         readln (textfile,string);  wmin      := rofstr (string);
00363      2  3         readln (textfile,string);  wmax      := rofstr (string);
00364      2  3         readln (textfile,string);  tau       := rofstr (string);
00365      2  3         readln (textfile,string);  level     := iofstr (string);
00366      2  3         readln (textfile,string);  zoh := string[1] = 'Z';
00367      2  3         readln (textfile,string);  compdelay := rofstr (string);
00368      2  3         readln (textfile,string);  star := string[1] = 'S';
00369      2  3         readln (textfile,string);
00370      2  3         END
00371      2  2       ELSE IF index (string,'DESCRIBING FUNCTION DATA') = 1
00372      2  2        THEN
00373      2  3         BEGIN
00374      2  3         ftype := DES;
00375      2  3         readln (textfile,string);  amin      := rofstr (string);
00376      2  3         readln (textfile,string);  amax      := rofstr (string);
00377      2  3         readln (textfile,dftype);
00378      2  3         readln (textfile,string);  count     := iofstr (string);
00379      2  3         FOR i := 1 TO count DO
00380      2  3            BEGIN  readln (textfile,string);  p[i] := rofstr (string);  END;
00381      2  3         readln (textfile,string);
00382      2  3        END
00383      2  2       ELSE
00384      2  2         WHILE NOT eof(textfile) DO
00385      2  3            BEGIN

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    8
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00386      2  3            readln (textfile,string);
00387      2  3            steps := steps + 1;
00388      2  3            readv(string,dat[steps].omega,dat[steps].db,dat[steps].phase);
00389      2  2            END;
00390      2  1    END;
00391      1  0 END;
00392   C  1  0 {------------------------------}
00393      2  0 PROCEDURE loadtimer (VAR tc : tircurve_type);
00394      2  0 VAR
00395      2  0    k      : integer;
00396      2  0    p      : parse_type;
00397      2  1 BEGIN
00398      2  1 WITH tc DO
00399      2  2    BEGIN
00400      2  2    plantfcn := onefcn;
00401      2  2    samplerfcn := onefcn;
00402      2  2    feedbackfcn := onefcn;
00403      2  2    inputfcn := onefcn;
00404      2  2    steps := 0;
00405      2  2    readln (textfile,string);
00406      2  2    WHILE NOT eof(textfile) DO
00407      2  2       IF index (string,'INPUT FUNCTION') = 1
00408      2  2        THEN
00409      2  3         BEGIN
00410      2  3         readfcn (textfile,inputfcn);
00411      2  3         readln (textfile,string);
00412      2  3         END
00413      2  2       ELSE IF index (string,'PLANT FUNCTION') = 1
00414      2  2        THEN
00415      2  3         BEGIN
00416      2  3         readfcn (textfile,plantfcn);
00417      2  3         readln (textfile,string);
00418      2  3         END
00419      2  2       ELSE IF index (string,'FEEDBACK FUNCTION') = 1
00420      2  2        THEN
00421      2  3         BEGIN
00422      2  3         readfcn (textfile,feedbackfcn);
00423      2  3         readln (textfile,string);
00424      2  3         END
00425      2  2       ELSE IF index (string,'SAMPLER FUNCTION') = 1
00426      2  2        THEN
00427      2  3         BEGIN
00428      2  3         readfcn (textfile,samplerfcn);
00429      2  3         readln (textfile,string);
00430      2  3         END
00431      2  2       ELSE IF index (string,'COMP DATA') = 1
00432      2  2        THEN
00433      2  3         BEGIN
00434      2  3         readln (textfile,string);  tau       := rofstr (string);
00435      2  3         readln (textfile,string);  dt        := rofstr (string);
00436      2  3         readln (textfile,string);  substeps  := iofstr (string);
00437      2  3         readln (textfile,string);  blocktype := string[1];
00438      2  3         readln (textfile,string);  workplane := string[1];
00439      2  3         readln (textfile,string);  continuous:= string[1] = 'C';
00440      2  3         readln (textfile,string);  compdelay := rofstr (string);

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page    9
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00441      2  3         readln (textfile,string);  zoh := string[1] = 'Z';
00442      2  3         readln (textfile,string);
00443      2  3         END
00444      2  2       ELSE IF index (string,'COMP GAIN') = 1
00445      2  2        THEN
00446      2  3         BEGIN
00447      2  3         readln (textfile,string);  count     := iofstr (string);
00448      2  3         FOR k := 1 TO count DO
00449      2  4            BEGIN
00450      2  4            readln (textfile,string);  compgain[k] := rofstr (string);
00451      2  3            END;
00452      2  3         readln (textfile,string);
00453      2  3         END
00454      2  2       ELSE IF index (string,'DATA') = 1
00455      2  2        THEN
00456      2  2         WHILE NOT eof(textfile) DO
00457      2  3            BEGIN
00458      2  3            steps := steps + 1;
00459      2  3            readln (textfile,string);
00460      2  3            startparse (p,string);
00461      2  3            dat[steps].time := rofstr (parse (p,' ,'));
00462      2  3            FOR k := 1 TO count DO
00463      2  3               dat[steps].value[k] := rofstr (parse (p,' ,'));
00464      2  2            END;
00465      2  1    END;
00466      1  0 END;
00467   C  1  0 {------------------------------}
00468      1  1 BEGIN
00469      1  1 IF exist (filename)
00470      1  1  THEN
00471      1  2   BEGIN
00472      1  2   close (textfile,ERROR:=CONTINUE);
00473      1  2   open (textfile,filename,old,ERROR:=CONTINUE);
00474      1  2   IF status (textfile) <> 0 THEN raise ('Curve file not found');
00475      1  2   reset (textfile);
00476      1  2   readln (textfile,string);
00477      1  2   IF string = '' THEN ch := ' ' ELSE ch := string[1];
00478      1  2   startparse (p,string);
00479      1  2   goodcurve := false;
00480      1  3   REPEAT
00481      1  3      st := parse (p,' ');
00482      1  3      IF st = 'INCA'
00483      1  3       THEN
00484      1  4        BEGIN
00485      1  4        st := parse (p,' ');
00486      1  4        IF rofstr (st) >= 3.00 THEN goodcurve := true;
00487      1  3        END;
00488      1  2      UNTIL st = '';
00489      1  2   IF NOT goodcurve
00490      1  2    THEN writeline (out,'Curve file is possibly not compatible with INCA '
00491      1  2                        + strofr2 (verno,4,2));
00492      1  2   readln (textfile,string);
00493      1  2   deletecurve (string);
00494      1  3   CASE ch OF
00495      1  4      'F':  BEGIN

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   10
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00496      1  4            j := createcurve (C_FRE,string,'File=' + filename);
00497      1  4            loadfreqr (curve.data[j].fcptr^);
00498      1  3            END;
00499      1  4      'R':  BEGIN
00500      1  4            j := createcurve (C_LOC,string,'File=' + filename);
00501      1  4            loadlocus (curve.data[j].lcptr^);
00502      1  3            END;
00503      1  4      'T':  BEGIN
00504      1  4            j := createcurve (C_TIR,string,'File=' + filename);
00505      1  4            loadtimer (curve.data[j].tcptr^);
00506      1  3            END;
00507      1  2      END;
00508      1  2   close (textfile);
00509      1  2   END
00510      1  1  ELSE
00511      1  2   BEGIN
00512      1  2   writeline (out,'Curve ' + filename + ' not found');
00513      1  2   pause;
00514      1  1   END;
00515      0  0 END;
00516   C  0  0 {-----------------------------------------------------------------------------}
00517      1  0 PROCEDURE writecurve (sel : command_type;  filename : anystring;  verno : real);
00518      1  0 VAR
00519      1  0    j        : integer;
00520      1  0    string   : anystring;
00521   C  1  0 {------------------------------}
00522      2  0 PROCEDURE transfer;
00523      2  1 BEGIN
00524      2  1 reset (tempfile);
00525      2  1 WHILE NOT eof(tempfile) DO
00526      2  2    BEGIN
00527      2  2    readln (tempfile,string);
00528      2  2    writeln (textfile,string);
00529      2  1    END;
00530      1  0 END;
00531   C  1  0 {------------------------------}
00532      2  0 PROCEDURE writelocus (VAR lc : loccurve_type);
00533      2  0 VAR
00534      2  0    i,br   : integer;
00535      2  1 BEGIN
00536      2  1 WITH lc,l DO
00537      2  2    BEGIN
00538      2  3    CASE ltype OF
00539      2  4       EVA:  BEGIN
00540      2  4             writeln (textfile,'STANDARD LOCUS');
00541      2  4             writeln (textfile,strofr(phaseangle,0));
00542      2  4             writeln (textfile,strofr(dr,0));
00543      2  4             writeln (textfile,strofr(thbend,0));
00544      2  4             writeln (textfile,strofr(window,0));
00545      2  4             rewrite (tempfile);  writefcn (temp,locfcn,'R');  transfer;
00546      2  3             END;
00547      2  4       RCO:  BEGIN
00548      2  4             writeln (textfile,'CONTOUR LOCUS');
00549      2  4             writeln (textfile,project);
00550      2  4             writeln (textfile,expression);

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   11
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00551      2  4             writeln (textfile,independent);
00552      2  4             writeln (textfile,strofr(indmin,0));
00553      2  4             writeln (textfile,strofr(indmax,0));
00554      2  4             writeln (textfile,strofr(ds,0));
00555      2  3             END;
00556      2  2       END;
00557      2  2    writeln (textfile,'PLANE AND LIMITS');
00558      2  2    writeln (textfile,plane);
00559      2  2    writeln (textfile,strofr(lim.min.x,0));
00560      2  2    writeln (textfile,strofr(lim.min.y,0));
00561      2  2    writeln (textfile,strofr(lim.max.x,0));
00562      2  2    writeln (textfile,strofr(lim.max.y,0));
00563      2  2    FOR br := 1 TO brmax DO WITH branch[br] DO
00564      2  3       BEGIN
00565      2  3       writev (string,locend);
00566      2  3       writeln (textfile,'BRANCH  ' + stripblank(string));
00567      2  3       FOR i := locmin TO locmax DO
00568      2  3          writeln (textfile,dat[i].lg,' ',dat[i].pt.re,' ',dat[i].pt.im);
00569      2  2       END;
00570      2  1    END;
00571      1  0 END;
00572   C  1  0 {------------------------------}
00573      2  0 PROCEDURE writefreqr (VAR fc : frecurve_type);
00574      2  0 VAR
00575      2  0    i      : integer;
00576      2  1 BEGIN
00577      2  1 WITH fc,f DO
00578      2  2    BEGIN
00579      2  3    CASE ftype OF
00580      2  4       SFR:  BEGIN
00581      2  4             writeln (textfile,'S FUNCTION');
00582      2  4             rewrite (tempfile);  writefcn (temp,bodsfcn,'R');  transfer;
00583      2  4             writeln (textfile,'Z FUNCTION');
00584      2  4             rewrite (tempfile);  writefcn (temp,bodzfcn,'R');  transfer;
00585      2  4             writeln (textfile,'COMP DATA');
00586      2  4             writeln (textfile,strofr(wmin,0));
00587      2  4             writeln (textfile,strofr(wmax,0));
00588      2  4             writeln (textfile,strofr(tau,0));
00589      2  4             writeln (textfile,strofi(level,6));
00590      2  4             IF zoh
00591      2  4              THEN writeln (textfile,'ZOH')
00592      2  4              ELSE writeln (textfile,'NO ZOH');
00593      2  4             writeln (textfile,strofr(compdelay,0));
00594      2  4             IF star
00595      2  4              THEN writeln (textfile,'STAR')
00596      2  4              ELSE writeln (textfile,'NO STAR');
00597      2  3             END;
00598      2  3       NRA:  ;
00599      2  4       DES:  BEGIN
00600      2  4             writeln (textfile,'DESCRIBING FUNCTION DATA');
00601      2  4             writeln (textfile,strofr(amin,0));
00602      2  4             writeln (textfile,strofr(amax,0));
00603      2  4             writeln (textfile,dftype);
00604      2  4             writeln (textfile,strofi(count,6));
00605      2  4             FOR i := 1 TO count DO

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   12
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00606      2  4                writeln (textfile,strofr(p[i],0));
00607      2  3             END;
00608      2  3       MNY:  ;
00609      2  2       END;
00610      2  2 
00611      2  2    writeln (textfile,'DATA');
00612      2  2    FOR i := 1 TO steps DO
00613      2  2       writeln (textfile,dat[i].omega,' ',dat[i].db,' ',dat[i].phase);
00614      2  1    END;
00615      1  0 END;
00616   C  1  0 {------------------------------}
00617      2  0 PROCEDURE writetimer (VAR tc : tircurve_type);
00618      2  0 VAR
00619      2  0    i,k    : integer;
00620      2  0    string : anystring;
00621      2  1 BEGIN
00622      2  1 WITH tc DO
00623      2  2    BEGIN
00624      2  2    writeln (textfile,'PLANT FUNCTION');
00625      2  2    rewrite (tempfile);  writefcn (temp,plantfcn,'R');  transfer;
00626      2  2    writeln (textfile,'FEEDBACK FUNCTION');
00627      2  2    rewrite (tempfile);  writefcn (temp,feedbackfcn,'R');  transfer;
00628      2  2    writeln (textfile,'SAMPLER FUNCTION');
00629      2  2    rewrite (tempfile);  writefcn (temp,samplerfcn,'R');  transfer;
00630      2  2    writeln (textfile,'INPUT FUNCTION');
00631      2  2    rewrite (tempfile);  writefcn (temp,inputfcn,'R');  transfer;
00632      2  2    writeln (textfile,'COMP DATA');
00633      2  2    writeln (textfile,strofr(tau,20));
00634      2  2    writeln (textfile,strofr(dt,20));
00635      2  2    writeln (textfile,strofi(substeps,6));
00636      2  2    writeln (textfile,blocktype);
00637      2  2    writeln (textfile,workplane);
00638      2  2    IF continuous
00639      2  2     THEN writeln (textfile,'CONTINUOUS')
00640      2  2     ELSE writeln (textfile,'NOT CONTINUOUS');
00641      2  2    writeln (textfile,strofr(compdelay,20));
00642      2  2    IF zoh
00643      2  2     THEN writeln (textfile,'ZOH')
00644      2  2     ELSE writeln (textfile,'NO ZOH');
00645      2  2    writeln (textfile,'COMP GAIN');
00646      2  2    writeln (textfile,count);
00647      2  2    FOR k := 1 TO count DO
00648      2  2       writeln (textfile,strofr(compgain[k],20));
00649      2  2    writeln (textfile,'DATA');
00650      2  2    FOR i := 1 TO steps DO
00651      2  3       BEGIN
00652      2  3       write (textfile,dat[i].time);
00653      2  3       FOR k := 1 TO count DO
00654      2  3          write (textfile,' ',dat[i].value[k]);
00655      2  3       writeln (textfile);
00656      2  2       END;
00657      2  1    END;
00658      1  0 END;
00659   C  1  0 {------------------------------}
00660      1  1 BEGIN

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   13
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00661      1  1 IF curveexist (sel)
00662      1  1  THEN
00663      1  2   BEGIN
00664      1  2   j := getcurveindex (sel);
00665      1  2   close (textfile,ERROR:=CONTINUE);
00666      1  3   CASE curve.data[j].curveclass OF
00667      1  4      C_LOC:  BEGIN
00668      1  4              open (textfile,filename + '.RL',NEW,1023);
00669      1  4              rewrite (textfile);
00670      1  4              writeln (textfile,'ROOT LOCUS CURVE, INCA '
00671      1  4                                + strofr2 (verno,4,2));
00672      1  4              writeln (textfile,sel);
00673      1  4              writelocus (curve.data[j].lcptr^);
00674      1  4              close (textfile);
00675      1  3              END;
00676      1  4      C_FRE:  BEGIN
00677      1  4              open (textfile,filename + '.FR',NEW,1023);
00678      1  4              rewrite (textfile);
00679      1  4              writeln (textfile,'FREQUENCY RESPONSE CURVE, INCA '
00680      1  4                                + strofr2 (verno,4,2));
00681      1  4              writeln (textfile,sel);
00682      1  4              writefreqr (curve.data[j].fcptr^);
00683      1  4              close (textfile);
00684      1  3              END;
00685      1  4      C_TIR:  BEGIN
00686      1  4              open (textfile,filename + '.TR',NEW,1023);
00687      1  4              rewrite (textfile);
00688      1  4              writeln (textfile,'TIME RESPONSE CURVE, INCA '
00689      1  4                                + strofr2 (verno,4,2));
00690      1  4              writeln (textfile,sel);
00691      1  4              writetimer (curve.data[j].tcptr^);
00692      1  4              close (textfile);
00693      1  3              END;
00694      1  2      END;
00695      1  1   END;
00696      0  0 END;
00697   C  0  0 {-----------------------------------------------------------------------------}
00698      1  0 PROCEDURE showcurvetable (dest : destination);
00699      1  0 VAR
00700      1  0    j    : integer;
00701      1  0    sel  : command_type;
00702   C  1  0 {------------------------------}
00703      2  0 PROCEDURE showlocustable (VAR lc : loccurve_type);
00704      2  0 VAR
00705      2  0    k,j,jmax,i,br : integer;
00706      2  0    head,line,str : anystring;
00707      2  0    sdata         : ARRAY [1..3] OF anystring;
00708      2  1 BEGIN
00709      2  1 WITH lc,l DO
00710      2  2    BEGIN
00711      2  3    CASE ltype OF
00712      2  3       EVA:  head := ' GAIN (k)      REAL part     IMAG part ';
00713      2  3       RCO:  head := ' INDEPENDENT   REAL part     IMAG part ';
00714      2  2       END;
00715      2  2    line := '-----------   -----------   -----------';

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   14
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00716      2  2    FOR br := 1 TO brmax DO
00717      2  2       WITH branch[br] DO
00718      2  3          BEGIN
00719      2  3          writeline (dest,'');
00720      2  3          writeline (dest,'');
00721      2  3          writev (str,locend);
00722      2  3          writeline (dest,'BRANCH NUMBER '
00723      2  3                             + strofi(br,3) + ' CONTAINS POINTS FROM '
00724      2  3                             + strofi(locmin,4) + ' TO ' + strofi(locmax,4)
00725      2  3                             + ', AND ENDED BECAUSE OF ' + stripblank (str));
00726      2  3          writeline (dest,'');
00727      2  3          writeline (dest,head + '  ||  ' + head + '  ||  ' + head);
00728      2  3          writeline (dest,line + '  ||  ' + line + '  ||  ' + line);
00729      2  3          jmax := (locmax-locmin+3) DIV 3;
00730      2  3          FOR j := 1 TO jmax DO
00731      2  4             BEGIN
00732      2  4             FOR k := 1 TO 3 DO
00733      2  5                BEGIN
00734      2  5                i := (locmin-1) + (jmax*(k-1)+j);
00735      2  5                IF i > locmax
00736      2  5                 THEN sdata[k] := ''
00737      2  5                 ELSE
00738      2  6                  CASE ltype OF
00739      2  6                     EVA:  sdata[k] := strofr(exp10(dat[i].lg),11)
00740      2  6                             + '   ' + strofr(dat[i].pt.re,11)
00741      2  6                             + '   ' + strofr(dat[i].pt.im,11);
00742      2  6                     RCO:  sdata[k] := strofr(dat[i].ind,11)
00743      2  6                             + '   ' + strofr(dat[i].pt.re,11)
00744      2  6                             + '   ' + strofr(dat[i].pt.im,11);
00745      2  5                     END;
00746      2  4                END;
00747      2  4             writeline (dest,sdata[1] + '  ||  ' + sdata[2] + '  ||  ' + sdata[3]);
00748      2  3             END;
00749      2  3          writeline (dest,line + '  ||  ' + line + '  ||  ' + line);
00750      2  2          END;
00751      2  1    END;
00752      1  0 END;
00753   C  1  0 {------------------------------}
00754      2  0 PROCEDURE showfreqrtable (VAR fc : frecurve_type);
00755      2  0 VAR
00756      2  0    i     : integer;
00757      2  0    chnat : VARYING [3] OF char;
00758      2  1 BEGIN{showfreqrtable}
00759      2  1 WITH fc,f DO
00760      2  2    CASE ftype of
00761      2  2       NRA: ;
00762      2  3       SFR: BEGIN
00763      2  3            writeline (dest,'') ;
00764      2  3            writeline (dest,'FREQ: rad/s   Nat    Hertz            '
00765      2  3                         +  ' REAL part   IMAG part          '
00766      2  3                         +  ' amplitude   decibels           '
00767      2  3                         +  ' ARG: rads   ARG: deg  ');
00768      2  3            writeline (dest,'------------- --- -----------         '
00769      2  3                         +  '----------- -----------         '
00770      2  3                         +  '----------- -----------         '

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   15
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00771      2  3                         +  '----------- -----------');
00772      2  3            FOR i := 1 TO steps DO WITH dat[i] DO
00773      2  4               BEGIN
00774      2  4               IF abs(db) > 10 * LOGINFINITY
00775      2  4                THEN chnat := '***'
00776      2  4                ELSE chnat := '   ';
00777      2  4               writeline (dest,     strofr (omega,13)
00778      2  4                 + ' '         + chnat
00779      2  4                 + ' '         + strofr (omega/2d0/PI,11)
00780      2  4                 + '         ' + strofr (exp10(db/20d0) * cos(phase*PI/180d0),11)
00781      2  4                 + ' '         + strofr (exp10(db/20d0) * sin(phase*PI/180d0),11)
00782      2  4                 + '         ' + strofr (exp10(db/20d0),11)
00783      2  4                 + ' '         + strofr (db,11)
00784      2  4                 + '         ' + strofr (phase * PI/180d0,11)
00785      2  4                 + ' '         + strofr (phase,11));
00786      2  3               END;
00787      2  3            writeline (dest,'------------- --- -----------         '
00788      2  3                         +  '----------- -----------         '
00789      2  3                         +  '----------- -----------         '
00790      2  3                         +  '----------- -----------');
00791      2  3            writeline (dest,'');
00792      2  2            END;{SFR}
00793      2  3       DES: BEGIN
00794      2  3            writeline (dest,'') ;
00795      2  3            writeline (dest,'amplitude            '
00796      2  3                         +  ' REAL part   IMAG part          '
00797      2  3                         +  ' range   decibels           '
00798      2  3                         +  ' ARG: rads   ARG: deg  ');
00799      2  3            writeline (dest,'-------------         '
00800      2  3                         +  '----------- -----------         '
00801      2  3                         +  '------- --------           '
00802      2  3                         +  '----------- -----------');
00803      2  3            FOR i := 1 TO steps DO WITH dat[i] DO
00804      2  4               BEGIN
00805      2  4               IF abs(db) > 10 * LOGINFINITY
00806      2  4                THEN chnat := '***'
00807      2  4                ELSE chnat := '   ';
00808      2  4               writeline (dest,     strofr (amp,13)
00809      2  4                 + ' '         + chnat
00810      2  4                 + '         ' + strofr (exp10(db/20d0) * cos(phase*PI/180d0),11)
00811      2  4                 + ' '         + strofr (exp10(db/20d0) * sin(phase*PI/180d0),11)
00812      2  4                 + '         ' + strofr (exp10(db/20d0),11)
00813      2  4                 + ' '         + strofr (db,11)
00814      2  4                 + '         ' + strofr (phase * PI/180d0,11)
00815      2  4                 + ' '         + strofr (phase,11));
00816      2  3               END;
00817      2  3            writeline (dest,'-------------         '
00818      2  3                         +  '----------- -----------         '
00819      2  3                         +  '------- --------           '
00820      2  3                         +  '----------- -----------');
00821      2  3            writeline (dest,'');
00822      2  2            END;
00823      2  1    END;
00824      1  0 END;
00825   C  1  0 {------------------------------}

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   16
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00826      2  0 PROCEDURE showtimertable (VAR tc : tircurve_type);
00827      2  0 VAR
00828      2  0    i,j,k,l,jmax : integer;
00829      2  1 BEGIN
00830      2  1 WITH tc DO
00831      2  1    FOR k := 1 TO count DO
00832      2  2       BEGIN
00833      2  2       writeline (dest,'');
00834      2  2       writeline (dest,'COMPENSATION GAIN : ' + strofr (compgain[k],14));
00835      2  2       writeline (dest,'');
00836      2  2       FOR l := 1 TO 4 DO writestring (dest,'     TIME        VALUE          ');
00837      2  2       writeline (dest,'');
00838      2  2       writeline (dest,'');
00839      2  2       jmax := (steps+3) DIV 4;
00840      2  2       FOR j := 1 TO jmax DO
00841      2  3          BEGIN
00842      2  3          FOR l := 1 TO 4 DO
00843      2  4             BEGIN
00844      2  4             i := jmax * (l-1) + j;
00845      2  4             IF i <= steps
00846      2  4              THEN writestring (dest,strofr (dat[i].time,13)
00847      2  4                                   + strofr (dat[i].value[k],13));
00848      2  4             IF l <> 4 THEN writestring (dest,'  ||  ');
00849      2  3             END;
00850      2  3          writeline (dest,'')
00851      2  2          END;
00852      2  2       writeline (dest,'');
00853      2  1       END;
00854      1  0 END;
00855   C  1  0 {------------------------------}
00856      1  1 BEGIN
00857      1  1 selectcurve (sel,false,false);
00858      1  1 IF curveexist (sel)
00859      1  1  THEN
00860      1  2   BEGIN
00861      1  2   j := getcurveindex (sel);
00862      1  3   CASE curve.data[j].curveclass OF
00863      1  3      C_LOC:  showlocustable (curve.data[j].lcptr^);
00864      1  3      C_FRE:  showfreqrtable (curve.data[j].fcptr^);
00865      1  3      C_TIR:  showtimertable (curve.data[j].tcptr^);
00866      1  2      END;
00867      1  1   END;
00868      0  0 END;
00869   C  0  0 {-----------------------------------------------------------------------------}
00870      1  0 PROCEDURE wormcurvestotext;
00871      1  0 VAR
00872      1  0    j    : integer;
00873      1  0    sel  : command_type;
00874   C  1  0 {------------------------------}
00875      2  0 PROCEDURE wormcurvestimer (VAR tc : tircurve_type);
00876      2  0 VAR
00877      2  0    i,j,k,l,jmax : integer;
00878      2  0    v            : RECORD
00879      2  0                   CASE integer OF
00880      2  0                      1:   (dummy1  : char;

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   17
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00881      2  0                            dummy2  : char;
00882      2  0                            r       : ARRAY [0..TIRARRLIM] OF real);
00883      2  0                      2:   (st      : VARYING [8 * (TIRARRLIM+1)] OF char);
00884      2  0                   END;
00885      2  1 BEGIN
00886      2  1 WITH tc DO
00887      2  1    FOR i := 1 TO steps DO
00888      2  2       BEGIN
00889      2  2       v.st.length := 8 * (1 + count);
00890      2  2       v.r[0] := dat[i].time;
00891      2  2       FOR k := 1 TO count DO
00892      2  2          v.r[k] := dat[i].value[k];
00893      2  2       writeln (textfile,v.st);
00894      2  1       END;
00895      1  0 END;
00896   C  1  0 {------------------------------}
00897      1  1 BEGIN
00898      1  1 selectcurve (sel,false,false);
00899      1  1 IF curveexist (sel)
00900      1  1  THEN
00901      1  2   BEGIN
00902      1  2   j := getcurveindex (sel);
00903      1  3   CASE curve.data[j].curveclass OF
00904      1  3      C_LOC:  ;
00905      1  3      C_FRE:  ;
00906      1  3      C_TIR:  wormcurvestimer (curve.data[j].tcptr^);
00907      1  2      END;
00908      1  1   END;
00909      0  0 END;
00910   C  0  0 {-----------------------------------------------------------------------------}
00911      1  0 PROCEDURE listcurves (dest : destination);
00912      1  0 VAR
00913      1  0    i,j : integer;
00914      1  1 BEGIN
00915      1  1 writeline (dest,'  #  Name      Label               Steps Type');
00916      1  1 writeline (dest,'---  -----     ---------------     ----- ---------------');
00917      1  1 FOR i := 1 TO curve.count DO
00918      1  1    WITH curve.data[i] DO
00919      1  2       BEGIN
00920      1  2       writestring (dest,strofi(i,3) + '  ' + strfix (name,10)
00921      1  2                       + strfix (lable,20));
00922      1  3       CASE curveclass OF
00923      1  3          C_EMP:  writeline (dest,'      Null curve type, internal error');
00924      1  3          C_LOC:  WITH lcptr^,l DO
00925      1  4                     BEGIN
00926      1  4                     writestring (dest,strofi(branch[brmax].locmax,5) + ' ');
00927      1  5                     CASE ltype OF
00928      1  5                        EVA:  writeline (dest,'Evans Locus of ' + locfcn.name);
00929      1  5                        RCO:  writeline (dest,'Contour Locus of ' + expression);
00930      1  4                        END;
00931      1  3                     END;
00932      1  3          C_FRE:  WITH fcptr^,f DO
00933      1  4                     BEGIN
00934      1  4                     writestring (dest,strofi(steps,5) + ' ');
00935      1  5                     CASE ftype OF

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   18
INCA                            Source Listing                   2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

-LINE-IDC-PL-SL-

00936      1  5                        SFR:  IF star
00937      1  5                               THEN writeline (dest,'GH* frequency response')
00938      1  5                               ELSE writeline
00939      1  5                                         (dest,'Standard frequency response');
00940      1  5                        NRA:  ;
00941      1  5                        DES:  writeline(dest,'Describing Funct., Type '+dftype);
00942      1  5  		       MNY:  writeline(dest,'Describing Funct., Type '+pwpftype);
00943      1  4                        END;
00944      1  3                     END;
00945      1  3          C_TIR:  WITH tcptr^ DO
00946      1  4                     BEGIN
00947      1  4                     writestring (dest,strofi(steps,5) + ' ');
00948      1  5                     CASE blocktype OF
00949      1  5                        'S':  writeline (dest,'Simple Time Response');
00950      1  5                        'C':  writeline (dest,'Closed Loop Time Response');
00951      1  5                        'P':  writeline (dest,'Plant Sampler Time Response');
00952      1  5                        'F':  writeline (dest,'Feedback Sampler Time Response');
00953      1  4                        END;
00954      1  3                     END;
00955      1  2          END;
00956      1  1       END;
00957      1  1 writeline (dest,'---  -----     ---------------     ----- ---------------');
00958      0  0 END;
00959   C  0  0 {=============================================================================}
00960      0  0 END.

CURVE                                                           23-Dec-1988 10:51:05    VAX Pascal V3.7-254                Page   19
INCA                            Pascal Compilation Statistics    2-Dec-1988 15:11:50    DUA1:[QPLOT.INCA.SOURCE]CURVE.PAS;9 (1)

PSECT SUMMARY

        Name                     Bytes                         Attributes

$CODE                               23374  NOVEC,NOWRT,  RD,  EXE,  SHR,  LCL,  REL,  CON,  PIC,ALIGN(2)
$LOCAL                               5684  NOVEC,  WRT,  RD,NOEXE,NOSHR,  LCL,  REL,  CON,  PIC,ALIGN(2)


ENVIRONMENT STATISTICS

                                                       -------- Symbols --------
        File                                           Total    Loaded   Percent

DUA1:[QPLOT.QPLOT.SOURCE]STARLETQ.PEN;1                  260         3         1
DUA1:[QPLOT.QPLOT.SOURCE]STANDARD.PEN;1                  124        47        38
DUA1:[QPLOT.QPLOT.SOURCE]GENERAL.PEN;1                    20         7        35
DUA1:[QPLOT.QPLOT.SOURCE]DIRECTORY.PEN;1                  45         0         0
DUA1:[QPLOT.QPLOT.SOURCE]MATH.PEN;1                       59         5         8
DUA1:[QPLOT.QPLOT.SOURCE]COMPLEX.PEN;1                    62         4         6
DUA1:[QPLOT.QPLOT.SOURCE]STRING.PEN;1                     72        45        63
DUA1:[QPLOT.QPLOT.SOURCE]IO.PEN;1                        204        41        20
DUA1:[QPLOT.QPLOT.SOURCE]FIG.PEN;1                       213         7         3
DUA1:[QPLOT.INCA.SOURCE]FCN.PEN;1                        248        73        29
DUA1:[QPLOT.INCA.SOURCE]FCNIO.PEN;1                      184        70        38



