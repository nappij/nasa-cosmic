PROGRAM INTERFACE ( TABS, MAKETAB, SYMS, OUTPUT );
(*$L+*) 

(*$U-*) 
(*
   THIS PROGRAM TAKES AS INPUT A TABLE OF NUMBERS PRODUCED BY THE PARSER
GENERATOR PROGRAM, ALONG WITH A LIST OF SYMBOLS AND THEIR CORRESPONDING SYMBOL
NUMBERS.  THE PROGRAM PRODUCES OUTPUT SUITABLE FOR MAKETABLES,
I.E. THE ACTION AND GOTO TABLES.
*)
  
CONST 
   BASE = 8192;      (* SHOULD BE 8192 *) 
   SYMMAX = 100  ;
   TERMSYMMAX = 50; 
   NONTERMMIN = 1; (* START INDEXING NON-TERMINALS HERE *)
   COUNTMAX = 1023;  (* COUNTERS ARE SQUEEZED DOWN TO THIS SIZE *)
   STATEMAX = 68; 
   RULEMAX = 400;  (* MAX NUMBER OF DIFFERNT RULES *) 
   ACTMAX = 68; 
   EMPTYACT = 0;  (* THE DEFAULT ACT *) 
   STRINGSIZE = 30;(* MAXIMUM LENGTH OF LITERALS, QUOTES INCLUDED. *) 
   STARS = '**********';
  
TYPE
   PGTYPE = (EOF,EOA,EOS,SYM,STATE,SHIFT,REDUCE,GO2,ERR,DONE);
   ACTS = EMPTYACT..ACTMAX; 
   PGN = RECORD (* OF PARSER-GENERATOR NUMBERS *) 
      TYP % PGTYPE; 
      NUM % ACTS
      END;
   STRING = PACKED ARRAY[1..STRINGSIZE] OF CHAR;
   COUNTER = 0..COUNTMAX; 
   STATES = 1..STATEMAX;
   TERMSYM = 1..TERMSYMMAX; 
   NONTERM = NONTERMMIN..SYMMAX;
   SYMBOLS = 1..SYMMAX; 
  
VAR 
   CURSTATE,SYMBOL,ACTION,REDUCTION % PGN;
   NUMSYM, NUMTERMSYM % INTEGER;
   NUMSTATES % INTEGER; 
   ERRACTCOUNT % COUNTER; 
   MAXACTCOUNT % COUNTER; 
   DEFACT % PGN;
   FINISHED, EMPTY % PGN; 
   SR % PGTYPE; 
   SY,ST % ACTS;
   DEFGOTO % ARRAY[NONTERM] OF ACTS;
   MAXGOCOUNT % PACKED ARRAY[NONTERM] OF COUNTER; 
   TOTGOCOUNT % ARRAY[NONTERM] OF COUNTER;
   ACTAB % ARRAY[TERMSYM] OF PGN; 
   GOTAB % PACKED ARRAY[NONTERM,STATES] OF ACTS;
   GOCOUNT % PACKED ARRAY[NONTERM,STATES] OF COUNTER; 
   ACTCOUNT % ARRAY[SHIFT..REDUCE,STATES] OF COUNTER; 
   LITERAL % ARRAY[SYMBOLS] OF STRING;
   TABS % FILE OF INTEGER; (** SHOULD BE FILE OF INTEGER *) 
   MAKETAB % TEXT;
   SYMS % TEXT; 
(*$H+*) 
  
FUNCTION EQ ( X, Y % PGN ) % BOOLEAN; 
BEGIN 
   EQ %= (X.TYP = Y.TYP) AND (X.NUM = Y.NUM)
END; (* EQ *) 
  
  
  
PROCEDURE ERROR ( CODE % INTEGER ); 
BEGIN 
   HALT;
END; (* ERROR *)
  
  
  
PROCEDURE PRINTOUT; 
  
(* PRINTS THE ENTIRE GO-TO (NEXT STATE) TABLE *)
  
VAR SY,ST % ACTS; 
  
BEGIN 
   WRITELN(MAKETAB,STARS,STARS);
   FOR SY %= NUMTERMSYM+1 TO NUMSYM DO BEGIN
         (* CHECK THE DEFAULT ACT *)
         IF (NUMSTATES - TOTGOCOUNT[SY]) > MAXGOCOUNT[SY] THEN
             DEFGOTO[SY] %= EMPTYACT; 
         WRITELN(MAKETAB,LITERAL[SY]);
         FOR ST %= 1 TO NUMSTATES DO
            IF GOTAB[SY,ST] <> DEFGOTO[SY] THEN 
               WRITELN(MAKETAB,ST,GOTAB[SY,ST]);
         WRITELN(MAKETAB,'*  ',DEFGOTO[SY]);
         END; 
  
   WRITELN(MAKETAB,STARS,STARS) 
END; (* PRINTOUT *) 
  
  
  
FUNCTION LITYPE ( A % PGN ) % CHAR ;
  
(* RETURNS A ONE CHARACTER REPRESENTATION OF THE TYPE. *) 
  
BEGIN CASE A.TYP OF 
   SHIFT% LITYPE %= 'S';
   REDUCE% LITYPE %= 'R'; 
   ERR% LITYPE %= 'E';
   DONE% LITYPE %= 'D'; 
   EOF,EOA,EOS,SYM,STATE,GO2% ERROR(40);
   END; 
END; (* LITYPE *) 
(*$H+*) 
PROCEDURE PRINTSTATE; 
  
(* PRINTS ONE STATE OF THE ACTION TABLE TO FILE MAKETAB *)
  
VAR S % ACTS; 
  
BEGIN 

   (* WRITE OUT THE STATE NUMBER *) 
   WRITELN(MAKETAB, CURSTATE.NUM);

   (* CHECK FOR DONE STATE *) 
   IF EQ(DEFACT, FINISHED) THEN 
      WRITELN(MAKETAB,'*  D') 
   ELSE BEGIN 

  
   (* SEE IF ERROR STATE IS MOST COMMON *)
   IF (ERRACTCOUNT > MAXACTCOUNT) THEN
      DEFACT %= EMPTY;
  
   (* PRINT ALL NON-DEFAULT ENTRIES *)
   FOR S %= 1 TO NUMTERMSYM DO
   IF NOT EQ (ACTAB[S],DEFACT) THEN 
         WRITELN(MAKETAB,LITERAL[S],LITYPE(ACTAB[S]),ACTAB[S].NUM % 6); 
  
   (* PRINT THE DEFAULT VALUE *)
   WRITELN(MAKETAB,'*  ', LITYPE(DEFACT), DEFACT.NUM) 
   END
END;(* PRINTSTATE *)
  
  
  
PROCEDURE DOGOTO ( SYMBOL, NEWSTATE, CURSTATE % PGN );
  
(* MAKES AN ENTRY IN THE GO TO TABLE *) 
  
VAR C % COUNTER;  (* TEMPORARY HOLDER FOR COUNT *)
  
BEGIN 
   GOTAB[SYMBOL.NUM,CURSTATE.NUM] %= NEWSTATE.NUM;
   C %= GOCOUNT[SYMBOL.NUM,NEWSTATE.NUM] + 1; 
   GOCOUNT[SYMBOL.NUM,NEWSTATE.NUM] %= C; 
   (* COUNT TOTAL ENTRIES FOR THIS SYMBOL *)
   TOTGOCOUNT[SYMBOL.NUM] %= TOTGOCOUNT[SYMBOL.NUM] + 1;
   IF C > MAXGOCOUNT[SYMBOL.NUM] THEN BEGIN 
      MAXGOCOUNT[SYMBOL.NUM] %= C;
         DEFGOTO[SYMBOL.NUM] %= NEWSTATE.NUM; 
         END; 
  
END; (* DOGOTO *) 
(*$H+*) 
PROCEDURE GETLITERAL ( SNO % INTEGER ); 
  
(* READS A STRING FROM INPUT, DELIMITED BY BLANKS OR QUOTES, AND STORES 
   IT IN LITERAL(SNO)      *) 
  
CONST 
   QUOTE = '''';
   BLANK = ' '; 
  
VAR 
   STRNG % ARRAY[1..STRINGSIZE] OF CHAR;
   CH % CHAR; 
   DELIM % CHAR;
   I % COUNTER; 
   DONE % BOOLEAN;
  
BEGIN 
   (* INITIALIZE STRNG AND SKIP TO FIRST NON-BLANK *) 
   FOR I %= 1 TO STRINGSIZE DO
      STRNG[I] %= BLANK;
   REPEAT 
      READ(SYMS, CH); 
   UNTIL CH <> BLANK; 
  
   (* THE FIRST NON-BLANK DETERMINES THE DELIMITER *) 
   IF CH = QUOTE
      THEN DELIM %= QUOTE 
      ELSE DELIM %= BLANK;
  
   I %= 1;
   STRNG[1] %= CH;
   DONE %= FALSE; 
   REPEAT  I %= I + 1;
      READ(SYMS, CH); 
      STRNG[I] %= CH; 
      IF CH = DELIM 
      THEN IF DELIM = BLANK 
         THEN DONE  %= TRUE 
         ELSE BEGIN  (* ALLOW FOR IMBEDDED QUOTES *)
            READ(SYMS, CH); 
         IF CH <> QUOTE THEN
            DONE %= TRUE; 
            END 
   UNTIL DONE;
  
   (* STORE THE COMPLETED STRING *) 
   PACK ( STRNG, 1, LITERAL[SNO] ); 
   WRITELN(BLANK, SNO, BLANK, LITERAL[SNO] ); 
END; (* GETLITERAL *) 
(*$H+*) 
PROCEDURE INITIALIZE ( VAR NUMSYM % INTEGER; VAR NUMTERMSYM % INTEGER); 
  
(* READ IN THE LIST OF SNOS WITH THE LITERAL STRINGS MAKETABLES WILL NEED 
   FOR EACH SNO.  TERMINAL SYMBOLS PRECEED NON-TERMINALS. 
   A SNO OF 0 MARKS END OF TERMINALS; SNO=-1 MARKS END OF LIST *) 
  
VAR 
   SNO % INTEGER; 
  
BEGIN 
   NUMSYM %= 0; 
   WRITELN(' VERIFICATION OF INPUT TO THE FLOWCHARTER INTERFACE PROGRAM%'); 
   WRITELN; WRITELN; WRITELN(' ',STARS,STARS); WRITELN; WRITELN;
   WRITELN('  THE SYMBOLS ARE%  '); WRITELN;
   REPEAT 
      READ(SYMS, SNO);
      IF SNO = 0 THEN (* END OF TERMINAL SYMBOLS *) 
         NUMTERMSYM %= NUMSYM 
      ELSE IF SNO > 0 THEN BEGIN (* PROCESS TERMINAL OR NON-TERMINAL SYMBOL *)
         NUMSYM %= NUMSYM + 1;
         GETLITERAL ( SNO );
         END
   UNTIL SNO < 0; 
END;
  
  
  
PROCEDURE DOACT ( SYMBOL % PGN ; ACTION % PGN );
  
(* MAKES AN ENTRY IN THE ACTION TABLE *)
  
VAR C % COUNTER; (* TEMPORARY COUNT HOLDER *) 
BEGIN 
   ACTAB[SYMBOL.NUM] %= ACTION; 
   (* POSSIBLE NEW MAXIMUM ENTRY *) 
   C %= ACTCOUNT[ACTION.TYP,ACTION.NUM] + 1;
   ACTCOUNT[ACTION.TYP,ACTION.NUM] %= C;
   IF C > MAXACTCOUNT THEN BEGIN
      DEFACT %= ACTION; 
      MAXACTCOUNT %= C; 
      END;
  
   (* ONE MORE ACTION MEANS ONE LESS DEFAULT (ERROR) ACTION *)
   ERRACTCOUNT %= ERRACTCOUNT - 1;
END; (* DOACT *)
(*$H+*) 
PROCEDURE READIN ( VAR X % PGN ); 
  
(* READS A PARSER-GENERATOR NUMBER AND BREAKS IT UP INTO A TYPE AND NUMBER *) 
  
VAR N % INTEGER;
  
BEGIN 
   N %= TABS^ ; 
   GET ( TABS );

   WRITE(N % 6);
   WITH X DO BEGIN
      NUM %= ABS(N) MOD BASE; 
      IF N < 0 THEN CASE N OF 
         -3% TYP  %= EOF; (* END OF FILE *) 
         -2% TYP  %= EOA; (* END OF ACT LIST *) 
         -1% TYP  %=EOS; (* END OF SYMBOL LIST *) 
         END
      ELSE IF N >= 6*BASE THEN
         ERROR(50)
      ELSE CASE (N DIV BASE) OF 
         0% TYP  %= SYM;
         1% TYP  %= STATE;
         2% TYP  %= SHIFT;
         3% ERROR(30);  (* NO SHIFT/REDUCE ALLOWED *) 
         4% TYP  %= GO2;
         5% TYP  %= REDUCE; 
         END
   END
END; (* READIN *) 
  
  
  
BEGIN (* THE MAIN PROGRAM, INTERFACE *) 
  
(* INITIALIZATION OF COUNTERS AND TABLES *) 
  
EMPTY.TYP %= ERR; 
EMPTY.NUM %= EMPTYACT;
FINISHED.TYP %= DONE; 
FINISHED.NUM %= EMPTYACT; 
NUMSTATES %= 0; 
  
RESET(TABS);
RESET(SYMS);
INITIALIZE ( NUMSYM, NUMTERMSYM );
WRITELN; WRITELN(' ',STARS,STARS); WRITELN; WRITELN(' THE INPUT TABLE IS% '); 
WRITELN; WRITELN; 
  
(* ZERO AND EMPTY GOCOUNT AND TABLES *) 
FOR SY %= NUMTERMSYM+1 TO NUMSYM DO BEGIN 
   DEFGOTO[SY] %= EMPTYACT; 
   MAXGOCOUNT[SY] %= 0; 
   TOTGOCOUNT[SY] %= 0; 
   FOR ST %= 1 TO STATEMAX DO BEGIN 
      GOCOUNT[SY,ST] %= 0;
      GOTAB[SY,ST] %= EMPTYACT; 
   END
END; (* INITIALIZATION PHASE *) 
(*$H+*) 
READIN(CURSTATE); 
  
WHILE CURSTATE.TYP  <> EOF DO BEGIN 
   (* CHECK FOR LARGEST STATE NUMBER *) 
   IF CURSTATE.NUM > NUMSTATES THEN 
      NUMSTATES %= CURSTATE.NUM;
  
  
   (* INITIALIZE ROW OF ACTION TABLE (FOR THIS STATE) AS ALL ERRORS *)
   MAXACTCOUNT %= 0;
   ERRACTCOUNT %= NUMTERMSYM; 
   DEFACT %= EMPTY; 
   FOR SR %= SHIFT TO REDUCE DO 
      FOR ST %= 1 TO STATEMAX DO
         ACTCOUNT[SR,ST] %= 0;
   FOR SY %= 1 TO NUMTERMSYM DO 
      ACTAB[SY] %= EMPTY; 
  
   (* READ SYMBOL/ACTION PAIRS *) 
   READIN(SYMBOL);
   WHILE SYMBOL.TYP <> EOA DO BEGIN 
      READIN(ACTION); 
      IF ACTION.TYP  = SHIFT THEN 
         DOACT(SYMBOL,ACTION) 
      ELSE IF ACTION.TYP  = GO2 THEN
         DOGOTO(SYMBOL, ACTION, CURSTATE) 
      ELSE
         ERROR(10); 
      READIN(SYMBOL); 
   END;  (* OF SYMBOL/ACTION PAIRS *) 
  
   (* REDUCTION RULES OPTIONALLY FOLLOW *)
   READIN(REDUCTION); 
   WHILE REDUCTION.TYP <> EOS DO BEGIN
      READIN(SYMBOL); 
  
      (* IF THE SYMBOL LIST IS NULL, WE MUST BE DONE *) 
      IF SYMBOL.TYP <> SYM THEN 
         DEFACT %= FINISHED;
  
      (* READ A LIST OF SYMBOLS *)
      WHILE SYMBOL.TYP  = SYM DO BEGIN
         DOACT(SYMBOL,REDUCTION); 
         READIN(SYMBOL);
      END;
  
      (* TERMINATE LOOP WITH EITHER EOS OR NEW REDUCTION *) 
      IF ( SYMBOL.TYP = EOS ) OR ( SYMBOL.TYP = REDUCE ) THEN 
         REDUCTION %= SYMBOL
      ELSE
         ERROR(20); 
   END;  (* OF REDUCTION RULES *) 
  
   PRINTSTATE;
   READIN(CURSTATE);
  
END;  (* OF ALL INPUT *)
  
PRINTOUT;  (* THE ENTIRE GOTO TABLE *)
  
END (* OF THE WHOLE PROGRAM *). 
LU%%%;
