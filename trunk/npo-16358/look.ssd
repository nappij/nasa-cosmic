1                                                                               Page   1
  
                        Software manual : Module LOOK
                        ---------------------------------
  
  
 Description            FORTRAN PROGRAM
 -----------            This program is designed to look at long printout files.  It has
                        the features that it can jump to any place in the file (either back-
                        wards or forwards) without having to read in any of the intermediate
                        data.  It can also search (either forward or backward) for strings,
                        and scroll at different speeds.
  
                            When run on a VT100 the program is puts the terminal in some
                        rather strange modes, so if the program exits abnormally (by ^Y or
                        by the system crashing, for example) one should push the SET-UP key
                        followed by a shift-R (capital R) to restore the terminals default
                        modes.
  
                             Either of the following will actually start running the program;
                        typing RUN JPL:[JLV.LOOK]LOOK, or defining a symbol to run the
                        program (i.e. LOOK:==$JPL:[JLV.LOOK]LOOK.EXE) and then typing the
                        symbol.  The later method has the advantage that one can enter the
                        name of the file to be looked at and/or the symbol definition file's
                        name (see below) on the command line (for example:
                                         LOOK PRINT.LIS/DEFINITIONS=LOOKCOM.DAT
                        will run the program (if LOOK is defined as above) on the file
                        PRINT.LIS with the symbol definitions taken from LOOKCOM.DAT
                        (the DEFINITIONS switch can go before or after the main file's
                        name and can be abbreviated all the way to a D)).  If the switch
                        /NARROW is on the command line, then the screen will not be converted
                        into 132 column mode (this, of course, only applies to VT100 terminals).
                        If the switch /WRAP is present then the lines will be printed with
                        terminal wrapping, instead of being cut to the width of the terminal.
                        If the switch /BOX is present then one line of output is sacrificed
                        to allow a line to be drawn dividing the file text from the command
                        input line.
  
                             The following commands are the "basic" command set of the
                        program:
                                  n$         - jump by n lines (positive or negative)
                                  n%         - jump by n blocks (positive or negative)
                                  ^          - search (forward) for the string(s) in the search
                                               buffers (up to 10) and display from that line if
                                               found, if not found ring the terminal bell and
                                               turn on LED 3 (VT100's only).  Matches are found
                                               irregardless of lower/uppercase differences.
                                  -^         - search (backward) for string(s), same rules as
                                               forward search.
                                  - "string" 'string' ... ^
                                             - load search buffers with the given strings and
                                               search (backward) for them, same rules as
                                               forward search.
                                  "string"   - clear the search buffers and save the given
                                               string as the only search string.  A string
                                               can consist of any characters, to include a
                                               quotation mark (") one must put two of them in
                                               a row ("").
                                  'string' 'string' ...
                                             - add the given string(s) to the search buffers.
1                                                                               Page   2
  
                                               A string can consist of any characters, to
                                               include a single quote (') one must put two of
                                               them in a row ('').
                                  !          - set reverse switch, all commands will now work
                                               in reverse (i.e. n$ will jump -n lines, etc.)
                                  #          - scroll
                                  -#         - scroll backward
                                  (          - stop scrolling (only valid command when
                                               scrolling is in operation),
                                               or cancel current line jump, search, or
                                               & command.
                                  n)         - set scrolling speed to n lines per second
                                               (positive or negative, integer or real)
                                               (originally set to 2).
                                               NOTE:  there is a maximum speed that will not
                                               be exceeded (varies with situation) even if
                                               scrolling speed is set at a fast value.
                                  n*         - mark the nth line from the top of the screen
                                               as the boundary of the print range.  The print
                                               range is defined by the last two such marked
                                               lines.
                                  n&         - print the range of lines from the top of the
                                               screen to the nth line from the top of the
                                               screen (n can be either positive or negative).
                                               onto device SYS$PRINT.  if n is 0 or absent
                                               then the range marked with the * command is
                                               used, if available, otherwise 23 is used for
                                               n.  The format of the printout will be that
                                               of the original file, not necessarily what
                                               is shown on the screen (i.e. FORTRAN carriage-
                                               control, and all printer control will work as
                                               they are supposed to).
                                  n-&        - same as n&, except output is put into a file
                                               named LOOKPRINT.LIS in the default directory
                                               (File format will be the same as the original
                                               file, except organization will be sequential)
                                               (appended to the latest version if a previous n-&
                                               or n--& command has been given, otherwise a new
                                               version is created).
                                  n--&       - same as n-&, except always creates a new version
                                               of the output file.
                                  @          - exit the program.
                                  +          - re-writes the screen.
                                  <          - repeat the last command.
  
                             If an invalid command is typed the terminal bell is rung and on
                        a VT100 LED #3 is turned on.  The line is parsed in such a way that a
                        valid command will be executed even if followed by an invalid command.
                        Note that no command is executed until a standard line terminator is
                        received (ASCII code of 1 to 31).  Note that commands are limited to
                        34 characters when entered in response to the prompt.  In order to
                        enter longer commands one can use the "command mode" DEFINE command
                        (see below) and then execute the symbol.  Also all search strings
                        are limited to 30 characters.
  
                             If the user types ^Z (Control-Z) whenever the program is not
                        currently executing a command, the program will enter "command" mode.
                        This mode allows the user to use any of the following commands:
1                                                                               Page   3
  
                                  DEFINE s := a1 a2 ...
                                                 - which defines a symbol s in the same man-
                                                   ner as a line in the definitions file (see
                                                   below), including line continuations.
                                  EXIT           - returns to the normal "look" mode.
                                  HELP a         - where a is one of the commands shown above.
                                  SET [NO]switch - with switch being any of WRAP, BOX, WIDE
                                                   or NARROW.  These have the same affect as
                                                   the command line switches of the same
                                                   names (WIDE is the same as NONARROW),
                                                   with the NO qualifier turning them off.
                                  SHOW [s]       - where s is a defined symbol.  This will
                                                   show what commands a symbol is defined
                                                   as. (if s is omitted, all defined symbols
                                                   are shown).
                                  @filename      - Inputs the file filename as a definitions
                                                   file.
  
                             The user is also allowed to define symbols for a command or
                        commands.  Valid symbols consist of the characters a-z (lower and
                        upper-case are equivalent), _, =, `, ~, [, ], {, }, ;, :,
                        ,(comma), >, ?, /, \,and  |.  Symbol definitions are given in
                        a symbol definition file which is read at the start of execution
                        (or by the "command" level @ command), or by the "command" level
                        DEFINE command.  This file is either given by the /DEFINITIONS
                        switch, or a file named LOOKCOM.DAT is searched for in the fol-
                        lowing places:  The default directory (the file is used only if
                        the user owns it), the user's username directory on JPL,
                        CIT, and SYS2 in that order.
  
                             In the symbol definition file the user can place both commands
                        and definitions.  Commands will be executed on encounter, and def-
                        initions will be placed in the definitons list.  Definitions have
                        the following form:
                                      symbol := command1 command2 command3 ... command9
                        Up to ten commands can be contained in each symbol (exception - a
                        symbol for the stop scrolling command should have only the one command
                        in it ( ( )) and will be executed (when the symbol is typed) in the
                        order they appear in the definition.  A - (minus sign) as the last
                        character in a line means the definition is continued on the next
                        line.  The following are default symbol definitions (they can be
                        overriden by the symbol definition file):
                                  U := 23$
                                  D := -23$
                                  S := #
                                  Q := (
                                  J := 20%
                                  B := -20%
                                  P := 23&
                                  A := 23-&
                                  L := 23--&
                                  E := @
                                  M := *
                                  C := +
                                  R := <
  
                        Note, that only the first character of a symbol is significant in the
                        symbol definition file.  Also when input as a command the symbol should
1                                                                               Page   4
  
                        be input as only one character.
  
                             A line enclosed by braces ({ }) will be treated as a "command"
                        level command (such as SET WIDE, @filename, etc.).
  
                             The LEDs on a VT100 terminal are used to convey various bits of
                        information.  Their meanings are as follows:
                                  1 - on indicates a command is being executed (useful since
                                      some of the commands don't affect the screen until
                                      completion).
                                  2 - on indicates that reverse is on (an odd number of !
                                      commands have been executed).
                                  3 - on indicates an invalid command was encountered (either
                                      input from the terminal, or while executeing a def-
                                      inition), or a search failed.
                                  4 - on indicates that a range of lines has been marked for
                                      printing
  
  
                        NOTE:  If while using the program (on variable length record files)
                               one gets garbage on the screen, try moving either one block
                               forward or backward to realign the record boundaries.  Also
                               when working with FORTRAN carriage-control files the + (plus)
                               carriage-control character is ignored, and when working with
                               printer files, all carriage-control with the exception of
                               line feeds is ignored, and at least one line feed before each
                               record is assumed.
  
                        Programmer - Jon Vavrus  12 NOV 1980
                        Revised    - Jon Vavrus  30 MAR 1981
                        Revised    - Jon Vavrus   4 MAY 1981
                        Revised    - Jon Vavrus  12 MAY 1981
                        Revised    - Jon Vavrus  31 JUL 1981 (changed CCLINE usage)
                        Revised    - Jon Vavrus  27 AUG 1981
                        Revised    - Jon Vavrus   3 SEP 1981
                        Revised    - Jon Vavrus  30 DEC 1981 (added ^X)
                        Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)
                        Revised    - Jon Vavrus  15 JUL 1982 (extract some proc's add
                                                              "command" level to symbol file)
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                        Revised    - Jon Vavrus   9 SEP 1982
                        Revised    - Jon Vavrus   4 APR 1983 (broadcast stuff)
                        Revised    - Jon Vavrus  13 APR 1983
                        Revised    - Jon Vavrus  17 MAY 1983
                        Revised    - Jon Vavrus  28 MAY 1983
                        Revised    - Jon Vavrus   9 SEP 1983
                        Revised    - Jon Vavrus  27 SEP 1983
  
 Calls                  BLKIN   Reads in one block of data from the input file.                               
 -----                  BLKOPN  Opens a file for block input.                                                 
                        BLKSIN  Reads in 7 blocks of data from the input file.                                
                        BRDCST  Fields braodcast messages.                                                    
                        COMLVL  Executes "command level" commands.                                            
                        DODEF   Processes a symbol file.                                                      
                        DOIT    Executes a command.                                                           
                        INTASC  Converts a string of bytes into a character variable                          
                        LINCON  Converts data in the input buffer into lines in the output                    
                                arrays.
1                                                                               Page   5
  
                        PRSCOM  Parses a command line.
                        TTBRDINI Initializes broadcast handler.
                        EXIT
                        SETERM
  
 Additional entries     NONE
 ------------------
  
 Common storage         BRDCM1  Contains character variables for broadcast handling.
 --------------                   BRDNOT holds the notice to be displayed on the screen.
                                  BRDMSG which holds broadcast messages.
                        BRDCM2  Contains non-character information for broadcast handling.
                                  BRDLEN the length of strings in BRDMSG.
                                  BRDCNT the count of strings in BRDMSG.
                                  BRDFLG a flag telling if there are unread messages.
                        CHARS   Used to pass character variables; contains LINES a character
                                array of the output lines, and SRCHBF the search buffer, and
                                CRLF which contains <CR><LF>, and REVVID + REGVID which are
                                the VT100 control sequences to set/unset reverse video
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length(s) of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        INPUTC  Contains the input character buffer INLINE and the defined
                                symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUMDEF
                        LNCN    Contains output arrays, and file pointers and information:
                                     LINLEN - array of output line lengths
                                     LINEP  - top of screen line (or last line output by
                                              backward scroll)
                                     NLINES - number of lines in arrays
                                     BUFFER - array of unconverted data
                                     PBUF   - current position in BUFFER
                                     NBUF   - number of bytes in BUFFER
                                     BLK    - next block in file
                                     FSZ    - record length for FIX files, or FSZ for VFC files
                                     IFSZ   - word extended record length for FIX files
                                     RFM    - files RFM
                                     RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)
                                     SBLK   - starting block of current batch of output lines
                                     CCLINE - array containing pointer to where the line's
1                                                                               Page   6
  
                                              record starts in the file (CCLINE(1,x) = block
                                              #, CCLINE(2,x) = byte number in block).  If
                                              CCLINE(1,x) = 0 then it is a carriage control
                                              line.
                                     LBLK   - last block processed by LINCON
                                     LPBUF  - last value of PBUF processed by LINCON
                        OWNER   Used to pass the file owner's UIC back to the main program
                                from a FORTRAN OPEN.
  
 Procedures             ERASE_COMMAND
 ----------                This procedure erase the command part of the bottom line.
  
                        GET_FIRST_SCREEN
                           This procedure inputs and formats the first screen-full of output.
  
                        MAIN_DIR_SEARCH
                           This routine searches the directories of the users username on the
                           various disks (JPL, CIT, and SYS2 in that order) for the
                           symbol file (LOOKCOM.DAT), and if found opens it.
  
                        NO_INPUT_EXIT
                           This routine is an error routine if something goes wrong with getting
                           input from the terminal.
  
                        OPEN_PRINTOUT
                           This procedure opens the input file.
  
                        PROCESS_COM_LINE
                           This procedure processes the command line.
  
                        PROCESS_SYMBOL_FILE
                           This procedure processes the symbol/command file.
  
                        READ_ERROR
                           This procedure is executed if an error occurs while reading the
                           input file.
  
                        SETUP_TERM
                           This procedure opens and sets up the terminal.
  
 Input variables        FILE    Used to input the symbol file's name.
 ---------------
  
 Output variables       FILE    Output with error message on open failure.
 ----------------       LINES   Output array, contains converted lines of output.
  
 I/O variables          LINE    Used to get an error message from SYS$GETMSG and to input
 -------------                  a line from the symbol file, or to output error message,
                                and as the terminal input buffer.
  
 Input units            INCHAN  Input channel number of the terminal.
 -----------            30      Symbol file (file containing symbol definitions).
  
 Output units           6       Output to terminal.  Used for error messages.
 ------------           9       Output to terminal.  Carriage-control LIST.
                        UNIT
1                                                                               Page   7
  
  
 I/O units              NONE
 ---------
  
 Source lines           936 (Total)
 ------------           465 (Non-comment)                                                                     
1                                                                               Page   8
  
                        Software manual : Module   COMLVL
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine implements the "command" mode of look, by processing
                        one command which is passed to it.
  
                         Programmer - Jon Vavrus  26 AUG 1981
                         Revised    - Jon Vavrus   3 SEP 1981
                         Revised    - Jon Vavrus  18 SEP 1981
                         Revised    - Jon Vavrus   3 MAR 1982 (added SETNAR/SETWID)
                         Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)
                         Revised    - Jon Vavrus  15 JUL 1982 (changed to handle only one
                                                               command)
                         Revised    - Jon Vavrus  18 AUG 1982 (Bigger arrays)
                         Revised    - Jon Vavrus   9 SEP 1982
                         Revised    - Jon Vavrus   4 APR 1983 (add broadcast and spawn stuff)
                         Revised    - Jon Vavrus  17 MAY 1983
                         Revised    - Jon Vavrus  28 MAY 1983 (check defined symbols)
                         Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)
                         Revised    - Jon Vavrus  27 SEP 1983
  
 Calls                  CLRWRP  Sets the terminal NOWRAP                                                      
 -----                  DODEF   Processes a symbol file                                                       
                        GETDEF  Translates a line into a symbol definition                                    
                        SETNAR  Set VT100 terminal to 80 columns                                              
                        SETWID  Set VT100 terminal to 132 columns                                             
                        SETWRP  Sets the terminal WRAP                                                        
                        TTSPAWN Spawns a sub-process (needed to get rid of broadcast                          
                                trap
  
 Additional entries     NONE
 ------------------
  
 Common storage         BRDCM1  Contains character variables for broadcast handling.
 --------------                   BRDNOT holds the notice to be displayed on the screen.
                                  BRDMSG which holds broadcast messages.
                        BRDCM2  Contains non-character information for broadcast handling.
                                  BRDLEN the length of strings in BRDMSG.
                                  BRDCNT the count of strings in BRDMSG.
                                  BRDFLG a flag telling if there are unread messages.
                        CHARS   Used to pass character variables; contains LINES a character
                                array of the output lines, and SRCHBF the search buffer, and
                                CRLF which contains <CR><LF>, and REVVID + REGVID which are
                                the VT100 control sequences to set/unset reverse video
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
1                                                                               Page   9
  
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        INPUTC  Contains the input character buffer INLINE and the defined
                                symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUDMEF
  
 Procedures             DEFINE_SYMBOL
 ----------                This procedure defines a symbol.
  
                        ERROR
                           This writes an error message
  
                        OK_RETURN
                           This procedure sets DONE to false and returns.
  
                        SET_NARROW
                           This procedure sets the terminal to 80 column mode.
  
                        SET_WIDE
                           This procedure sets the terminal to 132 column mode.
  
                        SHOW_SYMBOL
                           This procedure writes out the definition for one symbol
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           UNIT
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           599 (Total)
 ------------           408 (Non-comment)                                                                     
1                                                                               Page  10
  
                        Software manual : Module    DODEF
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine processes the file open on unit 30 as a "symbol" file.
  
                        Programmer - Jon Vavrus  15 JUL 1982
                        Revised    - Jon Vavrus   9 SEP 1982
                        Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)
                        Revised    - Jon Vavrus  21 SEP 1983
  
 Calls                  DOIT    Executes a command.                                                           
 -----                  GETDEF  Translates a line into a symbol definition                                    
                        PRSCOM  Parses a command line                                                         
                        COMLVL                                                                                
  
 Additional entries     NONE
 ------------------
  
 Common storage         INPUTC  Contains the input character buffer INLINE and the defined
 --------------                 symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUMDEF
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            30
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           117 (Total)
 ------------            71 (Non-comment)                                                                     
1                                                                               Page  11
  
                        Software manual : Module     DOIT
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine executes the commands passed by the main program or
                        rings the terminal bell and turns LED 3 on (error signal) if the
                        command is invalid.
  
                        Programmer - Jon Vavrus  13 NOV 1980
                        Revised    - Jon Vavrus  30 MAR 1981
                        Revised    - Jon Vavrus  12 MAY 1981
                        Revised    - Jon Vavrus  21 JUL 1981
                        Revised    - Jon Vavrus  31 JUL 1981 (change CCLINE usage)
                        Revised    - Jon Vavrus  27 AUG 1981
                        Revised    - Jon Vavrus  10 SEP 1981
                        Revised    - Jon Vavrus  23 SEP 1981
                        Revised    - Jon Vavrus   6 NOV 1981
                        Revised    - Jon Vavrus  30 DEC 1981 (make LED's work right)
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                        Revised    - Jon Vavrus   9 SEP 1982
                        Revised    - Jon Vavrus  30 NOV 1982
                        Revised    - Jon Vavrus  12 JAN 1983
                        Revised    - Jon Vavrus   4 APR 1983 (Take care of "Quitting")
  
 Calls                  BLKCLS  Closes the input file.                                                        
 -----                  BLKIN   Reads in one block of data.                                                   
                        BLKSIN  Reads in 7 blocks of data.                                                    
                        CONVUP  Converts a string to upper-case.                                              
                        INTASC  Converts a given character variable to upper-case.                            
                        LINCON  Converts data to output lines in the output arrays.                           
                        PRTCLS  Closes the printer output file used in & commands.                            
                        PRTOPN  Opens the printer output file.                                                
                        PRTOUT  Outputs a record to the printer output file.                                  
                        REDOIT  Calls DOIT, allows for recursion.                                             
                        STOPSC  AST routine to cause "stop" command to work.                                  
                        WORKNG  Writes flashing "WORKING" message.                                            
                        EXIT                                                                                  
                        RESTRM                                                                                
  
 Additional entries     NONE
 ------------------
  
 Common storage         CHARS   Used to pass character variables; contains LINES a character
 --------------                 array of the output lines, and SRCHBF the search buffer, and
                                CRLF which contains <CR><LF>, and REVVID + REGVID which are
                                the VT100 control sequences to set/unset reverse video.
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length(s) of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - starting and ending block numbers and pointers
1                                                                               Page  12
  
                                              of print range
                                     VT100  - flag set .TRUE. if terminal is a VT100
                                     LRL    - length of longest record in input file
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen.
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        LNCN    Contains output arrays, and file pointers and information:
                                     LINLEN - array of output line lengths
                                     LINEP  - top of screen line (or last line output by
                                              backward scroll)
                                     NLINES - number of lines in arrays
                                     BUFFER - array of unconverted data
                                     PBUF   - current position in BUFFER
                                     NBUF   - number of bytes in BUFFER
                                     BLK    - next block in file
                                     FSZ    - record length for FIX files, or FSZ for VFC files
                                     IFSZ   - word extended record length for FIX files
                                     RFM    - files RFM
                                     RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)
                                     SBLK   - starting block of current batch of output lines
                                     CCLINE - array containing pointer to where the line's
                                              record starts in the file (CCLINE(1,x) = block
                                              #, CCLINE(2,x) = byte number in block).  If
                                              CCLINE(1,x) = 0 then it is a carriage control
                                              line.
                                     LBLK   - last block processed by LINCON
                                     LPBUF  - last value of PBUF processed by LINCON
                        STOPCM  Used to pass information back and forth to/from the stop
                                scrolling AST.  STOPIT is a flag set .TRUE. if scrolling
                                should be stopped, INBUF is the input character, IOFLAG and
                                TIMFLG are event flags, and IOSB is the I/O IOSB.
  
 Procedures             BACK_SCROLL_EXIT
 ----------                This routine exits from scrolling backward in FIX files.  It converts
                           the data at the current position into output lines, frees the event
                           event flags, resets the LEDs (#3 off) and returns.
  
                        BACKWARD_SEARCH
                           This procedure searches backward through the file for a string. IF
                           found the position is located there, the screen refreshed and the
                           LEDs reset (#3 off), otherwise the screen is left alone, the position
                           is not changed, and the LEDs are reset (#3 on).  In either case the
                           a return from DOIT is executed.
  
                        BACKWARD_SCROLLING
                           This procedure handles scrolling backward through the file.
  
                        CANCEL_COMMAND
                           This routine is used to terminate either line jumps or searches on
                           input of a (.
  
                        CANCEL_STOPPER
                           This routine gets rid of the stopping AST.
  
                        ERROR_EXIT
                           This routine rings the terminal bell then resets the LEDs (#3 on)
1                                                                               Page  13
  
                           and returns.
  
                        FIND_NON_CC_LINE
                           This procedure locates a non-carriage-control line near LINEP
  
                        FORWARD_SEARCH
                           This routine searchs forward through the file for a given string.
                           If it is found the screen is reset to that position, and the LEDs are
                           reset (#3 off), otherwise the position and screen remain unchanged
                           and the LEDs are reset (#3 on).  In either case a return from DOIT
                           is executed.
  
                        FORWARD_SCROLLING
                           This procedure executes scrolling in a forward direction.
  
                        FREE_FLAGS_EXIT
                           This routine exits from scrolling.  It frees the event flags, cancels
                           any input requests to the terminal, resets the LEDs (#3 off) and
                           returns.
  
                        GET_LAST_LINE
                           This procedure determines PAGEND given LINEP
  
                        GET_START_LINE
                           This procedure determines LINEP given a value for PAGEND
  
                        HIT_BEGINNING
                           This procedure is executed if the position goes past the beginning
                           of the file.  Everything is reset to the beginning of the file.
  
                        HOLD_CURRENT_SETUP
                           This routine is used in searches.  It holds all the information
                           needed to recreate the current position and array conditions.
  
                        HOME_PLUS_LEDS_EXIT
                           This routine homes the cursor, resets the LEDs (#3 off).
  
                        INPUT_SEVEN_BLOCKS
                           This procedure inputs seven blocks of data
  
                        JUMP_LINES
                           This procedure moves the current position NUMBER lines.
  
                        OUTPUT_RANGE
                           This procedure performs the output for the print, list, and append
                           commands.  Which is being used is determined by the value of PRINT
                           (-1 = print, 0 = append, 1 = list).
  
                        QUEUE_STOPPER
                           This procedure sets up an AST to allow the user to stop an
                           operation.
  
                        READ_ERROR
                           This procedure terminates program execution with an error message.
                           It is used when an input error occurs.
  
                        REFRESH_EXIT
                           This procedure refreshes the screen (puts up a new set of lines
1                                                                               Page  14
  
                           corresponding to the current line position), resets the LEDs (#3
                           off).
  
                        RESTORE_HELD_SETUP
                           This routine is used in searches.  It restores the position and
                           arrays that have previously been saved by HOLD_CURRENT_SETUP.
  
                        SCROLL_BLANK_LINE_POST
                           This routine is used in scrolling backwards in non-FIXfiles.  It prints
                           a blank line then waits for one timer interval (which is set by the
                           scrolling speed), and then checks for the stop signal.
  
                        SCROLL_BLANK_LINE_PRE
                           This routine is used in scrolling backward in FIX files.  It waits
                           one timer interval (set by scrolling speed), checks for the stop
                           signal, then writes one blank line.
  
                        SCROLL_BLANK_LINE_VAR_PRE
                           This routine is used in scrolling backward in non-FIX files.  It
                           waits for one timer interval (set by scrolling speed), checks for
                           the stop signal, and then writes one blank line.
  
                        SCROLL_DOWN
                           This procedure scrolls the screen down one line and leaves the
                           cursor at the upper left hand corner.
  
                        SCROLL_REFRESH_EXIT
                           This procedure scrolls to the proper line, resets the LED's (#3
                           off).
  
                        SEARCH_ERROR_EXIT
                           This procedure stops execution of a search command with an error.
                           while restoring the held setup and getting rid of the I/O request
                           to the terminal
  
                        STOP_WITH_ERROR
                           This procedure stops execution of a command with an error exit,
                           while restoring the held setup and getting rid of the I/O request
                           to the terminal
  
                        VAR_BACK_SCROLL_EXIT
                           This routine exits from scrolling backwards in non-FIX files.  It
                           sets the position to the correct place in the buffer, then converts
                           the rest of the buffer, sets the current line position, resets the
                           LEDs (#3 off) and returns.
  
                        WAIT_FOR_SCROLL
                           This procedure waits for the scrolling interval to pass.
  
                        WAIT_FOR_SCROLL_AST
                           This procedure waits for the scrolling interval to pass after
                           queueing the stop command AST.
  
                        WORKING
                           This procedure turns on LED 1 and starts up the working message.
  
                        WRITE_BLOCK_NUMBER
                           This procedure scrolls an extra line if needed (if dividing line
1                                                                               Page  15
  
                           (BOX) switch is chosen, and writes out the block number in the
                           lower right corner.
  
 Input variables        INBUF   One byte buffer used to get stop scrolling command.
 ---------------
  
 Output variables       BUFFER  Buffer holding input data.  During back scrolling output
 ----------------               is done directly from here.
                        ESC     Used to output an ASCII <ESC>.
                        LINES   Lines of output converted by LINCON.
  
 I/O variables          NONE
 -------------
  
 Input units            INCHAN  Channel number of the terminal.
 -----------
  
 Output units           9       Output to the terminal (no carriage-control).
 ------------           20      Output for the List, Print, and Append commands
                        UNIT
  
 I/O units              NONE
 ---------
  
 Source lines           1962 (Total)
 ------------           1545 (Non-comment)                                                                    
1                                                                               Page  16
  
                        Software manual : Module   GETDEF
                        ---------------------------------
  
  
 Description            FORTRAN FUNCTION
 -----------            This routine translates a line into a symbol definition
  
                        Programmer - Jon Vavrus   3 SEP 1981
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                        Revised    - Jon Vavrus   9 SEP 1982
                        Revised    - Jon Vavrus  28 MAY 1983
                        Revised    - Jon Vavrus  17 AUG 1983
  
 Calls                  PRSCOM  Parses a command string                                                       
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         CHARS   Used to pass character variables; contains LINES a character
 --------------                 array of the output lines, and SRCHBF the search buffer, and
                                CRLF which contains <CR><LF>, and REVVID + REGVID which are
                                the VT100 control sequences to set/unset reverse video
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        INPUTC  Contains the input character buffer INLINE and the defined
                                symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUDMEF
                        PRSCHR  Contains the current symbol's search buffers (CURBUF)
                        PRSNUM  Contains the current symbol's definitions (CUR), flags
                                (CURFLG), and associated numbers (NUMCUR)
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
1                                                                               Page  17
  
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           152 (Total)
 ------------            80 (Non-comment)                                                                     
1                                                                               Page  18
  
                        Software manual : Module   LINCON
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine converts a buffer full of data into output lines in
                        the output arrays.
  
                        Programmer - Jon Vavrus  12 NOV 1980
                        Revised    - Jon Vavrus  13 MAY 1981
                        Revised    - Jon Vavrus  30 JUL 1981 (change CCLINE usage)
                        Revised    - Jon Vavrus  26 AUG 1981
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                        Revised    - Jon Vavrus  12 JAN 1983
  
 Calls                  INTASC  Converts a string of bytes into a character variable.                         
 -----                  SFTLIN  Shifts the lines in the output arrays to free up space for                    
                                more lines to be converted.
  
 Additional entries     NONE
 ------------------
  
 Common storage         CHARS   Contains the character array containing the actual output lines.
 --------------         DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length(s) of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        LNCN    Contains output arrays, and file pointers and information:
                                     LINLEN - array of output line lengths
                                     LINEP  - top of screen line (or last line output by
                                              backward scroll)
                                     NLINES - number of lines in arrays
                                     BUFFER - array of unconverted data
                                     PBUF   - current position in BUFFER
                                     NBUF   - number of bytes in BUFFER
                                     BLK    - next block in file
                                     FSZ    - record length for FIX files, or FSZ for VFC files
                                     IFSZ   - word extended record length for FIX files
                                     RFM    - files RFM
                                     RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)
                                     SBLK   - starting block of current batch of output lines
                                     CCLINE - array containing pointer to where the line's
                                              record starts in the file (CCLINE(1,x) = block
1                                                                               Page  19
  
                                              #, CCLINE(2,x) = byte number in block).  If
                                              CCLINE(1,x) = 0 then it is a carriage control
                                              line.
                                     LBLK   - last block processed by LINCON
                                     LPBUF  - last PBUF value processed by LINCON
  
 Procedures             CONVERT_TO_LINES
 ----------                This procedure converts the LENGTH bytes in BUFFER into lines in LINES
                           (starting at NLINES).  It takes into account form feeds (generate 2
                           blank lines) and line feeds.
  
                        INSERT_BLANK_LINE
                           This procedure inserts a blank line of length one character into the
                           proper arrays.
  
                        NEW_LINE
                           This procedure takes care of shifting the translated lines in the
                           arrays to make more room.
  
                        SET_CCLINE
                           This procedure sets the block and pointer values in the array CCLINE.
  
                        STORE_REMAINDER
                           This procedure moves the partial record at the end of BUFFER to
                           the beginning of BUFFER and sets NBUF, and PBUF accordingly.
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           429 (Total)
 ------------           272 (Non-comment)                                                                     
1                                                                               Page  20
  
                        Software manual : Module   BRDCST
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine catches broadcast messages and stores them away in
                        common.
  
                        Programmer - Jon Vavrus   4 APR 1983
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         BRDCM1  Contains character variables for broadcast handling.
 --------------                   BRDNOT holds the notice to be displayed on the screen.
                                  BRDMSG which holds broadcast messages.
                        BRDCM2  Contains non-character information for broadcast handling.
                                  BRDLEN the length of strings in BRDMSG.
                                  BRDCNT the count of strings in BRDMSG.
                                  BRDFLG a flag telling if there are unread messages.
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - starting and ending block numbers and pointers
                                              of the print range.
                                     VT100  - flag set .TRUE. if terminal is a VT100
                                     LRL    - length of longest record in input file
                                     LENLMT - maximum length of output (if <0 then WRAP set)
                                     PAGEND - Line number of last line output to screen.
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
1                                                                               Page  21
  
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           78 (Total)
 ------------           31 (Non-comment)                                                                      
1                                                                               Page  22
  
                        Software manual : Module   CONVUP
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine converts a string from lower to upper case.
                        Both of the strings are passed in non-descriptor form.
  
                        Programmer - Jon Vavrus  13 NOV 1980
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         NONE
 --------------
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           33 (Total)
 ------------           13 (Non-comment)                                                                      
1                                                                               Page  23
  
                        Software manual : Module    EXITR
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine is invoked on image exit and cancels any
                        AST, and closes the file and re-stores the terminal.
  
                        Programmer - Jon Vavrus  13 JAN 1983
  
 Calls                  RESTRM                                                                                
 -----                  BLKCLS                                                                                
                        WORKNG                                                                                
  
 Additional entries     NONE
 ------------------
  
 Common storage         DOITNM  Contains information transferred from the main program:
 --------------                      INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - starting and ending block numbers and pointers
                                              of the print range.
                                     VT100  - flag set .TRUE. if terminal is a VT100
                        STOPCM  Used to pass information back and forth to/from the stop
                                scrolling AST.  STOPIT is a flag set .TRUE. if scrolling
                                should be stopped, INBUF is the input character, IOFLAG and
                                TIMFLG are event flags, and IOSB is the I/O IOSB.
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           54 (Total)
 ------------           19 (Non-comment)                                                                      
1                                                                               Page  24
  
                        Software manual : Module   INTASC
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine converts a string of ascii coded bytes to a character
                        variable
  
                        Programmer - Jon Vavrus    JUL 1980
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         NONE
 --------------
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           25 (Total)
 ------------           10 (Non-comment)                                                                      
1                                                                               Page  25
  
                        Software manual : Module   REDOIT
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine calls DOIT
  
                        Programmer - Jon Vavrus  26 AUG 1981
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         NONE
 --------------
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           23 (Total)
 ------------            6 (Non-comment)                                                                      
1                                                                               Page  26
  
                        Software manual : Module   SFTLIN
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine shifts the output lines stored in the line storage
                        arrays in order to make room at the end of the arrays for more lines.
  
                         Programmer - Jon Vavrus  13 NOV 1980
                         Revised    - Jon Vavrus  12 MAY 1981
                         Revised    - Jon Vavrus  29 JUL 1981 (change CCLINE usage)
                         Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         LNCN    Contains output arrays, and file pointers and information:
 --------------                      LINLEN - array of output line lengths
                                     LINEP  - top of screen line (or last line output by
                                              backward scroll)
                                     NLINES - number of lines in arrays
                                     BUFFER - array of unconverted data
                                     PBUF   - current position in BUFFER
                                     NBUF   - number of bytes in BUFFER
                                     BLK    - next block in file
                                     FSZ    - record length for FIX files, or FSZ for VFC files
                                     IFSZ   - word extended record length for FIX files
                                     RFM    - files RFM
                                     RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)
                                     SBLK   - starting block of current batch of output lines
                                     CCLINE - array containing pointer to where the line's
                                              record starts in the file (CCLINE(1,x) = block
                                              #, CCLINE(2,x) = byte number in block).  If
                                              CCLINE(1,x) = 0 then it is a carriage control
                                              line.
                                     LBLK   - last block processed by LINCON
                                     LPBUF  - last value of PBUF processed by LINCON
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
1                                                                               Page  27
  
  
 I/O units              NONE
 ---------
  
 Source lines           73 (Total)
 ------------           29 (Non-comment)                                                                      
1                                                                               Page  28
  
                        Software manual : Module   STOPSC
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine is the AST used to stop the scrolling function.
  
                        Programmer - Jon Vavrus  13 NOV 1980
                        Revised    - Jon Vavrus  12 MAY 1981
                        Revised    - Jon Vavrus  26 AUG 1981
                        Revised    - Jon Vavrus   6 NOV 1981
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
  
 Calls                  STPSC2  Routine which simply calls this one.                                          
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         STOPCM  Used to pass information back and forth to/from the main
 --------------                 process.  STOPIT is a flag set .TRUE. if scrolling should
                                be stopped, INBUF is the input character, IOFLAG and TIMFLG
                                are event flags, and IOSB is the I/O IOSB.
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - starting and ending block numbers and pointers
                                              of the print range.
                                     VT100  - flag set .TRUE. if terminal is a VT100
                                     LRL    - length of longest record in input file
                                     LENLMT - maximum length of output (if <0 then WRAP set)
                                     PAGEND - Line number of last line output to screen.
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        INPUTC  Contains the input character buffer INLINE and the defined
                                symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUMDEF
  
 Procedures             NONE
 ----------
  
 Input variables        INBUF   One byte buffer used for the QIO input request.
 ---------------
  
 Output variables       NONE
 ----------------
1                                                                               Page  29
  
  
 I/O variables          NONE
 -------------
  
 Input units            INCHAN  Channel number of the terminal.
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           137 (Total)
 ------------            50 (Non-comment)                                                                     
1                                                                               Page  30
  
                        Software manual : Module   STPSC2
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine is the AST for the I/O request from STOPSC, if
                        invoked it will call STOPSC and exit.
  
                        Programmer - Jon Vavrus  13 NOV 1980
  
 Calls                  NONE
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         NONE
 --------------
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           19 (Total)
 ------------            4 (Non-comment)                                                                      
1                                                                               Page  31
  
                        Software manual : Module   TMAST2
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine is simply a means for TIMAST to refer to itself.  All it
                        does is call TIMAST.
  
                        Programmer  Jon Vavrus -  3 SEP 1982
                        Revised     Jon Vavrus - 21 SEP 1983 (changed name with TIMAST)
  
 Calls                  NONE
 -----
                        TIMAST
  
 Additional entries     NONE
 ------------------
  
 Common storage         NONE
 --------------
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           21 (Total)
 ------------            4 (Non-comment)                                                                      
1                                                                               Page  32
  
                        Software manual : Module   TIMAST
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine outputs the proper "WORKING" message at the bottom of the
                        screen and requeues itself as a timer AST (through TMAST2).
  
                        Programmer  Jon Vavrus -  8 SEP 1982
                        Revised     Jon Vavrus - 21 SEP 1983 (changed name with TMAST2)
  
 Calls                  TMAST2   - Routine which calls this one.                                              
 -----
                        DOIT
  
 Additional entries     NONE
 ------------------
  
 Common storage         DOITNM  Contains information transferred from the main program:
 --------------                      INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length(s) of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        TASTNM  Used to pass the ROW and COLUMN for the message, the flag
                                ONEFLG, the timer delta time DELTA, and the timer event flag
                                TIMREF.
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
1                                                                               Page  33
  
  
 I/O units              NONE
 ---------
  
 Source lines           72 (Total)
 ------------           29 (Non-comment)                                                                      
1                                                                               Page  34
  
                        Software manual : Module   WORKNG
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This subroutine puts out the flashing "WORKING" message.
  
                        Programmer  Jon Vavrus -  8 SEP 1982
  
 Calls                  TIMAST  Timer AST.                                                                    
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         DOITNM  Contains information transferred from the main program:
 --------------                      INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length(s) of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        TASTNM  Used to pass the ROW and COLUMN for the message, the flag
                                ONEFLG, the timer delta time DELTA, and the timer event flag
                                TIMREF.
  
 Procedures             NONE
 ----------
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
1                                                                               Page  35
  
  
 Source lines           89 (Total)
 ------------           32 (Non-comment)                                                                      
1                                                                               Page  36
  
                        Software manual : Module   PRSCOM
                        ---------------------------------
  
  
 Description            FORTRAN SUBROUTINE
 -----------            This routine parses a command line.
  
                        Programmer - Jon Vavrus  26 AUG 1981
                        Revised    - Jon Vavrus   3 SEP 1981
                        Revised    - Jon Vavrus  23 SEP 1981
                        Revised    - Jon Vavrus  30 DEC 1981 (put LED #1 turn-on in DOIT)
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                        Revised    - Jon Vavrus   9 SEP 1982
                        Revised    - Jon Vavrus  30 NOV 1982
                        Revised    - Jon Vavrus  28 MAY 1983 (Allow real scroll speeds)
                        Revised    - Jon Vavrus   7 SEP 1983
                        Revised    - Jon Vavrus  21 SEP 1983
  
 Calls                  DOIT    Executes commands                                                             
 -----
  
 Additional entries     NONE
 ------------------
  
 Common storage         CHARS   Used to pass character variables; contains LINES a character
 --------------                 array of the output lines, and SRCHBF the search buffer, and
                                CRLF which contains <CR><LF>, and REVVID + REGVID which are
                                the VT100 control sequences to set/unset reverse video
                        DOITNM  Contains information transferred from the main program:
                                     INCHAN - input channel of the terminal
                                     TIME   - scrolling speed in -10000000*seconds/line
                                     SBFFLG - flag indicating whether there is a string
                                              in the search buffer
                                     DIRECT - flag for reverse (-1 for reverse, else 1)
                                     EBK    - EBK of input file
                                     SBFLEN - length of string(s) in search buffer(s)
                                     RECBLK - number of bytes used per block in FIX-BLK files
                                     RANGE  - beginning and ending block numbers and pointers
                                              of the print range
                                     VT100  - flag set .TRUE. if terminal is VT100.
                                     LRL    - length of the longest record in input file.
                                     LENLMT - maximum output length (if <0 then WRAP set)
                                     PAGEND - line number of last line output to screen
                                     PAGLEN - number of lines per page
                                     COMLIN - line number for command input (bottom of screen)
                                     VT100A - flag set .TRUE. if VT100 has advanced video option
                        INPUTC  Contains the input character buffer INLINE and the defined
                                symbols SYMS and the definition search buffers DEFBUF
                        INPUTN  Contains the input character buffer length LENSAV, and the
                                symbol definitions DEFS, the number of such definitions
                                (NDEFS), the definition flags DEFFLG, and the definition
                                numbers NUMDEF
                        PRSCHR  Contains the current symbol's search buffers (CURBUF)
                        PRSNUM  Contains the current symbol's definitions (CUR), flags
                                (CURFLG), and associated numbers (NUMCUR)
1                                                                               Page  37
  
  
 Procedures             GET_NUMBER
 ----------                This procedure converts the number which starts the line into a
                           real (floating point) number in ANUMB.
  
                        INSERT_SEARCH_STRING
                           This procedure inserts a search string (LINE(2:J-1)) in the search
                           buffers as string NSRCH.
  
                        INVALID_COMMAND
                           This procedure takes care of invalid command syntax.
  
                        NO_COMMAND
                           This procedure handles a "empty" line.
  
 Input variables        NONE
 ---------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            UNIT
 -----------
  
 Output units           9       Output to terminal.  Carriage-control LIST if file is either
 ------------                   CR, FTN, or PRN; otherwise no carriage-control.
  
 I/O units              NONE
 ---------
  
 Source lines           434 (Total)
 ------------           304 (Non-comment)                                                                     
1                                                                               Page  38
  
                        Software manual : Module    BLKIN
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------            This module contains routines for block I/O
                             BLKOPN opens a file for block input
                             BLKSIN inputs 7 blocks of data
                             BLKIN  inputs one block of data
                             BLKCLS closes the file
  
                        Programmer - Jon Vavrus  28 OCT 1980
                        Revised    - Jon Vavrus  12 MAY 1981
                        Revised    - Jon Vavrus  27 JUL 1981
                        Revised    - Jon Vavrus  29 JUL 1981
                        Revised    - Jon Vavrus  26 AUG 1981
  
                        BLKIN inputs the a single block of data from the file opened by
                        BLKOPN.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           71 (Total)
 ------------           38 (Non-comment)                                                                      
1                                                                               Page  39
  
                        Software manual : Module   BLKOPN
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        BLKOPN opens a file for block input.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           94 (Total)
 ------------           69 (Non-comment)                                                                      
1                                                                               Page  40
  
                        Software manual : Module   BLKSIN
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        BLKSIN is used to input 7 blocks of data in a manner similiar to
                        BLKIN.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           52 (Total)
 ------------           41 (Non-comment)                                                                      
1                                                                               Page  41
  
                        Software manual : Module   BLKCLS
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        BLKCLS closes the input file.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           35 (Total)
 ------------           27 (Non-comment)                                                                      
1                                                                               Page  42
  
                        Software manual : Module   GETOWN
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------            This routine is used to get a file ownership.
  
                        Programmer - Jon Vavrus  28 OCT 1980
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           58 (Total)
 ------------           46 (Non-comment)                                                                      
1                                                                               Page  43
  
                        Software manual : Module   PRTOUT
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------            This module consists of routines to write out files for the & command
                             PRTOPN - Opens the output file.
                             PRTOUT - Outputs a record.
                             PRTCLS - Closes the file.
  
                        Programmer - Jon Vavrus  12 NOV 1980
                        Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
  
                        PRTOUT outputs a record.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           72 (Total)
 ------------           41 (Non-comment)                                                                      
1                                                                               Page  44
  
                        Software manual : Module   PRTOPN
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        PRTOPN opens or creates the output file.  If it is supposed to be
                        queued for printing the correct characteristics will be assigned to
                        it.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           81 (Total)
 ------------           66 (Non-comment)                                                                      
1                                                                               Page  45
  
                        Software manual : Module   PRTCLS
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        PRTCLS Closes the file previously opened by PRTOPN.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           59 (Total)
 ------------           49 (Non-comment)                                                                      
1                                                                               Page  46
  
                        Software manual : Module   SETERM
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------            These routines sets and resets the terminal characteristics
                        CLRWRP  sets the terminal NOWRAP
                        RESTRM  restores original terminal characterisitics
                        SETERM  sets terminal characteristics
                        SETNAR  sets a VT100 to 80 columns
                        SETWID  sets a VT100 to 132 columns
                        SETWRP  sets the terminal WRAP
  
                        Programmer - Jon Vavrus  31 MAR 1981
                        Revised    - Jon vavrus  12 MAY 1981
                        Revised    - Jon Vavrus  31 JUL 1981
                        Revised    - Jon Vavrus  26 AUG 1981
                        Revised    - Jon Vavrus   3 MAR 1982 (added SETWID/SETNAR)
                        Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                        Revised    - Jon Vavrus  15 JUL 1982 (Use FORM for <FF> fixing)
                        Revised    - Jon Vavrus  27 JUL 1982 (Recognizes printer-ports)
                        Revised    - Jon Vavrus  12 AUG 1982 (@# references changed to G^)
                        Revised    - Jon Vavrus   2 SEP 1982
                        Revised    - Jon Vavrus  29 SEP 1983
  
                        SETERM sets up the terminal with the appropriate characteristics.
                        It also determines whether the terminal is a VT100 and (if so)
                        whether it has the advanced video option installed.
  
 Calls                  SETNAR  sets a VT100 to 80 columns                                                    
 -----                  SETWID  sets a VT100 to 132 columns                                                   
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           192 (Total)
 ------------           143 (Non-comment)                                                                     
1                                                                               Page  47
  
                        Software manual : Module   RESTRM
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        RESTRM is called to restore the terminal to the characteristics it
                        had prior to the call to SETERM.
  
 Calls                  SETNAR  sets a VT100 to 80 columns                                                    
 -----                  SETWID  sets a VT100 to 132 columns                                                   
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           52 (Total)
 ------------           34 (Non-comment)                                                                      
1                                                                               Page  48
  
                        Software manual : Module   SETWRP
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        SETWRP sets the terminal characteristics to WRAP so that lines of
                        output will be continued on subsequent lines of the screen, rather
                        than truncated to fit on one.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           22 (Total)
 ------------           12 (Non-comment)                                                                      
1                                                                               Page  49
  
                        Software manual : Module   CLRWRP
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        CLRWRP sets the terminal characteristics to NOWRAP so that lines of
                        output will be truncated to fit on one line of the screen, rather
                        continued on subsequent lines.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           22 (Total)
 ------------           12 (Non-comment)                                                                      
1                                                                               Page  50
  
                        Software manual : Module   SETNAR
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        SETNAR sets the terminal to narrow mode (80 columns).
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           45 (Total)
 ------------           32 (Non-comment)                                                                      
1                                                                               Page  51
  
                        Software manual : Module   SETWID
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        SETWID sets the terminal to wide mode (132 columns).
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           127 (Total)
 ------------           114 (Non-comment)                                                                     
1                                                                               Page  52
  
                        Software manual : Module TTBRDINI
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------            This is a package which enables a program to intercept messages that
                        are broadcast to its terminal without having them actually appear on
                        the terminal.  This allows them to be examined/thrown-away or whatever
                        by a user routine.  It consists of the following routines:
                        TTBRDINI - Initializes things
                        TTBRDEND - Shuts things down
                        TTBRDAST - AST to handle messages received
                        TTSPAWN  - Spawns off a sub-process correctly.
  
                        Programmer  Jon Vavrus -  4 APR 1983
  
 Calls                  TTBRDEND - This cleans things up on exit.                                             
 -----                  TTBRDAST - This is invoked on receipt of a broadcast message.                         
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           93 (Total)
 ------------           68 (Non-comment)                                                                      
1                                                                               Page  53
  
                        Software manual : Module TTBRDAST
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        TTBRDAST is the actual AST routine invoked on message receipt.
  
 Calls                  BRDCST  - User routine to field broadcast messages.                                   
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           34 (Total)
 ------------           22 (Non-comment)                                                                      
1                                                                               Page  54
  
                        Software manual : Module TTBRDEND
                        ---------------------------------
  
  
 Description            MACRO SUBROUTINE
 -----------
                        TTBRDEND returns broadcast message processing to the normal procedure.
  
 Calls                  NONE
 -----
  
 Common storage         NONE
 --------------
  
 Output variables       NONE
 ----------------
  
 I/O variables          NONE
 -------------
  
 Input units            NONE
 -----------
  
 Output units           NONE
 ------------
  
 I/O units              NONE
 ---------
  
 Source lines           27 (Total)
 ------------           17 (Non-comment)                                                                      

1                                                                      Page   1

                    Operations manual : Module LOOK    
                    -----------------------------------

         Either of the following will actually start running the program;      
    typing RUN JPL:[JLV.LOOK]LOOK, or defining a symbol to run the             
    program (i.e. LOOK:==$JPL:[JLV.LOOK]LOOK.EXE) and then typing the          
    symbol.  The later method has the advantage that one can enter the         
    name of the file to be looked at and/or the symbol definition file's       
    name (see below) on the command line (for example:                         
                     LOOK PRINT.LIS/DEFINITIONS=LOOKCOM.DAT                    
    will run the program (if LOOK is defined as above) on the file             
    PRINT.LIS with the symbol definitions taken from LOOKCOM.DAT               
    (the DEFINITIONS switch can go before or after the main file's             
    name and can be abbreviated all the way to a D)).  If the switch           
    /NARROW is on the command line, then the screen will not be converted      
    into 132 column mode (this, of course, only applies to VT100 terminals).   
    If the switch /WRAP is present then the lines will be printed with         
    terminal wrapping, instead of being cut to the width of the terminal.      
    If the switch /BOX is present then one line of output is sacrificed        
    to allow a line to be drawn dividing the file text from the command        
    input line.                                                                
                                                                               
         The following commands are the "basic" command set of the             
    program:                                                                   
              n$         - jump by n lines (positive or negative)              
              n%         - jump by n blocks (positive or negative)             
              ^          - search (forward) for the string(s) in the search    
                           buffers (up to 10) and display from that line if    
                           found, if not found ring the terminal bell and      
                           turn on LED 3 (VT100's only).  Matches are found    
                           irregardless of lower/uppercase differences.        
              -^         - search (backward) for string(s), same rules as      
                           forward search.                                     
              - "string" 'string' ... ^                                        
                         - load search buffers with the given strings and      
                           search (backward) for them, same rules as           
                           forward search.                                     
              "string"   - clear the search buffers and save the given         
                           string as the only search string.  A string         
                           can consist of any characters, to include a         
                           quotation mark (") one must put two of them in      
                           a row ("").                                         
              'string' 'string' ...                                            
                         - add the given string(s) to the search buffers.      
                           A string can consist of any characters, to          
                           include a single quote (') one must put two of      
                           them in a row ('').                                 
              !          - set reverse switch, all commands will now work      
                           in reverse (i.e. n$ will jump -n lines, etc.)       
              #          - scroll                                              
              -#         - scroll backward                                     
              (          - stop scrolling (only valid command when             
                           scrolling is in operation),                         
                           or cancel current line jump, search, or             
                           & command.                                          
              n)         - set scrolling speed to n lines per second           
                           (positive or negative, integer or real)             
                           (originally set to 2).                              
1                                                                      Page   2

                           NOTE:  there is a maximum speed that will not       
                           be exceeded (varies with situation) even if         
                           scrolling speed is set at a fast value.             
              n*         - mark the nth line from the top of the screen        
                           as the boundary of the print range.  The print      
                           range is defined by the last two such marked        
                           lines.                                              
              n&         - print the range of lines from the top of the        
                           screen to the nth line from the top of the          
                           screen (n can be either positive or negative).      
                           onto device SYS$PRINT.  if n is 0 or absent         
                           then the range marked with the * command is         
                           used, if available, otherwise 23 is used for        
                           n.  The format of the printout will be that         
                           of the original file, not necessarily what          
                           is shown on the screen (i.e. FORTRAN carriage-      
                           control, and all printer control will work as       
                           they are supposed to).                              
              n-&        - same as n&, except output is put into a file        
                           named LOOKPRINT.LIS in the default directory        
                           (File format will be the same as the original       
                           file, except organization will be sequential)       
                           (appended to the latest version if a previous n-&   
                           or n--& command has been given, otherwise a new     
                           version is created).                                
              n--&       - same as n-&, except always creates a new version    
                           of the output file.                                 
              @          - exit the program.                                   
              +          - re-writes the screen.                               
              <          - repeat the last command.                            
                                                                               
         If an invalid command is typed the terminal bell is rung and on       
    a VT100 LED #3 is turned on.  The line is parsed in such a way that a      
    valid command will be executed even if followed by an invalid command.     
    Note that no command is executed until a standard line terminator is       
    received (ASCII code of 1 to 31).  Note that commands are limited to       
    34 characters when entered in response to the prompt.  In order to         
    enter longer commands one can use the "command mode" DEFINE command        
    (see below) and then execute the symbol.  Also all search strings          
    are limited to 30 characters.                                              
                                                                               
         If the user types ^Z (Control-Z) whenever the program is not          
    currently executing a command, the program will enter "command" mode.      
    This mode allows the user to use any of the following commands:            
              DEFINE s := a1 a2 ...                                            
                             - which defines a symbol s in the same man-       
                               ner as a line in the definitions file (see      
                               below), including line continuations.           
              EXIT           - returns to the normal "look" mode.              
              HELP a         - where a is one of the commands shown above.     
              SET [NO]switch - with switch being any of WRAP, BOX, WIDE        
                               or NARROW.  These have the same affect as       
                               the command line switches of the same           
                               names (WIDE is the same as NONARROW),           
                               with the NO qualifier turning them off.         
              SHOW [s]       - where s is a defined symbol.  This will         
                               show what commands a symbol is defined          
                               as. (if s is omitted, all defined symbols       
1                                                                      Page   3

                               are shown).                                     
              @filename      - Inputs the file filename as a definitions       
                               file.                                           
                                                                               
         The user is also allowed to define symbols for a command or           
    commands.  Valid symbols consist of the characters a-z (lower and          
    upper-case are equivalent), _, =, `, ~, [, ], {, }, ;, :,                  
    ,(comma), >, ?, /, \,and  |.  Symbol definitions are given in              
    a symbol definition file which is read at the start of execution           
    (or by the "command" level @ command), or by the "command" level           
    DEFINE command.  This file is either given by the /DEFINITIONS             
    switch, or a file named LOOKCOM.DAT is searched for in the fol-            
    lowing places:  The default directory (the file is used only if            
    the user owns it), the user's username directory on JPL,                   
    CIT, and SYS2 in that order.                                               
                                                                               
         In the symbol definition file the user can place both commands        
    and definitions.  Commands will be executed on encounter, and def-         
    initions will be placed in the definitons list.  Definitions have          
    the following form:                                                        
                  symbol := command1 command2 command3 ... command9            
    Up to ten commands can be contained in each symbol (exception - a          
    symbol for the stop scrolling command should have only the one command     
    in it ( ( )) and will be executed (when the symbol is typed) in the        
    order they appear in the definition.  A - (minus sign) as the last         
    character in a line means the definition is continued on the next          
    line.  The following are default symbol definitions (they can be           
    overriden by the symbol definition file):                                  
              U := 23$                                                         
              D := -23$                                                        
              S := #                                                           
              Q := (                                                           
              J := 20%                                                         
              B := -20%                                                        
              P := 23&                                                         
              A := 23-&                                                        
              L := 23--&                                                       
              E := @                                                           
              M := *                                                           
              C := +                                                           
              R := <                                                           
                                                                               
    Note, that only the first character of a symbol is significant in the      
    symbol definition file.  Also when input as a command the symbol should    
    be input as only one character.                                            
                                                                               
         A line enclosed by braces ({ }) will be treated as a "command"        
    level command (such as SET WIDE, @filename, etc.).                         
                                                                               
         The LEDs on a VT100 terminal are used to convey various bits of       
    information.  Their meanings are as follows:                               
              1 - on indicates a command is being executed (useful since       
                  some of the commands don't affect the screen until           
                  completion).                                                 
              2 - on indicates that reverse is on (an odd number of !          
                  commands have been executed).                                
              3 - on indicates an invalid command was encountered (either      
                  input from the terminal, or while executeing a def-          
1                                                                      Page   4

                  inition), or a search failed.                                
              4 - on indicates that a range of lines has been marked for       
                  printing                                                     
                                                                               
                                                                               
    NOTE:  If while using the program (on variable length record files)        
           one gets garbage on the screen, try moving either one block         
           forward or backward to realign the record boundaries.  Also         
           when working with FORTRAN carriage-control files the + (plus)       
           carriage-control character is ignored, and when working with        
           printer files, all carriage-control with the exception of           
           line feeds is ignored, and at least one line feed before each       
           record is assumed.                                                  
                                                                               
    Programmer - Jon Vavrus  12 NOV 1980                                       
    Revised    - Jon Vavrus  30 MAR 1981                                       
    Revised    - Jon Vavrus   4 MAY 1981                                       
    Revised    - Jon Vavrus  12 MAY 1981                                       
    Revised    - Jon Vavrus  31 JUL 1981 (changed CCLINE usage)                
    Revised    - Jon Vavrus  27 AUG 1981                                       
    Revised    - Jon Vavrus   3 SEP 1981                                       
    Revised    - Jon Vavrus  30 DEC 1981 (added ^X)                            
    Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)             
    Revised    - Jon Vavrus  15 JUL 1982 (extract some proc's add              
                                          "command" level to symbol file)      
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
    Revised    - Jon Vavrus   9 SEP 1982                                       
    Revised    - Jon Vavrus   4 APR 1983 (broadcast stuff)                     
    Revised    - Jon Vavrus  13 APR 1983                                       
    Revised    - Jon Vavrus  17 MAY 1983                                       
    Revised    - Jon Vavrus  28 MAY 1983                                       
    Revised    - Jon Vavrus   9 SEP 1983                                       
    Revised    - Jon Vavrus  27 SEP 1983                                       
                                                                               
    -------------------------------------------------------------------------  
                                                                               
         The program works by calculating or finding a record boundary         
    near the current position and extracting actual records from there.        
    This is done for fixed files by calculating the record boundary from       
    the start of the file (or start of the block for blocked files),           
    keeping in mind the fact that records are extended to an even number       
    of bytes (word aligned).  For variable length records a record length      
    count word is looked for (a byte containing a number equal to or           
    less than 133 plus the record header size (FSZ), followed by a zeroed      
    byte), which points to another record length count word.                   
                                                                               
         When the current line position needs to be converted to a             
    position in terms of blocks and bytes, the program calculates the          
    byte count from the last line in the output arrays to the current          
    line, then using this plus the block number of the next block to be        
    read in the position is calculated.  This is fairly straight forward       
    for all but fixed blocked files, in which the count of unused bytes        
    in each block must be taken into account.  For variable length record      
    files a further check on position is made by trying to match the           
    line pointed to and the lines around it to a specific area in the          
    block.                                                                     
                                                                               
         Command input is handled by a QIO request to the terminal.  This      
1                                                                      Page   5

    input is terminated by the standard terminators, whihc are not echoed.     
    Input is done with conversion to upper case (to make life easier), and     
    with no translation of ^U, ^R, and <DEL> (all of which is done by the      
    program).  One will note that while scrolling, the QIO is alternately      
    requested and cancelled with each output to the terminal, this is done     
    so that the terminal will not get simultaneous read and write requests.    
                                                                               
         Scrolling speed is controlled by the use of the SYS$SETIMR and        
    SYS$WAITFR system services.  Thus the QIO AST for the stop scrolling       
    command must cancel the timer request, and also set the event flag.        
                                                                               
         Symbol definitions are kept in several arrays (DEFS - command         
    number and length of any search buffers, NUMDEF - associated numbers,      
    DEFBUF - search buffers, and DEFFLG - associated command flags).           
    The total number of defined symbols is thus limited to 60.                 
1                                                                      Page   6

                    Operations manual : Module   COMLVL
                    -----------------------------------

    This routine implements the "command" mode of look, by processing          
    one command which is passed to it.                                         
                                                                               
     Programmer - Jon Vavrus  26 AUG 1981                                      
     Revised    - Jon Vavrus   3 SEP 1981                                      
     Revised    - Jon Vavrus  18 SEP 1981                                      
     Revised    - Jon Vavrus   3 MAR 1982 (added SETNAR/SETWID)                
     Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)            
     Revised    - Jon Vavrus  15 JUL 1982 (changed to handle only one          
                                           command)                            
     Revised    - Jon Vavrus  18 AUG 1982 (Bigger arrays)                      
     Revised    - Jon Vavrus   9 SEP 1982                                      
     Revised    - Jon Vavrus   4 APR 1983 (add broadcast and spawn stuff)      
     Revised    - Jon Vavrus  17 MAY 1983                                      
     Revised    - Jon Vavrus  28 MAY 1983 (check defined symbols)              
     Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                     
     Revised    - Jon Vavrus  27 SEP 1983                                      
                                                                               
         This routine allows the use of the following commands:                
              DEFINE s := a1 a2 ...                                            
                             - which defines a symbol s in the same man-       
                               ner as a line in the definitions file (see      
                               below), including line continuations.           
              EXIT           - returns to the normal "look" mode.              
              HELP a         - where a is one of the commands shown above.     
              READ           - outputs the broadcast messages (if any)         
                               which have been received.                       
              SET [NO]switch - with switch being any of WRAP, BOX, WIDE        
                               or NARROW.  These have the same affect as       
                               the command line switches of the same           
                               names (WIDE is the same as NONARROW),           
                               with the NO qualifier turning them off.         
              SHOW [s]       - where s is a defined symbol.  This will         
                               show what commands a symbol is defined          
                               as. (if s is omitted, all defined symbols       
                               are shown).                                     
              SPAWN          - starts a sub-process up to allow the user       
                               to do DCL commands.                             
              @filename      - Inputs the file filename as a definitions       
                               file.                                           
                                                                               
          Upon return DONE is set .TRUE. if the command was EXIT, .FALSE.      
      otherwise.                                                               
1                                                                      Page   7

                    Operations manual : Module    DODEF
                    -----------------------------------

    This routine processes the file open on unit 30 as a "symbol" file.        
                                                                               
    Programmer - Jon Vavrus  15 JUL 1982                                       
    Revised    - Jon Vavrus   9 SEP 1982                                       
    Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                      
    Revised    - Jon Vavrus  21 SEP 1983                                       
                                                                               
         The routine reads unit 30.  Each line is tested for:                  
              s :=     which is taken as a symbol definition                   
              {    }   which is taken as a "command" level command line        
              or anything else which is taken as a command line.               
1                                                                      Page   8

                    Operations manual : Module     DOIT
                    -----------------------------------

    This subroutine executes the commands passed by the main program or        
    rings the terminal bell and turns LED 3 on (error signal) if the           
    command is invalid.                                                        
                                                                               
    Programmer - Jon Vavrus  13 NOV 1980                                       
    Revised    - Jon Vavrus  30 MAR 1981                                       
    Revised    - Jon Vavrus  12 MAY 1981                                       
    Revised    - Jon Vavrus  21 JUL 1981                                       
    Revised    - Jon Vavrus  31 JUL 1981 (change CCLINE usage)                 
    Revised    - Jon Vavrus  27 AUG 1981                                       
    Revised    - Jon Vavrus  10 SEP 1981                                       
    Revised    - Jon Vavrus  23 SEP 1981                                       
    Revised    - Jon Vavrus   6 NOV 1981                                       
    Revised    - Jon Vavrus  30 DEC 1981 (make LED's work right)               
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
    Revised    - Jon Vavrus   9 SEP 1982                                       
    Revised    - Jon Vavrus  30 NOV 1982                                       
    Revised    - Jon Vavrus  12 JAN 1983                                       
    Revised    - Jon Vavrus   4 APR 1983 (Take care of "Quitting")             
                                                                               
         The routine is called with the numeric code for the command           
    (COMAND) which if negative, means that it is not to be "saved" for         
    possible command #13 execution; a flag set .TRUE. if there is an           
    associated number (NUMFLG); a number (TANUMB); and a flag set              
    .TRUE. if there is an associated minus sign.                               
                                                                               
         For VT100's the given command is executed after which LED 1 is        
    turned off (indicating operation finished), LED 3 is turned off            
    if successful and on if not (error indication), LED 2 is turned            
    on if the reverse option is currently set or off if not (reverse           
    indicator), and LED 4 is turned on if the search buffer now contains       
    something (buffer indicator).                                              
                                                                               
         The valid commands types are:                                         
              1 - jump TANUMB lines (positive or negative)                     
              2 - jump by TANUMB blocks (positive or negative)                 
              3 - search (forward) for string(s) in SRCHBF array and           
                  display from that line if found, if not found the            
                  terminal bell is rung and LED 3 is turned on.  Matches       
                  are found regardless of lower/uppercase differences.         
                  Search backward if MINFLG = .TRUE..  Repeat TANUMB           
                  times if NUMFLG = .TRUE..                                    
              4 - set reverse switch, all commands will now work in re-        
                  verse (i.e. n$ will jump -n lines, etc.).  Repeat            
                  TANUMB times if NUMFLG = .TRUE..                             
              5 - scroll (backwards if MINFLG = .TRUE.)                        
              6 - stop scrolling or cancel current line jump, search,          
                  or & command.                                                
              7 - set scrolling speed to TANUMB lines per second (positive     
                  or negative) (originally set to 2).                          
                  NOTE:  there is a maximum speed that will not be ex-         
                  ceeded (varies with situation) even if scrolling             
                  speed is set at a high value.                                
              8 - mark the TANUMB line form the top of the screen as one       
1                                                                      Page   9

                  of the boundaries of the print range.  The last two so       
                  marked lines define the print range.                         
              9 - output TANUMB lines to the file LOOKPRINT.LIS in the         
                  default directory (file format will be the same as the       
                  original file, with sequential organization).  Creates       
                  a new file.  If no number is specified (or is zero)          
                  and there is a valid print range marked, then that           
                  range will be output, if no valid print range then           
                  23 lines are output.                                         
             10 - same as 9 except the lines are output to SYS$PRINT.          
                  If MINFLG = .TRUE. then output goes to LOOKPRINT.LIS         
                  file (new file if no previous command created one            
                  during this job, otherwise appended to the end of the        
                  existing file).                                              
             11 - exit the program.                                            
             12 - re-write the screen                                          
             13 - re-execute the last command that was passed to DOIT          
                  with a positive value (except for 13)                        
1                                                                      Page  10

                    Operations manual : Module   GETDEF
                    -----------------------------------

    This routine translates a line into a symbol definition                    
                                                                               
    Programmer - Jon Vavrus   3 SEP 1981                                       
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
    Revised    - Jon Vavrus   9 SEP 1982                                       
    Revised    - Jon Vavrus  28 MAY 1983                                       
    Revised    - Jon Vavrus  17 AUG 1983                                       
                                                                               
         The routine is called with the line to be translated in the           
    character variable LINE.  The number of the symbol definition is           
    passed as ISYM.                                                            
1                                                                      Page  11

                    Operations manual : Module   LINCON
                    -----------------------------------

    This subroutine converts a buffer full of data into output lines in        
    the output arrays.                                                         
                                                                               
    Programmer - Jon Vavrus  12 NOV 1980                                       
    Revised    - Jon Vavrus  13 MAY 1981                                       
    Revised    - Jon Vavrus  30 JUL 1981 (change CCLINE usage)                 
    Revised    - Jon Vavrus  26 AUG 1981                                       
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
    Revised    - Jon Vavrus  12 JAN 1983                                       
                                                                               
         The conversion is done one line per record with blank lines           
    being inserted to take care of FORTRAN carriage-control (which is          
    then stripped off the record)(+ carriage control is ignored), and          
    printer form-feeds (other printer control sequences are ignored).          
                                                                               
         If START is set to .TRUE. in the call, then it is assumed that        
    the buffer is completely new, and bears no relationship to the current     
    contents of the output arrays, thus the current contents of the arrays     
    are disregarded and written over.  If START is set to .FALSE. in the       
    call, the buffer is assumed to be full of data which should immediately    
    follows the information currently in the output arrays.  It is also        
    assumed (if START is .FALSE.) that the buffer pointer (PBUF) is            
    pointing at the correct byte.                                              
1                                                                      Page  12

                    Operations manual : Module   BRDCST
                    -----------------------------------

    This subroutine catches broadcast messages and stores them away in         
    common.                                                                    
                                                                               
    Programmer - Jon Vavrus   4 APR 1983                                       
                                                                               
         This routine is called as an AST whenever a broadcast message         
    comes through to the terminal.  That message is then stored away           
    in the common area BRDCM1.  A flag is set and a count is updated           
    in BRDCM2.                                                                 
                                                                               
         A message is also output on to the screen.                            
1                                                                      Page  13

                    Operations manual : Module   CONVUP
                    -----------------------------------

    This subroutine converts a string from lower to upper case.                
    Both of the strings are passed in non-descriptor form.                     
                                                                               
    Programmer - Jon Vavrus  13 NOV 1980                                       
                                                                               
         The routine takes a string of bytes starting at the location          
    given for LOWER and converts any alphabetic characters in the first        
    LENGTH bytes to upper-case, returning the converted string of bytes        
    starting at the location given for UPPER.                                  
1                                                                      Page  14

                    Operations manual : Module    EXITR
                    -----------------------------------

    This subroutine is invoked on image exit and cancels any                   
    AST, and closes the file and re-stores the terminal.                       
                                                                               
    Programmer - Jon Vavrus  13 JAN 1983                                       
                                                                               
    Should be set up by a call to SYS$DCLEXH(BLOCK) where block                
    is a 4 longword array with this routines address as the second             
    longword, 1 as the third longword, and the address of any                  
    writable location (longword) as the fourth.                                
1                                                                      Page  15

                    Operations manual : Module   INTASC
                    -----------------------------------

    This subroutine converts a string of ascii coded bytes to a character      
    variable                                                                   
                                                                               
    Programmer - Jon Vavrus    JUL 1980                                        
                                                                               
         The subroutine is called with LENGTH (the number of bytes to be       
    converted), DATA (the starting location of the data), and STRING (a        
    character variable to recieve the translation).  After translation the     
    LENGTH+1 character of STRING is set to a blank.                            
1                                                                      Page  16

                    Operations manual : Module   REDOIT
                    -----------------------------------

    This routine calls DOIT                                                    
                                                                               
    Programmer - Jon Vavrus  26 AUG 1981                                       
                                                                               
         The routine simply calls DOIT with the same argument list.            
    This allows DOIT to call itself.                                           
1                                                                      Page  17

                    Operations manual : Module   SFTLIN
                    -----------------------------------

    This subroutine shifts the output lines stored in the line storage         
    arrays in order to make room at the end of the arrays for more lines.      
                                                                               
     Programmer - Jon Vavrus  13 NOV 1980                                      
     Revised    - Jon Vavrus  12 MAY 1981                                      
     Revised    - Jon Vavrus  29 JUL 1981 (change CCLINE usage)                
     Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
                                                                               
         The routine requires LINES (the character array of actual             
    output lines) to be passed as an argument, all the other arrays are        
    passed through common area LNCN.  The normal shift is to make room         
    for 100 more lines at the end, however, if there are less then 500         
    lines already then the shift frees up 599 of the 600 lines.  When          
    the shift occurs lines shifted off the front of the arrays are lost.       
1                                                                      Page  18

                    Operations manual : Module   STOPSC
                    -----------------------------------

    This subroutine is the AST used to stop the scrolling function.            
                                                                               
    Programmer - Jon Vavrus  13 NOV 1980                                       
    Revised    - Jon Vavrus  12 MAY 1981                                       
    Revised    - Jon Vavrus  26 AUG 1981                                       
    Revised    - Jon Vavrus   6 NOV 1981                                       
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
                                                                               
         The routine is executed whenever anything is typed while a            
    scroll is in progress.  If the character typed is "(" or a symbol          
    defined as "(", all timer requests are cancelled, the timer event          
    flag is set, and STOPIT is set to .TRUE..  If the character typed          
    is not one of the above, then the I/O is requeued with STPSC2 as           
    its AST (STPSC2 just calls this routine), and the character is in-         
    serted into the input buffer.                                              
1                                                                      Page  19

                    Operations manual : Module   STPSC2
                    -----------------------------------

    This subroutine is the AST for the I/O request from STOPSC, if             
    invoked it will call STOPSC and exit.                                      
                                                                               
    Programmer - Jon Vavrus  13 NOV 1980                                       
1                                                                      Page  20

                    Operations manual : Module   TMAST2
                    -----------------------------------

    This routine is simply a means for TIMAST to refer to itself.  All it      
    does is call TIMAST.                                                       
                                                                               
    Programmer  Jon Vavrus -  3 SEP 1982                                       
    Revised     Jon Vavrus - 21 SEP 1983 (changed name with TIMAST)            
1                                                                      Page  21

                    Operations manual : Module   TIMAST
                    -----------------------------------

    This routine outputs the proper "WORKING" message at the bottom of the     
    screen and requeues itself as a timer AST (through TMAST2).                
                                                                               
    Programmer  Jon Vavrus -  8 SEP 1982                                       
    Revised     Jon Vavrus - 21 SEP 1983 (changed name with TMAST2)            
1                                                                      Page  22

                    Operations manual : Module   WORKNG
                    -----------------------------------

    This subroutine puts out the flashing "WORKING" message.                   
                                                                               
    Programmer  Jon Vavrus -  8 SEP 1982                                       
                                                                               
    The message is displayed at screen position COMLIN(from DOITNM),           
    IABS(LENLMT)-19(DOITNM also) if START (logical) is .TRUE., and is          
    stopped if START is .FALSE..  The changing of the display is done          
    through the use of a system timer AST.                                     
1                                                                      Page  23

                    Operations manual : Module   PRSCOM
                    -----------------------------------

    This routine parses a command line.                                        
                                                                               
    Programmer - Jon Vavrus  26 AUG 1981                                       
    Revised    - Jon Vavrus   3 SEP 1981                                       
    Revised    - Jon Vavrus  23 SEP 1981                                       
    Revised    - Jon Vavrus  30 DEC 1981 (put LED #1 turn-on in DOIT)          
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
    Revised    - Jon Vavrus   9 SEP 1982                                       
    Revised    - Jon Vavrus  30 NOV 1982                                       
    Revised    - Jon Vavrus  28 MAY 1983 (Allow real scroll speeds)            
    Revised    - Jon Vavrus   7 SEP 1983                                       
    Revised    - Jon Vavrus  21 SEP 1983                                       
                                                                               
         The routine parses a command line.  It is passed the command line     
    in LINE its length in LENLIN.  The command number is returned in           
    ICOM, if it is "minussed" the flag MINFLG is set, if there is a number     
    preceding it the number is stored in ANUMB and the flag NUMFLG is          
    set.  If ICOM = 0 then no command was found/legal (error "beep" +          
    LED 3 are taken care of).  If a defined symbol is found its commands       
    are executed and ICOM = -1.  After execution the procedure sets LINE       
    and LENLIN to the after parse values.  Note:  If a definition symbol       
    encountered, it's internal commands will be executed should NDEF or        
    NSYM be zero, otherwise its definition will be inserted into the           
    definition arrays  beginning at command NDEF of definition NSYM.           
1                                                                      Page  24

                    Operations manual : Module    BLKIN
                    -----------------------------------

    This module contains routines for block I/O                                
         BLKOPN opens a file for block input                                   
         BLKSIN inputs 7 blocks of data                                        
         BLKIN  inputs one block of data                                       
         BLKCLS closes the file                                                
                                                                               
    Programmer - Jon Vavrus  28 OCT 1980                                       
    Revised    - Jon Vavrus  12 MAY 1981                                       
    Revised    - Jon Vavrus  27 JUL 1981                                       
    Revised    - Jon Vavrus  29 JUL 1981                                       
    Revised    - Jon Vavrus  26 AUG 1981                                       
                                                                               
    BLKIN inputs the a single block of data from the file opened by            
    BLKOPN.                                                                    
                                                                               
         The routine BLKIN inputs the Nth block of the file.  N is the         
    first argument in the call list, the second argument receives the          
    actual number of bytes input, and the third argument is the                
    address of the buffer to receive the input.                                
1                                                                      Page  25

                    Operations manual : Module   BLKOPN
                    -----------------------------------

                                                                               
    BLKOPN opens a file for block input.                                       
                                                                               
         The routine BLKOPN takes a seven element argument list:               
              The first contains the name of the file to be opened;            
              The second receives a completion code (1 is success);            
              The third receives the files RFM;                                
              The fourth receives a value for the files RAT:                   
                   1 = CR                                                      
                   2 = FTN                                                     
                   3 = PRN                                                     
                   4 = none                                                    
                   <0 indicates BLK is set;                                    
              The fifth receives the files FSZ for VFC files, or the           
                   files MRS for FIX files;                                    
              The sixth receives the files EBK;                                
              And the seventh recieves the longest record's length.            
                                                                               
    If the file is not of sequential organization an RMS$_ORG error            
    code is returned.  If the records are either of unknown format or          
    of maximum record length greater than 132+FSZ an RMS$_RFM error            
    code is returned.                                                          
1                                                                      Page  26

                    Operations manual : Module   BLKSIN
                    -----------------------------------

                                                                               
    BLKSIN is used to input 7 blocks of data in a manner similiar to           
    BLKIN.                                                                     
                                                                               
         The routine BLKSIN starts input from the Nth block of the file.       
    N is given as the first argument in the call list, the second argument     
    receives the actual number of bytes input, and the third argument          
    is the address used as the start of the input buffer.                      
1                                                                      Page  27

                    Operations manual : Module   BLKCLS
                    -----------------------------------

                                                                               
    BLKCLS closes the input file.                                              
                                                                               
         The routine BLKCLS needs no argument list and simply closes the       
    file which BLKOPN has previously opened.                                   
1                                                                      Page  28

                    Operations manual : Module   GETOWN
                    -----------------------------------

    This routine is used to get a file ownership.                              
                                                                               
    Programmer - Jon Vavrus  28 OCT 1980                                       
                                                                               
         This routine is invoked as the USEROPEN qualifier in a FORTRAN        
    OPEN statement.  When invoked it will return the file owner's group        
    number as the first word of the common area OWNER, and the file            
    owner's member number as the second word.                                  
1                                                                      Page  29

                    Operations manual : Module   PRTOUT
                    -----------------------------------

    This module consists of routines to write out files for the & command      
         PRTOPN - Opens the output file.                                       
         PRTOUT - Outputs a record.                                            
         PRTCLS - Closes the file.                                             
                                                                               
    Programmer - Jon Vavrus  12 NOV 1980                                       
    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                       
                                                                               
    PRTOUT outputs a record.                                                   
                                                                               
         The routine PRTOUT prints one record to the file opened in            
    PRTOPN.  It is called with two values, the first is an longword            
    containing the number of bytes to be transfered, and the second is         
    the address of the start of the data.                                      
1                                                                      Page  30

                    Operations manual : Module   PRTOPN
                    -----------------------------------

                                                                               
    PRTOPN opens or creates the output file.  If it is supposed to be          
    queued for printing the correct characteristics will be assigned to        
    it.                                                                        
                                                                               
         The routine PRTOPN requires one argument an integer*4 variable        
    with the value -1 for printer output, 0 for output appended to file        
    LOOKPRINT.LIS in the default directory (a new file is created if           
    no previous call to PRTOPN was made, or the previous call was made         
    with a value of 1), and 1 for output to a new file named LOOKPRINT.LIS     
    in the default directory.  If the open was unsuccessful the value          
    47 is returned.                                                            
1                                                                      Page  31

                    Operations manual : Module   PRTCLS
                    -----------------------------------

                                                                               
    PRTCLS Closes the file previously opened by PRTOPN.                        
                                                                               
         The routine PRTCLS closes the file opened by PRTPN.  If an            
    argument list is present the file is deleted (for appended files           
    the new records are stripped off), otherwise the file is closed and        
    queued for printing if necessary.                                          
1                                                                      Page  32

                    Operations manual : Module   SETERM
                    -----------------------------------

    These routines sets and resets the terminal characteristics                
    CLRWRP  sets the terminal NOWRAP                                           
    RESTRM  restores original terminal characterisitics                        
    SETERM  sets terminal characteristics                                      
    SETNAR  sets a VT100 to 80 columns                                         
    SETWID  sets a VT100 to 132 columns                                        
    SETWRP  sets the terminal WRAP                                             
                                                                               
    Programmer - Jon Vavrus  31 MAR 1981                                       
    Revised    - Jon vavrus  12 MAY 1981                                       
    Revised    - Jon Vavrus  31 JUL 1981                                       
    Revised    - Jon Vavrus  26 AUG 1981                                       
    Revised    - Jon Vavrus   3 MAR 1982 (added SETWID/SETNAR)                 
    Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)          
    Revised    - Jon Vavrus  15 JUL 1982 (Use FORM for <FF> fixing)            
    Revised    - Jon Vavrus  27 JUL 1982 (Recognizes printer-ports)            
    Revised    - Jon Vavrus  12 AUG 1982 (@# references changed to G^)         
    Revised    - Jon Vavrus   2 SEP 1982                                       
    Revised    - Jon Vavrus  29 SEP 1983                                       
                                                                               
    SETERM sets up the terminal with the appropriate characteristics.          
    It also determines whether the terminal is a VT100 and (if so)             
    whether it has the advanced video option installed.                        
                                                                               
         The routines are called with the terminal channel number as           
    their first argument, and SETERM has a flag set to 0 for 132 char-         
    acter mode in the second argument, and a word set to -1 for WRAP           
    as the third argument.                                                     
                                                                               
         SETERM sets the terminal to page=1,width=150 and then tries           
    to change the terminal to 132 character mode if terminal is a VT100        
    with advanced video and the low bit of the second argument is set.         
    If the low bit of the third argument is set the terminal is set up to      
    cause line wrapping.  The terminal channel number is filled in and         
    should not be provided by the calling routine.                             
1                                                                      Page  33

                    Operations manual : Module   RESTRM
                    -----------------------------------

                                                                               
    RESTRM is called to restore the terminal to the characteristics it         
    had prior to the call to SETERM.                                           
                                                                               
         RESTRM sets the terminal back to what it was when SETERM was          
    called.  For VT100 terminals If the original width was > 80 then           
    the terminal is left in 132 character mode, otherwise it is put in         
    to 80 character mode, and the terminal is always left NOWRAP (second       
    bit of byte 3 off).  It is called with the terminal channel number         
    as its sole argument.                                                      
1                                                                      Page  34

                    Operations manual : Module   SETWRP
                    -----------------------------------

                                                                               
    SETWRP sets the terminal characteristics to WRAP so that lines of          
    output will be continued on subsequent lines of the screen, rather         
    than truncated to fit on one.                                              
                                                                               
    SETWRP is called with the terminal channel number as its sole              
    argument.                                                                  
1                                                                      Page  35

                    Operations manual : Module   CLRWRP
                    -----------------------------------

                                                                               
    CLRWRP sets the terminal characteristics to NOWRAP so that lines of        
    output will be truncated to fit on one line of the screen, rather          
    continued on subsequent lines.                                             
                                                                               
    CLRWRP is called with the terminal channel number as its sole              
    argument.                                                                  
1                                                                      Page  36

                    Operations manual : Module   SETNAR
                    -----------------------------------

                                                                               
    SETNAR sets the terminal to narrow mode (80 columns).                      
                                                                               
    SETNAR is called with the terminal channel number as its sole              
    argument.  It should only be called if the terminal in use is              
    a VT100 with advanced video.  The routine will check (by cursor            
    positioning) to see if the transition has been made (some VT100's          
    have been known to be flaky at 132<->80 column transitions).  If           
    it cannot successfully cause the transition after 10 tries it will         
    cause the program to exit with DEVCMDERR status.                           
1                                                                      Page  37

                    Operations manual : Module   SETWID
                    -----------------------------------

                                                                               
    SETWID sets the terminal to wide mode (132 columns).                       
                                                                               
    SETWID is called with the terminal channel number as its sole              
    argument.  It should only be called if the terminal in use is              
    a VT100 with advanced video.  The routine will check (by cursor            
    positioning) to see if the transition has been made (some VT100's          
    have been known to be flaky at 132<->80 column transitions).  If           
    it cannot successfully cause the transition after 10 tries it will         
    cause the program to exit with DEVCMDERR status.                           
1                                                                      Page  38

                    Operations manual : Module TTBRDINI
                    -----------------------------------

    This is a package which enables a program to intercept messages that       
    are broadcast to its terminal without having them actually appear on       
    the terminal.  This allows them to be examined/thrown-away or whatever     
    by a user routine.  It consists of the following routines:                 
    TTBRDINI - Initializes things                                              
    TTBRDEND - Shuts things down                                               
    TTBRDAST - AST to handle messages received                                 
    TTSPAWN  - Spawns off a sub-process correctly.                             
                                                                               
    Programmer  Jon Vavrus -  4 APR 1983                                       
                                                                               
         An initial call is made to TTBRDINI with an argument list             
    consisting of the address of a user routine to be called when a            
    broadcast message is received.  There is an exit handler established       
    to handle the necessary clean-up, thus no termination routine is           
    provided.  If an error occurs on initialization TTBRDINI will return       
    an even valued integer as its function value.                              
1                                                                      Page  39

                    Operations manual : Module TTBRDAST
                    -----------------------------------

                                                                               
    TTBRDAST is the actual AST routine invoked on message receipt.             
                                                                               
         TTBRDAST will call the user routine correctly.                        
1                                                                      Page  40

                    Operations manual : Module TTBRDEND
                    -----------------------------------

                                                                               
    TTBRDEND returns broadcast message processing to the normal procedure.     
                                                                               
         TTBRDEND is never really called but, rather, it is queued as an       
    exit handler and invoked on image exit.                                    
1CALL MATRIX, ORDER  1
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      . . . . . 1 . . 1 .  . . 1 . . . . . . .  . . . . 1 1 1 . . .  . . . . . 1 .    7
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       . . . . . . 1 . . 1  . . 1 . . . . 1 . .  . . . . . . . . . .  . . . . . . .    4
  10 DOIT        1 1 . 1 . . . 1 . .  1 . . . 1 1 . . 1 1  1 1 1 . . . . . 1 .  . . . . . . 1   14

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       1 . . . . . . . . .  . . . . . . . . . .  . . 1 . . . . . . .  . . . . . . 1    3
  13 GETDEF      . . . . . . . . . .  . . . . . . . 1 . .  . . . . . . . . . .  . . . . . . .    1
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . 1 . . . . .  . . . . . . . 1 . .  . . . . . . .    2
  17 LOOK        . 1 1 1 1 . 1 . 1 1  . . . . 1 1 . . . .  . . . . . . . . . .  . . . . . . .    9
  18 PRSCOM      . . . . . . . . . 1  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    1
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . 1 1 . . . .  . . . . . . .    2
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . 1 1 . . . .  . . . . . . .    2
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . 1  . . . . . . .    1
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . 1 . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    1
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . 1 1 . . .    2
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  1 . . . . . .    1

                                                                                        Total   51
1CALL MATRIX, ORDER  2
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      . . . . . . 1 . . 1  . . 1 . . . . 2 . .  . . . . . . . . . .  . . . . . . .    4
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       1 1 . 1 . 1 . 1 1 1  1 . 1 . 1 1 . 1 1 1  1 1 1 . 1 1 1 . 1 .  . . . . . 1 1   23
  10 DOIT        . . . . . . . . . .  . . . . 1 . . . . .  . . . . 1 1 . 1 . 1  1 . . . . . .    6

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . 1 1 . . . .  1 . . . . . .    3
  13 GETDEF      . . . . . . . . . 1  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    1
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        1 1 . 1 . 1 1 1 1 1  1 . 2 . 2 1 . 1 1 1  1 1 1 . 1 1 1 1 1 .  . . . . . 1 1   25
  18 PRSCOM      1 1 . 1 . . . 1 . .  1 . . . 1 1 . . 1 1  1 1 1 . . . . . 1 .  . . . . . . 1   14
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . 1 . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    1
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1

                                                                                        Total   78
1CALL MATRIX, ORDER  3
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      1 1 . 1 . 1 . 1 1 2  1 . 1 . 1 1 . 1 1 1  1 1 1 . 1 1 1 . 1 .  . . . . . 1 1   23
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       1 1 . 1 . . 1 1 . 2  1 . 1 . 2 1 . 2 1 1  1 1 1 . 1 1 . 1 1 1  1 . . . . . 1   23
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1
  13 GETDEF      1 1 . 1 . . . 1 . .  1 . . . 1 1 . . 1 1  1 1 1 . . . . . 1 .  . . . . . . 1   14
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        1 1 . 1 . 1 1 1 1 2  1 . 2 . 2 1 . 3 1 1  1 1 1 . 2 2 1 1 1 1  1 . . . . 1 1   27
  18 PRSCOM      . . . . . . . . . .  . . . . 1 . . . . .  . . . . 1 1 . 1 . 1  1 . . . . . .    6
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   95
1CALL MATRIX, ORDER  4
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 3 2 . 2 2 2  2 2 2 . 1 1 . 1 2 1  1 . . . . . 2   23
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 3 2 . 1 2 2  2 2 2 . 2 2 1 1 2 1  1 1 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . 1 . . . . .  . . . . 1 1 . 1 . 1  1 . . . . . .    6
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        2 2 . 2 . 1 1 2 1 4  2 . 2 . 3 2 . 3 2 2  2 2 2 . 2 2 1 1 2 1  1 1 . . . 1 2   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   85
1CALL MATRIX, ORDER  5
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 1 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 1 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . 1 . . . . .    1
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 6 4 . 3 4 4  4 4 4 . 3 3 1 2 4 2  2 1 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   80
1CALL MATRIX, ORDER  6
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 2 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER  7
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER  8
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER  9
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 10
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 11
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 12
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 13
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 14
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 15
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 16
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 17
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 18
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 19
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1CALL MATRIX, ORDER 20
 =====================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   2 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   3 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   4 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   5 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   6 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   7 COMLVL      2 2 . 2 . . 1 2 . 2  2 . 1 . 4 2 . 2 2 2  2 2 2 . 2 2 . 2 2 2  2 2 . . . . 2   24
   8 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
   9 DODEF       2 2 . 2 . 1 . 2 1 2  2 . 1 . 4 2 . 1 2 2  2 2 2 . 3 3 1 2 2 2  2 2 . . . 1 2   27
  10 DOIT        . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  11 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  12 EXITR       . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  13 GETDEF      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  14 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  15 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  16 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 LOOK        4 4 . 4 . 1 1 4 1 4  4 . 2 . 8 4 . 3 4 4  4 4 4 . 5 5 1 4 4 4  4 4 . . . 1 4   28
  18 PRSCOM      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TTBRDINI M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 WORKNG      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

                                                                                        Total   79
1
 CALL MATRIX REORDERED ACCORDING TO DECREASING CALLING LEVELS
 ============================================================
                                                                                             
                                   1  1 1 1 1 1 1 1 1 1 2  2 2 2 2 2 2 2 2 2 3  3 3 3 3 3 3 3
                 1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7 8 9 0  1 2 3 4 5 6 7

   1 COMLVL      . 1 . 1 . . . . . .  . . . . . . . . . .  1 . . . . . . . . 1  1 1 . . . . 1   20
   2 DODEF       1 . . 1 1 1 . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .   20
   3 LOOK        1 1 . . . 1 . . . 1  . . . . . . 1 1 1 1  . . . . 1 . . . . .  . . . . . . .   20
   4 GETDEF      . . . . 1 . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    5
   5 PRSCOM      . . . . . 1 . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    4
   6 DOIT        . . . . . . . . 1 1  1 . 1 . . 1 1 . 1 .  . 1 1 . 1 1 1 1 1 .  . . . . . . .    3
   7 EXITR       . . . . . . . . 1 .  1 . . . . 1 . . . .  . . . . . . . . . .  . . . . . . .    3
   8 TTBRDINI M  . . . . . . . . . .  . . . . 1 . . . . .  . . . . . . . . . .  . . . . . 1 .    2
   9 WORKNG      . . . . . . . . . .  . . . 1 . . . . . .  . . . . . . . . . .  . . . . . . .    2
  10 LINCON      . . . . . . . . . .  . . . . . . . . . .  . . . . 1 . . . . .  . . 1 . . . .    1

  11 RESTRM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . 1  1 . . . . . .    1
  12 SETERM   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . 1  1 . . . . . .    1
  13 STOPSC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . 1 . . .    1
  14 TIMAST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . 1 . .    1
  15 TTBRDAST M  . . . . . . . . . .  . . . . . . . . . 1  . . . . . . . . . .  . . . . . . .    1
  16 BLKCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  17 BLKIN    M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  18 BLKOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  19 BLKSIN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  20 BRDCST      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  21 CLRWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  22 CONVUP      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  23 EXIT     *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  24 GETOWN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  25 INTASC      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  26 PRTCLS   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  27 PRTOPN   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  28 PRTOUT   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  29 REDOIT      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  30 SETNAR   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0

  31 SETWID   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  32 SETWRP   M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  33 SFTLIN      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  34 STPSC2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  35 TMAST2      . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  36 TTBRDEND M  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
  37 TTSPAWN  *  . . . . . . . . . .  . . . . . . . . . .  . . . . . . . . . .  . . . . . . .    0
1 SUBROUTINE    LANGUAGE    TYPE        CALLS
  ===========================================

  BLKCLS        MACRO       SUB     
  BLKIN         MACRO       SUB     
  BLKOPN        MACRO       SUB     
  BLKSIN        MACRO       SUB     
  BRDCST        FORTRAN     SUB     
  CLRWRP        MACRO       SUB     
  COMLVL        FORTRAN     SUB         CLRWRP   DODEF    GETDEF   SETNAR   SETWID   SETWRP   TTSPAWN 
  CONVUP        FORTRAN     SUB     
  DODEF         FORTRAN     SUB         COMLVL   DOIT     GETDEF   PRSCOM  
  DOIT          FORTRAN     SUB         BLKCLS   BLKIN    BLKSIN   CONVUP   EXIT     INTASC   LINCON   PRTCLS   PRTOPN   PRTOUT  
                                        REDOIT   RESTRM   STOPSC   WORKNG  
  EXIT          EXTERNAL    SUB     
  EXITR         FORTRAN     SUB         BLKCLS   RESTRM   WORKNG  
  GETDEF        FORTRAN     FUNCTION    PRSCOM  
  GETOWN        MACRO       SUB     
  INTASC        FORTRAN     SUB     
  LINCON        FORTRAN     SUB         INTASC   SFTLIN  
  LOOK          FORTRAN     PROGRAM     BLKIN    BLKOPN   BLKSIN   BRDCST   COMLVL   DODEF    DOIT     INTASC   LINCON  
  PRSCOM        FORTRAN     SUB         DOIT    
  PRTCLS        MACRO       SUB     
  PRTOPN        MACRO       SUB     
  PRTOUT        MACRO       SUB     
  REDOIT        FORTRAN     SUB     
  RESTRM        MACRO       SUB         SETNAR   SETWID  
  SETERM        MACRO       SUB         SETNAR   SETWID  
  SETNAR        MACRO       SUB     
  SETWID        MACRO       SUB     
  SETWRP        MACRO       SUB     
  SFTLIN        FORTRAN     SUB     
  STOPSC        FORTRAN     SUB         STPSC2  
  STPSC2        FORTRAN     SUB     
  TIMAST        FORTRAN     SUB         TMAST2  
  TMAST2        FORTRAN     SUB     
  TTBRDAST      MACRO       SUB         BRDCST  
  TTBRDEND      MACRO       SUB     
  TTBRDINI      MACRO       SUB         TTBRDAST TTBRDEND
  TTSPAWN       EXTERNAL    SUB     
  WORKNG        FORTRAN     SUB         TIMAST  
1 SUBROUTINE    LANGUAGE    TYPE        CALLED BY
  ===============================================

  BLKCLS        MACRO       SUB         DOIT     EXITR   
  BLKIN         MACRO       SUB         DOIT     LOOK    
  BLKOPN        MACRO       SUB         LOOK    
  BLKSIN        MACRO       SUB         DOIT     LOOK    
  BRDCST        FORTRAN     SUB         LOOK     TTBRDAST
  CLRWRP        MACRO       SUB         COMLVL  
  COMLVL        FORTRAN     SUB         DODEF    LOOK    
  CONVUP        FORTRAN     SUB         DOIT    
  DODEF         FORTRAN     SUB         COMLVL   LOOK    
  DOIT          FORTRAN     SUB         DODEF    LOOK     PRSCOM  
  EXIT          EXTERNAL    SUB         DOIT    
  EXITR         FORTRAN     SUB     
  GETDEF        FORTRAN     FUNCTION    COMLVL   DODEF   
  GETOWN        MACRO       SUB     
  INTASC        FORTRAN     SUB         DOIT     LINCON   LOOK    
  LINCON        FORTRAN     SUB         DOIT     LOOK    
  LOOK          FORTRAN     PROGRAM 
  PRSCOM        FORTRAN     SUB         DODEF    GETDEF  
  PRTCLS        MACRO       SUB         DOIT    
  PRTOPN        MACRO       SUB         DOIT    
  PRTOUT        MACRO       SUB         DOIT    
  REDOIT        FORTRAN     SUB         DOIT    
  RESTRM        MACRO       SUB         DOIT     EXITR   
  SETERM        MACRO       SUB     
  SETNAR        MACRO       SUB         COMLVL   RESTRM   SETERM  
  SETWID        MACRO       SUB         COMLVL   RESTRM   SETERM  
  SETWRP        MACRO       SUB         COMLVL  
  SFTLIN        FORTRAN     SUB         LINCON  
  STOPSC        FORTRAN     SUB         DOIT    
  STPSC2        FORTRAN     SUB         STOPSC  
  TIMAST        FORTRAN     SUB         WORKNG  
  TMAST2        FORTRAN     SUB         TIMAST  
  TTBRDAST      MACRO       SUB         TTBRDINI
  TTBRDEND      MACRO       SUB         TTBRDINI
  TTBRDINI      MACRO       SUB     
  TTSPAWN       EXTERNAL    SUB         COMLVL  
  WORKNG        FORTRAN     SUB         DOIT     EXITR   
1 SUBROUTINE    COMMON
  ====================

  BLKCLS  
  BLKIN   
  BLKOPN  
  BLKSIN  
  BRDCST        BRDCM1  
  CLRWRP  
  COMLVL        BRDCM1  
  CONVUP  
  DODEF         INPUTC  
  DOIT          CHARS   
  EXIT    
  EXITR         DOITNM  
  GETDEF        CHARS   
  GETOWN  
  INTASC  
  LINCON        CHARS    DOITNM  
  LOOK          BRDCM1  
  PRSCOM        CHARS   
  PRTCLS  
  PRTOPN  
  PRTOUT  
  REDOIT  
  RESTRM  
  SETERM  
  SETNAR  
  SETWID  
  SETWRP  
  SFTLIN        LNCN    
  STOPSC        STOPCM  
  STPSC2  
  TIMAST        DOITNM  
  TMAST2  
  TTBRDAST
  TTBRDEND
  TTBRDINI
  TTSPAWN 
  WORKNG        DOITNM  
1 COMMON        SUBROUTINE
  ========================

  BRDCM1        BRDCST   COMLVL   LOOK    
  CHARS         DOIT     GETDEF   LINCON   PRSCOM  
  DOITNM        EXITR    LINCON   TIMAST   WORKNG  
  INPUTC        DODEF   
  LNCN          SFTLIN  
  STOPCM        STOPSC  
1 SUBROUTINE    ANCESTRY
  ======================

  BLKCLS        DOIT     DODEF    COMLVL   LOOK    
  BLKCLS        DOIT     DODEF    LOOK    
  BLKCLS        DOIT     LOOK    
  BLKCLS        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  BLKCLS        DOIT     PRSCOM   DODEF    LOOK    
  BLKCLS        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  BLKCLS        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  BLKCLS        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  BLKCLS        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  BLKIN         DOIT     DODEF    COMLVL   LOOK    
  BLKIN         DOIT     DODEF    LOOK    
  BLKIN         DOIT     LOOK    
  BLKIN         DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  BLKIN         DOIT     PRSCOM   DODEF    LOOK    
  BLKIN         DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  BLKIN         DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  BLKIN         DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  BLKIN         DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  BLKIN         LOOK    

  BLKOPN        LOOK    

  BLKSIN        DOIT     DODEF    COMLVL   LOOK    
  BLKSIN        DOIT     DODEF    LOOK    
  BLKSIN        DOIT     LOOK    
  BLKSIN        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  BLKSIN        DOIT     PRSCOM   DODEF    LOOK    
  BLKSIN        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  BLKSIN        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  BLKSIN        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  BLKSIN        DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  BLKSIN        LOOK    

  BRDCST        LOOK    

  CLRWRP        COMLVL   DODEF    LOOK    
  CLRWRP        COMLVL   LOOK    

  COMLVL        DODEF    LOOK    
  COMLVL        LOOK    

  CONVUP        DOIT     DODEF    COMLVL   LOOK    
  CONVUP        DOIT     DODEF    LOOK    
  CONVUP        DOIT     LOOK    
  CONVUP        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  CONVUP        DOIT     PRSCOM   DODEF    LOOK    
  CONVUP        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  CONVUP        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  CONVUP        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  CONVUP        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  DODEF         COMLVL   LOOK    
  DODEF         LOOK    

  DOIT          DODEF    COMLVL   LOOK    
  DOIT          DODEF    LOOK    
  DOIT          LOOK    
  DOIT          PRSCOM   DODEF    COMLVL   LOOK    
  DOIT          PRSCOM   DODEF    LOOK    
  DOIT          PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  DOIT          PRSCOM   GETDEF   COMLVL   LOOK    
  DOIT          PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  DOIT          PRSCOM   GETDEF   DODEF    LOOK    

  EXIT          DOIT     DODEF    COMLVL   LOOK    
  EXIT          DOIT     DODEF    LOOK    
  EXIT          DOIT     LOOK    
  EXIT          DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  EXIT          DOIT     PRSCOM   DODEF    LOOK    
  EXIT          DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  EXIT          DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  EXIT          DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  EXIT          DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  GETDEF        COMLVL   DODEF    LOOK    
  GETDEF        COMLVL   LOOK    
  GETDEF        DODEF    COMLVL   LOOK    
  GETDEF        DODEF    LOOK    

  INTASC        DOIT     DODEF    COMLVL   LOOK    
  INTASC        DOIT     DODEF    LOOK    
  INTASC        DOIT     LOOK    
  INTASC        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  INTASC        DOIT     PRSCOM   DODEF    LOOK    
  INTASC        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  INTASC        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  INTASC        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  INTASC        DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  INTASC        LINCON   DOIT     DODEF    COMLVL   LOOK    
  INTASC        LINCON   DOIT     DODEF    LOOK    
  INTASC        LINCON   DOIT     LOOK    
  INTASC        LINCON   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  INTASC        LINCON   DOIT     PRSCOM   DODEF    LOOK    
  INTASC        LINCON   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  INTASC        LINCON   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  INTASC        LINCON   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  INTASC        LINCON   DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  INTASC        LINCON   LOOK    
  INTASC        LOOK    

  LINCON        DOIT     DODEF    COMLVL   LOOK    
  LINCON        DOIT     DODEF    LOOK    
  LINCON        DOIT     LOOK    
  LINCON        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  LINCON        DOIT     PRSCOM   DODEF    LOOK    
  LINCON        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  LINCON        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  LINCON        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  LINCON        DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  LINCON        LOOK    

  LOOK    

  PRSCOM        DODEF    COMLVL   LOOK    
  PRSCOM        DODEF    LOOK    
  PRSCOM        GETDEF   COMLVL   DODEF    LOOK    
  PRSCOM        GETDEF   COMLVL   LOOK    
  PRSCOM        GETDEF   DODEF    COMLVL   LOOK    
  PRSCOM        GETDEF   DODEF    LOOK    

  PRTCLS        DOIT     DODEF    COMLVL   LOOK    
  PRTCLS        DOIT     DODEF    LOOK    
  PRTCLS        DOIT     LOOK    
  PRTCLS        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  PRTCLS        DOIT     PRSCOM   DODEF    LOOK    
  PRTCLS        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  PRTCLS        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  PRTCLS        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  PRTCLS        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  PRTOPN        DOIT     DODEF    COMLVL   LOOK    
  PRTOPN        DOIT     DODEF    LOOK    
  PRTOPN        DOIT     LOOK    
  PRTOPN        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  PRTOPN        DOIT     PRSCOM   DODEF    LOOK    
  PRTOPN        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  PRTOPN        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  PRTOPN        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  PRTOPN        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  PRTOUT        DOIT     DODEF    COMLVL   LOOK    
  PRTOUT        DOIT     DODEF    LOOK    
  PRTOUT        DOIT     LOOK    
  PRTOUT        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  PRTOUT        DOIT     PRSCOM   DODEF    LOOK    
  PRTOUT        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  PRTOUT        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  PRTOUT        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  PRTOUT        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  REDOIT        DOIT     DODEF    COMLVL   LOOK    
  REDOIT        DOIT     DODEF    LOOK    
  REDOIT        DOIT     LOOK    
  REDOIT        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  REDOIT        DOIT     PRSCOM   DODEF    LOOK    
  REDOIT        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  REDOIT        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  REDOIT        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  REDOIT        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  RESTRM        DOIT     DODEF    COMLVL   LOOK    
  RESTRM        DOIT     DODEF    LOOK    
  RESTRM        DOIT     LOOK    
  RESTRM        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  RESTRM        DOIT     PRSCOM   DODEF    LOOK    
  RESTRM        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  RESTRM        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  RESTRM        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  RESTRM        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  SETNAR        COMLVL   DODEF    LOOK    
  SETNAR        COMLVL   LOOK    
  SETNAR        RESTRM   DOIT     DODEF    COMLVL   LOOK    
  SETNAR        RESTRM   DOIT     DODEF    LOOK    
  SETNAR        RESTRM   DOIT     LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   DODEF    LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  SETNAR        RESTRM   DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  SETWID        COMLVL   DODEF    LOOK    
  SETWID        COMLVL   LOOK    
  SETWID        RESTRM   DOIT     DODEF    COMLVL   LOOK    
  SETWID        RESTRM   DOIT     DODEF    LOOK    
  SETWID        RESTRM   DOIT     LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   DODEF    LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  SETWID        RESTRM   DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  SETWRP        COMLVL   DODEF    LOOK    
  SETWRP        COMLVL   LOOK    

  SFTLIN        LINCON   DOIT     DODEF    COMLVL   LOOK    
  SFTLIN        LINCON   DOIT     DODEF    LOOK    
  SFTLIN        LINCON   DOIT     LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   DODEF    LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  SFTLIN        LINCON   DOIT     PRSCOM   GETDEF   DODEF    LOOK    
  SFTLIN        LINCON   LOOK    

  STOPSC        DOIT     DODEF    COMLVL   LOOK    
  STOPSC        DOIT     DODEF    LOOK    
  STOPSC        DOIT     LOOK    
  STOPSC        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  STOPSC        DOIT     PRSCOM   DODEF    LOOK    
  STOPSC        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  STOPSC        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  STOPSC        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  STOPSC        DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  STPSC2        STOPSC   DOIT     DODEF    COMLVL   LOOK    
  STPSC2        STOPSC   DOIT     DODEF    LOOK    
  STPSC2        STOPSC   DOIT     LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   DODEF    LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  STPSC2        STOPSC   DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  TIMAST        WORKNG   DOIT     DODEF    COMLVL   LOOK    
  TIMAST        WORKNG   DOIT     DODEF    LOOK    
  TIMAST        WORKNG   DOIT     LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   DODEF    LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  TIMAST        WORKNG   DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  TMAST2        TIMAST   WORKNG   DOIT     DODEF    COMLVL   LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     DODEF    LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   DODEF    LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  TMAST2        TIMAST   WORKNG   DOIT     PRSCOM   GETDEF   DODEF    LOOK    

  TTSPAWN       COMLVL   DODEF    LOOK    
  TTSPAWN       COMLVL   LOOK    

  WORKNG        DOIT     DODEF    COMLVL   LOOK    
  WORKNG        DOIT     DODEF    LOOK    
  WORKNG        DOIT     LOOK    
  WORKNG        DOIT     PRSCOM   DODEF    COMLVL   LOOK    
  WORKNG        DOIT     PRSCOM   DODEF    LOOK    
  WORKNG        DOIT     PRSCOM   GETDEF   COMLVL   DODEF    LOOK    
  WORKNG        DOIT     PRSCOM   GETDEF   COMLVL   LOOK    
  WORKNG        DOIT     PRSCOM   GETDEF   DODEF    COMLVL   LOOK    
  WORKNG        DOIT     PRSCOM   GETDEF   DODEF    LOOK    
1 SUBROUTINE    PROGENY 
  =====================

  BLKCLS  

  BLKIN   

  BLKOPN  

  BLKSIN  

  BRDCST  

  CLRWRP  

  COMLVL        CLRWRP  
  COMLVL        DODEF    DOIT     BLKCLS  
  COMLVL        DODEF    DOIT     BLKIN   
  COMLVL        DODEF    DOIT     BLKSIN  
  COMLVL        DODEF    DOIT     CONVUP  
  COMLVL        DODEF    DOIT     EXIT    
  COMLVL        DODEF    DOIT     INTASC  
  COMLVL        DODEF    DOIT     LINCON   INTASC  
  COMLVL        DODEF    DOIT     LINCON   SFTLIN  
  COMLVL        DODEF    DOIT     PRTCLS  
  COMLVL        DODEF    DOIT     PRTOPN  
  COMLVL        DODEF    DOIT     PRTOUT  
  COMLVL        DODEF    DOIT     REDOIT  
  COMLVL        DODEF    DOIT     RESTRM   SETNAR  
  COMLVL        DODEF    DOIT     RESTRM   SETWID  
  COMLVL        DODEF    DOIT     STOPSC   STPSC2  
  COMLVL        DODEF    DOIT     WORKNG   TIMAST   TMAST2  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     BLKCLS  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     BLKIN   
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     BLKSIN  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     CONVUP  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     EXIT    
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     INTASC  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     PRTCLS  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     PRTOPN  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     PRTOUT  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     REDOIT  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  COMLVL        DODEF    GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  COMLVL        DODEF    PRSCOM   DOIT     BLKCLS  
  COMLVL        DODEF    PRSCOM   DOIT     BLKIN   
  COMLVL        DODEF    PRSCOM   DOIT     BLKSIN  
  COMLVL        DODEF    PRSCOM   DOIT     CONVUP  
  COMLVL        DODEF    PRSCOM   DOIT     EXIT    
  COMLVL        DODEF    PRSCOM   DOIT     INTASC  
  COMLVL        DODEF    PRSCOM   DOIT     LINCON   INTASC  
  COMLVL        DODEF    PRSCOM   DOIT     LINCON   SFTLIN  
  COMLVL        DODEF    PRSCOM   DOIT     PRTCLS  
  COMLVL        DODEF    PRSCOM   DOIT     PRTOPN  
  COMLVL        DODEF    PRSCOM   DOIT     PRTOUT  
  COMLVL        DODEF    PRSCOM   DOIT     REDOIT  
  COMLVL        DODEF    PRSCOM   DOIT     RESTRM   SETNAR  
  COMLVL        DODEF    PRSCOM   DOIT     RESTRM   SETWID  
  COMLVL        DODEF    PRSCOM   DOIT     STOPSC   STPSC2  
  COMLVL        DODEF    PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  COMLVL        GETDEF   PRSCOM   DOIT     BLKCLS  
  COMLVL        GETDEF   PRSCOM   DOIT     BLKIN   
  COMLVL        GETDEF   PRSCOM   DOIT     BLKSIN  
  COMLVL        GETDEF   PRSCOM   DOIT     CONVUP  
  COMLVL        GETDEF   PRSCOM   DOIT     EXIT    
  COMLVL        GETDEF   PRSCOM   DOIT     INTASC  
  COMLVL        GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  COMLVL        GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  COMLVL        GETDEF   PRSCOM   DOIT     PRTCLS  
  COMLVL        GETDEF   PRSCOM   DOIT     PRTOPN  
  COMLVL        GETDEF   PRSCOM   DOIT     PRTOUT  
  COMLVL        GETDEF   PRSCOM   DOIT     REDOIT  
  COMLVL        GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  COMLVL        GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  COMLVL        GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  COMLVL        GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  COMLVL        SETNAR  
  COMLVL        SETWID  
  COMLVL        SETWRP  
  COMLVL        TTSPAWN 

  CONVUP  

  DODEF         COMLVL   CLRWRP  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     BLKCLS  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     BLKIN   
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     BLKSIN  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     CONVUP  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     EXIT    
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     INTASC  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     PRTCLS  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     PRTOPN  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     PRTOUT  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     REDOIT  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  DODEF         COMLVL   GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  DODEF         COMLVL   SETNAR  
  DODEF         COMLVL   SETWID  
  DODEF         COMLVL   SETWRP  
  DODEF         COMLVL   TTSPAWN 
  DODEF         DOIT     BLKCLS  
  DODEF         DOIT     BLKIN   
  DODEF         DOIT     BLKSIN  
  DODEF         DOIT     CONVUP  
  DODEF         DOIT     EXIT    
  DODEF         DOIT     INTASC  
  DODEF         DOIT     LINCON   INTASC  
  DODEF         DOIT     LINCON   SFTLIN  
  DODEF         DOIT     PRTCLS  
  DODEF         DOIT     PRTOPN  
  DODEF         DOIT     PRTOUT  
  DODEF         DOIT     REDOIT  
  DODEF         DOIT     RESTRM   SETNAR  
  DODEF         DOIT     RESTRM   SETWID  
  DODEF         DOIT     STOPSC   STPSC2  
  DODEF         DOIT     WORKNG   TIMAST   TMAST2  
  DODEF         GETDEF   PRSCOM   DOIT     BLKCLS  
  DODEF         GETDEF   PRSCOM   DOIT     BLKIN   
  DODEF         GETDEF   PRSCOM   DOIT     BLKSIN  
  DODEF         GETDEF   PRSCOM   DOIT     CONVUP  
  DODEF         GETDEF   PRSCOM   DOIT     EXIT    
  DODEF         GETDEF   PRSCOM   DOIT     INTASC  
  DODEF         GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  DODEF         GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  DODEF         GETDEF   PRSCOM   DOIT     PRTCLS  
  DODEF         GETDEF   PRSCOM   DOIT     PRTOPN  
  DODEF         GETDEF   PRSCOM   DOIT     PRTOUT  
  DODEF         GETDEF   PRSCOM   DOIT     REDOIT  
  DODEF         GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  DODEF         GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  DODEF         GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  DODEF         GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  DODEF         PRSCOM   DOIT     BLKCLS  
  DODEF         PRSCOM   DOIT     BLKIN   
  DODEF         PRSCOM   DOIT     BLKSIN  
  DODEF         PRSCOM   DOIT     CONVUP  
  DODEF         PRSCOM   DOIT     EXIT    
  DODEF         PRSCOM   DOIT     INTASC  
  DODEF         PRSCOM   DOIT     LINCON   INTASC  
  DODEF         PRSCOM   DOIT     LINCON   SFTLIN  
  DODEF         PRSCOM   DOIT     PRTCLS  
  DODEF         PRSCOM   DOIT     PRTOPN  
  DODEF         PRSCOM   DOIT     PRTOUT  
  DODEF         PRSCOM   DOIT     REDOIT  
  DODEF         PRSCOM   DOIT     RESTRM   SETNAR  
  DODEF         PRSCOM   DOIT     RESTRM   SETWID  
  DODEF         PRSCOM   DOIT     STOPSC   STPSC2  
  DODEF         PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  

  DOIT          BLKCLS  
  DOIT          BLKIN   
  DOIT          BLKSIN  
  DOIT          CONVUP  
  DOIT          EXIT    
  DOIT          INTASC  
  DOIT          LINCON   INTASC  
  DOIT          LINCON   SFTLIN  
  DOIT          PRTCLS  
  DOIT          PRTOPN  
  DOIT          PRTOUT  
  DOIT          REDOIT  
  DOIT          RESTRM   SETNAR  
  DOIT          RESTRM   SETWID  
  DOIT          STOPSC   STPSC2  
  DOIT          WORKNG   TIMAST   TMAST2  

  EXIT    

  EXITR         BLKCLS  
  EXITR         RESTRM   SETNAR  
  EXITR         RESTRM   SETWID  
  EXITR         WORKNG   TIMAST   TMAST2  

  GETDEF        PRSCOM   DOIT     BLKCLS  
  GETDEF        PRSCOM   DOIT     BLKIN   
  GETDEF        PRSCOM   DOIT     BLKSIN  
  GETDEF        PRSCOM   DOIT     CONVUP  
  GETDEF        PRSCOM   DOIT     EXIT    
  GETDEF        PRSCOM   DOIT     INTASC  
  GETDEF        PRSCOM   DOIT     LINCON   INTASC  
  GETDEF        PRSCOM   DOIT     LINCON   SFTLIN  
  GETDEF        PRSCOM   DOIT     PRTCLS  
  GETDEF        PRSCOM   DOIT     PRTOPN  
  GETDEF        PRSCOM   DOIT     PRTOUT  
  GETDEF        PRSCOM   DOIT     REDOIT  
  GETDEF        PRSCOM   DOIT     RESTRM   SETNAR  
  GETDEF        PRSCOM   DOIT     RESTRM   SETWID  
  GETDEF        PRSCOM   DOIT     STOPSC   STPSC2  
  GETDEF        PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  

  GETOWN  

  INTASC  

  LINCON        INTASC  
  LINCON        SFTLIN  

  LOOK          BLKIN   
  LOOK          BLKOPN  
  LOOK          BLKSIN  
  LOOK          BRDCST  
  LOOK          COMLVL   CLRWRP  
  LOOK          COMLVL   DODEF    DOIT     BLKCLS  
  LOOK          COMLVL   DODEF    DOIT     BLKIN   
  LOOK          COMLVL   DODEF    DOIT     BLKSIN  
  LOOK          COMLVL   DODEF    DOIT     CONVUP  
  LOOK          COMLVL   DODEF    DOIT     EXIT    
  LOOK          COMLVL   DODEF    DOIT     INTASC  
  LOOK          COMLVL   DODEF    DOIT     LINCON   INTASC  
  LOOK          COMLVL   DODEF    DOIT     LINCON   SFTLIN  
  LOOK          COMLVL   DODEF    DOIT     PRTCLS  
  LOOK          COMLVL   DODEF    DOIT     PRTOPN  
  LOOK          COMLVL   DODEF    DOIT     PRTOUT  
  LOOK          COMLVL   DODEF    DOIT     REDOIT  
  LOOK          COMLVL   DODEF    DOIT     RESTRM   SETNAR  
  LOOK          COMLVL   DODEF    DOIT     RESTRM   SETWID  
  LOOK          COMLVL   DODEF    DOIT     STOPSC   STPSC2  
  LOOK          COMLVL   DODEF    DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     BLKCLS  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     BLKIN   
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     BLKSIN  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     CONVUP  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     EXIT    
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     INTASC  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     PRTCLS  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     PRTOPN  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     PRTOUT  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     REDOIT  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          COMLVL   DODEF    GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     BLKCLS  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     BLKIN   
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     BLKSIN  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     CONVUP  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     EXIT    
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     INTASC  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     LINCON   INTASC  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     PRTCLS  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     PRTOPN  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     PRTOUT  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     REDOIT  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          COMLVL   DODEF    PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     BLKCLS  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     BLKIN   
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     BLKSIN  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     CONVUP  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     EXIT    
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     INTASC  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     PRTCLS  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     PRTOPN  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     PRTOUT  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     REDOIT  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          COMLVL   GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          COMLVL   SETNAR  
  LOOK          COMLVL   SETWID  
  LOOK          COMLVL   SETWRP  
  LOOK          COMLVL   TTSPAWN 
  LOOK          DODEF    COMLVL   CLRWRP  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     BLKCLS  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     BLKIN   
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     BLKSIN  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     CONVUP  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     EXIT    
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     INTASC  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     PRTCLS  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     PRTOPN  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     PRTOUT  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     REDOIT  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          DODEF    COMLVL   GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          DODEF    COMLVL   SETNAR  
  LOOK          DODEF    COMLVL   SETWID  
  LOOK          DODEF    COMLVL   SETWRP  
  LOOK          DODEF    COMLVL   TTSPAWN 
  LOOK          DODEF    DOIT     BLKCLS  
  LOOK          DODEF    DOIT     BLKIN   
  LOOK          DODEF    DOIT     BLKSIN  
  LOOK          DODEF    DOIT     CONVUP  
  LOOK          DODEF    DOIT     EXIT    
  LOOK          DODEF    DOIT     INTASC  
  LOOK          DODEF    DOIT     LINCON   INTASC  
  LOOK          DODEF    DOIT     LINCON   SFTLIN  
  LOOK          DODEF    DOIT     PRTCLS  
  LOOK          DODEF    DOIT     PRTOPN  
  LOOK          DODEF    DOIT     PRTOUT  
  LOOK          DODEF    DOIT     REDOIT  
  LOOK          DODEF    DOIT     RESTRM   SETNAR  
  LOOK          DODEF    DOIT     RESTRM   SETWID  
  LOOK          DODEF    DOIT     STOPSC   STPSC2  
  LOOK          DODEF    DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     BLKCLS  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     BLKIN   
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     BLKSIN  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     CONVUP  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     EXIT    
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     INTASC  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     LINCON   INTASC  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     PRTCLS  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     PRTOPN  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     PRTOUT  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     REDOIT  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          DODEF    GETDEF   PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          DODEF    PRSCOM   DOIT     BLKCLS  
  LOOK          DODEF    PRSCOM   DOIT     BLKIN   
  LOOK          DODEF    PRSCOM   DOIT     BLKSIN  
  LOOK          DODEF    PRSCOM   DOIT     CONVUP  
  LOOK          DODEF    PRSCOM   DOIT     EXIT    
  LOOK          DODEF    PRSCOM   DOIT     INTASC  
  LOOK          DODEF    PRSCOM   DOIT     LINCON   INTASC  
  LOOK          DODEF    PRSCOM   DOIT     LINCON   SFTLIN  
  LOOK          DODEF    PRSCOM   DOIT     PRTCLS  
  LOOK          DODEF    PRSCOM   DOIT     PRTOPN  
  LOOK          DODEF    PRSCOM   DOIT     PRTOUT  
  LOOK          DODEF    PRSCOM   DOIT     REDOIT  
  LOOK          DODEF    PRSCOM   DOIT     RESTRM   SETNAR  
  LOOK          DODEF    PRSCOM   DOIT     RESTRM   SETWID  
  LOOK          DODEF    PRSCOM   DOIT     STOPSC   STPSC2  
  LOOK          DODEF    PRSCOM   DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          DOIT     BLKCLS  
  LOOK          DOIT     BLKIN   
  LOOK          DOIT     BLKSIN  
  LOOK          DOIT     CONVUP  
  LOOK          DOIT     EXIT    
  LOOK          DOIT     INTASC  
  LOOK          DOIT     LINCON   INTASC  
  LOOK          DOIT     LINCON   SFTLIN  
  LOOK          DOIT     PRTCLS  
  LOOK          DOIT     PRTOPN  
  LOOK          DOIT     PRTOUT  
  LOOK          DOIT     REDOIT  
  LOOK          DOIT     RESTRM   SETNAR  
  LOOK          DOIT     RESTRM   SETWID  
  LOOK          DOIT     STOPSC   STPSC2  
  LOOK          DOIT     WORKNG   TIMAST   TMAST2  
  LOOK          INTASC  
  LOOK          LINCON   INTASC  
  LOOK          LINCON   SFTLIN  

  PRSCOM        DOIT     BLKCLS  
  PRSCOM        DOIT     BLKIN   
  PRSCOM        DOIT     BLKSIN  
  PRSCOM        DOIT     CONVUP  
  PRSCOM        DOIT     EXIT    
  PRSCOM        DOIT     INTASC  
  PRSCOM        DOIT     LINCON   INTASC  
  PRSCOM        DOIT     LINCON   SFTLIN  
  PRSCOM        DOIT     PRTCLS  
  PRSCOM        DOIT     PRTOPN  
  PRSCOM        DOIT     PRTOUT  
  PRSCOM        DOIT     REDOIT  
  PRSCOM        DOIT     RESTRM   SETNAR  
  PRSCOM        DOIT     RESTRM   SETWID  
  PRSCOM        DOIT     STOPSC   STPSC2  
  PRSCOM        DOIT     WORKNG   TIMAST   TMAST2  

  PRTCLS  

  PRTOPN  

  PRTOUT  

  REDOIT  

  RESTRM        SETNAR  
  RESTRM        SETWID  

  SETERM        SETNAR  
  SETERM        SETWID  

  SETNAR  

  SETWID  

  SETWRP  

  SFTLIN  

  STOPSC        STPSC2  

  STPSC2  

  TIMAST        TMAST2  

  TMAST2  

  TTBRDAST      BRDCST  

  TTBRDEND

  TTBRDINI      TTBRDAST BRDCST  
  TTBRDINI      TTBRDEND

  TTSPAWN 

  WORKNG        TIMAST   TMAST2  
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    1


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

    1              PROGRAM LOOK                                                                                                     
    2       C                                       CD    This program is designed to look at long printout files.  It has          
    3       C                                       CD    the features that it can jump to any place in the file (either back-      
    4       C                                       CD    wards or forwards) without having to read in any of the intermediate      
    5       C                                       CD    data.  It can also search (either forward or backward) for strings,       
    6       C                                       CD    and scroll at different speeds.                                           
    7       C                                       CD                                                                              
    8       C                                       CD        When run on a VT100 the program is puts the terminal in some          
    9       C                                       CD    rather strange modes, so if the program exits abnormally (by ^Y or        
   10       C                                       CD    by the system crashing, for example) one should push the SET-UP key       
   11       C                                       CD    followed by a shift-R (capital R) to restore the terminals default        
   12       C                                       CD    modes.                                                                    
   13       C                                       CD                                                                              
   14       C                                       CDM        Either of the following will actually start running the program;     
   15       C                                       CDM   typing RUN JPL:[JLV.LOOK]LOOK, or defining a symbol to run the            
   16       C                                       CDM   program (i.e. LOOK:==$JPL:[JLV.LOOK]LOOK.EXE) and then typing the         
   17       C                                       CDM   symbol.  The later method has the advantage that one can enter the        
   18       C                                       CDM   name of the file to be looked at and/or the symbol definition file's      
   19       C                                       CDM   name (see below) on the command line (for example:                        
   20       C                                       CDM                    LOOK PRINT.LIS/DEFINITIONS=LOOKCOM.DAT                   
   21       C                                       CDM   will run the program (if LOOK is defined as above) on the file            
   22       C                                       CDM   PRINT.LIS with the symbol definitions taken from LOOKCOM.DAT              
   23       C                                       CDM   (the DEFINITIONS switch can go before or after the main file's            
   24       C                                       CDM   name and can be abbreviated all the way to a D)).  If the switch          
   25       C                                       CDM   /NARROW is on the command line, then the screen will not be converted     
   26       C                                       CDM   into 132 column mode (this, of course, only applies to VT100 terminals).  
   27       C                                       CDM   If the switch /WRAP is present then the lines will be printed with        
   28       C                                       CDM   terminal wrapping, instead of being cut to the width of the terminal.     
   29       C                                       CDM   If the switch /BOX is present then one line of output is sacrificed       
   30       C                                       CDM   to allow a line to be drawn dividing the file text from the command       
   31       C                                       CDM   input line.                                                               
   32       C                                       CDM                                                                             
   33       C                                       CDM        The following commands are the "basic" command set of the            
   34       C                                       CDM   program:                                                                  
   35       C                                       CDM             n$         - jump by n lines (positive or negative)             
   36       C                                       CDM             n%         - jump by n blocks (positive or negative)            
   37       C                                       CDM             ^          - search (forward) for the string(s) in the search   
   38       C                                       CDM                          buffers (up to 10) and display from that line if   
   39       C                                       CDM                          found, if not found ring the terminal bell and     
   40       C                                       CDM                          turn on LED 3 (VT100's only).  Matches are found   
   41       C                                       CDM                          irregardless of lower/uppercase differences.       
   42       C                                       CDM             -^         - search (backward) for string(s), same rules as     
   43       C                                       CDM                          forward search.                                    
   44       C                                       CDM             - "string" 'string' ... ^                                       
   45       C                                       CDM                        - load search buffers with the given strings and     
   46       C                                       CDM                          search (backward) for them, same rules as          
   47       C                                       CDM                          forward search.                                    
   48       C                                       CDM             "string"   - clear the search buffers and save the given        
   49       C                                       CDM                          string as the only search string.  A string        
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    2


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

   50       C                                       CDM                          can consist of any characters, to include a        
   51       C                                       CDM                          quotation mark (") one must put two of them in     
   52       C                                       CDM                          a row ("").                                        
   53       C                                       CDM             'string' 'string' ...                                           
   54       C                                       CDM                        - add the given string(s) to the search buffers.     
   55       C                                       CDM                          A string can consist of any characters, to         
   56       C                                       CDM                          include a single quote (') one must put two of     
   57       C                                       CDM                          them in a row ('').                                
   58       C                                       CDM             !          - set reverse switch, all commands will now work     
   59       C                                       CDM                          in reverse (i.e. n$ will jump -n lines, etc.)      
   60       C                                       CDM             #          - scroll                                             
   61       C                                       CDM             -#         - scroll backward                                    
   62       C                                       CDM             (          - stop scrolling (only valid command when            
   63       C                                       CDM                          scrolling is in operation),                        
   64       C                                       CDM                          or cancel current line jump, search, or            
   65       C                                       CDM                          & command.                                         
   66       C                                       CDM             n)         - set scrolling speed to n lines per second          
   67       C                                       CDM                          (positive or negative, integer or real)            
   68       C                                       CDM                          (originally set to 2).                             
   69       C                                       CDM                          NOTE:  there is a maximum speed that will not      
   70       C                                       CDM                          be exceeded (varies with situation) even if        
   71       C                                       CDM                          scrolling speed is set at a fast value.            
   72       C                                       CDM             n*         - mark the nth line from the top of the screen       
   73       C                                       CDM                          as the boundary of the print range.  The print     
   74       C                                       CDM                          range is defined by the last two such marked       
   75       C                                       CDM                          lines.                                             
   76       C                                       CDM             n&         - print the range of lines from the top of the       
   77       C                                       CDM                          screen to the nth line from the top of the         
   78       C                                       CDM                          screen (n can be either positive or negative).     
   79       C                                       CDM                          onto device SYS$PRINT.  if n is 0 or absent        
   80       C                                       CDM                          then the range marked with the * command is        
   81       C                                       CDM                          used, if available, otherwise 23 is used for       
   82       C                                       CDM                          n.  The format of the printout will be that        
   83       C                                       CDM                          of the original file, not necessarily what         
   84       C                                       CDM                          is shown on the screen (i.e. FORTRAN carriage-     
   85       C                                       CDM                          control, and all printer control will work as      
   86       C                                       CDM                          they are supposed to).                             
   87       C                                       CDM             n-&        - same as n&, except output is put into a file       
   88       C                                       CDM                          named LOOKPRINT.LIS in the default directory       
   89       C                                       CDM                          (File format will be the same as the original      
   90       C                                       CDM                          file, except organization will be sequential)      
   91       C                                       CDM                          (appended to the latest version if a previous n-&  
   92       C                                       CDM                          or n--& command has been given, otherwise a new    
   93       C                                       CDM                          version is created).                               
   94       C                                       CDM             n--&       - same as n-&, except always creates a new version   
   95       C                                       CDM                          of the output file.                                
   96       C                                       CDM             @          - exit the program.                                  
   97       C                                       CDM             +          - re-writes the screen.                              
   98       C                                       CDM             <          - repeat the last command.                           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    3


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

   99       C                                       CDM                                                                             
  100       C                                       CDM        If an invalid command is typed the terminal bell is rung and on      
  101       C                                       CDM   a VT100 LED #3 is turned on.  The line is parsed in such a way that a     
  102       C                                       CDM   valid command will be executed even if followed by an invalid command.    
  103       C                                       CDM   Note that no command is executed until a standard line terminator is      
  104       C                                       CDM   received (ASCII code of 1 to 31).  Note that commands are limited to      
  105       C                                       CDM   34 characters when entered in response to the prompt.  In order to        
  106       C                                       CDM   enter longer commands one can use the "command mode" DEFINE command       
  107       C                                       CDM   (see below) and then execute the symbol.  Also all search strings         
  108       C                                       CDM   are limited to 30 characters.                                             
  109       C                                       CDM                                                                             
  110       C                                       CDM        If the user types ^Z (Control-Z) whenever the program is not         
  111       C                                       CDM   currently executing a command, the program will enter "command" mode.     
  112       C                                       CDM   This mode allows the user to use any of the following commands:           
  113       C                                       CDM             DEFINE s := a1 a2 ...                                           
  114       C                                       CDM                            - which defines a symbol s in the same man-      
  115       C                                       CDM                              ner as a line in the definitions file (see     
  116       C                                       CDM                              below), including line continuations.          
  117       C                                       CDM             EXIT           - returns to the normal "look" mode.             
  118       C                                       CDM             HELP a         - where a is one of the commands shown above.    
  119       C                                       CDM             SET [NO]switch - with switch being any of WRAP, BOX, WIDE       
  120       C                                       CDM                              or NARROW.  These have the same affect as      
  121       C                                       CDM                              the command line switches of the same          
  122       C                                       CDM                              names (WIDE is the same as NONARROW),          
  123       C                                       CDM                              with the NO qualifier turning them off.        
  124       C                                       CDM             SHOW [s]       - where s is a defined symbol.  This will        
  125       C                                       CDM                              show what commands a symbol is defined         
  126       C                                       CDM                              as. (if s is omitted, all defined symbols      
  127       C                                       CDM                              are shown).                                    
  128       C                                       CDM             @filename      - Inputs the file filename as a definitions      
  129       C                                       CDM                              file.                                          
  130       C                                       CDM                                                                             
  131       C                                       CDM        The user is also allowed to define symbols for a command or          
  132       C                                       CDM   commands.  Valid symbols consist of the characters a-z (lower and         
  133       C                                       CDM   upper-case are equivalent), _, =, `, ~, [, ], {, }, ;, :,                 
  134       C                                       CDM   ,(comma), >, ?, /, \,and  |.  Symbol definitions are given in             
  135       C                                       CDM   a symbol definition file which is read at the start of execution          
  136       C                                       CDM   (or by the "command" level @ command), or by the "command" level          
  137       C                                       CDM   DEFINE command.  This file is either given by the /DEFINITIONS            
  138       C                                       CDM   switch, or a file named LOOKCOM.DAT is searched for in the fol-           
  139       C                                       CDM   lowing places:  The default directory (the file is used only if           
  140       C                                       CDM   the user owns it), the user's username directory on JPL,                  
  141       C                                       CDM   CIT, and SYS2 in that order.                                              
  142       C                                       CDM                                                                             
  143       C                                       CDM        In the symbol definition file the user can place both commands       
  144       C                                       CDM   and definitions.  Commands will be executed on encounter, and def-        
  145       C                                       CDM   initions will be placed in the definitons list.  Definitions have         
  146       C                                       CDM   the following form:                                                       
  147       C                                       CDM                 symbol := command1 command2 command3 ... command9           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    4


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  148       C                                       CDM   Up to ten commands can be contained in each symbol (exception - a         
  149       C                                       CDM   symbol for the stop scrolling command should have only the one command    
  150       C                                       CDM   in it ( ( )) and will be executed (when the symbol is typed) in the       
  151       C                                       CDM   order they appear in the definition.  A - (minus sign) as the last        
  152       C                                       CDM   character in a line means the definition is continued on the next         
  153       C                                       CDM   line.  The following are default symbol definitions (they can be          
  154       C                                       CDM   overriden by the symbol definition file):                                 
  155       C                                       CDM             U := 23$                                                        
  156       C                                       CDM             D := -23$                                                       
  157       C                                       CDM             S := #                                                          
  158       C                                       CDM             Q := (                                                          
  159       C                                       CDM             J := 20%                                                        
  160       C                                       CDM             B := -20%                                                       
  161       C                                       CDM             P := 23&                                                        
  162       C                                       CDM             A := 23-&                                                       
  163       C                                       CDM             L := 23--&                                                      
  164       C                                       CDM             E := @                                                          
  165       C                                       CDM             M := *                                                          
  166       C                                       CDM             C := +                                                          
  167       C                                       CDM             R := <                                                          
  168       C                                       CDM                                                                             
  169       C                                       CDM   Note, that only the first character of a symbol is significant in the     
  170       C                                       CDM   symbol definition file.  Also when input as a command the symbol should   
  171       C                                       CDM   be input as only one character.                                           
  172       C                                       CDM                                                                             
  173       C                                       CDM        A line enclosed by braces ({ }) will be treated as a "command"       
  174       C                                       CDM   level command (such as SET WIDE, @filename, etc.).                        
  175       C                                       CDM                                                                             
  176       C                                       CDM        The LEDs on a VT100 terminal are used to convey various bits of      
  177       C                                       CDM   information.  Their meanings are as follows:                              
  178       C                                       CDM             1 - on indicates a command is being executed (useful since      
  179       C                                       CDM                 some of the commands don't affect the screen until          
  180       C                                       CDM                 completion).                                                
  181       C                                       CDM             2 - on indicates that reverse is on (an odd number of !         
  182       C                                       CDM                 commands have been executed).                               
  183       C                                       CDM             3 - on indicates an invalid command was encountered (either     
  184       C                                       CDM                 input from the terminal, or while executeing a def-         
  185       C                                       CDM                 inition), or a search failed.                               
  186       C                                       CDM             4 - on indicates that a range of lines has been marked for      
  187       C                                       CDM                 printing                                                    
  188       C                                       CDM                                                                             
  189       C                                       CDM                                                                             
  190       C                                       CDM   NOTE:  If while using the program (on variable length record files)       
  191       C                                       CDM          one gets garbage on the screen, try moving either one block        
  192       C                                       CDM          forward or backward to realign the record boundaries.  Also        
  193       C                                       CDM          when working with FORTRAN carriage-control files the + (plus)      
  194       C                                       CDM          carriage-control character is ignored, and when working with       
  195       C                                       CDM          printer files, all carriage-control with the exception of          
  196       C                                       CDM          line feeds is ignored, and at least one line feed before each      
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    5


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  197       C                                       CDM          record is assumed.                                                 
  198       C                                       CDM                                                                             
  199       C                                       CDM   Programmer - Jon Vavrus  12 NOV 1980                                      
  200       C                                       CDM   Revised    - Jon Vavrus  30 MAR 1981                                      
  201       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1981                                      
  202       C                                       CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
  203       C                                       CDM   Revised    - Jon Vavrus  31 JUL 1981 (changed CCLINE usage)               
  204       C                                       CDM   Revised    - Jon Vavrus  27 AUG 1981                                      
  205       C                                       CDM   Revised    - Jon Vavrus   3 SEP 1981                                      
  206       C                                       CDM   Revised    - Jon Vavrus  30 DEC 1981 (added ^X)                           
  207       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)            
  208       C                                       CDM   Revised    - Jon Vavrus  15 JUL 1982 (extract some proc's add             
  209       C                                       CDM                                         "command" level to symbol file)     
  210       C                                       CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
  211       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
  212       C                                       CDM   Revised    - Jon Vavrus   4 APR 1983 (broadcast stuff)                    
  213       C                                       CDM   Revised    - Jon Vavrus  13 APR 1983                                      
  214       C                                       CDM   Revised    - Jon Vavrus  17 MAY 1983                                      
  215       C                                       CDM   Revised    - Jon Vavrus  28 MAY 1983                                      
  216       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1983                                      
  217       C                                       CDM   Revised    - Jon Vavrus  27 SEP 1983                                      
  218       C                                       CM                                                                              
  219       C                                       CM    ------------------------------------------------------------------------- 
  220       C                                       CM                                                                              
  221       C                                       CM         The program works by calculating or finding a record boundary        
  222       C                                       CM    near the current position and extracting actual records from there.       
  223       C                                       CM    This is done for fixed files by calculating the record boundary from      
  224       C                                       CM    the start of the file (or start of the block for blocked files),          
  225       C                                       CM    keeping in mind the fact that records are extended to an even number      
  226       C                                       CM    of bytes (word aligned).  For variable length records a record length     
  227       C                                       CM    count word is looked for (a byte containing a number equal to or          
  228       C                                       CM    less than 133 plus the record header size (FSZ), followed by a zeroed     
  229       C                                       CM    byte), which points to another record length count word.                  
  230       C                                       CM                                                                              
  231       C                                       CM         When the current line position needs to be converted to a            
  232       C                                       CM    position in terms of blocks and bytes, the program calculates the         
  233       C                                       CM    byte count from the last line in the output arrays to the current         
  234       C                                       CM    line, then using this plus the block number of the next block to be       
  235       C                                       CM    read in the position is calculated.  This is fairly straight forward      
  236       C                                       CM    for all but fixed blocked files, in which the count of unused bytes       
  237       C                                       CM    in each block must be taken into account.  For variable length record     
  238       C                                       CM    files a further check on position is made by trying to match the          
  239       C                                       CM    line pointed to and the lines around it to a specific area in the         
  240       C                                       CM    block.                                                                    
  241       C                                       CM                                                                              
  242       C                                       CM         Command input is handled by a QIO request to the terminal.  This     
  243       C                                       CM    input is terminated by the standard terminators, whihc are not echoed.    
  244       C                                       CM    Input is done with conversion to upper case (to make life easier), and    
  245       C                                       CM    with no translation of ^U, ^R, and <DEL> (all of which is done by the     
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    6


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  246       C                                       CM    program).  One will note that while scrolling, the QIO is alternately     
  247       C                                       CM    requested and cancelled with each output to the terminal, this is done    
  248       C                                       CM    so that the terminal will not get simultaneous read and write requests.   
  249       C                                       CM                                                                              
  250       C                                       CM         Scrolling speed is controlled by the use of the SYS$SETIMR and       
  251       C                                       CM    SYS$WAITFR system services.  Thus the QIO AST for the stop scrolling      
  252       C                                       CM    command must cancel the timer request, and also set the event flag.       
  253       C                                       CM                                                                              
  254       C                                       CM         Symbol definitions are kept in several arrays (DEFS - command        
  255       C                                       CM    number and length of any search buffers, NUMDEF - associated numbers,     
  256       C                                       CM    DEFBUF - search buffers, and DEFFLG - associated command flags).          
  257       C                                       CM    The total number of defined symbols is thus limited to 60.                
  258       C                                       C                                                                               
  259       C                                       C***   CALLED ROUTINES                                                          
  260       C                                       C                                                                               
  261       C                                       CC    BLKIN   Reads in one block of data from the input file.                   
  262       C                                       CC    BLKOPN  Opens a file for block input.                                     
  263       C                                       CC    BLKSIN  Reads in 7 blocks of data from the input file.                    
  264       C                                       CC    BRDCST  Fields braodcast messages.                                        
  265       C                                       CC    COMLVL  Executes "command level" commands.                                
  266       C                                       CC    DODEF   Processes a symbol file.                                          
  267       C                                       CC    DOIT    Executes a command.                                               
  268       C                                       CC    INTASC  Converts a string of bytes into a character variable              
  269       C                                       CC    LINCON  Converts data in the input buffer into lines in the output        
  270       C                                       CC            arrays.                                                           
  271       C                                       CC    PRSCOM  Parses a command line.                                            
  272       C                                       CC    TTBRDINI Initializes broadcast handler.                                   
  273       C                                       C                                                                               
  274       C                                       C***   COMMON AREAS                                                             
  275       C                                       C                                                                               
  276       C                                       CS    BRDCM1  Contains character variables for broadcast handling.              
  277       C                                       CS              BRDNOT holds the notice to be displayed on the screen.          
  278       C                                       CS              BRDMSG which holds broadcast messages.                          
  279       C                                       C                                                                               
  280       C                                       CS    BRDCM2  Contains non-character information for broadcast handling.        
  281       C                                       CS              BRDLEN the length of strings in BRDMSG.                         
  282       C                                       CS              BRDCNT the count of strings in BRDMSG.                          
  283       C                                       CS              BRDFLG a flag telling if there are unread messages.             
  284       C                                       C                                                                               
  285       C                                       CS    CHARS   Used to pass character variables; contains LINES a character      
  286       C                                       CS            array of the output lines, and SRCHBF the search buffer, and      
  287       C                                       CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
  288       C                                       CS            the VT100 control sequences to set/unset reverse video            
  289       C                                       C                                                                               
  290       C                                       CS    DOITNM  Contains information transferred from the main program:           
  291       C                                       CS                 INCHAN - input channel of the terminal                       
  292       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
  293       C                                       CS                 SBFFLG - flag indicating whether there is a string           
  294       C                                       CS                          in the search buffer                                
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    7


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  295       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
  296       C                                       CS                 EBK    - EBK of input file                                   
  297       C                                       CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
  298       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
  299       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
  300       C                                       CS                          of the print range                                  
  301       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
  302       C                                       CS                 LRL    - length of the longest record in input file.         
  303       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
  304       C                                       CS                 PAGEND - line number of last line output to screen           
  305       C                                       CS                 PAGLEN - number of lines per page                            
  306       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
  307       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
  308       C                                       C                                                                               
  309       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
  310       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
  311       C                                       C                                                                               
  312       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
  313       C                                       CS            symbol definitions DEFS, the number of such definitions           
  314       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
  315       C                                       CS            numbers NUMDEF                                                    
  316       C                                       C                                                                               
  317       C                                       CS    LNCN    Contains output arrays, and file pointers and information:        
  318       C                                       CS                 LINLEN - array of output line lengths                        
  319       C                                       CS                 LINEP  - top of screen line (or last line output by          
  320       C                                       CS                          backward scroll)                                    
  321       C                                       CS                 NLINES - number of lines in arrays                           
  322       C                                       CS                 BUFFER - array of unconverted data                           
  323       C                                       CS                 PBUF   - current position in BUFFER                          
  324       C                                       CS                 NBUF   - number of bytes in BUFFER                           
  325       C                                       CS                 BLK    - next block in file                                  
  326       C                                       CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
  327       C                                       CS                 IFSZ   - word extended record length for FIX files           
  328       C                                       CS                 RFM    - files RFM                                           
  329       C                                       CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
  330       C                                       CS                 SBLK   - starting block of current batch of output lines     
  331       C                                       CS                 CCLINE - array containing pointer to where the line's        
  332       C                                       CS                          record starts in the file (CCLINE(1,x) = block      
  333       C                                       CS                          #, CCLINE(2,x) = byte number in block).  If         
  334       C                                       CS                          CCLINE(1,x) = 0 then it is a carriage control       
  335       C                                       CS                          line.                                               
  336       C                                       CS                 LBLK   - last block processed by LINCON                      
  337       C                                       CS                 LPBUF  - last value of PBUF processed by LINCON              
  338       C                                       C                                                                               
  339       C                                       CS    OWNER   Used to pass the file owner's UIC back to the main program        
  340       C                                       CS            from a FORTRAN OPEN.                                              
  341       C                                       C                                                                               
  342       C                                       C***   INPUT VARIABLS                                                           
  343       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    8


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  344       C                                       CI    FILE    Used to input the symbol file's name.                             
  345       C                                       C                                                                               
  346       C                                       C***   INPUT/OUTPUT VARIABLES                                                   
  347       C                                       C                                                                               
  348       C                                       CIO   LINE    Used to get an error message from SYS$GETMSG and to input         
  349       C                                       CIO           a line from the symbol file, or to output error message,          
  350       C                                       CIO           and as the terminal input buffer.                                 
  351       C                                       C                                                                               
  352       C                                       C***   OUTPUT VARIABLES                                                         
  353       C                                       C                                                                               
  354       C                                       CO    FILE    Output with error message on open failure.                        
  355       C                                       CO    LINES   Output array, contains converted lines of output.                 
  356       C                                       C                                                                               
  357       C                                       C***   INPUT UNITS                                                              
  358       C                                       C                                                                               
  359       C                                       CR    INCHAN  Input channel number of the terminal.                             
  360       C                                       CR    30      Symbol file (file containing symbol definitions).                 
  361       C                                       C                                                                               
  362       C                                       C***   OUTPUT UNITS                                                             
  363       C                                       C                                                                               
  364       C                                       CW    6       Output to terminal.  Used for error messages.                     
  365       C                                       CW    9       Output to terminal.  Carriage-control LIST.                       
  366       C                                       C                                                                               
  367              PARAMETER NULL1=CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)                                                               
  368              PARAMETER NULLS=NULL1//NULL1//NULL1                                                                              
  369              EXTERNAL GETOWN,EXITR,BRDCST                                                                                     
  370              CHARACTER*1024 LINE                                                                                              
  371              CHARACTER*135 DIVLIN                                                                                             
  372              CHARACTER*132 LINES(600),CLINE                                                                                   
  373              CHARACTER*128 INLINE,BRDMSG(20)                                                                                  
  374              CHARACTER*122 BLANK                                                                                              
  375              CHARACTER*64 FILE,SYMFIL                                                                                         
  376              CHARACTER*30 SRCHBF(10),TEMP(10),DEFBUF(10,10,60)                                                                
  377              CHARACTER*22 BRDNOT                                                                                              
  378              CHARACTER*12 CHUSER                                                                                              
  379              CHARACTER*11 DEFSW                                                                                               
  380              CHARACTER*8 NARROW                                                                                               
  381              CHARACTER*4 REVVID,REGVID,WRAP                                                                                   
  382              CHARACTER*3 BOX                                                                                                  
  383              CHARACTER*2 CRLF,MSGNUM                                                                                          
  384              CHARACTER*1 SYMS(60),COMAND(12)                                                                                  
  385              REAL*4 NUMDEF(10,60)                                                                                             
  386              INTEGER*4 GETLIS(10),ERR,RFM,RAT,FSZ,TERM(2),INCHAN,                                                             
  387            1       SYS$ASSIGN,SYS$SETIMR,TIME,PBUF,EBK,SYS$TRNLOG,                                                            
  388            2       BLK,SBLK,RANGE(2,2),CCLINE(2,600),PAGEND,DSCBLK(4)                                                         
  389              INTEGER*2 GROUP,MEMBER,OWNER(2),IOSB(4),LINLEN(600),DIRECT,                                                      
  390            1       SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,LENSAV,PAGLEN,                                                     
  391            2       HLDLEN(10),COMLIN,OUTLEN,BRDCNT,BRDLEN(20)                                                                 
  392              LOGICAL*1 BUFFER(3750),USER(12),SBFFLG,END(16),NUMFLG,MINFLG,                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE    9


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  393            1       ESC,WIDE,BSP,VT100,BELL,CR,LF,DELETE(11),FILEOK,                                                           
  394            2       DEFFLG(3,10,60),HLDFLG,VT100A,DONE,BRDFLG                                                                  
  395                                                                                                                               
  396              COMMON /OWNER/OWNER                                                                                              
  397              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
  398            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
  399              COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                                                                    
  400              COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,                                                  
  401            1       RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                                                                             
  402              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
  403              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
  404              COMMON /BRDCM1/BRDNOT,BRDMSG                                                                                     
  405              COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                                                              
  406       C                                       C                                                                               
  407       C                                       C***   Initialize many things......                                             
  408       C                                       C                                                                               
  409              DATA BRDCNT,BRDFLG/0,.FALSE./		! Broadcast info.                                                                 
  410              DATA FILEOK/.TRUE./                                                                                              
  411              DATA GETLIS/'202000C'X,0,0,'3080002'X,0,0,'3070002'X,0,0,0/                                                      
  412              DATA END/'FE'X,'FF'X,'FF'X,'FF'X,11*0,'80'X/,TERM(1)/16/                                                         
  413              DATA BUFFER/3750*1/			! Empty buffer                                                                             
  414              DATA BLANK,ESC,BELL,BSP,CR,LF		! ASCII values                                                                    
  415            1       /' ',0027,0007,008,13,10/                                                                                  
  416              DATA REGVID,REVVID/' [0m',' [7m'/                                                                                
  417              DATA DELETE/27,'[','0','m',8,32,8,27,'[','7','m'/                                                                
  418              DATA SYMFIL/' '/				! No definition file                                                                         
  419              DATA NARROW , WRAP , BOX , DEFSW		! Valid command switches                                                       
  420            1       /'NARROW','WRAP','BOX','DEFINITIONS'/                                                                      
  421              DATA VT100A/.FALSE./			! Not an AVO VT100                                                                        
  422              DATA WIDE/0/,LENLMT/132/			! Wide mode                                                                           
  423              DATA SBFFLG/.FALSE./			! No search buffer                                                                        
  424              DATA RANGE/0,0,0,0/			! No print range                                                                           
  425              DATA TIME/-5000000/			! Scrolling speed                                                                          
  426              DATA DIRECT/1/				! Forward movement                                                                             
  427              DATA OUTLEN/0/				! Wrap mode                                                                                    
  428              DATA PAGLEN,COMLIN/23,24/			! 23 lines of output                                                                 
  429              DATA NDEFS,(SYMS(I),DEFS(1,1,I),NUMDEF(1,I),DEFFLG(1,1,I),                                                       
  430            1       DEFFLG(2,1,I),DEFFLG(3,1,I),DEFS(1,2,I),I=1,13)/13,                                                        
  431       C                                       C          Default key definitions:                                             
  432       C                                       C          Key command   number     minus  search  0 to terminate               
  433            2       'U',   1,   23.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  434            3       'D',   1,  -23.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  435            4       'S',   5,    0.,.FALSE.,.FALSE.,.FALSE.,0,                                                                 
  436            5       'Q',   6,    0.,.FALSE.,.FALSE.,.FALSE.,0,                                                                 
  437            6       'J',   2,   20.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  438            7       'B',   2,  -20.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  439            8       'E',  11,    0.,.FALSE.,.FALSE.,.FALSE.,0,                                                                 
  440            9       'P',  10,   23.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  441            A       'A',  10,   23.,.TRUE., .TRUE., .FALSE.,0,                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   10


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  442            B       'L',   9,   23.,.TRUE., .FALSE.,.FALSE.,0,                                                                 
  443            C       'M',   8,    0.,.FALSE.,.FALSE.,.FALSE.,0,                                                                 
  444            D       'C',  12,    0.,.FALSE.,.FALSE.,.FALSE.,0,                                                                 
  445            E       'R',  13,    0.,.FALSE.,.FALSE.,.FALSE.,0/                                                                 
  446                                                                                                                               
  447              WRITE (UNIT=CRLF,FMT=100)CR,LF                                                                                   
  448       100    FORMAT (2A1)                                                                                                     
  449              WRITE (UNIT=REVVID(1:1),FMT=100)ESC                                                                              
  450              REGVID(1:1) = REVVID(1:1)                                                                                        
  451              TERM(2) = %LOC(END(1))                                                                                           
  452       C                                       C                                                                               
  453       C                                       C***   Set things up                                                            
  454       C                                       C                                                                               
  455     *        EXECUTE (PROCESS_COM_LINE)                                                                                       
  456     *        EXECUTE (OPEN_PRINTOUT)                                                                                          
  457     *        EXECUTE (SETUP_TERM)                                                                                             
  458     *        EXECUTE (GET_FIRST_SCREEN)                                                                                       
  459     *        EXECUTE (PROCESS_SYMBOL_FILE)                                                                                    
  460       C                                       C                                                                               
  461       C                                       C---   Set up to catch broadcast messages                                       
  462       C                                       C                                                                               
  463     *        IF (VT100)                                                                                                       
  464   1 *           IF (VT100A)                                                                                                   
  465   2                BRDNOT = CHAR(BELL)//CHAR(BELL)//CHAR(ESC)//'[0;1;5m'//                                                    
  466            1             'MESSAGES'//CHAR(ESC)//'8'                                                                           
  467   2                I = 20                                                                                                     
  468   1 *           ELSE                                                                                                          
  469   2                BRDNOT = CHAR(BELL)//CHAR(BELL)//'MESSAGES'//CHAR(ESC)//'8'                                                
  470   2                I = 12                                                                                                     
  471   1 *           ENDIF                                                                                                         
  472     *        ELSE                                                                                                             
  473   1             BRDNOT = CHAR(BELL)//CHAR(BELL)//'MESSAGES'                                                                   
  474   1             I = 10                                                                                                        
  475     *        ENDIF                                                                                                            
  476              BRDNOT = BRDNOT(:I)//NULLS                                                                                       
  477              CALL TTBRDINI(BRDCST)                                                                                            
  478       C                                       C                                                                               
  479       C                                       C***   Set up command input QIO request                                         
  480       C                                       C                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
  481     * 1400  |DO FOREVER                                                                                                       
  482       C     |                                 C                                                                               
  483       C     |                                 C---   Output dividing line if wanted                                           
  484       C     |                                 C                                                                               
  485   1 *       |   IF (PAGLEN .EQ. (COMLIN - 2))                                                                                 
  486   2 *       |      IF (VT100A)                                                                                                
  487   3         |         CALL LIB$PUT_SCREEN(DIVLIN(:IABS(LENLMT)+3)//DIVLIN(1:1)//                                              
  488            1|               '(A',COMLIN-1,1)                                                                                  
  489   2 *       |      ELSE                                                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   11


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  490   3         |         CALL LIB$PUT_SCREEN(DIVLIN(:80),COMLIN-1,1)                                                             
  491   2 *       |      ENDIF                                                                                                      
  492   1 *       |   ENDIF                                                                                                         
  493   1         |   IF (OUTLEN .GT. 0) CALL LIB$PUT_SCREEN(BLANK(:OUTLEN),COMLIN,10)                                              
  494   1         |   IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                                                                       
  495   1 *       |   IF (LENSAV .GT. 0)                                                                                            
  496   2         |      LINE(1+LENBUF:) = INLINE                                                                                   
  497   2         |      LENBUF = LENSAV + LENBUF                                                                                   
  498   2         |      LENSAV = 0                                                                                                 
  499   1 *       |   ENDIF                                                                                                         
  500       C     |                                 C                                                                               
  501       C     |                                 C---   Output "messages" message (without bells)                                
  502       C     |                                 C                                                                               
  503   1 *       |   IF (BRDFLG)                                                                                                   
  504   2         |      IF (VT100) CALL LIB$PUT_SCREEN(CHAR(27)//'7')                                                              
  505   2         |      CALL LIB$PUT_SCREEN(BRDNOT(3:),COMLIN,IABS(LENLMT)-28)                                                     
  506   1 *       |   ENDIF                                                                                                         
  507       C     |                                 C                                                                               
  508   1 *       |   IF (LENBUF .GT. 0)                                                                                            
  509   2         |      CALL LIB$PUT_SCREEN('Command: '//LINE(:LENBUF),COMLIN,1)                                                   
  510   1 *       |   ELSE                                                                                                          
  511   2         |      CALL LIB$PUT_SCREEN('Command: ',COMLIN,1)                                                                  
  512   1 *       |   ENDIF                                                                                                         
  513   1         |   LENBUF = LENBUF + 1                                                                                           
  514   1         |   J = 35 - LENBUF                                                                                               
  515       C     |                                 C                                                                               
  516       C     |                                 C***   Input loop                                                               
  517       C     |                                 C                                                                               
                  |  +--------------------------------------------------------------------------------------------------------------
  518   1 *       |  |DO FOREVER                                                                                                    
  519   2         |  |   CALL SYS$QIOW(,%VAL(INCHAN),%VAL('1331'X),IOSB,,,                                                          
  520            1|  |         %REF(LINE(LENBUF:)),%VAL(J),,TERM,,)                                                                 
  521   2         |  |   LENBUF = IOSB(2) + LENBUF                                                                                  
  522   2 *       |  |   IF (ICHAR(LINE(LENBUF:LENBUF)) .EQ. 127)                                                                   
  523       C     |  |                              C                                                                               
  524       C     |  |                              C---   Check for delete                                                         
  525       C     |  |                              C                                                                               
  526   3 *       |  |      IF (LENBUF .GT. 1)                                                                                      
  527   4         |  |         LENBUF = LENBUF - 1                                                                                  
  528   4 *       |  |         IF (VT100A)                                                                                          
  529   5         |  |            CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,DELETE,                                                
  530            1|  |                  %VAL(11),,,,)                                                                               
  531   4 *       |  |         ELSE                                                                                                 
  532   5         |  |            CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,DELETE(5),                                             
  533            1|  |                  %VAL(3),,,,)                                                                                
  534   4 *       |  |         ENDIF                                                                                                
  535   3 *       |  |      ENDIF                                                                                                   
  536   2 *       |  |   ELSE                                                                                                       
  537       C     |  |                              C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   12


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  538       C     |  |                              C---   Check for ^U/^X                                                          
  539       C     |  |                              C                                                                               
  540   3 *       |  |      IF (ICHAR(LINE(LENBUF:LENBUF)) .EQ. 21 .OR.                                                             
  541            1|  |            ICHAR(LINE(LENBUF:LENBUF)) .EQ. 24)                                                               
  542   4         |  |         LENBUF = 1                                                                                           
  543   4 *       |  |         EXECUTE (ERASE_COMMAND)                                                                              
  544   3 *       |  |      ELSE                                                                                                    
  545       C     |  |                              C                                                                               
  546       C     |  |                              C---   Check for ^R                                                             
  547       C     |  |                              C                                                                               
  548   4 *       |  |         IF (ICHAR(LINE(LENBUF:LENBUF)) .EQ. 18)                                                              
  549   5 *       |  |            EXECUTE (ERASE_COMMAND)                                                                           
  550   5         |  |            CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,%REF(LINE),                                            
  551            1|  |                  %VAL(LENBUF-1),,,,)                                                                         
  552   4 *       |  |         ELSE                                                                                                 
  553       C     |  |                              C                                                                               
  554       C     |  |                              C---   Check for ^Z                                                             
  555       C     |  |                              C                                                                               
  556   5 *       |  |            IF (ICHAR(LINE(LENBUF:LENBUF)) .EQ. 26)                                                           
  557       C     |  |                              C                                                                               
  558       C     |  |                              C===   Erase screen                                                             
  559       C     |  |                              C                                                                               
  560   6         |  |               CALL LIB$ERASE_PAGE(1,1)                                                                       
  561   6 *       |  |               IF (BRDFLG)                                                                                    
  562   7         |  |                  IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                                                     
  563   7 *       |  |                  IF (BRDCNT .EQ. 1)                                                                          
  564   8         |  |                     CALL LIB$PUT_OUTPUT('THERE IS A BROADCAST '//                                            
  565            1|  |                           'MESSAGE'//CHAR(BELL),1,1)                                                         
  566   7 *       |  |                  ELSE                                                                                        
  567   8         |  |                     WRITE (UNIT=MSGNUM,FMT='(I2)') BRDCNT                                                    
  568   8 *       |  |                     IF (BRDCNT .LT. 10)                                                                      
  569   9         |  |                        CALL LIB$PUT_OUTPUT('THERE ARE'//MSGNUM//                                             
  570            1|  |                              ' BROADCAST MESSAGES'//CHAR(BELL),1,1)                                          
  571   8 *       |  |                     ELSE                                                                                     
  572   9         |  |                        CALL LIB$PUT_OUTPUT('THERE ARE '//MSGNUM//                                            
  573            1|  |                              ' BROADCAST MESSAGES'//CHAR(BELL),1,1)                                          
  574   8 *       |  |                     ENDIF                                                                                    
  575   7 *       |  |                  ENDIF                                                                                       
  576   7         |  |                  CALL LIB$SET_CURSOR(3,1)                                                                    
  577   6 *       |  |               ENDIF                                                                                          
  578   6         |  |               IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                                                        
                  |  |              +-----------------------------------------------------------------------------------------------
  579   6 *       |  |              |DO FOREVER                                                                                     
  580   7         |  |              |   CALL LIB$GET_INPUT(CLINE,'Command: ',LENGTH)                                                
  581   7         |  |              |   CALL COMLVL(CLINE(:LENGTH),DONE)                                                            
  582   7 *       |  |              |   UNDO IF (DONE)                                                                              
                  |  |              <----                                                                                           
  583   6 *       |  |              |END DO FOREVER                                                                                 
                  |  |              +-----------------------------------------------------------------------------------------------
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   13


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  584   6         |  |               CALL DOIT(-1,.TRUE.,0.,.FALSE.)                                                                
  585   6         |  |               CALL DOIT(-12,.FALSE.,0.,.FALSE.)                                                              
  586   6         |  |               LENBUF = LENBUF - 1                                                                            
  587   6 *       |  |               CYCLE 1400                                                                                     
                  |<------------------                                                                                              
  588   5 *       |  |            ELSE                                                                                              
  589   6         |  |               LENBUF = LENBUF - 1                                                                            
  590   6 *       |  |               UNDO                                                                                           
                  |  <----------------                                                                                              
  591   5 *       |  |            ENDIF                                                                                             
  592   4 *       |  |         ENDIF                                                                                                
  593   3 *       |  |      ENDIF                                                                                                   
  594   2 *       |  |   ENDIF                                                                                                      
  595   1 *       |  |END DO FOREVER                                                                                                
                  |  +--------------------------------------------------------------------------------------------------------------
  596   1         |   OUTLEN = LENBUF                                                                                               
  597   1         |   IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                                                                       
  598   1         |   CALL LIB$SET_CURSOR(1,1)                                                                                      
  599       C     |                                 C                                                                               
  600       C     |                                 C***   Execute commands                                                         
  601       C     |                                 C                                                                               
  602   1         |   CALL STR$TRANSLATE(LINE,LINE,' ','	')                                                                         
  603   1         |   CALL STR$TRIM(LINE(:LENBUF),LINE(:LENBUF),LENBUF)                                                             
                  |  +--------------------------------------------------------------------------------------------------------------
  604   1 *       |  |DO FOREVER                                                                                                    
  605   2         |  |   CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,0,0)                                                      
  606   2 *       |  |   UNDO IF (ICOM .EQ. 0)                                                                                      
                  |  <----                                                                                                          
  607   2         |  |   IF (ICOM .GT. 0) CALL DOIT(ICOM,NUMFLG,ANUMB,MINFLG)                                                       
  608   2 *       |  |   UNDO IF (ICOM .EQ. 5)                                                                                      
                  |  <----                                                                                                          
  609   1 *       |  |END DO FOREVER                                                                                                
                  |  +--------------------------------------------------------------------------------------------------------------
  610     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
  611       C                                       C                                                                               
  612       C                                       C***********************************************************************        
  613       C                                       C****************************   PROCEDURES   ***************************        
  614       C                                       C***********************************************************************        
  615       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   14


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  616     *        PROCEDURE (ERASE_COMMAND)                                                                                        
  617       C                                       CP    This procedure erase the command part of the bottom line.                 
  618   1 *           IF (VT100A)                                                                                                   
  619   2                CALL LIB$PUT_SCREEN(REGVID//BLANK(:LENBUF)//REVVID,COMLIN,10)                                              
  620   1 *           ELSE                                                                                                          
  621   2                CALL LIB$PUT_SCREEN(BLANK(:LENBUF),COMLIN,10)                                                              
  622   1 *           ENDIF                                                                                                         
  623   1             CALL LIB$SET_CURSOR(COMLIN,10)                                                                                
  624     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   15


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  625     *        PROCEDURE (GET_FIRST_SCREEN)                                                                                     
  626       C                                       CP    This procedure inputs and formats the first screen-full of output.        
  627       C                                       C                                                                               
  628       C                                       C***   Read in first bunch of data and output                                   
  629       C                                       C                                                                               
  630   1             BLK = 1                                                                                                       
  631   1             SBLK = BLK                                                                                                    
  632   1 *           IF (EBK .GT. 6)                                                                                               
  633   2                CALL BLKSIN(BLK,NBUF,BUFFER(1))                                                                            
  634   2 *              IF (NBUF .EQ. 0)                                                                                           
  635   3 *                 EXECUTE (READ_ERROR)                                                                                    
  636   2 *              ENDIF                                                                                                      
  637   1 *           ELSE                                                                                                          
  638   2                NBUF = 0                                                                                                   
                        +-----------------------------------------------------------------------------------------------------------
  639   2 *             |DO FOR I=1,EBK                                                                                             
  640   3               |   CALL BLKIN(BLK,J,BUFFER(NBUF+1))                                                                        
  641   3 *             |   IF (J .EQ. 0)                                                                                           
  642   4 *             |      EXECUTE (READ_ERROR)                                                                                 
  643   3 *             |   ENDIF                                                                                                   
  644   3               |   NBUF = NBUF + J                                                                                         
  645   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
  646   1 *           ENDIF                                                                                                         
  647   1             CALL LINCON(.TRUE.)                                                                                           
  648   1             J = PAGLEN                                                                                                    
  649   1 *           IF (NLINES .LT. PAGLEN)                                                                                       
                        +-----------------------------------------------------------------------------------------------------------
  650   2 *             |DO FOREVER                                                                                                 
  651   3 *             |   IF (BLK .GT. EBK)                                                                                       
  652   4               |      J = NLINES                                                                                           
  653   4 *             |      UNDO                                                                                                 
                        <-------                                                                                                    
  654   3 *             |   ENDIF                                                                                                   
  655   3               |   CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                                        
  656   3 *             |   IF (I .EQ. 0)                                                                                           
  657   4 *             |      EXECUTE (READ_ERROR)                                                                                 
  658   3 *             |   ENDIF                                                                                                   
  659   3               |   NBUF = NBUF + I                                                                                         
  660   3               |   CALL LINCON(.FALSE.)                                                                                    
  661   3 *             |   UNDO IF (NLINES .GE. PAGLEN)                                                                            
                        <----                                                                                                       
  662   2 *             |END DO FOREVER                                                                                             
                        +-----------------------------------------------------------------------------------------------------------
  663   1 *           ENDIF                                                                                                         
  664   1             CALL LIB$ERASE_PAGE(1,1)                                                                                      
  665   1             CALL LIB$SET_CURSOR(1,1)                                                                                      
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   16


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                     +--------------------------------------------------------------------------------------------------------------
  666   1 *          |DO FOR I=1,J                                                                                                  
  667   2 *          |   IF (LENLMT .LT. 0)                                                                                         
  668   3 *          |      IF (LINLEN(I) .LE. (-LENLMT))                                                                           
  669   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                      
  670   3 *          |      ELSE                                                                                                    
  671   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                       
  672            1   |               LINES(I)(1-LENLMT:LINLEN(I))//CRLF)                                                            
  673   3 *          |      ENDIF                                                                                                   
  674   2 *          |   ELSE                                                                                                       
  675   3 *          |      IF (LINLEN(I) .LT. LENLMT)                                                                              
  676   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                      
  677   3 *          |      ELSE                                                                                                    
  678   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)                                                         
  679   3 *          |      ENDIF                                                                                                   
  680   2 *          |   ENDIF                                                                                                      
  681   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
  682   1             PAGEND = J                                                                                                    
  683   1             IF (PAGLEN .EQ. 22) CALL LIB$PUT_SCREEN(CRLF)                                                                 
  684   1             IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                                                                       
  685   1             CALL LIB$PUT_SCREEN('Block 1',24,IABS(LENLMT)-6)                                                              
  686   1             IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                                                                       
  687   1             CALL LIB$SET_CURSOR(1,1)                                                                                      
  688     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   17


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  689     *        PROCEDURE (MAIN_DIR_SEARCH)                                                                                      
  690       C                                       CP    This routine searches the directories of the users username on the        
  691       C                                       CP    various disks (JPL, CIT, and SYS2 in that order) for the                  
  692       C                                       CP    symbol file (LOOKCOM.DAT), and if found opens it.                         
  693   1             CALL INTASC(I,USER,CHUSER)                                                                                    
  694   1             SYMFIL='JPL:['//CHUSER(:INDEX(CHUSER,' ')-1)//']LOOKCOM.DAT'                                                  
  695   1             OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1000,                                                       
  696            1          ACCESS='SEQUENTIAL',FORM='FORMATTED')                                                                   
                     +--------------------------------------------------------------------------------------------------------------
  697   1 *          |DO LABEL                                                                                                      
  698   2 *          |   LABEL 1000                                                                                                 
  699   3            |      SYMFIL(1:3) = 'CIT'                                                                                     
  700   3            |      OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1100,                                                 
  701            1   |            ACCESS='SEQUENTIAL',FORM='FORMATTED')                                                             
  702   2 *          |   LABEL 1100                                                                                                 
  703   3            |      SYMFIL = 'SYS2'//SYMFIL(4:)                                                                             
  704   3            |      OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1200,                                                 
  705            1   |            ACCESS='SEQUENTIAL',FORM='FORMATTED')                                                             
  706   2 *          |   LABEL 1200                                                                                                 
  707   3            |      FILEOK = .FALSE.                                                                                        
  708   1 *          |END DO LABEL                                                                                                  
                     +--------------------------------------------------------------------------------------------------------------
  709     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   18


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  710     *        PROCEDURE (NO_INPUT_EXIT)                                                                                        
  711       C                                       CP    This routine is an error routine if something goes wrong with getting     
  712       C                                       CP    input from the terminal.                                                  
  713   1             CALL LIB$PUT_OUTPUT(' CANNOT INPUT FROM SYS$INPUT.')                                                          
  714   1             CALL EXIT                                                                                                     
  715     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   19


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  716     *        PROCEDURE (OPEN_PRINTOUT)                                                                                        
  717       C                                       CP    This procedure opens the input file.                                      
  718       C                                       C                                                                               
  719       C                                       C***  Try to open printout file                                                 
  720       C                                       C                                                                               
  721   1             J = LIB$SKPC(' ',LINE)                                                                                        
  722   1             FILE = LINE(J:)                                                                                               
  723   1             I = INDEX(FILE,' ') - 1                                                                                       
  724   1             CALL BLKOPN(FILE(:I),ERR,RFM,RAT,FSZ,EBK,LRL)                                                                 
  725   1 *           IF (ERR .NE. 1)                                                                                               
  726   2                IF (I .LE. 0) I = 1                                                                                        
  727   2                CALL SYS$GETMSG(%VAL(ERR),J,LINE,%VAL(15),)                                                                
  728   2                CALL LIB$PUT_OUTPUT('****   UNABLE TO OPEN FILE '//FILE(:I))                                               
  729   2                CALL LIB$PUT_OUTPUT(LINE(:J))                                                                              
  730   2                CALL EXIT                                                                                                  
  731   1 *           ENDIF                                                                                                         
  732   1 *           IF (RFM .EQ. 1 .AND. FSZ)                                                                                     
  733   2                IFSZ = FSZ + 1                                                                                             
  734   1 *           ELSE                                                                                                          
  735   2                IFSZ = FSZ                                                                                                 
  736   1 *           ENDIF                                                                                                         
  737   1 *           IF (RAT .LT. 0 .AND. RFM .EQ. 1)                                                                              
  738   2                RECBLK = IFSZ*(512/IFSZ)                                                                                   
  739   1 *           ELSE                                                                                                          
  740   2                RECBLK = 512                                                                                               
  741   1 *           ENDIF                                                                                                         
  742     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   20


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  743     *        PROCEDURE (PROCESS_COM_LINE)                                                                                     
  744       C                                       CP    This procedure processes the command line.                                
  745       C                                       C                                                                               
  746       C                                       C***  Get file name off command line or prompt for it                           
  747       C                                       C***  Also check for /DEFINITIONS switch                                        
  748       C                                       C                                                                               
  749   1             CALL LIB$GET_FOREIGN(LINE,'Filename: ',LENGTH)                                                                
  750   1             CALL STR$UPCASE(LINE(:LENGTH),LINE(:LENGTH))                                                                  
  751       C                                       C                                                                               
  752       C                                       C***  Get rid of tabs                                                           
  753       C                                       C                                                                               
  754   1             CALL STR$TRANSLATE(LINE(:LENGTH),LINE(:LENGTH),' ','	')                                                       
  755       C                                       C                                                                               
  756       C                                       C***  Get the switches                                                          
  757       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
  758   1 *          |DO FOREVER                                                                                                    
  759   2            |   I = INDEX(LINE(:LENGTH),'/') + 1                                                                           
  760   2 *          |   UNDO IF (I .EQ. 1)                                                                                         
                     <----                                                                                                          
  761   2            |   J = INDEX(LINE(I:LENGTH),'/') + I - 2                                                                      
  762   2            |   IF (J .EQ. (I - 2)) J = LENGTH                                                                             
  763   2            |   K = INDEX(LINE(I:LENGTH),' ') + I - 2                                                                      
  764   2            |   IF (K .EQ. (I - 2)) K = LENGTH                                                                             
  765   2            |   IF (K .LT. J) J = K                                                                                        
                     |  +-----------------------------------------------------------------------------------------------------------
  766   2 *          |  |DO                                                                                                         
  767       C        |  |                           C                                                                               
  768       C        |  |                           C---   WRAP                                                                     
  769       C        |  |                           C                                                                               
  770   3 *          |  |   IF ((J - I) .LE. 3)                                                                                     
  771   4 *          |  |      IF (LINE(I:J) .EQ. WRAP(:J-I+1))                                                                     
  772   5            |  |         LENLMT = -LENLMT                                                                                  
  773   5 *          |  |         UNDO                                                                                              
                     |  <----------                                                                                                 
  774   4 *          |  |      ENDIF                                                                                                
  775   3 *          |  |   ENDIF                                                                                                   
  776       C        |  |                           C                                                                               
  777       C        |  |                           C---   NARROW                                                                   
  778       C        |  |                           C                                                                               
  779   3 *          |  |   IF ((J - I) .LE. 5)                                                                                     
  780   4 *          |  |      IF (LINE(I:J) .EQ. NARROW(:J-I+1))                                                                   
  781   5            |  |         WIDE = 1                                                                                          
  782   5 *          |  |         IF (LENLMT .LT. 0)                                                                                
  783   6            |  |            LENLMT = -80                                                                                   
  784   5 *          |  |         ELSE                                                                                              
  785   6            |  |            LENLMT = 80                                                                                    
  786   5 *          |  |         ENDIF                                                                                             
  787   5 *          |  |         UNDO                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   21


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                     |  <----------                                                                                                 
  788   4 *          |  |      ENDIF                                                                                                
  789   3 *          |  |   ENDIF                                                                                                   
  790       C        |  |                           C                                                                               
  791       C        |  |                           C---   BOX                                                                      
  792       C        |  |                           C                                                                               
  793   3 *          |  |   IF ((J - I) .LE. 2)                                                                                     
  794   4 *          |  |      IF (LINE(I:J) .EQ. BOX(:J-I+1))                                                                      
  795   5            |  |         PAGLEN = 22                                                                                       
  796   5 *          |  |         UNDO                                                                                              
                     |  <----------                                                                                                 
  797   4 *          |  |      ENDIF                                                                                                
  798   3 *          |  |   ENDIF                                                                                                   
  799       C        |  |                           C                                                                               
  800       C        |  |                           C---   Definitions file                                                         
  801       C        |  |                           C                                                                               
  802   3            |  |   K = INDEX(LINE,'=')                                                                                     
  803   3 *          |  |   IF (K .NE. 0 .AND. K .NE. J .AND. (K - I) .LE. 11)                                                      
  804   4 *          |  |      IF (LINE(I:K-1) .EQ. DEFSW(:K-I))                                                                    
  805   5            |  |         SYMFIL = LINE(K+1:J)                                                                              
  806   5            |  |         L = INDEX(SYMFIL,']') + 1                                                                         
  807   5 *          |  |         IF (INDEX(SYMFIL(L:),'.') .EQ. 0)                                                                 
  808   6            |  |            L = INDEX(SYMFIL,';')                                                                          
  809   6 *          |  |            IF (L .EQ. 0)                                                                                  
  810   7            |  |               SYMFIL = LINE(K+1:J)//'.'                                                                   
  811   6 *          |  |            ELSE                                                                                           
  812   7            |  |               SYMFIL = SYMFIL(:L-1)//'.'//SYMFIL(L:)                                                      
  813   6 *          |  |            ENDIF                                                                                          
  814   5 *          |  |         ENDIF                                                                                             
  815   5 *          |  |         UNDO                                                                                              
                     |  <----------                                                                                                 
  816   4 *          |  |      ENDIF                                                                                                
  817   3 *          |  |   ENDIF                                                                                                   
  818   3            |  |   CALL LIB$PUT_OUTPUT(' ****   INVALID SWITCH   ****')                                                    
  819   3            |  |   CALL EXIT                                                                                               
  820   2 *          |  |END DO                                                                                                     
                     |  +-----------------------------------------------------------------------------------------------------------
  821   2            |   LINE = LINE(:I-2)//LINE(J+1:)                                                                              
  822   2            |   LENGTH = LENGTH - J + I - 2                                                                                
  823   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
  824     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   22


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  825     *        PROCEDURE (PROCESS_SYMBOL_FILE)                                                                                  
  826       C                                       CP    This procedure processes the symbol/command file.                         
                     +--------------------------------------------------------------------------------------------------------------
  827   1 * 300      |DO                                                                                                            
  828   2 *          |   IF (SYMFIL .EQ. ' ')                                                                                       
  829       C        |                              C                                                                               
  830       C        |                              C***  Get user information to try and find a definitions file                   
  831       C        |                              C                                                                               
  832   3            |      GETLIS(2) = %LOC(USER(1))                                                                               
  833   3            |      GETLIS(3) = %LOC(I)                                                                                     
  834   3            |      GETLIS(5) = %LOC(GROUP)                                                                                 
  835   3            |      GETLIS(8) = %LOC(MEMBER)                                                                                
  836   3            |      CALL SYS$GETJPI(,,,GETLIS,,,)                                                                           
  837   3            |      OPEN (UNIT=30,NAME='LOOKCOM.DAT',TYPE='OLD',READONLY,ERR=400,                                           
  838            1   |            ACCESS='SEQUENTIAL',FORM='FORMATTED',USEROPEN=GETOWN)                                             
  839   3 *          |      IF (OWNER(1) .NE. GROUP .OR. OWNER(2) .NE. MEMBER)                                                      
  840   4            |         CLOSE (UNIT=30)                                                                                      
  841   4 *          |         EXECUTE (MAIN_DIR_SEARCH)                                                                            
  842   3 *          |      ENDIF                                                                                                   
                     |     +--------------------------------------------------------------------------------------------------------
  843   3 *          |     |DO LABEL                                                                                                
  844   4 *          |     |   LABEL 400                                                                                            
  845   5 *          |     |      EXECUTE (MAIN_DIR_SEARCH)                                                                         
  846   3 *          |     |END DO LABEL                                                                                            
                     |     +--------------------------------------------------------------------------------------------------------
  847   2 *          |   ELSE                                                                                                       
  848   3            |      OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=500,                                                  
  849            1   |            ACCESS='SEQUENTIAL',FORM='FORMATTED')                                                             
                     |     +--------------------------------------------------------------------------------------------------------
  850   3 *          |     |DO LABEL                                                                                                
  851   4 *          |     |   LABEL 500                                                                                            
  852   5            |     |      CALL LIB$PUT_SCREEN(REVVID//'Could not open file '//                                              
  853            1   |     |            SYMFIL(:INDEX(SYMFIL,' ')-1)//REGVID//CHAR(BELL),                                           
  854            2   |     |            24,20)                                                                                      
  855   5 *          |     |      UNDO 300                                                                                          
                     <-------------                                                                                                 
  856   3 *          |     |END DO LABEL                                                                                            
                     |     +--------------------------------------------------------------------------------------------------------
  857   2 *          |   ENDIF                                                                                                      
  858       C        |                              C                                                                               
  859       C        |                              C***   Read in lines and interpret them                                         
  860       C        |                              C                                                                               
  861   2            |   IF (FILEOK) CALL DODEF                                                                                     
  862   1 *          |END DO                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
  863     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   23


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  864     *        PROCEDURE (READ_ERROR)                                                                                           
  865       C                                       CP    This procedure is executed if an error occurs while reading the           
  866       C                                       CP    input file.                                                               
  867   1             CALL LIB$PUT_OUTPUT(' ERROR READING FILE')                                                                    
  868   1             CALL EXIT                                                                                                     
  869     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   24


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  870     *        PROCEDURE (SETUP_TERM)                                                                                           
  871       C                                       CP    This procedure opens and sets up the terminal.                            
  872       C                                       C                                                                               
  873       C                                       C***   Open a channel to SYS$INPUT                                              
  874       C                                       C                                                                               
  875   1 *           IF (.NOT.SYS$TRNLOG('TT',I,SRCHBF(1),,,))                                                                     
  876   2 *              EXECUTE (NO_INPUT_EXIT)                                                                                    
  877   1 *           ENDIF                                                                                                         
  878   1 *           IF (INDEX(SRCHBF(1)(:I),'LPA0') .NE. 0)                                                                       
  879   2 *              IF (.NOT.SYS$TRNLOG('SYS$INPUT',I,SRCHBF(1),,,))                                                           
  880   3 *                 EXECUTE (NO_INPUT_EXIT)                                                                                 
  881   2 *              ENDIF                                                                                                      
  882   1 *           ENDIF                                                                                                         
  883   1 *           IF (ICHAR(SRCHBF(1)) .EQ. 27)                                                                                 
  884   2                I = I - 4                                                                                                  
  885   2                SRCHBF(1) = SRCHBF(1)(5:)                                                                                  
  886   1 *           ENDIF                                                                                                         
  887   1 *           IF (.NOT.SYS$ASSIGN(SRCHBF(1)(:I),INCHAN,,))                                                                  
  888   2 *              EXECUTE (NO_INPUT_EXIT)                                                                                    
  889   1 *           ENDIF                                                                                                         
  890       C                                       C                                                                               
  891       C                                       C***   Set terminal characteristics                                             
  892       C                                       C                                                                               
  893   1             CALL SETERM(INCHAN,WIDE,LENLMT)                                                                               
  894       C                                       C                                                                               
  895       C                                       C***   Declare exit handler                                                     
  896       C                                       C                                                                               
  897   1             DSCBLK(2) = %LOC(EXITR)                                                                                       
  898   1             DSCBLK(3) = 1                                                                                                 
  899   1             DSCBLK(4) = %LOC(I)                                                                                           
  900   1             CALL SYS$DCLEXH(DSCBLK)                                                                                       
  901       C                                       C                                                                               
  902       C                                       C***   If wanted format dividing line                                           
  903       C                                       C                                                                               
  904   1 *           IF (VT100A)                                                                                                   
  905   2                DIVLIN(1:1) = REVVID(1:1)                                                                                  
  906   2                DIVLIN(2:) = '(0qqqqqqqqqqqqqqqqqqqqqqqqqqq'//                                                             
  907            1             'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'//                                            
  908            2             'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'                                               
  909   1 *           ELSE                                                                                                          
  910   2                DIVLIN = '--------------------------------'//                                                              
  911            1             '---------------------------------------------------'                                                
  912   1 *           ENDIF                                                                                                         
  913     *        END PROCEDURE                                                                                                    
  914              END                                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LOOK                  30-SEP-83      08:30:11      PAGE   25


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

  616  ERASE_COMMAND                  
                                543   549 

  625  GET_FIRST_SCREEN               
                                458 

  689  MAIN_DIR_SEARCH                
                                841   845 

  710  NO_INPUT_EXIT                  
                                876   880   888 

  716  OPEN_PRINTOUT                  
                                456 

  743  PROCESS_COM_LINE               
                                455 

  825  PROCESS_SYMBOL_FILE            
                                459 

  864  READ_ERROR                     
                                635   642   657 

  870  SETUP_TERM                     
                                457 

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   26


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  915              SUBROUTINE COMLVL(CLINE,DONE)                                                                                    
  916       C                                       CDM   This routine implements the "command" mode of look, by processing         
  917       C                                       CDM   one command which is passed to it.                                        
  918       C                                       CDM                                                                             
  919       C                                       CDM    Programmer - Jon Vavrus  26 AUG 1981                                     
  920       C                                       CDM    Revised    - Jon Vavrus   3 SEP 1981                                     
  921       C                                       CDM    Revised    - Jon Vavrus  18 SEP 1981                                     
  922       C                                       CDM    Revised    - Jon Vavrus   3 MAR 1982 (added SETNAR/SETWID)               
  923       C                                       CDM    Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)           
  924       C                                       CDM    Revised    - Jon Vavrus  15 JUL 1982 (changed to handle only one         
  925       C                                       CDM                                          command)                           
  926       C                                       CDM    Revised    - Jon Vavrus  18 AUG 1982 (Bigger arrays)                     
  927       C                                       CDM    Revised    - Jon Vavrus   9 SEP 1982                                     
  928       C                                       CDM    Revised    - Jon Vavrus   4 APR 1983 (add broadcast and spawn stuff)     
  929       C                                       CDM    Revised    - Jon Vavrus  17 MAY 1983                                     
  930       C                                       CDM    Revised    - Jon Vavrus  28 MAY 1983 (check defined symbols)             
  931       C                                       CDM    Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                    
  932       C                                       CDM    Revised    - Jon Vavrus  27 SEP 1983                                     
  933       C                                       CM                                                                              
  934       C                                       CM         This routine allows the use of the following commands:               
  935       C                                       CM              DEFINE s := a1 a2 ...                                           
  936       C                                       CM                             - which defines a symbol s in the same man-      
  937       C                                       CM                               ner as a line in the definitions file (see     
  938       C                                       CM                               below), including line continuations.          
  939       C                                       CM              EXIT           - returns to the normal "look" mode.             
  940       C                                       CM              HELP a         - where a is one of the commands shown above.    
  941       C                                       CM              READ           - outputs the broadcast messages (if any)        
  942       C                                       CM                               which have been received.                      
  943       C                                       CM              SET [NO]switch - with switch being any of WRAP, BOX, WIDE       
  944       C                                       CM                               or NARROW.  These have the same affect as      
  945       C                                       CM                               the command line switches of the same          
  946       C                                       CM                               names (WIDE is the same as NONARROW),          
  947       C                                       CM                               with the NO qualifier turning them off.        
  948       C                                       CM              SHOW [s]       - where s is a defined symbol.  This will        
  949       C                                       CM                               show what commands a symbol is defined         
  950       C                                       CM                               as. (if s is omitted, all defined symbols      
  951       C                                       CM                               are shown).                                    
  952       C                                       CM              SPAWN          - starts a sub-process up to allow the user      
  953       C                                       CM                               to do DCL commands.                            
  954       C                                       CM              @filename      - Inputs the file filename as a definitions      
  955       C                                       CM                               file.                                          
  956       C                                       CM                                                                              
  957       C                                       CM          Upon return DONE is set .TRUE. if the command was EXIT, .FALSE.     
  958       C                                       CM      otherwise.                                                              
  959       C                                       C                                                                               
  960       C                                       C***   CALLED ROUTINES                                                          
  961       C                                       C                                                                               
  962       C                                       CC    CLRWRP  Sets the terminal NOWRAP                                          
  963       C                                       CC    DODEF   Processes a symbol file                                           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   27


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

  964       C                                       CC    GETDEF  Translates a line into a symbol definition                        
  965       C                                       CC    SETNAR  Set VT100 terminal to 80 columns                                  
  966       C                                       CC    SETWID  Set VT100 terminal to 132 columns                                 
  967       C                                       CC    SETWRP  Sets the terminal WRAP                                            
  968       C                                       CC    TTSPAWN Spawns a sub-process (needed to get rid of broadcast              
  969       C                                       CC            trap                                                              
  970       C                                       C                                                                               
  971       C                                       C***   COMMON AREAS                                                             
  972       C                                       C                                                                               
  973       C                                       CS    BRDCM1  Contains character variables for broadcast handling.              
  974       C                                       CS              BRDNOT holds the notice to be displayed on the screen.          
  975       C                                       CS              BRDMSG which holds broadcast messages.                          
  976       C                                       C                                                                               
  977       C                                       CS    BRDCM2  Contains non-character information for broadcast handling.        
  978       C                                       CS              BRDLEN the length of strings in BRDMSG.                         
  979       C                                       CS              BRDCNT the count of strings in BRDMSG.                          
  980       C                                       CS              BRDFLG a flag telling if there are unread messages.             
  981       C                                       C                                                                               
  982       C                                       CS    CHARS   Used to pass character variables; contains LINES a character      
  983       C                                       CS            array of the output lines, and SRCHBF the search buffer, and      
  984       C                                       CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
  985       C                                       CS            the VT100 control sequences to set/unset reverse video            
  986       C                                       C                                                                               
  987       C                                       CS    DOITNM  Contains information transferred from the main program:           
  988       C                                       CS                 INCHAN - input channel of the terminal                       
  989       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
  990       C                                       CS                 SBFFLG - flag indicating whether there is a string           
  991       C                                       CS                          in the search buffer                                
  992       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
  993       C                                       CS                 EBK    - EBK of input file                                   
  994       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
  995       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
  996       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
  997       C                                       CS                          of the print range                                  
  998       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
  999       C                                       CS                 LRL    - length of the longest record in input file.         
 1000       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 1001       C                                       CS                 PAGEND - line number of last line output to screen           
 1002       C                                       CS                 PAGLEN - number of lines per page                            
 1003       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 1004       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 1005       C                                       C                                                                               
 1006       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
 1007       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
 1008       C                                       C                                                                               
 1009       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
 1010       C                                       CS            symbol definitions DEFS, the number of such definitions           
 1011       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
 1012       C                                       CS            numbers NUDMEF                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   28


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1013       C                                       C                                                                               
 1014              CHARACTER*(*) CLINE                                                                                              
 1015              CHARACTER*1024 LINE                                                                                              
 1016              CHARACTER*132 LINES(600)                                                                                         
 1017              CHARACTER*128 INLINE,BRDMSG(20)                                                                                  
 1018              CHARACTER*64 IMAGE                                                                                               
 1019              CHARACTER*30 DEFBUF(10,10,60),SRCHBF(10)                                                                         
 1020              CHARACTER*22 BRDNOT                                                                                              
 1021              CHARACTER*6 DEFINE,NARROW                                                                                        
 1022              CHARACTER*5 SPAWN                                                                                                
 1023              CHARACTER*4 EXIT,HELP,SHOW,REVVID,REGVID,WRAP,WIDE,READ                                                          
 1024              CHARACTER*3 SET,BOX                                                                                              
 1025              CHARACTER*2 CRLF                                                                                                 
 1026              CHARACTER*1 SYMS(60),COMAND(13),ALLSYM(42)                                                                       
 1027              REAL*4 NUMDEF(10,60)                                                                                             
 1028              INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,GETLIS(4),TTSPAWN                                                    
 1029              INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,PAGLEN,                                                 
 1030            1       LENSAV,COMLIN,BRDCNT,BRDLEN(20)                                                                            
 1031              LOGICAL GETDEF                                                                                                   
 1032              LOGICAL*1 SBFFLG,VT100,DEFFLG(3,10,60),NO,VT100A,DONE,BRDFLG,                                                    
 1033            1       OKFLAG                                                                                                     
 1034                                                                                                                               
 1035              COMMON /BRDCM1/BRDNOT,BRDMSG                                                                                     
 1036              COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                                                              
 1037              COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                                                                    
 1038              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 1039            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 1040              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
 1041              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
 1042                                                                                                                               
 1043              DATA NUMCOM,COMAND/13,'$','%','^','!','#','(',')','*',' ','&','@',                                               
 1044            1       '+','<'/                                                                                                   
 1045              DATA NUMALL,ALLSYM/42,'A','B','C','D','E','F','G','H','I','J','K',                                               
 1046            1       'L','M','N','O','P','Q','R','S','T','U','V',                                                               
 1047            2       'W','X','Y','Z','_','=','`','~','[',']','{',                                                               
 1048            3       '}',';',':',',','>','?','/','\','|'/                                                                       
 1049              DATA GETLIS(1),GETLIS(4)/'2070040'X,0/,IMAGE/'{'/                                                                
 1050              DATA BOX , SET , WRAP , EXIT , HELP , SHOW , WIDE , DEFINE/                                                      
 1051            1       'BOX','SET','WRAP','EXIT','HELP','SHOW','WIDE','DEFINE'/                                                   
 1052              DATA READ , SPAWN , NARROW/                                                                                      
 1053            1       'READ','SPAWN','NARROW'/                                                                                   
 1054                                                                                                                               
 1055     *        IF (LEN(CLINE) .EQ. 0)                                                                                           
 1056   1 *           EXECUTE (ERROR)                                                                                               
 1057     *        ENDIF                                                                                                            
 1058       C                                       C                                                                               
 1059       C                                       C***   Get any continuation lines                                               
 1060       C                                       C                                                                               
 1061              CALL STR$TRIM(LINE,CLINE,LENGTH)                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   29


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                  +-----------------------------------------------------------------------------------------------------------------
 1062     *       |DO FOREVER                                                                                                       
 1063   1 *       |   UNDO IF (LINE(LENGTH:LENGTH) .NE. '-')                                                                        
                  <----                                                                                                             
 1064   1         |   CALL LIB$GET_INPUT(LINE(LENGTH:),'-',J)                                                                       
 1065   1         |   LENGTH = LENGTH + J                                                                                           
 1066     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
 1067              CALL STR$TRANSLATE(LINE(:LENGTH),LINE(:LENGTH),' ','	')                                                          
 1068              CALL STR$UPCASE(LINE(:LENGTH),LINE(:LENGTH))                                                                     
 1069       C                                       C                                                                               
 1070       C                                       C***   Trim leading blanks                                                      
 1071       C                                       C                                                                               
 1072              I = LIB$SKPC(' ',LINE)                                                                                           
 1073     *        IF (I .LE. LENGTH)                                                                                               
 1074   1             LINE = LINE(I:LENGTH)                                                                                         
 1075   1             I = INDEX(LINE,' ') - 1                                                                                       
 1076       C                                       C                                                                               
 1077       C                                       C***   Check for set                                                            
 1078       C                                       C                                                                               
 1079   1 *           IF (I .LE. 3)                                                                                                 
 1080   2 *              IF (LINE(:I) .EQ. SET(:I))                                                                                 
 1081   3                   J = LIB$SKPC(' ',LINE(I+1:)) + I                                                                        
 1082   3 *                 IF (J .LT. I)                                                                                           
 1083   4 *                    EXECUTE (ERROR)                                                                                      
 1084   3 *                 ENDIF                                                                                                   
 1085   3                   LINE = LINE(J:)                                                                                         
 1086   3                   I = INDEX(LINE,' ') - 1                                                                                 
 1087       C                                       C                                                                               
 1088       C                                       C---   NO?                                                                      
 1089       C                                       C                                                                               
 1090   3                   NO = .FALSE.                                                                                            
 1091   3 *                 IF (I .GT. 2)                                                                                           
 1092   4 *                    IF (LINE(:2) .EQ. 'NO')                                                                              
 1093   5                         NO = .TRUE.                                                                                       
 1094   5                         LINE = LINE(3:)                                                                                   
 1095   5                         I = I - 2                                                                                         
 1096   4 *                    ENDIF                                                                                                
 1097   3 *                 ENDIF                                                                                                   
 1098       C                                       C                                                                               
 1099       C                                       C---   BOX?                                                                     
 1100       C                                       C                                                                               
 1101   3 *                 IF (I .LE. 3)                                                                                           
 1102   4 *                    IF (LINE(:I) .EQ. BOX(:I))                                                                           
 1103   5 *                       IF (NO)                                                                                           
 1104   6                            PAGLEN = COMLIN - 1                                                                            
 1105   5 *                       ELSE                                                                                              
 1106   6                            PAGLEN = COMLIN - 2                                                                            
 1107   5 *                       ENDIF                                                                                             
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   30


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1108   5 *                       EXECUTE (OK_RETURN)                                                                               
 1109   4 *                    ENDIF                                                                                                
 1110   3 *                 ENDIF                                                                                                   
 1111       C                                       C                                                                               
 1112       C                                       C---   WRAP?                                                                    
 1113       C                                       C                                                                               
 1114   3 *                 IF (I .LE. 4)                                                                                           
 1115   4 *                    IF (WRAP(:I) .EQ. LINE(:I))                                                                          
 1116   5 *                       IF (NO)                                                                                           
 1117   6                            LENLMT = IABS(LENLMT)                                                                          
 1118   6                            CALL CLRWRP(INCHAN)                                                                            
 1119   5 *                       ELSE                                                                                              
 1120   6                            LENLMT = -IABS(LENLMT)                                                                         
 1121   6                            CALL SETWRP(INCHAN)                                                                            
 1122   5 *                       ENDIF                                                                                             
 1123   5 *                       EXECUTE (OK_RETURN)                                                                               
 1124   4 *                    ENDIF                                                                                                
 1125       C                                       C                                                                               
 1126       C                                       C---   WIDE?                                                                    
 1127       C                                       C                                                                               
 1128   4 *                    IF (WIDE(:I) .EQ. LINE(:I) .AND. VT100)                                                              
 1129   5 *                       IF (NO)                                                                                           
 1130   6 *                          EXECUTE (SET_NARROW)                                                                           
 1131   5 *                       ELSE                                                                                              
 1132   6 *                          EXECUTE (SET_WIDE)                                                                             
 1133   5 *                       ENDIF                                                                                             
 1134   5 *                       EXECUTE (OK_RETURN)                                                                               
 1135   4 *                    ENDIF                                                                                                
 1136   3 *                 ENDIF                                                                                                   
 1137       C                                       C                                                                               
 1138       C                                       C---   NARROW?                                                                  
 1139       C                                       C                                                                               
 1140   3 *                 IF (I .LE. 6)                                                                                           
 1141   4 *                    IF (LINE(:I) .EQ. NARROW(:I) .AND. VT100)                                                            
 1142   5 *                       IF (NO)                                                                                           
 1143   6 *                          EXECUTE (SET_WIDE)                                                                             
 1144   5 *                       ELSE                                                                                              
 1145   6 *                          EXECUTE (SET_NARROW)                                                                           
 1146   5 *                       ENDIF                                                                                             
 1147   5 *                       EXECUTE (OK_RETURN)                                                                               
 1148   4 *                    ENDIF                                                                                                
 1149   3 *                 ENDIF                                                                                                   
 1150   3 *                 EXECUTE (ERROR)                                                                                         
 1151   2 *              ENDIF                                                                                                      
 1152   1 *           ENDIF                                                                                                         
 1153       C                                       C                                                                               
 1154       C                                       C***   Check for EXIT                                                           
 1155       C                                       C                                                                               
 1156   1 *           IF (I .LE. 4)                                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   31


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1157   2 *              IF (LINE(:I) .EQ. EXIT(:I))                                                                                
 1158   3                   DONE = .TRUE.                                                                                           
 1159   3                   RETURN                                                                                                  
              <--------------                                                                                                       
 1160   2 *              ENDIF                                                                                                      
 1161       C                                       C                                                                               
 1162       C                                       C***   Check for HELP                                                           
 1163       C                                       C                                                                               
 1164   2 *              IF (LINE(:I) .EQ. HELP(:I))                                                                                
 1165       C                                       C                                                                               
 1166       C                                       C---   Open help file                                                           
 1167       C                                       C                                                                               
 1168   3                   CALL LBR$INI_CONTROL(J,1)                                                                               
 1169   3 *                 IF (IMAGE .EQ. '{')                                                                                     
 1170   4                      GETLIS(2) = %LOC(IMAGE)                                                                              
 1171   4                      GETLIS(3) = %LOC(K)                                                                                  
 1172   4                      CALL SYS$GETJPI(,,,GETLIS,,,)                                                                        
 1173   4                      L = INDEX(IMAGE,']')                                                                                 
 1174   4 *                    IF (L .EQ. 0)                                                                                        
 1175   5                         IMAGE = 'LOOK.HLB'                                                                                
 1176   4 *                    ELSE                                                                                                 
 1177   5                         IMAGE = IMAGE(:L)//'LOOK.HLB'                                                                     
 1178   4 *                    ENDIF                                                                                                
 1179   3 *                 ENDIF                                                                                                   
 1180   3 *                 IF (.NOT.LBR$OPEN(J,IMAGE))                                                                             
 1181   4                      CALL LIB$PUT_OUTPUT('***   COULD NOT OPEN HELP LIBRARY')                                             
 1182   4                      DONE = .FALSE.                                                                                       
 1183   4                      RETURN                                                                                               
              <-----------------                                                                                                    
 1184   3 *                 ENDIF                                                                                                   
 1185       C                                       C                                                                               
 1186       C                                       C---   Output message, close file                                               
 1187       C                                       C                                                                               
 1188   3                   K = INDEX(LINE(I+1:),'*') + I + 1                                                                       
 1189   3 *                 IF (K .NE. (I + 1))                                                                                     
 1190   4                      LINE = 'ASTERISK '//LINE(K:)                                                                         
 1191   3 *                 ELSE                                                                                                    
 1192   4                      K = INDEX(LINE(I+1:),'%') + I + 1                                                                    
 1193   4 *                    IF (K .NE. (I + 1))                                                                                  
 1194   5                         LINE = 'PERCENT '//LINE(K:)                                                                       
 1195   4 *                    ELSE                                                                                                 
 1196   5                         K = INDEX(LINE(I+1:),'!') + I + 1                                                                 
 1197   5 *                       IF (K .NE. (I + 1))                                                                               
 1198   6                            LINE = 'EXCLAMATION '//LINE(K:)                                                                
 1199   5 *                       ELSE                                                                                              
 1200   6                            K = LIB$SKPC(' ',LINE(I+1:)) + I                                                               
 1201   6 *                          IF (I .EQ. K)                                                                                  
 1202   7                               LINE = 'INFO'                                                                               
 1203   6 *                          ELSE                                                                                           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   32


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1204   7                               LINE = LINE(K:)                                                                             
 1205   6 *                          ENDIF                                                                                          
 1206   5 *                       ENDIF                                                                                             
 1207   4 *                    ENDIF                                                                                                
 1208   3 *                 ENDIF                                                                                                   
 1209   3                   CALL STR$TRIM(LINE,LINE,I)                                                                              
 1210   3                   K = INDEX(LINE,' ') - 1                                                                                 
 1211   3 *                 IF (K .EQ. I) THEN                                                                                      
 1212   4                      CALL LBR$GET_HELP(J,,,,LINE)                                                                         
 1213   3 *                 ELSE                                                                                                    
 1214   4                      I = LIB$SKPC(' ',LINE(K+1:)) + K                                                                     
 1215   4                      CALL LBR$GET_HELP(J,,,,LINE(:K),LINE(I:))                                                            
 1216   3 *                 ENDIF                                                                                                   
 1217   3                   CALL LBR$CLOSE(J)                                                                                       
 1218   3 *                 EXECUTE (OK_RETURN)                                                                                     
 1219   2 *              ENDIF                                                                                                      
 1220       C                                       C                                                                               
 1221       C                                       C***   Check for show                                                           
 1222       C                                       C                                                                               
 1223   2 *              IF (LINE(:I) .EQ. SHOW(:I))                                                                                
 1224   3                   J = LIB$SKPC(' ',LINE(I+1:)) + I                                                                        
 1225   3 *                 IF (LINE(J+1:) .NE. ' ')                                                                                
 1226   4 *                    EXECUTE (ERROR)                                                                                      
 1227   3 *                 ENDIF                                                                                                   
 1228   3 *                 IF (J .EQ. I)                                                                                           
                              +-----------------------------------------------------------------------------------------------------
 1229   4 *                   |DO FOR ISYM=1,NDEFS                                                                                  
 1230   5 *                   |   EXECUTE (SHOW_SYMBOL)                                                                             
 1231   4 *                   |END DO FOR                                                                                           
                              +-----------------------------------------------------------------------------------------------------
 1232   4 *                    EXECUTE (OK_RETURN)                                                                                  
 1233   3 *                 ELSE                                                                                                    
                              +-----------------------------------------------------------------------------------------------------
 1234   4 *                   |DO FOR ISYM=1,NDEFS                                                                                  
 1235   5 *                   |   IF (LINE(J:J) .EQ. SYMS(ISYM))                                                                    
 1236   6 *                   |      EXECUTE (SHOW_SYMBOL)                                                                          
 1237   6 *                   |      EXECUTE (OK_RETURN)                                                                            
 1238   5 *                   |   ENDIF                                                                                             
 1239   4 *                   |END DO FOR                                                                                           
                              +-----------------------------------------------------------------------------------------------------
 1240   4 *                    EXECUTE (ERROR)                                                                                      
 1241   3 *                 ENDIF                                                                                                   
 1242   2 *              ENDIF                                                                                                      
 1243       C                                       C                                                                               
 1244       C                                       C***   Check for read                                                           
 1245       C                                       C                                                                               
 1246   2 *              IF (LINE(:I) .EQ. READ(:I))                                                                                
 1247   3 *                 IF (BRDCNT .EQ. 0)                                                                                      
 1248   4                      CALL LIB$PUT_OUTPUT(CRLF//'No broadcast messages have '                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   33


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1249            1                   //'been received.'//CRLF)                                                                      
 1250   3 *                 ELSE                                                                                                    
 1251   4                      CALL LIB$PUT_OUTPUT(CRLF//'The following messages '//                                                
 1252            1                   'have been received:')                                                                         
 1253   4 *                    IF (BRDCNT .LE. 20)                                                                                  
 1254   5                         J = BRDCNT                                                                                        
 1255   4 *                    ELSE                                                                                                 
 1256   5                         J = 20                                                                                            
 1257   4 *                    ENDIF                                                                                                
                              +-----------------------------------------------------------------------------------------------------
 1258   4 *                   |DO FOR I=1,J                                                                                         
 1259       C                 |                     C                                                                               
 1260       C                 |                     C---   Remove bells from message                                                
 1261       C                 |                     C                                                                               
                              |  +--------------------------------------------------------------------------------------------------
 1262   5 *                   |  |DO FOREVER                                                                                        
 1263   6                     |  |   K = INDEX(BRDMSG(I)(:BRDLEN(I)),CHAR(7))                                                       
 1264   6 *                   |  |   UNDO IF (K .EQ. 0)                                                                             
                              |  <----                                                                                              
 1265   6                     |  |   BRDMSG(I) = BRDMSG(I)(:K-1)//BRDMSG(I)(K+1:)                                                   
 1266   6                     |  |   BRDLEN(I) = BRDLEN(I) - 1                                                                      
 1267   5 *                   |  |END DO FOREVER                                                                                    
                              |  +--------------------------------------------------------------------------------------------------
 1268       C                 |                     C                                                                               
 1269       C                 |                     C---   Output message                                                           
 1270       C                 |                     C                                                                               
 1271   5                     |   CALL LIB$PUT_OUTPUT(BRDMSG(I)(:BRDLEN(I)))                                                        
 1272   4 *                   |END DO FOR                                                                                           
                              +-----------------------------------------------------------------------------------------------------
 1273   4 *                    IF (BRDCNT .GT. 20)                                                                                  
 1274   5                         CALL LIB$PUT_OUTPUT(CRLF//                                                                        
 1275            1                      'There were too many messages!  The buffer over-'                                           
 1276            2                      //'flowed, there were un-seen messages'//CRLF)                                              
 1277   4 *                    ELSE                                                                                                 
 1278   5                         CALL LIB$PUT_OUTPUT(CRLF)                                                                         
 1279   4 *                    ENDIF                                                                                                
 1280   4                      BRDCNT = 0                                                                                           
 1281   3 *                 ENDIF                                                                                                   
 1282   3                   BRDFLG = .FALSE.                                                                                        
 1283   3 *                 EXECUTE (OK_RETURN)                                                                                     
 1284   2 *              ENDIF                                                                                                      
 1285   1 *           ENDIF                                                                                                         
 1286       C                                       C                                                                               
 1287       C                                       C***  SPAWN?                                                                    
 1288       C                                       C                                                                               
 1289   1 *           IF (I .LE. 5)                                                                                                 
 1290   2 *              IF (SPAWN(:I) .EQ. LINE(:I))                                                                               
 1291   3                   IF (.NOT.TTSPAWN()) CALL LIB$PUT_OUTPUT                                                                 
 1292            1                ('Unable to spawn sub-process')                                                                   
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   34


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1293   3 *                 EXECUTE (OK_RETURN)                                                                                     
 1294   2 *              ENDIF                                                                                                      
 1295   1 *           ENDIF                                                                                                         
 1296       C                                       C                                                                               
 1297       C                                       C***   DEFINE?                                                                  
 1298       C                                       C                                                                               
 1299   1 *           IF (I .LE. 6)                                                                                                 
 1300   2 *              IF (DEFINE(:I) .EQ. LINE(:I))                                                                              
 1301   3                   J = LIB$SKPC(' ',LINE(I+1:)) + I                                                                        
 1302   3 *                 IF (J .EQ. I)                                                                                           
 1303   4 *                    EXECUTE (ERROR)                                                                                      
 1304   3 *                 ENDIF                                                                                                   
 1305   3                   LINE = LINE(J:)                                                                                         
 1306   3                   CALL STR$TRIM(LINE,LINE,LENGTH)                                                                         
 1307   3                   I = INDEX(LINE,':=') - 1                                                                                
 1308   3                   J = INDEX(LINE,'"') - 1                                                                                 
 1309   3                   K = INDEX(LINE,'''') - 1                                                                                
 1310   3 *                 IF (I .LT. 1 .OR. (J .LT. I .AND. J .GE. 0) .OR. (K .LT. I                                              
 1311            1                .AND. K .GE. 0))                                                                                  
 1312       C                                       C                                                                               
 1313       C                                       C---   If no := then error                                                      
 1314       C                                       C                                                                               
 1315   4 *                    EXECUTE (ERROR)                                                                                      
 1316   3 *                 ENDIF                                                                                                   
 1317       C                                       C                                                                               
 1318       C                                       C---   Make sure that it is definable                                           
 1319       C                                       C                                                                               
 1320   3                   OKFLAG = .FALSE.                                                                                        
                           +--------------------------------------------------------------------------------------------------------
 1321   3 *                |DO FOR L=1,NUMALL                                                                                       
 1322   4                  |   IF (LINE(1:1) .EQ. ALLSYM(L)) OKFLAG = .TRUE.                                                        
 1323   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 1324   3 *                 IF (OKFLAG)                                                                                             
 1325   4 *                    EXECUTE (DEFINE_SYMBOL)                                                                              
 1326   4 *                    EXECUTE (OK_RETURN)                                                                                  
 1327   3 *                 ELSE                                                                                                    
 1328   4 *                    EXECUTE (ERROR)                                                                                      
 1329   3 *                 ENDIF                                                                                                   
 1330   2 *              ENDIF                                                                                                      
 1331   1 *           ENDIF                                                                                                         
 1332       C                                       C                                                                               
 1333       C                                       C***   Check for @                                                              
 1334       C                                       C                                                                               
 1335   1 *           IF (LINE(1:1) .EQ. '@')                                                                                       
 1336   2                OPEN (UNIT=30,NAME=LINE(2:I),TYPE='OLD',ERR=700,READONLY)                                                  
 1337   2                CALL DODEF                                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   35


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                        +-----------------------------------------------------------------------------------------------------------
 1338   2 *             |DO LABEL                                                                                                   
 1339   3 *             |   LABEL 700                                                                                               
 1340   4               |      I = INDEX(LINE,' ') - 1                                                                              
 1341   4               |      CALL LIB$PUT_OUTPUT('***   UNABLE TO OPEN '//LINE(:I))                                               
 1342   2 *             |END DO LABEL                                                                                               
                        +-----------------------------------------------------------------------------------------------------------
 1343   2 *              EXECUTE (OK_RETURN)                                                                                        
 1344   1 *           ENDIF                                                                                                         
 1345   1 *           EXECUTE (ERROR)                                                                                               
 1346     *        ENDIF                                                                                                            
 1347              DONE = .FALSE.                                                                                                   
 1348              RETURN                                                                                                           
              <-----                                                                                                                
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   36


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1349     *        PROCEDURE (DEFINE_SYMBOL)                                                                                        
 1350       C                                       CP    This procedure defines a symbol.                                          
 1351       C                                       C                                                                               
 1352       C                                       C***   See if symbol is already defined                                         
 1353       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 1354   1 * 900      |DO                                                                                                            
                     |  +-----------------------------------------------------------------------------------------------------------
 1355   2 *          |  |DO FOR II=1,NDEFS                                                                                          
 1356   3 *          |  |   UNDO 900 IF (SYMS(II) .EQ. LINE(1:1))                                                                   
                     <-------                                                                                                       
 1357   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 1358   2            |   NDEFS = NDEFS + 1                                                                                          
 1359   2            |   II = NDEFS                                                                                                 
 1360   2            |   SYMS(II) = LINE(1:1)                                                                                       
 1361   1 *          |END DO                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
 1362   1             LINE = LINE(I+3:)                                                                                             
 1363   1             LENGTH = LENGTH - I - 2                                                                                       
 1364       C                                       C                                                                               
 1365       C                                       C***   Actually get definitions                                                 
 1366       C                                       C                                                                               
 1367   1 *           IF (.NOT.GETDEF(LINE(:LENGTH),II))                                                                            
 1368   2 *              EXECUTE (ERROR)                                                                                            
 1369   1 *           ENDIF                                                                                                         
 1370     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   37


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1371     *        PROCEDURE (ERROR)                                                                                                
 1372       C                                       CP    This writes an error message                                              
 1373   1             CALL STR$TRIM(LINE,LINE,I)                                                                                    
 1374   1             IF (I .NE. 0) CALL LIB$PUT_OUTPUT(LINE(:I)//' ??')                                                            
 1375   1             DONE = .FALSE.                                                                                                
 1376   1             RETURN                                                                                                        
              <--------                                                                                                             
 1377     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   38


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1378     *        PROCEDURE (OK_RETURN)                                                                                            
 1379       C                                       CP    This procedure sets DONE to false and returns.                            
 1380   1             DONE = .FALSE.                                                                                                
 1381   1             RETURN                                                                                                        
              <--------                                                                                                             
 1382     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   39


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1383     *        PROCEDURE (SET_NARROW)                                                                                           
 1384       C                                       CP    This procedure sets the terminal to 80 column mode.                       
 1385   1             LENLMT = 80*LENLMT/IABS(LENLMT)                                                                               
 1386   1             CALL SETNAR(INCHAN)                                                                                           
 1387   1 *           IF (.NOT.VT100A)                                                                                              
 1388   2                COMLIN = 24                                                                                                
 1389   2                PAGLEN = PAGLEN + 10                                                                                       
 1390   1 *           ENDIF                                                                                                         
 1391     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   40


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1392     *        PROCEDURE (SET_WIDE)                                                                                             
 1393       C                                       CP    This procedure sets the terminal to 132 column mode.                      
 1394   1             LENLMT = 132*LENLMT/IABS(LENLMT)                                                                              
 1395   1             CALL SETWID(INCHAN)                                                                                           
 1396   1 *           IF (.NOT.VT100A)                                                                                              
 1397   2                COMLIN = 14                                                                                                
 1398   2                PAGLEN = PAGLEN - 10                                                                                       
 1399   1 *           ENDIF                                                                                                         
 1400     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   41


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1401     *        PROCEDURE (SHOW_SYMBOL)                                                                                          
 1402       C                                       CP    This procedure writes out the definition for one symbol                   
 1403   1             LINE = SYMS(ISYM)//' := '                                                                                     
 1404   1             L = 6                                                                                                         
                     +--------------------------------------------------------------------------------------------------------------
 1405   1 *          |DO FOR K=1,10                                                                                                 
 1406   2 *          |   UNDO IF (DEFS(1,K,ISYM) .EQ. 0)                                                                            
                     <----                                                                                                          
 1407       C        |                              C                                                                               
 1408       C        |                              C***   Convert the number                                                       
 1409       C        |                              C                                                                               
 1410   2 *          |   IF (DEFFLG(1,K,ISYM))                                                                                      
 1411   3            |      WRITE (UNIT=LINE(L:),FMT=1000)NUMDEF(K,ISYM)                                                            
 1412   3   1000     |      FORMAT (F10.3)                                                                                          
 1413   3            |      M = LIB$SKPC(' ',LINE(L:))                                                                              
 1414   3            |      LINE(L:) = LINE(L+M-1:)                                                                                 
 1415   3            |      L = 11 + L - M                                                                                          
 1416   3            |      IF (LINE(L-3:L-1) .EQ. '000') L = L - 4                                                                 
 1417   2 *          |   ENDIF                                                                                                      
 1418       C        |                              C                                                                               
 1419       C        |                              C***   Is it --&?                                                               
 1420       C        |                              C                                                                               
 1421   2 *          |   IF (DEFS(1,K,ISYM) .EQ. 9)                                                                                 
 1422   3            |      LINE(L:) = '--& '                                                                                       
 1423   3            |      L = L + 4                                                                                               
 1424   3 *          |      CYCLE                                                                                                   
                     |<------                                                                                                       
 1425   2 *          |   ENDIF                                                                                                      
 1426       C        |                              C                                                                               
 1427       C        |                              C***   Set minus if necessary                                                   
 1428       C        |                              C                                                                               
 1429   2 *          |   IF (DEFFLG(2,K,ISYM))                                                                                      
 1430   3            |      LINE(L:) = '-'                                                                                          
 1431   3            |      L = L + 1                                                                                               
 1432   2 *          |   ENDIF                                                                                                      
 1433       C        |                              C                                                                               
 1434       C        |                              C***   Search?                                                                  
 1435       C        |                              C                                                                               
 1436   2 *          |   IF (DEFS(1,K,ISYM) .EQ. 3)                                                                                 
 1437   3 *          |      IF (DEFFLG(3,K,ISYM))                                                                                   
 1438   4            |         LINE(L:) = '"'//DEFBUF(1,K,ISYM)(:DEFS(2,K,ISYM))                                                    
 1439   4            |         KK = L                                                                                               
 1440   4            |         L = L + 3 + DEFS(2,K,ISYM)                                                                           
                     |        +-----------------------------------------------------------------------------------------------------
 1441   4 *          |        |DO FOREVER                                                                                           
 1442   5            |        |   LL = INDEX(LINE(KK+1:),'"') + KK                                                                  
 1443   5 *          |        |   UNDO IF (LL .EQ. KK)                                                                              
                     |        <----                                                                                                 
 1444   5            |        |   LINE(LL:) = '"'//LINE(LL:)                                                                        
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   42


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1445   5            |        |   L = L + 1                                                                                         
 1446   5            |        |   KK = LL + 2                                                                                       
 1447   4 *          |        |END DO FOREVER                                                                                       
                     |        +-----------------------------------------------------------------------------------------------------
 1448   4            |         LINE(L-2:L-2) = '"'                                                                                  
                     |        +-----------------------------------------------------------------------------------------------------
 1449   4 *          |        |DO FOR JJ=2,10                                                                                       
 1450   5 *          |        |   UNDO IF (DEFS(1+JJ,K,ISYM) .EQ. 0)                                                                
                     |        <----                                                                                                 
 1451   5            |        |   LINE(L:) = ''''//DEFBUF(JJ,K,ISYM)(:DEFS(1+JJ,K,ISYM))                                            
 1452   5            |        |   KK = L                                                                                            
 1453   5            |        |   L = L + 3 + DEFS(1+JJ,K,ISYM)                                                                     
                     |        |  +--------------------------------------------------------------------------------------------------
 1454   5 *          |        |  |DO FOREVER                                                                                        
 1455   6            |        |  |   LL = INDEX(LINE(KK+1:),'''') + KK                                                              
 1456   6 *          |        |  |   UNDO IF (LL .EQ. KK)                                                                           
                     |        |  <----                                                                                              
 1457   6            |        |  |   LINE(LL:) = ''''//LINE(LL:)                                                                    
 1458   6            |        |  |   L = L + 1                                                                                      
 1459   6            |        |  |   KK = LL + 2                                                                                    
 1460   5 *          |        |  |END DO FOREVER                                                                                    
                     |        |  +--------------------------------------------------------------------------------------------------
 1461   5            |        |   LINE(L-2:L-2) = ''''                                                                              
 1462   4 *          |        |END DO FOR                                                                                           
                     |        +-----------------------------------------------------------------------------------------------------
 1463   4            |         LINE(L-1:) = '^'                                                                                     
 1464   4            |         L = L + 1                                                                                            
 1465   3 *          |      ELSE                                                                                                    
 1466   4            |         LINE(L:) = '^ '                                                                                      
 1467   4            |         L = L + 2                                                                                            
 1468   3 *          |      ENDIF                                                                                                   
 1469   3 *          |      CYCLE                                                                                                   
                     |<------                                                                                                       
 1470   2 *          |   ENDIF                                                                                                      
 1471       C        |                              C                                                                               
 1472       C        |                              C***   Set LINE                                                                 
 1473       C        |                              C                                                                               
                     |  +-----------------------------------------------------------------------------------------------------------
 1474   2 *          |  |DO FOR M=1,NUMCOM                                                                                          
 1475   3 *          |  |   IF (DEFS(1,K,ISYM) .EQ. M)                                                                              
 1476   4            |  |      LINE(L:) = COMAND(M)                                                                                 
 1477   4            |  |      L = L + 2                                                                                            
 1478   4 *          |  |      UNDO                                                                                                 
                     |  <-------                                                                                                    
 1479   3 *          |  |   ENDIF                                                                                                   
 1480   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 1481   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   43


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1482       C                                       C                                                                               
 1483       C                                       C***   Output line                                                              
 1484       C                                       C                                                                               
 1485   1             M = 1                                                                                                         
 1486   1             L = L - 1                                                                                                     
                     +--------------------------------------------------------------------------------------------------------------
 1487   1 *          |DO FOREVER                                                                                                    
 1488   2 *          |   IF ((L - M) .LT. IABS(LENLMT))                                                                             
 1489   3            |      CALL LIB$PUT_OUTPUT(LINE(M:L-1))                                                                        
 1490   3 *          |      UNDO                                                                                                    
                     <-------                                                                                                       
 1491   2 *          |   ELSE                                                                                                       
 1492   3            |      CALL LIB$PUT_OUTPUT(LINE(M:M+IABS(LENLMT)-1))                                                           
 1493   2 *          |   ENDIF                                                                                                      
 1494   2            |   M = M + IABS(LENLMT)                                                                                       
 1495   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 1496     *        END PROCEDURE                                                                                                    
 1497              END                                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        COMLVL                30-SEP-83      08:30:11      PAGE   44


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 1349  DEFINE_SYMBOL                  
                               1325 

 1371  ERROR                          
                               1056  1083  1150  1226  1240  1303  1315  1328  1345  1368 

 1378  OK_RETURN                      
                               1108  1123  1134  1147  1218  1232  1237  1283  1293  1326  1343 

 1383  SET_NARROW                     
                               1130  1145 

 1392  SET_WIDE                       
                               1132  1143 

 1401  SHOW_SYMBOL                    
                               1230  1236 

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DODEF                 30-SEP-83      08:30:11      PAGE   45


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1498              SUBROUTINE DODEF                                                                                                 
 1499       C                                       CDM   This routine processes the file open on unit 30 as a "symbol" file.       
 1500       C                                       CDM                                                                             
 1501       C                                       CDM   Programmer - Jon Vavrus  15 JUL 1982                                      
 1502       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
 1503       C                                       CDM   Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                     
 1504       C                                       CDM   Revised    - Jon Vavrus  21 SEP 1983                                      
 1505       C                                       CM                                                                              
 1506       C                                       CM         The routine reads unit 30.  Each line is tested for:                 
 1507       C                                       CM              s :=     which is taken as a symbol definition                  
 1508       C                                       CM              {    }   which is taken as a "command" level command line       
 1509       C                                       CM              or anything else which is taken as a command line.              
 1510       C                                       C                                                                               
 1511       C                                       C***   COMMON AREAS                                                             
 1512       C                                       C                                                                               
 1513       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
 1514       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
 1515       C                                       C                                                                               
 1516       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
 1517       C                                       CS            symbol definitions DEFS, the number of such definitions           
 1518       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
 1519       C                                       CS            numbers NUMDEF                                                    
 1520       C                                       C                                                                               
 1521       C                                       C***   CALLED ROUTINES                                                          
 1522       C                                       C                                                                               
 1523       C                                       CC    DOIT    Executes a command.                                               
 1524       C                                       CC    GETDEF  Translates a line into a symbol definition                        
 1525       C                                       CC    PRSCOM  Parses a command line                                             
 1526       C                                       C                                                                               
 1527              CHARACTER*1024 LINE                                                                                              
 1528              CHARACTER*128 INLINE                                                                                             
 1529              CHARACTER*30 DEFBUF(10,10,60)                                                                                    
 1530              CHARACTER*1 SYMS(60)                                                                                             
 1531              REAL*4 NUMDEF(10,60)                                                                                             
 1532              INTEGER*2 DEFS(11,10,60),LENSAV                                                                                  
 1533              LOGICAL GETDEF                                                                                                   
 1534              LOGICAL*1 DEFFLG(3,10,60)                                                                                        
 1535                                                                                                                               
 1536              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
 1537              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
 1538                                                                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 1539     * 600   |DO FOREVER                                                                                                       
 1540   1         |   READ (30,700,END=800)LINE                                                                                     
 1541   1   700   |   FORMAT (A)                                                                                                    
                  |  +--------------------------------------------------------------------------------------------------------------
 1542   1 *       |  |DO LABEL                                                                                                      
 1543   2 *       |  |   LABEL 800                                                                                                  
 1544   3 *       |  |      UNDO 600                                                                                                
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DODEF                 30-SEP-83      08:30:11      PAGE   46


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                  <----------                                                                                                       
 1545   1 *       |  |END DO LABEL                                                                                                  
                  |  +--------------------------------------------------------------------------------------------------------------
 1546   1         |   CALL STR$UPCASE(LINE,LINE)                                                                                    
 1547   1         |   CALL STR$TRANSLATE(LINE,LINE,' ','	')                                                                         
 1548   1         |   CALL STR$TRIM(LINE,LINE,LENBUF)                                                                               
 1549   1         |   I = INDEX(LINE(:LENBUF),':=') - 1                                                                             
 1550   1         |   J = INDEX(LINE(:LENBUF),'"') - 1                                                                              
 1551   1         |   K = INDEX(LINE(:LENBUF),'''') - 1                                                                             
 1552   1 *       |   IF (I .LT. 1 .OR. (J .LT. I .AND. J .GE. 0) .OR. (K .LT. I .AND.                                              
 1553            1|         K .GE. 0))                                                                                              
 1554       C     |                                 C                                                                               
 1555       C     |                                 C***   If no := then it must be a command line, or a " in front of :=           
 1556       C     |                                 C***   (this must mean a command line with a search, or the user screwed up)    
 1557       C     |                                 C                                                                               
 1558       C     |                                 C---   First test for { }                                                       
 1559       C     |                                 C                                                                               
 1560   2         |      I = INDEX(LINE(:LENBUF),'{') + 1                                                                           
 1561   2 *       |      IF (I .EQ. 1 .OR. (J .LT. I .AND. J .GE. 0))                                                               
                  |        +--------------------------------------------------------------------------------------------------------
 1562   3 *       |        |DO FOREVER                                                                                              
 1563   4         |        |   CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,0,0)                                                
 1564   4 *       |        |   UNDO IF (ICOM .EQ. 0)                                                                                
                  |        <----                                                                                                    
 1565   4         |        |   CALL DOIT(ICOM,NUMFLG,ANUMB,MINFLG)                                                                  
 1566   3 *       |        |END DO FOREVER                                                                                          
                  |        +--------------------------------------------------------------------------------------------------------
 1567   2 *       |      ELSE                                                                                                       
                  |        +--------------------------------------------------------------------------------------------------------
 1568   3 *       |        |DO FOR J=LENBUF,I,-1                                                                                    
 1569   4 *       |        |   UNDO IF (LINE(J:J) .EQ. '}')                                                                         
                  |        <----                                                                                                    
 1570   3 *       |        |END DO FOR                                                                                              
                  |        +--------------------------------------------------------------------------------------------------------
 1571   3 *       |         IF (J .GT. I)                                                                                           
 1572   4         |            CALL COMLVL(LINE(I:J-1),I)                                                                           
 1573   4         |            CALL DOIT(-1,.TRUE.,0.,.FALSE.)                                                                      
 1574   4         |            CALL DOIT(-12,.FALSE.,0.,.FALSE.)                                                                    
 1575   3 *       |         ENDIF                                                                                                   
 1576   2 *       |      ENDIF                                                                                                      
 1577   1 *       |   ELSE                                                                                                          
                  |     +-----------------------------------------------------------------------------------------------------------
 1578   2 *       |     |DO FOREVER                                                                                                 
 1579       C     |     |                           C                                                                               
 1580       C     |     |                           C***   Take care of continuations                                               
 1581       C     |     |                           C                                                                               
 1582   3 *       |     |   UNDO IF (LINE(LENBUF:LENBUF) .NE. '-')                                                                  
                  |     <----                                                                                                       
 1583   3         |     |   READ (30,700,END=800)LINE(LENBUF:)                                                                      
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DODEF                 30-SEP-83      08:30:11      PAGE   47


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1584   3         |     |   CALL STR$UPCASE(LINE,LINE)                                                                              
 1585   3         |     |   CALL STR$TRANSLATE(LINE,LINE,' ','	')                                                                   
 1586   3         |     |   CALL STR$TRIM(LINE,LINE,LENBUF)                                                                         
 1587   2 *       |     |END DO FOREVER                                                                                             
                  |     +-----------------------------------------------------------------------------------------------------------
 1588   2         |      J = LIB$SKPC(' ',LINE(:LENBUF))                                                                            
 1589       C     |                                 C                                                                               
 1590       C     |                                 C***   See if symbol is already defined                                         
 1591       C     |                                 C                                                                               
                  |     +-----------------------------------------------------------------------------------------------------------
 1592   2 * 900   |     |DO                                                                                                         
                  |     |  +--------------------------------------------------------------------------------------------------------
 1593   3 *       |     |  |DO FOR II=1,NDEFS                                                                                       
 1594   4 *       |     |  |   UNDO 900 IF (SYMS(II) .EQ. LINE(J:J))                                                                
                  |     <-------                                                                                                    
 1595   3 *       |     |  |END DO FOR                                                                                              
                  |     |  +--------------------------------------------------------------------------------------------------------
 1596   3         |     |   NDEFS = NDEFS + 1                                                                                       
 1597   3         |     |   II = NDEFS                                                                                              
 1598   3         |     |   SYMS(II) = LINE(J:J)                                                                                    
 1599   2 *       |     |END DO                                                                                                     
                  |     +-----------------------------------------------------------------------------------------------------------
 1600   2         |      LINE = LINE(I+3:)                                                                                          
 1601   2         |      LENBUF = LENBUF - I - 2                                                                                    
 1602       C     |                                 C                                                                               
 1603       C     |                                 C***   Actually get definitions                                                 
 1604       C     |                                 C                                                                               
 1605   2 *       |      CYCLE IF (.NOT.GETDEF(LINE(:LENBUF),II))                                                                   
                  |<------                                                                                                          
 1606   1 *       |   ENDIF                                                                                                         
 1607     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
 1608       C                                       C                                                                               
 1609       C                                       C***   Close the symbol file                                                    
 1610       C                                       C                                                                               
 1611              CLOSE (UNIT=30)                                                                                                  
 1612              RETURN                                                                                                           
              <-----                                                                                                                
 1613              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   48


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1614              SUBROUTINE DOIT(COMAND,NUMFLG,TANUMB,MINFLG)                                                                     
 1615       C                                       CDM   This subroutine executes the commands passed by the main program or       
 1616       C                                       CDM   rings the terminal bell and turns LED 3 on (error signal) if the          
 1617       C                                       CDM   command is invalid.                                                       
 1618       C                                       CDM                                                                             
 1619       C                                       CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
 1620       C                                       CDM   Revised    - Jon Vavrus  30 MAR 1981                                      
 1621       C                                       CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
 1622       C                                       CDM   Revised    - Jon Vavrus  21 JUL 1981                                      
 1623       C                                       CDM   Revised    - Jon Vavrus  31 JUL 1981 (change CCLINE usage)                
 1624       C                                       CDM   Revised    - Jon Vavrus  27 AUG 1981                                      
 1625       C                                       CDM   Revised    - Jon Vavrus  10 SEP 1981                                      
 1626       C                                       CDM   Revised    - Jon Vavrus  23 SEP 1981                                      
 1627       C                                       CDM   Revised    - Jon Vavrus   6 NOV 1981                                      
 1628       C                                       CDM   Revised    - Jon Vavrus  30 DEC 1981 (make LED's work right)              
 1629       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
 1630       C                                       CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
 1631       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
 1632       C                                       CDM   Revised    - Jon Vavrus  30 NOV 1982                                      
 1633       C                                       CDM   Revised    - Jon Vavrus  12 JAN 1983                                      
 1634       C                                       CDM   Revised    - Jon Vavrus   4 APR 1983 (Take care of "Quitting")            
 1635       C                                       CM                                                                              
 1636       C                                       CM         The routine is called with the numeric code for the command          
 1637       C                                       CM    (COMAND) which if negative, means that it is not to be "saved" for        
 1638       C                                       CM    possible command #13 execution; a flag set .TRUE. if there is an          
 1639       C                                       CM    associated number (NUMFLG); a number (TANUMB); and a flag set             
 1640       C                                       CM    .TRUE. if there is an associated minus sign.                              
 1641       C                                       CM                                                                              
 1642       C                                       CM         For VT100's the given command is executed after which LED 1 is       
 1643       C                                       CM    turned off (indicating operation finished), LED 3 is turned off           
 1644       C                                       CM    if successful and on if not (error indication), LED 2 is turned           
 1645       C                                       CM    on if the reverse option is currently set or off if not (reverse          
 1646       C                                       CM    indicator), and LED 4 is turned on if the search buffer now contains      
 1647       C                                       CM    something (buffer indicator).                                             
 1648       C                                       CM                                                                              
 1649       C                                       CM         The valid commands types are:                                        
 1650       C                                       CM              1 - jump TANUMB lines (positive or negative)                    
 1651       C                                       CM              2 - jump by TANUMB blocks (positive or negative)                
 1652       C                                       CM              3 - search (forward) for string(s) in SRCHBF array and          
 1653       C                                       CM                  display from that line if found, if not found the           
 1654       C                                       CM                  terminal bell is rung and LED 3 is turned on.  Matches      
 1655       C                                       CM                  are found regardless of lower/uppercase differences.        
 1656       C                                       CM                  Search backward if MINFLG = .TRUE..  Repeat TANUMB          
 1657       C                                       CM                  times if NUMFLG = .TRUE..                                   
 1658       C                                       CM              4 - set reverse switch, all commands will now work in re-       
 1659       C                                       CM                  verse (i.e. n$ will jump -n lines, etc.).  Repeat           
 1660       C                                       CM                  TANUMB times if NUMFLG = .TRUE..                            
 1661       C                                       CM              5 - scroll (backwards if MINFLG = .TRUE.)                       
 1662       C                                       CM              6 - stop scrolling or cancel current line jump, search,         
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   49


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1663       C                                       CM                  or & command.                                               
 1664       C                                       CM              7 - set scrolling speed to TANUMB lines per second (positive    
 1665       C                                       CM                  or negative) (originally set to 2).                         
 1666       C                                       CM                  NOTE:  there is a maximum speed that will not be ex-        
 1667       C                                       CM                  ceeded (varies with situation) even if scrolling            
 1668       C                                       CM                  speed is set at a high value.                               
 1669       C                                       CM              8 - mark the TANUMB line form the top of the screen as one      
 1670       C                                       CM                  of the boundaries of the print range.  The last two so      
 1671       C                                       CM                  marked lines define the print range.                        
 1672       C                                       CM              9 - output TANUMB lines to the file LOOKPRINT.LIS in the        
 1673       C                                       CM                  default directory (file format will be the same as the      
 1674       C                                       CM                  original file, with sequential organization).  Creates      
 1675       C                                       CM                  a new file.  If no number is specified (or is zero)         
 1676       C                                       CM                  and there is a valid print range marked, then that          
 1677       C                                       CM                  range will be output, if no valid print range then          
 1678       C                                       CM                  23 lines are output.                                        
 1679       C                                       CM             10 - same as 9 except the lines are output to SYS$PRINT.         
 1680       C                                       CM                  If MINFLG = .TRUE. then output goes to LOOKPRINT.LIS        
 1681       C                                       CM                  file (new file if no previous command created one           
 1682       C                                       CM                  during this job, otherwise appended to the end of the       
 1683       C                                       CM                  existing file).                                             
 1684       C                                       CM             11 - exit the program.                                           
 1685       C                                       CM             12 - re-write the screen                                         
 1686       C                                       CM             13 - re-execute the last command that was passed to DOIT         
 1687       C                                       CM                  with a positive value (except for 13)                       
 1688       C                                       C                                                                               
 1689       C                                       C***   CALLED ROUTINES                                                          
 1690       C                                       C                                                                               
 1691       C                                       CC    BLKCLS  Closes the input file.                                            
 1692       C                                       CC    BLKIN   Reads in one block of data.                                       
 1693       C                                       CC    BLKSIN  Reads in 7 blocks of data.                                        
 1694       C                                       CC    CONVUP  Converts a string to upper-case.                                  
 1695       C                                       CC    INTASC  Converts a given character variable to upper-case.                
 1696       C                                       CC    LINCON  Converts data to output lines in the output arrays.               
 1697       C                                       CC    PRTCLS  Closes the printer output file used in & commands.                
 1698       C                                       CC    PRTOPN  Opens the printer output file.                                    
 1699       C                                       CC    PRTOUT  Outputs a record to the printer output file.                      
 1700       C                                       CC    REDOIT  Calls DOIT, allows for recursion.                                 
 1701       C                                       CC    STOPSC  AST routine to cause "stop" command to work.                      
 1702       C                                       CC    WORKNG  Writes flashing "WORKING" message.                                
 1703       C                                       C                                                                               
 1704       C                                       C***   COMMON AREAS                                                             
 1705       C                                       C                                                                               
 1706       C                                       CS    CHARS   Used to pass character variables; contains LINES a character      
 1707       C                                       CS            array of the output lines, and SRCHBF the search buffer, and      
 1708       C                                       CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
 1709       C                                       CS            the VT100 control sequences to set/unset reverse video.           
 1710       C                                       C                                                                               
 1711       C                                       CS    DOITNM  Contains information transferred from the main program:           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   50


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1712       C                                       CS                 INCHAN - input channel of the terminal                       
 1713       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 1714       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 1715       C                                       CS                          in the search buffer                                
 1716       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 1717       C                                       CS                 EBK    - EBK of input file                                   
 1718       C                                       CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
 1719       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 1720       C                                       CS                 RANGE  - starting and ending block numbers and pointers      
 1721       C                                       CS                          of print range                                      
 1722       C                                       CS                 VT100  - flag set .TRUE. if terminal is a VT100              
 1723       C                                       CS                 LRL    - length of longest record in input file              
 1724       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 1725       C                                       CS                 PAGEND - line number of last line output to screen.          
 1726       C                                       CS                 PAGLEN - number of lines per page                            
 1727       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 1728       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 1729       C                                       C                                                                               
 1730       C                                       CS    LNCN    Contains output arrays, and file pointers and information:        
 1731       C                                       CS                 LINLEN - array of output line lengths                        
 1732       C                                       CS                 LINEP  - top of screen line (or last line output by          
 1733       C                                       CS                          backward scroll)                                    
 1734       C                                       CS                 NLINES - number of lines in arrays                           
 1735       C                                       CS                 BUFFER - array of unconverted data                           
 1736       C                                       CS                 PBUF   - current position in BUFFER                          
 1737       C                                       CS                 NBUF   - number of bytes in BUFFER                           
 1738       C                                       CS                 BLK    - next block in file                                  
 1739       C                                       CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
 1740       C                                       CS                 IFSZ   - word extended record length for FIX files           
 1741       C                                       CS                 RFM    - files RFM                                           
 1742       C                                       CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
 1743       C                                       CS                 SBLK   - starting block of current batch of output lines     
 1744       C                                       CS                 CCLINE - array containing pointer to where the line's        
 1745       C                                       CS                          record starts in the file (CCLINE(1,x) = block      
 1746       C                                       CS                          #, CCLINE(2,x) = byte number in block).  If         
 1747       C                                       CS                          CCLINE(1,x) = 0 then it is a carriage control       
 1748       C                                       CS                          line.                                               
 1749       C                                       CS                 LBLK   - last block processed by LINCON                      
 1750       C                                       CS                 LPBUF  - last value of PBUF processed by LINCON              
 1751       C                                       C                                                                               
 1752       C                                       CS    STOPCM  Used to pass information back and forth to/from the stop          
 1753       C                                       CS            scrolling AST.  STOPIT is a flag set .TRUE. if scrolling          
 1754       C                                       CS            should be stopped, INBUF is the input character, IOFLAG and       
 1755       C                                       CS            TIMFLG are event flags, and IOSB is the I/O IOSB.                 
 1756       C                                       C                                                                               
 1757       C                                       C***   INPUT VARIABLES                                                          
 1758       C                                       C                                                                               
 1759       C                                       CI    INBUF   One byte buffer used to get stop scrolling command.               
 1760       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   51


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1761       C                                       C***   OUTPUT VARIABLES                                                         
 1762       C                                       C                                                                               
 1763       C                                       CO    BUFFER  Buffer holding input data.  During back scrolling output          
 1764       C                                       CO            is done directly from here.                                       
 1765       C                                       CO    ESC     Used to output an ASCII <ESC>.                                    
 1766       C                                       CO    LINES   Lines of output converted by LINCON.                              
 1767       C                                       C                                                                               
 1768       C                                       C***   INPUT UNITS                                                              
 1769       C                                       C                                                                               
 1770       C                                       CR    INCHAN  Channel number of the terminal.                                   
 1771       C                                       C                                                                               
 1772       C                                       C***   OUTPUT UNITS                                                             
 1773       C                                       C                                                                               
 1774       C                                       CW    9       Output to the terminal (no carriage-control).                     
 1775       C                                       CW    20      Output for the List, Print, and Append commands                   
 1776       C                                       C                                                                               
 1777              EXTERNAL STOPSC                                                                                                  
 1778              CHARACTER*132 LINES(600),HLIN(600),CAPLIN                                                                        
 1779              CHARACTER*33 CHAR                                                                                                
 1780              CHARACTER*30 SRCHBF(10)                                                                                          
 1781              CHARACTER*5 TEMPCH                                                                                               
 1782              CHARACTER*4 REVVID,REGVID                                                                                        
 1783              CHARACTER*2 CRLF                                                                                                 
 1784              INTEGER*4 TIME,BLK,PBUF,EBK,HNBUF,HPBUF,FSZ,RFM,RAT,TIMFLG,                                                      
 1785            1       DELTIM(2),SBLK,PAUSTM(2),PRINT,HBLK,HSBLK,                                                                 
 1786            2       RANGE(2,2),CCLINE(2,600),HLBLK,HLPBUF,HCCLIN(2,600),                                                       
 1787            3       PAGEND,OLDEND,SAVCOM,IDESCR(2),STRPOS(10)                                                                  
 1788              INTEGER*2 IOSB(4),LINLEN(600),HLINLN(600),HLINES,HLINEP,DIRECT,                                                  
 1789            1       SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMAND,COMLIN                                                              
 1790              LOGICAL*1 SBFFLG,INBUF,BUFFER(3750),FIRST,NUMFLG,MINFLG,                                                         
 1791            1       HBUFER(150),STOPIT,ESC,TEMP(30),CAPBUF(3750),VT100,                                                        
 1792            2       BELL,BSP,RFLAG,SECOND,SAVFLG(2),VT100A                                                                     
 1793                                                                                                                               
 1794              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 1795            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 1796              COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,                                                  
 1797            1       RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                                                                             
 1798              COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                                                                    
 1799              COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                                                                   
 1800                                                                                                                               
 1801              DATA ESC,BELL,BSP/27,7,8/                                                                                        
 1802              DATA DELTIM(2)/-1/                                                                                               
 1803              DATA PAUSTM/-30000000,-1/                                                                                        
 1804              DATA OPNFIL/.FALSE./                                                                                             
 1805                                                                                                                               
 1806              ANUMB = TANUMB                                                                                                   
 1807       C                                       C                                                                               
 1808       C                                       C***   Turn LED #1 on                                                           
 1809       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   52


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1810     *        IF (COMAND .NE. 13)                                                                                              
 1811   1 *           EXECUTE (WORKING)                                                                                             
 1812     *        ENDIF                                                                                                            
 1813       C                                       C                                                                               
 1814       C                                       C***   Save command                                                             
 1815       C                                       C                                                                               
 1816     *        IF (COMAND .LT. 0)                                                                                               
 1817   1             ICOM = -COMAND                                                                                                
 1818     *        ELSE                                                                                                             
 1819   1 *           IF (COMAND .NE. 13)                                                                                           
 1820   2                SAVFLG(1) = NUMFLG                                                                                         
 1821   2                SAVFLG(2) = MINFLG                                                                                         
 1822   2                SAVCOM = COMAND                                                                                            
 1823   2                SAVNUM = TANUMB                                                                                            
 1824   1 *           ENDIF                                                                                                         
 1825   1             ICOM = COMAND                                                                                                 
 1826     *        ENDIF                                                                                                            
                  +-----------------------------------------------------------------------------------------------------------------
 1827     *       |DO CASE ICOM                                                                                                     
 1828   1 *       |   CASE 1                                                                                                        
 1829       C     |                                 C                                                                               
 1830       C     |                                 C***   Line jump                                                                
 1831       C     |                                 C                                                                               
 1832   2         |      NUMBER = ANUMB*DIRECT                                                                                      
 1833   2 *       |      IF (.NOT.NUMFLG)                                                                                           
 1834   3 *       |         EXECUTE (ERROR_EXIT)                                                                                    
 1835   2 *       |      ENDIF                                                                                                      
 1836   2 *       |      EXECUTE (HOLD_CURRENT_SETUP)                                                                               
 1837       C     |                                 C                                                                               
 1838       C     |                                 C***   Execute line jumps                                                       
 1839       C     |                                 C                                                                               
 1840   2 *       |      EXECUTE (JUMP_LINES)                                                                                       
 1841   2 *       |      EXECUTE (GET_LAST_LINE)                                                                                    
 1842   2 *       |      EXECUTE (CANCEL_STOPPER)                                                                                   
 1843   2 *       |      IF (IABS(NUMBER) .LE. PAGLEN)                                                                              
 1844   3 *       |         EXECUTE (SCROLL_REFRESH_EXIT)                                                                           
 1845   2 *       |      ELSE                                                                                                       
 1846   3 *       |         EXECUTE (REFRESH_EXIT)                                                                                  
 1847   2 *       |      ENDIF                                                                                                      
 1848   1 *       |   CASE 2                                                                                                        
 1849       C     |                                 C                                                                               
 1850       C     |                                 C***   Block jumps                                                              
 1851       C     |                                 C                                                                               
 1852   2 *       |      IF (.NOT.NUMFLG)                                                                                           
 1853   3 *       |         EXECUTE (ERROR_EXIT)                                                                                    
 1854   2 *       |      ENDIF                                                                                                      
 1855   2 *       |      EXECUTE (FIND_NON_CC_LINE)                                                                                 
 1856   2         |      BLK = CCLINE(1,I) + ANUMB*DIRECT                                                                           
 1857   2         |      IF (BLK .LE. 0) BLK = 1                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   53


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1858   2         |      IF (BLK .GT. EBK) BLK = EBK                                                                                
 1859   2         |      IBLK = BLK                                                                                                 
 1860   2 *       |      EXECUTE (INPUT_SEVEN_BLOCKS)                                                                               
 1861   2         |      CALL LINCON(.TRUE.)                                                                                        
 1862       C     |                                 C                                                                               
 1863       C     |                                 C***   If input was at end of file, must find line position                     
 1864       C     |                                 C                                                                               
 1865   2 *       |      IF (BLK .GT. EBK)                                                                                          
                  |        +--------------------------------------------------------------------------------------------------------
 1866   3 *       |        |DO FOR LINEP=1,NLINES                                                                                   
 1867   4 *       |        |   UNDO IF (CCLINE(1,LINEP) .EQ. IBLK)                                                                  
                  |        <----                                                                                                    
 1868   3 *       |        |END DO FOR                                                                                              
                  |        +--------------------------------------------------------------------------------------------------------
 1869   3 *       |         IF (NLINES .LT. (LINEP + PAGLEN - 1))                                                                   
 1870   4         |            LINEP = NLINES - PAGLEN + 1                                                                          
 1871   4         |            IF (LINEP .LE. 0) LINEP = 1                                                                          
 1872   3 *       |         ENDIF                                                                                                   
 1873   2 *       |      ENDIF                                                                                                      
 1874   2 *       |      EXECUTE (GET_LAST_LINE)                                                                                    
 1875   2 *       |      EXECUTE (REFRESH_EXIT)                                                                                     
 1876   1 *       |   CASE 3                                                                                                        
 1877       C     |                                 C                                                                               
 1878       C     |                                 C***   Searches                                                                 
 1879       C     |                                 C                                                                               
 1880   2 *       |      IF (.NOT.SBFFLG)                                                                                           
 1881   3 *       |         EXECUTE (ERROR_EXIT)                                                                                    
 1882   2 *       |      ENDIF                                                                                                      
 1883       C     |                                 C                                                                               
 1884       C     |                                 C***   Loop ANUMB times                                                         
 1885       C     |                                 C                                                                               
 1886   2 *       |      IF (NUMFLG)                                                                                                
 1887   3         |         NUMBER = ANUMB                                                                                          
 1888   2 *       |      ELSE                                                                                                       
 1889   3         |         NUMBER = 1                                                                                              
 1890   2 *       |      ENDIF                                                                                                      
                  |     +-----------------------------------------------------------------------------------------------------------
 1891   2 *       |     |DO FOR III=1,NUMBER                                                                                        
 1892   3 *       |     |   IF (MINFLG)                                                                                             
 1893   4 *       |     |      IF (DIRECT .EQ. -1)                                                                                  
 1894   5 *       |     |         EXECUTE (FORWARD_SEARCH)                                                                          
 1895   4 *       |     |      ELSE                                                                                                 
 1896   5 *       |     |         EXECUTE (BACKWARD_SEARCH)                                                                         
 1897   4 *       |     |      ENDIF                                                                                                
 1898   3 *       |     |   ELSE                                                                                                    
 1899   4 *       |     |      IF (DIRECT .EQ. -1)                                                                                  
 1900   5 *       |     |         EXECUTE (BACKWARD_SEARCH)                                                                         
 1901   4 *       |     |      ELSE                                                                                                 
 1902   5 *       |     |         EXECUTE (FORWARD_SEARCH)                                                                          
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   54


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1903   4 *       |     |      ENDIF                                                                                                
 1904   3 *       |     |   ENDIF                                                                                                   
 1905   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 1906   1 *       |   CASE 4                                                                                                        
 1907       C     |                                 C                                                                               
 1908       C     |                                 C***   Reversing operation                                                      
 1909       C     |                                 C                                                                               
 1910   2         |      IF (MINFLG) DIRECT = -DIRECT                                                                               
 1911   2 *       |      IF (NUMFLG)                                                                                                
 1912   3         |         NUMBER = ANUMB                                                                                          
 1913   3         |         DIRECT = -1**NUMBER*DIRECT                                                                              
 1914   2 *       |      ELSE                                                                                                       
 1915   3         |         DIRECT = -DIRECT                                                                                        
 1916   2 *       |      ENDIF                                                                                                      
 1917   2 *       |      EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                              
 1918   1 *       |   CASE 5                                                                                                        
 1919       C     |                                 C                                                                               
 1920       C     |                                 C***   Scrolling                                                                
 1921       C     |                                 C                                                                               
 1922   2         |      CALL WORKNG(.FALSE.)                                                                                       
 1923   2         |      IF (NUMFLG) TIME = (-10000000./ANUMB)*DIRECT                                                               
 1924   2         |      CALL LIB$GET_EF(TIMFLG)                                                                                    
 1925   2 *       |      IF (TIMFLG .EQ. -1)                                                                                        
 1926   3         |         CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//                                             
 1927            1|               'flags.  SCROLLING ABORTED.',COMLIN,20)                                                           
 1928   3 *       |         EXECUTE (ERROR_EXIT)                                                                                    
 1929   2 *       |      ENDIF                                                                                                      
 1930   2 *       |      EXECUTE (QUEUE_STOPPER)                                                                                    
 1931   2         |      DELTIM(1) = TIME*DIRECT                                                                                    
 1932   2 *       |      IF ((DELTIM(1) .LT. 0 .AND. .NOT.MINFLG) .OR. (DELTIM(1) .GT. 0                                            
 1933            1|            .AND. MINFLG))                                                                                       
 1934   3 *       |         EXECUTE (FORWARD_SCROLLING)                                                                             
 1935   2 *       |      ELSE                                                                                                       
 1936   3 *       |         EXECUTE (BACKWARD_SCROLLING)                                                                            
 1937   2 *       |      ENDIF                                                                                                      
 1938   1 *       |   CASE 7                                                                                                        
 1939       C     |                                 C                                                                               
 1940       C     |                                 C***   Set scrolling speed                                                      
 1941       C     |                                 C                                                                               
 1942   2 *       |      IF (.NOT.NUMFLG)                                                                                           
 1943   3 *       |         EXECUTE (ERROR_EXIT)                                                                                    
 1944   2 *       |      ENDIF                                                                                                      
 1945   2         |      TIME = (-10000000./ANUMB)*DIRECT                                                                           
 1946   2 *       |      EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                              
 1947   1 *       |   CASE 8                                                                                                        
 1948       C     |                                 C                                                                               
 1949       C     |                                 C***   Mark command                                                             
 1950       C     |                                 C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   55


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1951   2 *       |      IF (NUMFLG)                                                                                                
 1952   3         |         NUMBER = ANUMB*DIRECT                                                                                   
 1953   2 *       |      ELSE                                                                                                       
 1954   3         |         NUMBER = 0                                                                                              
 1955   2 *       |      ENDIF                                                                                                      
 1956   2 *       |      EXECUTE (HOLD_CURRENT_SETUP)                                                                               
 1957       C     |                                 C                                                                               
 1958       C     |                                 C***   Point to line we want                                                    
 1959       C     |                                 C                                                                               
 1960   2         |      JNUMB = 0                                                                                                  
 1961   2 *       |      EXECUTE (JUMP_LINES)                                                                                       
 1962   2         |      LINEP = LINEP + JNUMB                                                                                      
 1963   2         |      IF (LINEP .GT. NLINES) LINEP = NLINES                                                                      
                  |     +-----------------------------------------------------------------------------------------------------------
 1964   2 *       |     |DO FOR I=LINEP,NLINES                                                                                      
 1965   3 *       |     |   IF (CCLINE(1,I) .NE. 0)                                                                                 
 1966   4 *       |     |      IF (RANGE(1,1) .NE. 0)                                                                               
 1967   5         |     |         RANGE(1,2) = RANGE(1,1)                                                                           
 1968   5         |     |         RANGE(2,2) = RANGE(2,1)                                                                           
 1969   4 *       |     |      ENDIF                                                                                                
 1970   4         |     |      RANGE(1,1) = CCLINE(1,I)                                                                             
 1971   4         |     |      RANGE(2,1) = CCLINE(2,I)                                                                             
 1972   4 *       |     |      UNDO                                                                                                 
                  |     <-------                                                                                                    
 1973   3 *       |     |   ENDIF                                                                                                   
 1974   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 1975   2 *       |      EXECUTE (CANCEL_STOPPER)                                                                                   
 1976   2 *       |      EXECUTE (RESTORE_HELD_SETUP)                                                                               
 1977   2 *       |      EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                              
 1978   1 *       |   CASE 9                                                                                                        
 1979       C     |                                 C                                                                               
 1980       C     |                                 C***   Print, List, and Append commands                                         
 1981       C     |                                 C                                                                               
 1982   2         |      PRINT = 1                                                                                                  
 1983   2 *       |      EXECUTE (OUTPUT_RANGE)                                                                                     
 1984   1 *       |   CASE 10                                                                                                       
 1985   2 *       |      IF (MINFLG)                                                                                                
 1986   3         |         PRINT = 0                                                                                               
 1987   2 *       |      ELSE                                                                                                       
 1988   3         |         PRINT = -1                                                                                              
 1989   2 *       |      ENDIF                                                                                                      
 1990   2 *       |      EXECUTE (OUTPUT_RANGE)                                                                                     
 1991   1 *       |   CASE 11                                                                                                       
 1992       C     |                                 C                                                                               
 1993       C     |                                 C***   Exit                                                                     
 1994       C     |                                 C                                                                               
 1995   2         |      CALL EXIT                                                                                                  
 1996   1 *       |   CASE 12                                                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   56


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 1997       C     |                                 C                                                                               
 1998       C     |                                 C***   Re-write screen                                                          
 1999       C     |                                 C                                                                               
 2000   2 *       |      EXECUTE (REFRESH_EXIT)                                                                                     
 2001       C     |                                 C                                                                               
 2002       C     |                                 C***   Repeat last command                                                      
 2003       C     |                                 C                                                                               
 2004   1 *       |   CASE 13                                                                                                       
 2005   2 *       |      IF (NUMFLG)                                                                                                
 2006   3         |         III = ANUMB                                                                                             
 2007   2 *       |      ELSE                                                                                                       
 2008   3         |         III = 1                                                                                                 
 2009   2 *       |      ENDIF                                                                                                      
                  |     +-----------------------------------------------------------------------------------------------------------
 2010   2 *       |     |DO FOR IIII=1,III                                                                                          
 2011   3         |     |   CALL REDOIT(SAVCOM,SAVFLG(1),SAVNUM,SAVFLG(2))                                                          
 2012   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 2013     *       |END DO CASE                                                                                                      
                  +-----------------------------------------------------------------------------------------------------------------
 2014     *        EXECUTE (CANCEL_STOPPER)                                                                                         
 2015              CALL WORKNG(.FALSE.)                                                                                             
 2016              RETURN                                                                                                           
              <-----                                                                                                                
 2017       C                                       C                                                                               
 2018       C                                       C****************************************************************************** 
 2019       C                                       C***********************   HERE FOLLOW THE PROCEDURES   *********************** 
 2020       C                                       C****************************************************************************** 
 2021       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   57


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2022     *        PROCEDURE (BACK_SCROLL_EXIT)                                                                                     
 2023       C                                       CP    This routine exits from scrolling backward in FIX files.  It converts     
 2024       C                                       CP    the data at the current position into output lines, frees the event       
 2025       C                                       CP    event flags, resets the LEDs (#3 off) and returns.                        
 2026   1             II = PBUF                                                                                                     
 2027   1             SBLK = BLK - 1                                                                                                
 2028   1 *           IF (BLK .LE. EBK)                                                                                             
 2029   2                CALL BLKIN(BLK,I,BUFFER(513))                                                                              
 2030   2 *              IF (I .EQ. 0)                                                                                              
 2031   3 *                 EXECUTE (READ_ERROR)                                                                                    
 2032   2 *              ENDIF                                                                                                      
 2033   2                NBUF = 512 + I                                                                                             
 2034   1 *           ENDIF                                                                                                         
 2035   1             CALL LINCON(.TRUE.)                                                                                           
                     +--------------------------------------------------------------------------------------------------------------
 2036   1 *          |DO FOR LINEP=1,NLINES                                                                                         
 2037   2 *          |   UNDO IF (CCLINE(1,LINEP) .EQ. SBLK .AND. CCLINE(2,LINEP).EQ.II)                                            
                     <----                                                                                                          
 2038   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 2039   1 *           EXECUTE (GET_LAST_LINE)                                                                                       
 2040   1 *           EXECUTE (WRITE_BLOCK_NUMBER)                                                                                  
 2041   1 *           EXECUTE (FREE_FLAGS_EXIT)                                                                                     
 2042   1             RETURN                                                                                                        
              <--------                                                                                                             
 2043     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   58


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2044     *        PROCEDURE (BACKWARD_SEARCH)                                                                                      
 2045       C                                       CP    This procedure searches backward through the file for a string. IF        
 2046       C                                       CP    found the position is located there, the screen refreshed and the         
 2047       C                                       CP    LEDs reset (#3 off), otherwise the screen is left alone, the position     
 2048       C                                       CP    is not changed, and the LEDs are reset (#3 on).  In either case the       
 2049       C                                       CP    a return from DOIT is executed.                                           
 2050       C                                       C                                                                               
 2051       C                                       C***   First search lines in buffer                                             
 2052       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 2053   1 * 1650     |DO                                                                                                            
 2054   2 *          |   IF (LINEP .NE. 1)                                                                                          
                     |     +--------------------------------------------------------------------------------------------------------
 2055   3 *          |     |DO FOR I=LINEP-1,1,-1                                                                                   
 2056   4            |     |   CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))                                                   
                     |     |  +-----------------------------------------------------------------------------------------------------
 2057   4 *          |     |  |DO FOR JJ=1,10                                                                                       
 2058   5 *          |     |  |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                                       
                     |     |  <----                                                                                                 
 2059   5 *          |     |  |   IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ)))                                             
 2060            1   |     |  |         .NE. 0)                                                                                     
 2061   6            |     |  |      NUMBER = I - LINEP                                                                             
 2062   6            |     |  |      LINEP = I                                                                                      
 2063   6 *          |     |  |      EXECUTE (GET_LAST_LINE)                                                                        
 2064   6 *          |     |  |      IF (IABS(NUMBER) .GT. PAGLEN)                                                                  
 2065   7 *          |     |  |         EXECUTE (REFRESH_EXIT)                                                                      
 2066   6 *          |     |  |      ELSE                                                                                           
 2067   7 *          |     |  |         EXECUTE (SCROLL_REFRESH_EXIT)                                                               
 2068   6 *          |     |  |      ENDIF                                                                                          
 2069   6 *          |     |  |      UNDO 1650                                                                                      
                     <----------------                                                                                              
 2070   5 *          |     |  |   ENDIF                                                                                             
 2071   4 *          |     |  |END DO FOR                                                                                           
                     |     |  +-----------------------------------------------------------------------------------------------------
 2072   3 *          |     |END DO FOR                                                                                              
                     |     +--------------------------------------------------------------------------------------------------------
 2073   2 *          |   ENDIF                                                                                                      
 2074       C        |                              C                                                                               
 2075       C        |                              C***   Then start searching backward if not found                               
 2076       C        |                              C                                                                               
 2077   2 *          |   EXECUTE (HOLD_CURRENT_SETUP)                                                                               
 2078   2            |   IBLK = SBLK - 1                                                                                            
 2079   2 *          |   IF (IBLK .LE. 0)                                                                                           
 2080   3 *          |      EXECUTE (SEARCH_ERROR_EXIT)                                                                             
 2081   2 *          |   ENDIF                                                                                                      
 2082   2            |   CALL BLKIN(IBLK,NBUF,BUFFER)                                                                               
 2083   2 *          |   IF (NBUF .EQ. 0)                                                                                           
 2084   3 *          |      EXECUTE (READ_ERROR)                                                                                    
 2085   2 *          |   ENDIF                                                                                                      
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   59


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2086   2            |   CALL BLKIN(IBLK,I,BUFFER(NBUF+1))                                                                          
 2087   2 *          |   IF (I .EQ. 0)                                                                                              
 2088   3 *          |      EXECUTE (READ_ERROR)                                                                                    
 2089   2 *          |   ENDIF                                                                                                      
 2090   2 *          |   IF (I .GT. 140)                                                                                            
 2091   3            |      NBUF = NBUF + 140                                                                                       
 2092   2 *          |   ELSE                                                                                                       
 2093   3            |      NBUF = NBUF + I                                                                                         
 2094   2 *          |   ENDIF                                                                                                      
 2095   2            |   IBLK = SBLK                                                                                                
 2096       C        |                              C                                                                               
 2097       C        |                              C===   Search loop                                                              
 2098       C        |                              C                                                                               
                     |  +-----------------------------------------------------------------------------------------------------------
 2099   2 *          |  |DO FOREVER                                                                                                 
 2100   3            |  |   CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))                                                                   
                     |  |  +--------------------------------------------------------------------------------------------------------
 2101   3 *          |  |  |DO FOR JJ=1,10                                                                                          
 2102   4 *          |  |  |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                                          
                     |  |  <----                                                                                                    
 2103   4            |  |  |   IDESCR(1) = NBUF                                                                                     
 2104   4            |  |  |   IDESCR(2) = %LOC(CAPBUF(1))                                                                          
 2105   4            |  |  |   I = 1                                                                                                
                     |  |  |  +-----------------------------------------------------------------------------------------------------
 2106   4 *          |  |  |  |DO FOREVER                                                                                           
 2107   5            |  |  |  |   K = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))                                                     
 2108   5 *          |  |  |  |   IF (STOPIT)                                                                                       
 2109   6 *          |  |  |  |      EXECUTE (CANCEL_COMMAND)                                                                       
 2110   5 *          |  |  |  |   ENDIF                                                                                             
 2111   5 *          |  |  |  |   IF (K .EQ. 0)                                                                                     
 2112   6            |  |  |  |      STRPOS(JJ) = I - 1                                                                             
 2113   6 *          |  |  |  |      UNDO                                                                                           
                     |  |  |  <-------                                                                                              
 2114   5 *          |  |  |  |   ENDIF                                                                                             
 2115   5            |  |  |  |   IDESCR(1) = IDESCR(1) - K                                                                         
 2116   5            |  |  |  |   I = I + K                                                                                         
 2117   5            |  |  |  |   IDESCR(2) = %LOC(CAPBUF(I))                                                                       
 2118   4 *          |  |  |  |END DO FOREVER                                                                                       
                     |  |  |  +-----------------------------------------------------------------------------------------------------
 2119   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2120   3            |  |   I = 0                                                                                                   
                     |  |  +--------------------------------------------------------------------------------------------------------
 2121   3 *          |  |  |DO FOR K=1,10                                                                                           
 2122   4 *          |  |  |   UNDO IF (SBFLEN(K) .EQ. 0)                                                                           
                     |  |  <----                                                                                                    
 2123   4 *          |  |  |   IF (STRPOS(K) .GT. I)                                                                                
 2124   5            |  |  |      JJ = K                                                                                            
 2125   5            |  |  |      I = STRPOS(K)                                                                                     
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   60


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2126   4 *          |  |  |   ENDIF                                                                                                
 2127   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2128       C        |  |                           C                                                                               
 2129       C        |  |                           C===   Found                                                                    
 2130       C        |  |                           C                                                                               
 2131   3 *          |  |   IF (I .NE. 0)                                                                                           
 2132   4            |  |      BLK = IBLK - 2                                                                                       
 2133   4            |  |      IF (BLK .LE. 0) BLK = 1                                                                              
 2134   4            |  |      SBLK = BLK                                                                                           
 2135   4            |  |      CALL BLKIN(BLK,NBUF,BUFFER)                                                                          
 2136   4 *          |  |      IF (NBUF .EQ. 0)                                                                                     
 2137   5 *          |  |         EXECUTE (READ_ERROR)                                                                              
 2138   4 *          |  |      ENDIF                                                                                                
 2139   4 *          |  |      IF (BLK .LE. EBK)                                                                                    
 2140   5            |  |         CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                                  
 2141   5 *          |  |         IF (I .EQ. 0)                                                                                     
 2142   6 *          |  |            EXECUTE (READ_ERROR)                                                                           
 2143   5 *          |  |         ENDIF                                                                                             
 2144   5            |  |         NBUF = NBUF + I                                                                                   
 2145   5 *          |  |         IF (BLK .LE. EBK)                                                                                 
 2146   6            |  |            CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                               
 2147   6 *          |  |            IF (I .EQ. 0)                                                                                  
 2148   7 *          |  |               EXECUTE (READ_ERROR)                                                                        
 2149   6 *          |  |            ENDIF                                                                                          
 2150   6            |  |            NBUF = NBUF + I                                                                                
 2151   5 *          |  |         ENDIF                                                                                             
 2152   4 *          |  |      ENDIF                                                                                                
 2153   4            |  |      CALL LINCON(.TRUE.)                                                                                  
 2154       C        |  |                           C                                                                               
 2155       C        |  |                           C===   Find right line                                                          
 2156       C        |  |                           C                                                                               
                     |  |     +-----------------------------------------------------------------------------------------------------
 2157   4 *          |  |     |DO FOR J=NLINES,1,-1                                                                                 
 2158   5            |  |     |   CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))                                                
 2159   5 *          |  |     |   IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))                                             
 2160            1   |  |     |         .NE. 0)                                                                                     
 2161   6            |  |     |      LINEP = J                                                                                      
 2162   6 *          |  |     |      EXECUTE (GET_LAST_LINE)                                                                        
 2163   6 *          |  |     |      EXECUTE (CANCEL_STOPPER)                                                                       
 2164   6 *          |  |     |      EXECUTE (REFRESH_EXIT)                                                                         
 2165   6 *          |  |     |      UNDO 1650                                                                                      
                     <----------------                                                                                              
 2166   5 *          |  |     |   ENDIF                                                                                             
 2167   4 *          |  |     |END DO FOR                                                                                           
                     |  |     +-----------------------------------------------------------------------------------------------------
 2168       C        |  |                           C                                                                               
 2169       C        |  |                           C===   Not found                                                                
 2170       C        |  |                           C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   61


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2171   3 *          |  |   ENDIF                                                                                                   
 2172   3            |  |   IBLK = IBLK - 2                                                                                         
 2173   3 *          |  |   IF (IBLK .LE. 0)                                                                                        
 2174   4 *          |  |      EXECUTE (SEARCH_ERROR_EXIT)                                                                          
 2175   3 *          |  |   ENDIF                                                                                                   
                     |  |  +--------------------------------------------------------------------------------------------------------
 2176   3 *          |  |  |DO FOR I=1,30                                                                                           
 2177   4            |  |  |   TEMP(I) = CAPBUF(I)                                                                                  
 2178   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2179   3            |  |   CALL BLKIN(IBLK,NBUF,BUFFER)                                                                            
 2180   3 *          |  |   IF (NBUF .EQ. 0)                                                                                        
 2181   4 *          |  |      EXECUTE (READ_ERROR)                                                                                 
 2182   3 *          |  |   ENDIF                                                                                                   
                     |  |  +--------------------------------------------------------------------------------------------------------
 2183   3 *          |  |  |DO FOR I=1,30                                                                                           
 2184   4            |  |  |   BUFFER(NBUF+I) = TEMP(I)                                                                             
 2185   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2186   3            |  |   NBUF = NBUF + 30                                                                                        
 2187   3 *          |  |   IF (STOPIT)                                                                                             
 2188   4 *          |  |      EXECUTE (CANCEL_COMMAND)                                                                             
 2189   3 *          |  |   ENDIF                                                                                                   
 2190   2 *          |  |END DO FOREVER                                                                                             
                     |  +-----------------------------------------------------------------------------------------------------------
 2191   1 *          |END DO                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
 2192     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   62


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2193     *        PROCEDURE (BACKWARD_SCROLLING)                                                                                   
 2194       C                                       CP    This procedure handles scrolling backward through the file.               
 2195   1             IF (.NOT.MINFLG) DELTIM(1) = -DELTIM(1)                                                                       
 2196       C                                       C                                                                               
 2197       C                                       C***   Scroll through line buffer                                               
 2198       C                                       C                                                                               
 2199   1 *           IF (LINEP .NE. 1)                                                                                             
                        +-----------------------------------------------------------------------------------------------------------
 2200   2 *             |DO FOR LINEP=LINEP-1,1,-1                                                                                  
 2201   3 *             |   IF (LENLMT .LT. 0)                                                                                      
 2202   4               |      K = -LENLMT                                                                                          
                        |     +-----------------------------------------------------------------------------------------------------
 2203   4 *             |     |DO FOR L=1,LINLEN(LINEP)/K+1                                                                         
 2204   5 *             |     |   EXECUTE (SCROLL_DOWN)                                                                             
 2205   4 *             |     |END DO FOR                                                                                           
                        |     +-----------------------------------------------------------------------------------------------------
 2206   4 *             |      IF (K .LT. LINLEN(LINEP))                                                                            
 2207   5               |         CALL LIB$PUT_SCREEN(LINES(LINEP)(:K)//CRLF//                                                      
 2208            1      |               LINES(LINEP)(K+1:LINLEN(LINEP))//CRLF,1,1)                                                  
 2209   4 *             |      ELSE                                                                                                 
 2210   5               |         CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,                                           
 2211            1      |               1,1)                                                                                        
 2212   4 *             |      ENDIF                                                                                                
 2213   3 *             |   ELSE                                                                                                    
 2214   4 *             |      EXECUTE (SCROLL_DOWN)                                                                                
 2215   4 *             |      IF (LINLEN(LINEP) .GT. LENLMT)                                                                       
 2216   5               |         CALL LIB$PUT_SCREEN(LINES(LINEP)(:LENLMT)//CRLF,1,1)                                              
 2217   4 *             |      ELSE                                                                                                 
 2218   5               |         CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,                                           
 2219            1      |               1,1)                                                                                        
 2220   4 *             |      ENDIF                                                                                                
 2221   3 *             |   ENDIF                                                                                                   
 2222   3 *             |   EXECUTE (WAIT_FOR_SCROLL_AST)                                                                           
 2223   3 *             |   IF (STOPIT)                                                                                             
 2224   4 *             |      EXECUTE (GET_LAST_LINE)                                                                              
 2225   4 *             |      EXECUTE (WRITE_BLOCK_NUMBER)                                                                         
 2226   4 *             |      EXECUTE (FREE_FLAGS_EXIT)                                                                            
 2227   4               |      RETURN                                                                                               
              <-----------------                                                                                                    
 2228   3 *             |   ENDIF                                                                                                   
 2229   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2230   1 *           ENDIF                                                                                                         
 2231       C                                       C                                                                               
 2232       C                                       C***   Scroll through file                                                      
 2233       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 2234   1 *          |DO FOR I=1,NLINES                                                                                             
 2235   2 *          |   UNDO IF (CCLINE(1,I) .NE. 0)                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   63


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                     <----                                                                                                          
 2236   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 2237   1             BLK = CCLINE(1,I) - 1                                                                                         
 2238   1 *           IF (BLK .GT. 0)                                                                                               
 2239   2                CALL BLKIN(BLK,PBUF,BUFFER)                                                                                
 2240   2 *              IF (PBUF .EQ. 0)                                                                                           
 2241   3 *                 EXECUTE (READ_ERROR)                                                                                    
 2242   2 *              ENDIF                                                                                                      
 2243   1 *           ELSE                                                                                                          
 2244   2                PBUF = 0                                                                                                   
 2245   2                BLK = 1                                                                                                    
 2246   1 *           ENDIF                                                                                                         
 2247   1             CALL BLKIN(BLK,NBUF,BUFFER(PBUF+1))                                                                           
 2248   1 *           IF (NBUF .EQ. 0)                                                                                              
 2249   2 *              EXECUTE (READ_ERROR)                                                                                       
 2250   1 *           ENDIF                                                                                                         
 2251   1             IF (PBUF .NE. 0) BLK = BLK - 1                                                                                
 2252   1             PBUF = PBUF + CCLINE(2,I)                                                                                     
 2253   1             NBUF = PBUF                                                                                                   
 2254   1             ISAVE = PBUF                                                                                                  
                     +--------------------------------------------------------------------------------------------------------------
 2255   1 *          |DO FOREVER                                                                                                    
 2256   2 *          |   IF (RFM .EQ. 1)                                                                                            
 2257       C        |                              C                                                                               
 2258       C        |                              C---   Fixed length records                                                     
 2259       C        |                              C                                                                               
 2260       C        |                              C===   Establish output record length                                           
 2261       C        |                              C                                                                               
 2262   3 *          |      IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                                        
 2263   4 *          |         IF ((FSZ - 1) .LT. LENLMT .OR. LENLMT .LT. 0)                                                        
 2264   5            |            LENREC = FSZ - 1                                                                                  
 2265   4 *          |         ELSE                                                                                                 
 2266   5            |            LENREC = LENLMT                                                                                   
 2267   4 *          |         ENDIF                                                                                                
 2268   3 *          |      ELSE                                                                                                    
 2269   4 *          |         IF (FSZ .LT. LENLMT .OR. LENLMT .LT. 0)                                                              
 2270   5            |            LENREC = FSZ                                                                                      
 2271   4 *          |         ELSE                                                                                                 
 2272   5            |            LENREC = LENLMT                                                                                   
 2273   4 *          |         ENDIF                                                                                                
 2274   3 *          |      ENDIF                                                                                                   
                     |     +--------------------------------------------------------------------------------------------------------
 2275   3 *          |     |DO FOREVER                                                                                              
 2276   4 *          |     |   EXECUTE (WAIT_FOR_SCROLL)                                                                            
 2277   4 *          |     |   IF (STOPIT)                                                                                          
 2278   5 *          |     |      EXECUTE (BACK_SCROLL_EXIT)                                                                        
 2279   4 *          |     |   ENDIF                                                                                                
 2280   4            |     |   PBUF = PBUF - IFSZ                                                                                   
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   64


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2281   4 *          |     |   UNDO IF (PBUF .LE. 0)                                                                                
                     |     <----                                                                                                    
 2282   4 *          |     |   EXECUTE (SCROLL_DOWN)                                                                                
 2283   4 *          |     |   IF (LENLMT .LT. 0 .AND. RECLEN .GT. (-LENLMT))                                                       
                     |     |     +--------------------------------------------------------------------------------------------------
 2284   5 *          |     |     |DO FOR K=1,(-LENLMT)/RECLEN                                                                       
 2285   6 *          |     |     |   EXECUTE (SCROLL_DOWN)                                                                          
 2286   5 *          |     |     |END DO FOR                                                                                        
                     |     |     +--------------------------------------------------------------------------------------------------
 2287   4 *          |     |   ENDIF                                                                                                
 2288   4 *          |     |   IF (RAT .NE. 2 .AND. RAT .NE. -2)                                                                    
 2289   5            |     |      CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,BUFFER(PBUF),                                          
 2290            1   |     |            %VAL(LENREC),,,,)                                                                           
 2291   5            |     |      CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),                                             
 2292            1   |     |            IOSB,STOPSC,,INBUF,%VAL(1),,,,)                                                             
 2293   4 *          |     |   ELSE                                                                                                 
 2294   5            |     |      CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,                                                       
 2295            1   |     |            BUFFER(PBUF+1),%VAL(LENREC),,,,)                                                            
 2296   5            |     |      CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),                                             
 2297            1   |     |            IOSB,STOPSC,,INBUF,%VAL(1),,,,)                                                             
 2298   5 *          |     |      IF (BUFFER(PBUF) .EQ. '1')                                                                        
 2299   6 *          |     |         EXECUTE (SCROLL_BLANK_LINE_PRE)                                                                
 2300   6 *          |     |         EXECUTE (SCROLL_BLANK_LINE_PRE)                                                                
 2301   5 *          |     |      ELSE                                                                                              
 2302   6 *          |     |         IF (BUFFER(PBUF) .EQ. '0')                                                                     
 2303   7 *          |     |            EXECUTE (SCROLL_BLANK_LINE_PRE)                                                             
 2304   6 *          |     |         ENDIF                                                                                          
 2305   5 *          |     |      ENDIF                                                                                             
 2306   4 *          |     |   ENDIF                                                                                                
 2307   3 *          |     |END DO FOREVER                                                                                          
                     |     +--------------------------------------------------------------------------------------------------------
 2308   2 *          |   ELSE                                                                                                       
 2309       C        |                              C                                                                               
 2310       C        |                              C---   Variable length records                                                  
 2311       C        |                              C                                                                               
                     |     +--------------------------------------------------------------------------------------------------------
 2312   3 *          |     |DO FOR I=PBUF,2,-1                                                                                      
 2313   4 *          |     |   IF (.NOT.I)                                                                                          
 2314   5 *          |     |      IF (BUFFER(I) .EQ. 0)                                                                             
 2315   6 *          |     |         CYCLE IF (I .GT. ISAVE)                                                                        
                     |     |<---------                                                                                              
 2316   6            |     |         LEN = LIB$EXTZV(0,8,BUFFER(I-1))                                                               
 2317   6 *          |     |         IF ((LEN - FSZ) .EQ. 0)                                                                        
 2318   7 *          |     |            EXECUTE (SCROLL_BLANK_LINE_POST)                                                            
 2319   7            |     |            ISAVE = I - 4 - FSZ                                                                         
 2320   7 *          |     |            CYCLE                                                                                       
                     |     |<------------                                                                                           
 2321   6 *          |     |         ENDIF                                                                                          
 2322   6 *          |     |         IF (LEN)                                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   65


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2323   7            |     |            ILEN = LEN + 1                                                                              
 2324   6 *          |     |         ELSE                                                                                           
 2325   7            |     |            ILEN = LEN                                                                                  
 2326   6 *          |     |         ENDIF                                                                                          
 2327   6 *          |     |         IF (BUFFER(I+ILEN+2) .EQ. 0 .AND. LEN .LE. LRL .AND.                                           
 2328            1   |     |               LIB$EXTZV(0,8,BUFFER(I+ILEN+1)) .LE. LRL)                                                
 2329   7            |     |            ISAVE = I - 4 - FSZ                                                                         
 2330   7 *          |     |            IF (RAT .EQ. 3 .OR. RAT .EQ. -3)                                                            
 2331   8 *          |     |               IF (LIB$EXTZV(7,1,BUFFER(I+2)) .EQ. 0)                                                   
 2332   9            |     |                  J = LIB$EXTZV(0,7,BUFFER(I+2)) - 1                                                    
 2333   9 *          |     |                  IF (J .GT. 0)                                                                         
                     |     |                    +-----------------------------------------------------------------------------------
 2334  10 *          |     |                    |DO FOR K=1,J                                                                       
 2335  11 *          |     |                    |   EXECUTE (SCROLL_BLANK_LINE_POST)                                                
 2336  10 *          |     |                    |END DO FOR                                                                         
                     |     |                    +-----------------------------------------------------------------------------------
 2337   9 *          |     |                  ENDIF                                                                                 
 2338   8 *          |     |               ENDIF                                                                                    
 2339   8 *          |     |               EXECUTE (SCROLL_DOWN)                                                                    
 2340   8            |     |               CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,                                              
 2341            1   |     |                     BUFFER(I+FSZ+1),%VAL(LEN-FSZ),,,,)                                                 
 2342   8            |     |               CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),                                                  
 2343            1   |     |                     %VAL('1171'X),IOSB,STOPSC,,INBUF,                                                  
 2344            2   |     |                     %VAL(1),,,,)                                                                       
 2345   8 *          |     |               IF (LIB$EXTZV(7,1,BUFFER(I+1)) .EQ. 0)                                                   
 2346   9            |     |                  J = LIB$EXTZV(0,7,BUFFER(I+1))                                                        
 2347   9 *          |     |                  IF (J .NE. 0)                                                                         
                     |     |                    +-----------------------------------------------------------------------------------
 2348  10 *          |     |                    |DO FOR K=1,J                                                                       
 2349  11 *          |     |                    |   EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                             
 2350  10 *          |     |                    |END DO FOR                                                                         
                     |     |                    +-----------------------------------------------------------------------------------
 2351   9 *          |     |                  ENDIF                                                                                 
 2352   8 *          |     |               ENDIF                                                                                    
 2353   7 *          |     |            ELSE                                                                                        
 2354   8 *          |     |               EXECUTE (SCROLL_DOWN)                                                                    
 2355   8 *          |     |               IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                         
 2356   9 *          |     |                  IF (LEN .NE. 1)                                                                       
 2357  10 *          |     |                     IF (LENLMT .LT. 0)                                                                 
 2358  11 *          |     |                        IF (LENLMT .GT. (1 + FSZ - LEN))                                                
                     |     |                          +-----------------------------------------------------------------------------
 2359  12 *          |     |                          |DO FOR M=1,(FSZ-LEN)/LENLMT                                                  
 2360  13 *          |     |                          |   EXECUTE (SCROLL_DOWN)                                                     
 2361  12 *          |     |                          |END DO FOR                                                                   
                     |     |                          +-----------------------------------------------------------------------------
 2362  12            |     |                           M = LEN - FSZ - 1                                                            
 2363  11 *          |     |                        ELSE                                                                            
 2364  12            |     |                           M = -LENLMT                                                                  
 2365  11 *          |     |                        ENDIF                                                                           
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   66


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2366  10 *          |     |                     ELSE                                                                               
 2367  11 *          |     |                        IF (LENLMT .GT. (LEN - FSZ - 1))                                                
 2368  12            |     |                           M = LEN - FSZ - 1                                                            
 2369  11 *          |     |                        ELSE                                                                            
 2370  12            |     |                           M = LENLMT                                                                   
 2371  11 *          |     |                        ENDIF                                                                           
 2372  10 *          |     |                     ENDIF                                                                              
 2373  10            |     |                     CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,                                         
 2374            1   |     |                           ,BUFFER(I+FSZ+2),%VAL(M),,,,)                                                
 2375   9 *          |     |                  ENDIF                                                                                 
 2376   9            |     |                  CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),                                               
 2377            1   |     |                        %VAL('1171'X),IOSB,STOPSC,,                                                     
 2378            2   |     |                        INBUF,%VAL(1),,,,)                                                              
 2379   9 *          |     |                  IF (BUFFER(I+FSZ+1) .EQ. '1')                                                         
 2380  10 *          |     |                     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                                
 2381  10 *          |     |                     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                                
 2382   9 *          |     |                  ELSE                                                                                  
 2383  10 *          |     |                     IF (BUFFER(I+FSZ+1) .EQ. '0')                                                      
 2384  11 *          |     |                        EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                             
 2385  10 *          |     |                     ENDIF                                                                              
 2386   9 *          |     |                  ENDIF                                                                                 
 2387   8 *          |     |               ELSE                                                                                     
 2388   9 *          |     |                  IF (LENLMT .LT. 0)                                                                    
 2389  10 *          |     |                     IF (LENLMT .GT. (FSZ - LEN))                                                       
                     |     |                       +--------------------------------------------------------------------------------
 2390  11 *          |     |                       |DO FOR M=1,(FSZ-LEN-1)/LENLMT                                                   
 2391  12 *          |     |                       |   EXECUTE (SCROLL_DOWN)                                                        
 2392  11 *          |     |                       |END DO FOR                                                                      
                     |     |                       +--------------------------------------------------------------------------------
 2393  11            |     |                        M = LEN - FSZ                                                                   
 2394  10 *          |     |                     ELSE                                                                               
 2395  11            |     |                        M = -LENLMT                                                                     
 2396  10 *          |     |                     ENDIF                                                                              
 2397   9 *          |     |                  ELSE                                                                                  
 2398  10 *          |     |                     IF (LENLMT .GT. (LEN - FSZ))                                                       
 2399  11            |     |                        M = LEN - FSZ                                                                   
 2400  10 *          |     |                     ELSE                                                                               
 2401  11            |     |                        M = LENLMT                                                                      
 2402  10 *          |     |                     ENDIF                                                                              
 2403   9 *          |     |                  ENDIF                                                                                 
 2404   9            |     |                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,                                           
 2405            1   |     |                        BUFFER(I+FSZ+1),%VAL(M),,,,)                                                    
 2406   9            |     |                  CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),                                               
 2407            1   |     |                        %VAL('1171'X),IOSB,STOPSC,,                                                     
 2408            2   |     |                        INBUF,%VAL(1),,,,)                                                              
 2409   8 *          |     |               ENDIF                                                                                    
 2410   8 *          |     |               EXECUTE (WAIT_FOR_SCROLL)                                                                
 2411   8 *          |     |               IF (STOPIT)                                                                              
 2412   9 *          |     |                  EXECUTE (VAR_BACK_SCROLL_EXIT)                                                        
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   67


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2413   8 *          |     |               ENDIF                                                                                    
 2414   7 *          |     |            ENDIF                                                                                       
 2415   6 *          |     |         ENDIF                                                                                          
 2416   5 *          |     |      ENDIF                                                                                             
 2417   4 *          |     |   ENDIF                                                                                                
 2418   3 *          |     |END DO FOR                                                                                              
                     |     +--------------------------------------------------------------------------------------------------------
 2419   2 *          |   ENDIF                                                                                                      
 2420   2            |   BLK = BLK - 2                                                                                              
 2421   2 *          |   IF (BLK .LE. 0)                                                                                            
 2422   3 *          |      EXECUTE (HIT_BEGINNING)                                                                                 
 2423   3 *          |      EXECUTE (GET_LAST_LINE)                                                                                 
 2424   3 *          |      EXECUTE (FREE_FLAGS_EXIT)                                                                               
 2425   3            |      RETURN                                                                                                  
              <--------------                                                                                                       
 2426   2 *          |   ENDIF                                                                                                      
                     |  +-----------------------------------------------------------------------------------------------------------
 2427   2 *          |  |DO FOR I=1,150                                                                                             
 2428   3            |  |   HBUFER(I) = BUFFER(I)                                                                                   
 2429   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 2430   2            |   CALL BLKIN(BLK,PBUF,BUFFER)                                                                                
 2431   2 *          |   IF (PBUF .EQ. 0)                                                                                           
 2432   3 *          |      EXECUTE (READ_ERROR)                                                                                    
 2433   2 *          |   ENDIF                                                                                                      
                     |  +-----------------------------------------------------------------------------------------------------------
 2434   2 *          |  |DO FOR I=1,150                                                                                             
 2435   3            |  |   BUFFER(PBUF+I) = HBUFER(I)                                                                              
 2436   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 2437   2            |   ISAVE = PBUF                                                                                               
 2438   2            |   NBUF = PBUF + 150                                                                                          
 2439   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 2440     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   68


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2441     *        PROCEDURE (CANCEL_COMMAND)                                                                                       
 2442       C                                       CP    This routine is used to terminate either line jumps or searches on        
 2443       C                                       CP    input of a (.                                                             
 2444   1             CALL LIB$FREE_EF(IOFLAG)                                                                                      
 2445   1 *           EXECUTE (RESTORE_HELD_SETUP)                                                                                  
 2446   1 *           EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                                 
 2447   1             RETURN                                                                                                        
              <--------                                                                                                             
 2448     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   69


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2449     *        PROCEDURE (CANCEL_STOPPER)                                                                                       
 2450       C                                       CP    This routine gets rid of the stopping AST.                                
 2451   1             CALL SYS$CANCEL(%VAL(INCHAN))                                                                                 
 2452   1             CALL LIB$FREE_EF(IOFLAG)                                                                                      
 2453     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   70


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2454     *        PROCEDURE (ERROR_EXIT)                                                                                           
 2455       C                                       CP    This routine rings the terminal bell then resets the LEDs (#3 on)         
 2456       C                                       CP    and returns.                                                              
 2457   1 *           EXECUTE (CANCEL_STOPPER)                                                                                      
 2458   1             CALL WORKNG(.FALSE.)                                                                                          
 2459   1             CALL LIB$PUT_SCREEN(CHAR(BELL))                                                                               
 2460   1 *           IF (VT100)                                                                                                    
 2461   2                CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;3q')                                                                    
 2462   2                IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')                                                   
 2463   2                IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                                                             
 2464            1             CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                                                                
 2465   1 *           ENDIF                                                                                                         
 2466   1             RETURN                                                                                                        
              <--------                                                                                                             
 2467     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   71


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2468     *        PROCEDURE (FIND_NON_CC_LINE)                                                                                     
 2469       C                                       CP    This procedure locates a non-carriage-control line near LINEP             
                     +--------------------------------------------------------------------------------------------------------------
 2470   1 * 1550     |DO                                                                                                            
                     |  +-----------------------------------------------------------------------------------------------------------
 2471   2 *          |  |DO FOR I=LINEP,NLINES                                                                                      
 2472   3 *          |  |   UNDO 1550 IF (CCLINE(1,I) .NE. 0)                                                                       
                     <-------                                                                                                       
 2473   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
                     |  +-----------------------------------------------------------------------------------------------------------
 2474   2 *          |  |DO FOR I=LINEP-1,1,-1                                                                                      
 2475   3 *          |  |   UNDO 1550 IF (CCLINE(1,I) .NE. 0)                                                                       
                     <-------                                                                                                       
 2476   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 2477   1 *          |END DO                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
 2478     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   72


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2479     *        PROCEDURE (FORWARD_SEARCH)                                                                                       
 2480       C                                       CP    This routine searchs forward through the file for a given string.         
 2481       C                                       CP    If it is found the screen is reset to that position, and the LEDs are     
 2482       C                                       CP    reset (#3 off), otherwise the position and screen remain unchanged        
 2483       C                                       CP    and the LEDs are reset (#3 on).  In either case a return from DOIT        
 2484       C                                       CP    is executed.                                                              
 2485       C                                       C                                                                               
 2486       C                                       C***   First search lines in buffer                                             
 2487       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 2488   1 * 1750     |DO                                                                                                            
 2489   2 *          |   IF (LINEP .LT. NLINES)                                                                                     
                     |     +--------------------------------------------------------------------------------------------------------
 2490   3 *          |     |DO FOR I=LINEP+1,NLINES                                                                                 
                     |     |  +-----------------------------------------------------------------------------------------------------
 2491   4 *          |     |  |DO FOR JJ=1,10                                                                                       
 2492   5 *          |     |  |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                                       
                     |     |  <----                                                                                                 
 2493   5            |     |  |   CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))                                                
 2494   5 *          |     |  |   IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ))) .NE.                                        
 2495            1   |     |  |         0)                                                                                          
 2496   6            |     |  |      NUMBER = I - LINEP                                                                             
 2497   6            |     |  |      LINEP = I                                                                                      
 2498   6 *          |     |  |      EXECUTE (GET_LAST_LINE)                                                                        
 2499   6 *          |     |  |      IF ((NUMBER+LINEP) .LT. PAGEND)                                                                
 2500   7 *          |     |  |         EXECUTE (SCROLL_REFRESH_EXIT)                                                               
 2501   6 *          |     |  |      ELSE                                                                                           
 2502   7 *          |     |  |         EXECUTE (REFRESH_EXIT)                                                                      
 2503   6 *          |     |  |      ENDIF                                                                                          
 2504   6 *          |     |  |      UNDO 1750                                                                                      
                     <----------------                                                                                              
 2505   5 *          |     |  |   ENDIF                                                                                             
 2506   4 *          |     |  |END DO FOR                                                                                           
                     |     |  +-----------------------------------------------------------------------------------------------------
 2507   3 *          |     |END DO FOR                                                                                              
                     |     +--------------------------------------------------------------------------------------------------------
 2508   2 *          |   ENDIF                                                                                                      
 2509       C        |                              C                                                                               
 2510       C        |                              C***   Then search file                                                         
 2511       C        |                              C                                                                               
 2512   2 *          |   EXECUTE (HOLD_CURRENT_SETUP)                                                                               
 2513   2            |   IBLK = BLK                                                                                                 
 2514   2 *          |   IF (NBUF .GT. 0)                                                                                           
 2515   3            |      I = NBUF + 1                                                                                            
 2516   2 *          |   ELSE                                                                                                       
 2517   3            |      I = 1                                                                                                   
 2518   2 *          |   ENDIF                                                                                                      
 2519   2            |   IDESCR(2) = %LOC(CAPBUF(1))                                                                                
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   73


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                     |  +-----------------------------------------------------------------------------------------------------------
 2520   2 *          |  |DO FOREVER                                                                                                 
 2521       C        |  |                           C                                                                               
 2522       C        |  |                           C---   Input some buffer                                                        
 2523       C        |  |                           C                                                                               
 2524   3 *          |  |   IF (IBLK .GT. EBK)                                                                                      
 2525   4 *          |  |      EXECUTE (SEARCH_ERROR_EXIT)                                                                          
 2526   3 *          |  |   ENDIF                                                                                                   
 2527   3 *          |  |   IF (IBLK .LT. (EBK - 6))                                                                                
 2528       C        |  |                           C                                                                               
 2529       C        |  |                           C===   Not near the end of the file                                             
 2530       C        |  |                           C                                                                               
 2531   4            |  |      CALL BLKSIN(IBLK,J,BUFFER(I))                                                                        
 2532   4 *          |  |      IF (J .EQ. 0)                                                                                        
 2533   5 *          |  |         EXECUTE (READ_ERROR)                                                                              
 2534   4 *          |  |      ENDIF                                                                                                
 2535   3 *          |  |   ELSE                                                                                                    
 2536       C        |  |                           C                                                                               
 2537       C        |  |                           C===   Near the end of the file                                                 
 2538       C        |  |                           C                                                                               
 2539   4            |  |      J = 0                                                                                                
                     |  |     +-----------------------------------------------------------------------------------------------------
 2540   4 *          |  |     |DO FOR II=IBLK,EBK                                                                                   
 2541   5            |  |     |   CALL BLKIN(IBLK,JJ,BUFFER(J+I))                                                                   
 2542   5 *          |  |     |   IF (JJ .EQ. 0)                                                                                    
 2543   6 *          |  |     |      EXECUTE (READ_ERROR)                                                                           
 2544   5 *          |  |     |   ENDIF                                                                                             
 2545   5            |  |     |   J = J + JJ                                                                                        
 2546   4 *          |  |     |END DO FOR                                                                                           
                     |  |     +-----------------------------------------------------------------------------------------------------
 2547   3 *          |  |   ENDIF                                                                                                   
 2548   3            |  |   NBUF = J + I - 1                                                                                        
 2549   3            |  |   CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))                                                                   
 2550   3            |  |   IDESCR(1) = NBUF                                                                                        
                     |  |  +--------------------------------------------------------------------------------------------------------
 2551   3 *          |  |  |DO FOR JJ=1,10                                                                                          
 2552   4 *          |  |  |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                                          
                     |  |  <----                                                                                                    
 2553   4            |  |  |   STRPOS(JJ) = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))                                               
 2554   4 *          |  |  |   IF (STOPIT)                                                                                          
 2555   5 *          |  |  |      EXECUTE (CANCEL_COMMAND)                                                                          
 2556   4 *          |  |  |   ENDIF                                                                                                
 2557   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2558   3            |  |   I = NBUF                                                                                                
                     |  |  +--------------------------------------------------------------------------------------------------------
 2559   3 *          |  |  |DO FOR K=1,10                                                                                           
 2560   4 *          |  |  |   UNDO IF (SBFLEN(K) .EQ. 0)                                                                           
                     |  |  <----                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   74


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2561   4 *          |  |  |   IF (STRPOS(K) .NE. 0 .AND. STRPOS(K) .LT. I)                                                         
 2562   5            |  |  |      I = STRPOS(K)                                                                                     
 2563   5            |  |  |      JJ = K                                                                                            
 2564   4 *          |  |  |   ENDIF                                                                                                
 2565   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2566   3 *          |  |   IF (I .NE. NBUF)                                                                                        
 2567       C        |  |                           C                                                                               
 2568       C        |  |                           C===   Found it                                                                 
 2569       C        |  |                           C                                                                               
 2570   4            |  |      IBLK = IBLK - (NBUF - I)/512 - 2                                                                     
 2571   4            |  |      IF (IBLK .LE. 0) IBLK = 1                                                                            
 2572   4 *          |  |      IF (IBLK .LE. (EBK - 6))                                                                             
 2573   5            |  |         BLK = IBLK                                                                                        
 2574   5            |  |         I = 1                                                                                             
 2575   4 *          |  |      ELSE                                                                                                 
 2576   5            |  |         BLK = EBK - 6                                                                                     
 2577   5            |  |         I = 0                                                                                             
 2578   4 *          |  |      ENDIF                                                                                                
 2579   4 *          |  |      EXECUTE (INPUT_SEVEN_BLOCKS)                                                                         
 2580   4            |  |      CALL LINCON(.TRUE.)                                                                                  
 2581   4 *          |  |      IF (I .EQ. 0)                                                                                        
                     |  |        +--------------------------------------------------------------------------------------------------
 2582   5 *          |  |        |DO FOR I=1,NLINES                                                                                 
 2583   6 *          |  |        |   UNDO IF (CCLINE(1,I) .EQ. IBLK)                                                                
                     |  |        <----                                                                                              
 2584   5 *          |  |        |END DO FOR                                                                                        
                     |  |        +--------------------------------------------------------------------------------------------------
 2585   4 *          |  |      ENDIF                                                                                                
                     |  |     +-----------------------------------------------------------------------------------------------------
 2586   4 *          |  |     |DO FOR J=I,NLINES                                                                                    
 2587   5            |  |     |   CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))                                                
 2588   5 *          |  |     |   IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))                                             
 2589            1   |  |     |         .NE. 0)                                                                                     
 2590   6            |  |     |      LINEP = J                                                                                      
 2591   6 *          |  |     |      EXECUTE (GET_LAST_LINE)                                                                        
 2592   6 *          |  |     |      EXECUTE (CANCEL_STOPPER)                                                                       
 2593   6 *          |  |     |      EXECUTE (REFRESH_EXIT)                                                                         
 2594   6 *          |  |     |      UNDO 1750                                                                                      
                     <----------------                                                                                              
 2595   5 *          |  |     |   ENDIF                                                                                             
 2596   5 *          |  |     |   IF (STOPIT)                                                                                       
 2597   6 *          |  |     |      EXECUTE (CANCEL_COMMAND)                                                                       
 2598   5 *          |  |     |   ENDIF                                                                                             
 2599   4 *          |  |     |END DO FOR                                                                                           
                     |  |     +-----------------------------------------------------------------------------------------------------
 2600       C        |  |                           C                                                                               
 2601       C        |  |                           C===   Not found                                                                
 2602       C        |  |                           C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   75


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2603   3 *          |  |   ENDIF                                                                                                   
 2604   3            |  |   I = 31                                                                                                  
                     |  |  +--------------------------------------------------------------------------------------------------------
 2605   3 *          |  |  |DO FOR J=1,30                                                                                           
 2606   4            |  |  |   BUFFER(J) = CAPBUF(NBUF-30+J)                                                                        
 2607   3 *          |  |  |END DO FOR                                                                                              
                     |  |  +--------------------------------------------------------------------------------------------------------
 2608   2 *          |  |END DO FOREVER                                                                                             
                     |  +-----------------------------------------------------------------------------------------------------------
 2609   1 *          |END DO                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
 2610     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   76


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2611     *        PROCEDURE (FORWARD_SCROLLING)                                                                                    
 2612       C                                       CP    This procedure executes scrolling in a forward direction.                 
 2613   1             LINEP = PAGEND                                                                                                
 2614   1             FIRST = .TRUE.                                                                                                
 2615   1 *           IF (PAGLEN .EQ. (COMLIN - 2))                                                                                 
 2616   2                SECOND = .TRUE.                                                                                            
 2617   1 *           ELSE                                                                                                          
 2618   2                SECOND = .FALSE.                                                                                           
 2619   1 *           ENDIF                                                                                                         
                     +--------------------------------------------------------------------------------------------------------------
 2620   1 *          |DO FOREVER                                                                                                    
 2621       C        |                              C                                                                               
 2622       C        |                              C***   Scroll through line buffer                                               
 2623       C        |                              C                                                                               
 2624   2 *          |   UNDO IF (LINEP .EQ. NLINES)                                                                                
                     <----                                                                                                          
                     |  +-----------------------------------------------------------------------------------------------------------
 2625   2 *          |  |DO FOR I=LINEP+1,NLINES                                                                                    
 2626   3            |  |   CALL SYS$CANCEL(%VAL(INCHAN))                                                                           
 2627   3 *          |  |   IF (FIRST)                                                                                              
 2628   4            |  |      FIRST = .FALSE.                                                                                      
                     |  |     +-----------------------------------------------------------------------------------------------------
 2629   4 *          |  |     |DO FOR J=PAGLEN+1,COMLIN                                                                             
 2630   5            |  |     |   CALL LIB$ERASE_LINE(J,1)                                                                          
 2631   4 *          |  |     |END DO FOR                                                                                           
                     |  |     +-----------------------------------------------------------------------------------------------------
 2632   4 *          |  |      IF (LENLMT .LT. 0)                                                                                   
 2633   5 *          |  |         IF (LINLEN(I) .LE. -LENLMT)                                                                       
 2634   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)                                           
 2635   5 *          |  |         ELSE                                                                                              
 2636   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                 
 2637            1   |  |                  LINES(I)(1-LENLMT:LINLEN(I)),PAGLEN+1,1)                                                 
 2638   5 *          |  |         ENDIF                                                                                             
 2639   4 *          |  |      ELSE                                                                                                 
 2640   5 *          |  |         IF (LINLEN(I) .GT. LENLMT)                                                                        
 2641   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),PAGLEN+1,1)                                              
 2642   5 *          |  |         ELSE                                                                                              
 2643   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)                                           
 2644   5 *          |  |         ENDIF                                                                                             
 2645   4 *          |  |      ENDIF                                                                                                
 2646   3 *          |  |   ELSE                                                                                                    
 2647   4 *          |  |      IF (SECOND)                                                                                          
 2648   5            |  |         SECOND = .FALSE.                                                                                  
 2649   5            |  |         IF (LENLMT .LT. 0 .AND. LINLEN(I) .GT. (-LENLMT))                                                 
 2650            1   |  |               CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                                                          
 2651   4 *          |  |      ELSE                                                                                                 
 2652   5            |  |         CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                                                                
 2653   4 *          |  |      ENDIF                                                                                                
 2654   4 *          |  |      IF (LENLMT .LT. 0)                                                                                   
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   77


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2655   5 *          |  |         IF (LINLEN(I) .LE. -LENLMT)                                                                       
 2656   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)                                             
 2657   5 *          |  |         ELSE                                                                                              
 2658   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                 
 2659            1   |  |                  LINES(I)(1-LENLMT:LINLEN(I)),COMLIN,1)                                                   
 2660   5 *          |  |         ENDIF                                                                                             
 2661   4 *          |  |      ELSE                                                                                                 
 2662   5 *          |  |         IF (LINLEN(I) .GT. LENLMT)                                                                        
 2663   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),COMLIN,1)                                                
 2664   5 *          |  |         ELSE                                                                                              
 2665   6            |  |            CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)                                             
 2666   5 *          |  |         ENDIF                                                                                             
 2667   4 *          |  |      ENDIF                                                                                                
 2668   3 *          |  |   ENDIF                                                                                                   
 2669   3            |  |   CALL LIB$SET_CURSOR(1,1)                                                                                
 2670   3 *          |  |   EXECUTE (WAIT_FOR_SCROLL_AST)                                                                           
 2671   3 *          |  |   IF (STOPIT)                                                                                             
 2672   4            |  |      PAGEND = I                                                                                           
 2673   4 *          |  |      EXECUTE (GET_START_LINE)                                                                             
 2674   4 *          |  |      IF (.NOT.FIRST)                                                                                      
 2675   5            |  |         CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                                                                
 2676   5            |  |         IF (PAGLEN .EQ. (COMLIN - 2))                                                                     
 2677            1   |  |               CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                                                          
 2678   5            |  |         CALL LIB$SET_CURSOR(1,1)                                                                          
 2679   4 *          |  |      ENDIF                                                                                                
 2680   4 *          |  |      EXECUTE (WRITE_BLOCK_NUMBER)                                                                         
 2681   4 *          |  |      EXECUTE (FREE_FLAGS_EXIT)                                                                            
 2682   4            |  |      RETURN                                                                                               
              <-----------------                                                                                                    
 2683   3 *          |  |   ENDIF                                                                                                   
 2684   2 *          |  |END DO FOR                                                                                                 
                     |  +-----------------------------------------------------------------------------------------------------------
 2685       C        |                              C                                                                               
 2686       C        |                              C***   Input to line buffer                                                     
 2687       C        |                              C                                                                               
 2688       C        |                              C                                                                               
 2689       C        |                              C---   End of file                                                              
 2690       C        |                              C                                                                               
 2691   2 *          |   IF (BLK .GT. EBK)                                                                                          
 2692   3            |      PAGEND = NLINES                                                                                         
 2693   3 *          |      EXECUTE (GET_START_LINE)                                                                                
 2694   3            |      CALL SYS$CANCEL(%VAL(INCHAN))                                                                           
 2695   3 *          |      IF (.NOT.FIRST)                                                                                         
 2696   4            |         CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                                                                   
 2697   4            |         CALL LIB$SET_CURSOR(1,1)                                                                             
 2698   3 *          |      ENDIF                                                                                                   
 2699   3 *          |      EXECUTE (WRITE_BLOCK_NUMBER)                                                                            
 2700   3 *          |      EXECUTE (FREE_FLAGS_EXIT)                                                                               
 2701   3            |      RETURN                                                                                                  
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   78


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

              <--------------                                                                                                       
 2702   2 *          |   ENDIF                                                                                                      
 2703   2 *          |   IF (BLK .LT. (EBK - 6))                                                                                    
 2704       C        |                              C                                                                               
 2705       C        |                              C---   Not near the end of the file                                             
 2706       C        |                              C                                                                               
 2707   3            |      CALL BLKSIN(BLK,I,BUFFER(NBUF+1))                                                                       
 2708   3 *          |      IF (I .EQ. 0)                                                                                           
 2709   4 *          |         EXECUTE (READ_ERROR)                                                                                 
 2710   3 *          |      ENDIF                                                                                                   
 2711   2 *          |   ELSE                                                                                                       
 2712       C        |                              C                                                                               
 2713       C        |                              C---   Near the end of the file                                                 
 2714       C        |                              C                                                                               
 2715   3            |      I = 0                                                                                                   
                     |     +--------------------------------------------------------------------------------------------------------
 2716   3 *          |     |DO FOR J=BLK,EBK                                                                                        
 2717   4            |     |   CALL BLKIN(BLK,II,BUFFER(NBUF+I+1))                                                                  
 2718   4 *          |     |   IF (II .EQ. 0)                                                                                       
 2719   5 *          |     |      EXECUTE (READ_ERROR)                                                                              
 2720   4 *          |     |   ENDIF                                                                                                
 2721   4            |     |   I = I + II                                                                                           
 2722   3 *          |     |END DO FOR                                                                                              
                     |     +--------------------------------------------------------------------------------------------------------
 2723   2 *          |   ENDIF                                                                                                      
 2724   2            |   NBUF = NBUF + I                                                                                            
 2725   2            |   LINEP = NLINES                                                                                             
 2726   2            |   PBUF = 1                                                                                                   
 2727   2            |   CALL LINCON(.FALSE.)                                                                                       
 2728   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 2729     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   79


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2730     *        PROCEDURE (FREE_FLAGS_EXIT)                                                                                      
 2731       C                                       CP    This routine exits from scrolling.  It frees the event flags, cancels     
 2732       C                                       CP    any input requests to the terminal, resets the LEDs (#3 off) and          
 2733       C                                       CP    returns.                                                                  
 2734   1 *           EXECUTE (CANCEL_STOPPER)                                                                                      
 2735   1             CALL LIB$FREE_EF(TIMFLG)                                                                                      
 2736   1 *           EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                                 
 2737     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   80


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2738     *        PROCEDURE (GET_LAST_LINE)                                                                                        
 2739       C                                       CP    This procedure determines PAGEND given LINEP                              
 2740   1             OLDEND = PAGEND                                                                                               
 2741   1 *           IF (LENLMT .LT. 0)                                                                                            
 2742   2                I = PAGLEN                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2743   2 *             |DO FOR PAGEND=LINEP,LINEP+PAGLEN                                                                           
 2744   3               |   I = I + (LINLEN(PAGEND) - 1)/LENLMT - 1                                                                 
 2745   3 *             |   UNDO IF (I .LE. 0)                                                                                      
                        <----                                                                                                       
 2746   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2747   1 *           ELSE                                                                                                          
 2748   2                PAGEND = LINEP + PAGLEN - 1                                                                                
 2749   1 *           ENDIF                                                                                                         
 2750     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   81


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2751     *        PROCEDURE (GET_START_LINE)                                                                                       
 2752       C                                       CP    This procedure determines LINEP given a value for PAGEND                  
 2753   1 *           IF (LENLMT .LT. 0)                                                                                            
 2754   2                I = PAGLEN                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2755   2 *             |DO FOR LINEP=PAGEND,PAGEND-PAGLEN,-1                                                                       
 2756   3               |   I = I + (LINLEN(LINEP) - 1)/LENLMT - 1                                                                  
 2757   3 *             |   UNDO IF (I .LE. 0)                                                                                      
                        <----                                                                                                       
 2758   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2759   1 *           ELSE                                                                                                          
 2760   2                LINEP = PAGEND - PAGLEN + 1                                                                                
 2761   1 *           ENDIF                                                                                                         
 2762     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   82


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2763     *        PROCEDURE (HIT_BEGINNING)                                                                                        
 2764       C                                       CP    This procedure is executed if the position goes past the beginning        
 2765       C                                       CP    of the file.  Everything is reset to the beginning of the file.           
 2766   1             BLK = 1                                                                                                       
 2767   1 *           EXECUTE (INPUT_SEVEN_BLOCKS)                                                                                  
 2768   1             CALL LINCON(.TRUE.)                                                                                           
 2769   1             LINEP = 1                                                                                                     
 2770     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   83


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2771     *        PROCEDURE (HOLD_CURRENT_SETUP)                                                                                   
 2772       C                                       CP    This routine is used in searches.  It holds all the information           
 2773       C                                       CP    needed to recreate the current position and array conditions.             
                     +--------------------------------------------------------------------------------------------------------------
 2774   1 *          |DO FOR I=1,NLINES                                                                                             
 2775   2            |   HLIN(I) = LINES(I)                                                                                         
 2776   2            |   HLINLN(I) = LINLEN(I)                                                                                      
 2777   2            |   HCCLIN(1,I) = CCLINE(1,I)                                                                                  
 2778   2            |   HCCLIN(2,I) = CCLINE(2,I)                                                                                  
 2779   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 2780   1             HLINES = NLINES                                                                                               
 2781   1             HLINEP = LINEP                                                                                                
 2782   1 *           IF (NBUF .NE. 0)                                                                                              
                        +-----------------------------------------------------------------------------------------------------------
 2783   2 *             |DO FOR I=1,NBUF                                                                                            
 2784   3               |   HBUFER(I) = BUFFER(I)                                                                                   
 2785   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 2786   1 *           ENDIF                                                                                                         
 2787   1             HPBUF = PBUF                                                                                                  
 2788   1             HNBUF = NBUF                                                                                                  
 2789   1             HBLK = BLK                                                                                                    
 2790   1             HSBLK = SBLK                                                                                                  
 2791   1             HLBLK = LBLK                                                                                                  
 2792   1             HLPBUF = LPBUF                                                                                                
 2793   1 *           EXECUTE (QUEUE_STOPPER)                                                                                       
 2794     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   84


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2795     *        PROCEDURE (HOME_PLUS_LEDS_EXIT)                                                                                  
 2796       C                                       CP    This routine homes the cursor, resets the LEDs (#3 off).                  
 2797   1 *           IF (VT100)                                                                                                    
 2798   2                CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0q',1,1)                                                                  
 2799   2                IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                                                             
 2800            1             CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                                                                
 2801   2                IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')                                                   
 2802   1 *           ELSE                                                                                                          
 2803   2                CALL LIB$SET_CURSOR(1,1)                                                                                   
 2804   1 *           ENDIF                                                                                                         
 2805     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   85


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2806     *        PROCEDURE (INPUT_SEVEN_BLOCKS)                                                                                   
 2807       C                                       CP    This procedure inputs seven blocks of data                                
 2808   1 *           IF (BLK .LT. (EBK - 6))                                                                                       
 2809       C                                       C                                                                               
 2810       C                                       C***   Not near the end of the file                                             
 2811       C                                       C                                                                               
 2812   2                SBLK = BLK                                                                                                 
 2813   2                CALL BLKSIN(BLK,NBUF,BUFFER)                                                                               
 2814   2 *              IF (NBUF .EQ. 0)                                                                                           
 2815   3 *                 EXECUTE (READ_ERROR)                                                                                    
 2816   2 *              ENDIF                                                                                                      
 2817   1 *           ELSE                                                                                                          
 2818       C                                       C                                                                               
 2819       C                                       C***   Near the end of the file                                                 
 2820       C                                       C                                                                               
 2821   2                BLK = EBK - 6                                                                                              
 2822   2 *              IF (BLK .GT. 0)                                                                                            
 2823   3                   SBLK = BLK                                                                                              
 2824   3                   CALL BLKSIN(BLK,NBUF,BUFFER)                                                                            
 2825   3 *                 IF (NBUF .EQ. 0)                                                                                        
 2826   4 *                    EXECUTE (READ_ERROR)                                                                                 
 2827   3 *                 ENDIF                                                                                                   
 2828   2 *              ELSE                                                                                                       
 2829       C                                       C                                                                               
 2830       C                                       C***   Do this if file size is < 7 blocks                                       
 2831       C                                       C                                                                               
 2832   3                   BLK = 1                                                                                                 
 2833   3                   SBLK = 1                                                                                                
 2834   3                   NBUF = 0                                                                                                
                           +--------------------------------------------------------------------------------------------------------
 2835   3 *                |DO FOR I=BLK,EBK                                                                                        
 2836   4                  |   CALL BLKIN(BLK,J,BUFFER(NBUF+1))                                                                     
 2837   4 *                |   IF (J .EQ. 0)                                                                                        
 2838   5 *                |      EXECUTE (READ_ERROR)                                                                              
 2839   4 *                |   ENDIF                                                                                                
 2840   4                  |   NBUF = NBUF + J                                                                                      
 2841   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 2842   2 *              ENDIF                                                                                                      
 2843   1 *           ENDIF                                                                                                         
 2844     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   86


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2845     *        PROCEDURE (JUMP_LINES)                                                                                           
 2846       C                                       CP    This procedure moves the current position NUMBER lines.                   
 2847   1 *           IF ((NUMBER + LINEP) .GT. (NLINES - PAGLEN + 1))                                                              
 2848       C                                       C                                                                               
 2849       C                                       C***   Big jumps forward                                                        
 2850       C                                       C                                                                               
 2851   2                SECOND = .FALSE.                                                                                           
                        +-----------------------------------------------------------------------------------------------------------
 2852   2 *             |DO FOREVER                                                                                                 
 2853   3 *             |   IF (BLK .GT. EBK)                                                                                       
 2854   4               |      LINEP = NLINES - PAGLEN + 1                                                                          
 2855   4               |      IF (LINEP .LT. 1) LINEP = 1                                                                          
 2856   4               |      JNUMB = NUMBER                                                                                       
 2857   4 *             |      UNDO                                                                                                 
                        <-------                                                                                                    
 2858   3 *             |   ENDIF                                                                                                   
 2859   3               |   CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                                        
 2860   3 *             |   IF (I .EQ. 0)                                                                                           
 2861   4 *             |      EXECUTE (READ_ERROR)                                                                                 
 2862   3 *             |   ENDIF                                                                                                   
 2863   3               |   NBUF = NBUF + I                                                                                         
 2864   3               |   PBUF = 1                                                                                                
 2865   3               |   CALL LINCON(.FALSE.)                                                                                    
 2866   3 *             |   IF (STOPIT)                                                                                             
 2867   4 *             |      EXECUTE (CANCEL_COMMAND)                                                                             
 2868   3 *             |   ENDIF                                                                                                   
 2869   3 *             |   IF ((LINEP + NUMBER) .LE. (NLINES - PAGLEN + 1))                                                        
 2870   4               |      LINEP = LINEP + NUMBER                                                                               
 2871   4 *             |      UNDO                                                                                                 
                        <-------                                                                                                    
 2872   3 *             |   ENDIF                                                                                                   
 2873   3 *             |   IF ((NLINES - LINEP) .GE. (600 - 100))                                                                  
 2874   4               |      SECOND = .TRUE.                                                                                      
 2875   4               |      NUMBER = NUMBER - NLINES + LINEP - 1                                                                 
 2876   4               |      LINEP = NLINES                                                                                       
 2877   3 *             |   ENDIF                                                                                                   
 2878   2 *             |END DO FOREVER                                                                                             
                        +-----------------------------------------------------------------------------------------------------------
 2879   2                IF (SECOND) NUMBER = 25                                                                                    
 2880   1 *           ELSE                                                                                                          
 2881   2 *              IF ((NUMBER + LINEP) .LE. 0)                                                                               
 2882       C                                       C                                                                               
 2883       C                                       C***   Big jumps backward                                                       
 2884       C                                       C                                                                               
 2885   3                   NUMBER = -(NUMBER + LINEP)                                                                              
 2886   3                   INUMBR = 1 - LINEP                                                                                      
 2887   3 *                 IF (RFM .EQ. 1 .AND. RAT .NE. 2 .AND. RAT .NE. -2)                                                      
 2888       C                                       C                                                                               
 2889       C                                       C---   Fixed record length with no carriage-control                             
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   87


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2890       C                                       C                                                                               
 2891   4 *                    IF (RAT .LT. 0)                                                                                      
 2892       C                                       C===   No spanned                                                               
 2893   5                         BLK = SBLK - NUMBER*IFSZ/RECBLK - 1                                                               
 2894   5                         J = RECBLK/IFSZ - NUMBER + (SBLK-BLK-1)*RECBLK/IFSZ                                               
 2895   4 *                    ELSE                                                                                                 
 2896       C                                       C===   Spanned                                                                  
 2897   5                         I = 512*(CCLINE(1,1) - 1) + CCLINE(2,1) -                                                         
 2898            1                      IFSZ*NUMBER                                                                                 
 2899   5                         J = LIB$EXTZV(0,8,I)                                                                              
 2900   5                         IF (J .EQ. 0) J = 512                                                                             
 2901   5                         BLK = I/512 + 1                                                                                   
 2902   4 *                    ENDIF                                                                                                
 2903   4 *                    IF (STOPIT)                                                                                          
 2904   5 *                       EXECUTE (CANCEL_COMMAND)                                                                          
 2905   4 *                    ENDIF                                                                                                
 2906   4 *                    IF (BLK .LE. 0)                                                                                      
 2907   5                         BLK = 1                                                                                           
 2908   5                         J = 1                                                                                             
 2909   4 *                    ENDIF                                                                                                
 2910       C                                       C===   Input lines                                                              
 2911   4 *                    EXECUTE (INPUT_SEVEN_BLOCKS)                                                                         
 2912   4                      CALL LINCON(.TRUE.)                                                                                  
 2913   4                      LINEP = J                                                                                            
 2914   4                      NUMBER = 25                                                                                          
 2915   3 *                 ELSE                                                                                                    
 2916       C                                       C                                                                               
 2917       C                                       C---   Variable length records and/or carriage-control                          
 2918       C                                       C                                                                               
                              +-----------------------------------------------------------------------------------------------------
 2919   4 *                   |DO FOR I=1,NLINES                                                                                    
 2920   5 *                   |   UNDO IF (CCLINE(1,I) .NE. 0)                                                                      
                              <----                                                                                                 
 2921   4 *                   |END DO FOR                                                                                           
                              +-----------------------------------------------------------------------------------------------------
 2922   4                      BLK = CCLINE(1,I)                                                                                    
 2923   4                      PBUF = CCLINE(2,I)                                                                                   
 2924   4                      CALL BLKIN(BLK,NBUF,BUFFER)                                                                          
 2925   4 *                    IF (NBUF .EQ. 0)                                                                                     
 2926   5 *                       EXECUTE (READ_ERROR)                                                                              
 2927   4 *                    ENDIF                                                                                                
                              +-----------------------------------------------------------------------------------------------------
 2928   4 * 1810              |DO                                                                                                   
 2929   5                     |   SECOND = .TRUE.                                                                                   
                              |  +--------------------------------------------------------------------------------------------------
 2930   5 * 1820              |  |DO FOREVER                                                                                        
 2931   6 *                   |  |   IF (NUMBER .LT. 0)                                                                             
 2932   7                     |  |      NUMBER = 25                                                                                 
 2933   7 *                   |  |      UNDO                                                                                        
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   88


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                              |  <-------                                                                                           
 2934   6 *                   |  |   ENDIF                                                                                          
 2935   6 *                   |  |   IF (RFM .EQ. 1)                                                                                
 2936       C                 |  |                  C                                                                               
 2937       C                 |  |                  C===  Fixed length records (must have carriage-control)                         
 2938       C                 |  |                  C                                                                               
 2939   7                     |  |      PBUF = PBUF - IFSZ                                                                          
 2940   7 *                   |  |      IF (PBUF .LT. 1)                                                                            
 2941   8                     |  |         BLK = BLK - 2                                                                            
 2942   8 *                   |  |         IF (BLK .LE. 0)                                                                          
 2943   9 *                   |  |            EXECUTE (HIT_BEGINNING)                                                               
 2944   9 *                   |  |            IF (SECOND)                                                                           
 2945  10                     |  |               NUMBER = INUMBR                                                                    
 2946   9 *                   |  |            ELSE                                                                                  
 2947  10                     |  |               NUMBER = 25                                                                        
 2948   9 *                   |  |            ENDIF                                                                                 
 2949   9 *                   |  |            UNDO 1810                                                                             
                              <----------------                                                                                     
 2950   8 *                   |  |         ENDIF                                                                                    
 2951   8                     |  |         CALL BLKIN(BLK,NBUF,BUFFER)                                                              
 2952   8 *                   |  |         IF (NBUF .EQ. 0)                                                                         
 2953   9 *                   |  |            EXECUTE (READ_ERROR)                                                                  
 2954   8 *                   |  |         ENDIF                                                                                    
 2955   8                     |  |         SECOND = .FALSE.                                                                         
 2956   8                     |  |         PBUF = PBUF + NBUF                                                                       
 2957   7 *                   |  |      ENDIF                                                                                       
 2958   7 *                   |  |      IF (BUFFER(PBUF) .EQ. '1')                                                                  
 2959   8                     |  |         NUMBER = NUMBER - 3                                                                      
 2960   7 *                   |  |      ELSE                                                                                        
 2961   8 *                   |  |         IF (BUFFER(PBUF) .EQ. '0')                                                               
 2962   9                     |  |            NUMBER = NUMBER - 2                                                                   
 2963   8 *                   |  |         ELSE                                                                                     
 2964   9                     |  |            NUMBER = NUMBER - 1                                                                   
 2965   8 *                   |  |         ENDIF                                                                                    
 2966   7 *                   |  |      ENDIF                                                                                       
 2967   6 *                   |  |   ELSE                                                                                           
 2968       C                 |  |                  C                                                                               
 2969       C                 |  |                  C===   Variable length records                                                  
 2970       C                 |  |                  C                                                                               
                              |  |     +--------------------------------------------------------------------------------------------
 2971   7 *                   |  |     |DO FOREVER                                                                                  
                              |  |     |  +-----------------------------------------------------------------------------------------
 2972   8 *                   |  |     |  |DO FOR I=PBUF-1,2,-1                                                                     
 2973   9 *                   |  |     |  |   IF (.NOT.I)                                                                           
 2974  10 *                   |  |     |  |      IF (BUFFER(I) .EQ. 0)                                                              
 2975  11                     |  |     |  |         J = LIB$EXTZV(0,8,BUFFER(I-1))                                                  
 2976  11 *                   |  |     |  |         IF (J .LE. LRL)                                                                 
 2977  12                     |  |     |  |            IF (J) J = J + 1                                                             
 2978  12 *                   |  |     |  |            IF (BUFFER(I+J+2) .EQ. 0)                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   89


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 2979  13 *                   |  |     |  |               IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                          
 2980  14 *                   |  |     |  |               IF (BUFFER(I+FSZ+1) .EQ. '1')                                             
 2981  15                     |  |     |  |               NUMBER = NUMBER - 3                                                       
 2982  14 *                   |  |     |  |               ELSE                                                                      
 2983  15 *                   |  |     |  |               IF (BUFFER(I+FSZ+1) .EQ. '0')                                             
 2984  16                     |  |     |  |               NUMBER = NUMBER - 2                                                       
 2985  15 *                   |  |     |  |               ELSE                                                                      
 2986  16                     |  |     |  |               NUMBER = NUMBER - 1                                                       
 2987  15 *                   |  |     |  |               ENDIF                                                                     
 2988  14 *                   |  |     |  |               ENDIF                                                                     
 2989  13 *                   |  |     |  |               ELSE                                                                      
 2990  14                     |  |     |  |               NUMBER = NUMBER - 1                                                       
 2991  14 *                   |  |     |  |               IF (RAT .EQ. 3 .OR. RAT .EQ. -3)                                          
 2992  15                     |  |     |  |               IF (LIB$EXTZV(7,1,BUFFER(I+1)) .EQ. 0)                                    
 2993            1            |  |     |  |               NUMBER = NUMBER -                                                         
 2994            2            |  |     |  |               LIB$EXTZV(0,7,BUFFER(I+1))                                                
 2995  15                     |  |     |  |               IF (LIB$EXTZV(7,1,BUFFER(I+2)) .EQ. 0)                                    
 2996            1            |  |     |  |               NUMBER = NUMBER -                                                         
 2997            2            |  |     |  |               LIB$EXTZV(0,7,BUFFER(I+2))                                                
 2998  14 *                   |  |     |  |               ENDIF                                                                     
 2999  13 *                   |  |     |  |               ENDIF                                                                     
 3000  13                     |  |     |  |               PBUF = I - 1                                                              
 3001  13 *                   |  |     |  |               CYCLE 1820                                                                
                              |  |<------------------------                                                                         
 3002  12 *                   |  |     |  |            ENDIF                                                                        
 3003  11 *                   |  |     |  |         ENDIF                                                                           
 3004  10 *                   |  |     |  |      ENDIF                                                                              
 3005   9 *                   |  |     |  |   ENDIF                                                                                 
 3006   9 *                   |  |     |  |   IF (STOPIT)                                                                           
 3007  10 *                   |  |     |  |      EXECUTE (CANCEL_COMMAND)                                                           
 3008   9 *                   |  |     |  |   ENDIF                                                                                 
 3009   8 *                   |  |     |  |END DO FOR                                                                               
                              |  |     |  +-----------------------------------------------------------------------------------------
 3010       C                 |  |     |            C===  New block                                                                 
                              |  |     |  +-----------------------------------------------------------------------------------------
 3011   8 *                   |  |     |  |DO FOR I=1,150                                                                           
 3012   9                     |  |     |  |   CAPBUF(I) = BUFFER(I)                                                                 
 3013   8 *                   |  |     |  |END DO FOR                                                                               
                              |  |     |  +-----------------------------------------------------------------------------------------
 3014   8                     |  |     |   BLK = BLK - 2                                                                            
 3015   8 *                   |  |     |   IF (BLK .LE. 0)                                                                          
 3016   9 *                   |  |     |      IF (SECOND)                                                                           
 3017  10                     |  |     |         NUMBER = INUMBR                                                                    
 3018   9 *                   |  |     |      ELSE                                                                                  
 3019  10                     |  |     |         NUMBER = 25                                                                        
 3020   9 *                   |  |     |      ENDIF                                                                                 
 3021   9 *                   |  |     |      EXECUTE (HIT_BEGINNING)                                                               
 3022   9 *                   |  |     |      UNDO 1810                                                                             
                              <----------------                                                                                     
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   90


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3023   8 *                   |  |     |   ENDIF                                                                                    
 3024   8                     |  |     |   CALL BLKIN(BLK,PBUF,BUFFER)                                                              
 3025   8 *                   |  |     |   IF (PBUF .EQ. 0)                                                                         
 3026   9 *                   |  |     |      EXECUTE (READ_ERROR)                                                                  
 3027   8 *                   |  |     |   ENDIF                                                                                    
 3028   8                     |  |     |   SECOND = .FALSE.                                                                         
                              |  |     |  +-----------------------------------------------------------------------------------------
 3029   8 *                   |  |     |  |DO FOR I=1,150                                                                           
 3030   9                     |  |     |  |   BUFFER(PBUF+I) = CAPBUF(I)                                                            
 3031   8 *                   |  |     |  |END DO FOR                                                                               
                              |  |     |  +-----------------------------------------------------------------------------------------
 3032   7 *                   |  |     |END DO FOREVER                                                                              
                              |  |     +--------------------------------------------------------------------------------------------
 3033   6 *                   |  |   ENDIF                                                                                          
 3034   5 *                   |  |END DO FOREVER                                                                                    
                              |  +--------------------------------------------------------------------------------------------------
 3035   5                     |   BLK = BLK - 1                                                                                     
 3036   5                     |   J = PBUF                                                                                          
 3037   5 *                   |   EXECUTE (INPUT_SEVEN_BLOCKS)                                                                      
 3038   5                     |   CALL LINCON(.TRUE.)                                                                               
                              |  +--------------------------------------------------------------------------------------------------
 3039   5 *                   |  |DO FOR I=1,NLINES                                                                                 
 3040   6 *                   |  |   IF (CCLINE(1,I) .EQ. SBLK .AND. CCLINE(2,I) .EQ. J)                                            
 3041   7                     |  |      LINEP = I                                                                                   
 3042   7 *                   |  |      UNDO                                                                                        
                              |  <-------                                                                                           
 3043   6 *                   |  |   ENDIF                                                                                          
 3044   5 *                   |  |END DO FOR                                                                                        
                              |  +--------------------------------------------------------------------------------------------------
 3045   4 *                   |END DO                                                                                               
                              +-----------------------------------------------------------------------------------------------------
 3046   3 *                 ENDIF                                                                                                   
 3047   2 *              ELSE                                                                                                       
 3048       C                                       C                                                                               
 3049       C                                       C---   Jumps within the stored buffer                                           
 3050       C                                       C                                                                               
 3051   3                   LINEP = LINEP + NUMBER                                                                                  
 3052   2 *              ENDIF                                                                                                      
 3053   1 *           ENDIF                                                                                                         
 3054   1 *           EXECUTE (CANCEL_STOPPER)                                                                                      
 3055     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   91


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3056     *        PROCEDURE (OUTPUT_RANGE)                                                                                         
 3057       C                                       CP    This procedure performs the output for the print, list, and append        
 3058       C                                       CP    commands.  Which is being used is determined by the value of PRINT        
 3059       C                                       CP    (-1 = print, 0 = append, 1 = list).                                       
 3060       C                                       C                                                                               
 3061       C                                       C---   Open printer output file                                                 
 3062       C                                       C                                                                               
 3063   1             CALL PRTOPN(PRINT)                                                                                            
 3064   1 *           IF (PRINT .EQ. 47)                                                                                            
 3065   2 *              EXECUTE (ERROR_EXIT)                                                                                       
 3066   1 *           ENDIF                                                                                                         
 3067   1 *           EXECUTE (HOLD_CURRENT_SETUP)                                                                                  
 3068       C                                       C                                                                               
 3069       C                                       C---   Point to right place                                                     
 3070       C                                       C                                                                               
 3071   1 *           IF (NUMFLG)                                                                                                   
 3072   2                NUMBER = DIRECT*ANUMB                                                                                      
 3073   2                RFLAG = .FALSE.                                                                                            
 3074   1 *           ELSE                                                                                                          
 3075   2 *              IF (RANGE(1,2) .EQ. 0)                                                                                     
 3076   3                   NUMBER = PAGLEN                                                                                         
 3077   3                   RFLAG = .FALSE.                                                                                         
 3078   2 *              ELSE                                                                                                       
 3079   3                   RFLAG = .TRUE.                                                                                          
 3080   2 *              ENDIF                                                                                                      
 3081   1 *           ENDIF                                                                                                         
 3082   1 *           IF (RFLAG)                                                                                                    
 3083   2 *              IF (RANGE(1,1) .LT. RANGE(1,2) .OR. (RANGE(1,1) .EQ.                                                       
 3084            1             RANGE(1,2) .AND. RANGE(2,1) .LE. RANGE(2,2)))                                                        
 3085   3                   BLK = RANGE(1,1)                                                                                        
 3086   3                   PBUF = RANGE(2,1)                                                                                       
 3087   3                   IENDPB = RANGE(1,2)                                                                                     
 3088   3                   IENDPP = RANGE(2,2)                                                                                     
 3089   2 *              ELSE                                                                                                       
 3090   3                   BLK = RANGE(1,2)                                                                                        
 3091   3                   PBUF = RANGE(2,2)                                                                                       
 3092   3                   IENDPB = RANGE(1,1)                                                                                     
 3093   3                   IENDPP = RANGE(2,1)                                                                                     
 3094   2 *              ENDIF                                                                                                      
 3095   2                SBLK = BLK                                                                                                 
 3096   2                CALL BLKIN(BLK,NBUF,BUFFER)                                                                                
 3097   2 *              IF (NBUF .EQ. 0)                                                                                           
 3098   3 *                 EXECUTE (READ_ERROR)                                                                                    
 3099   2 *              ENDIF                                                                                                      
 3100   1 *           ELSE                                                                                                          
 3101   2 *              IF (NUMBER .LT. 0)                                                                                         
 3102   3                   INUMB = NUMBER                                                                                          
 3103   3 *                 EXECUTE (FIND_NON_CC_LINE)                                                                              
 3104   3                   IENDPB = CCLINE(1,I)                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   92


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3105   3                   IENDPP = CCLINE(2,I)                                                                                    
 3106   3 *                 EXECUTE (JUMP_LINES)                                                                                    
 3107   3                   NUMBER = -1000                                                                                          
 3108   2 *              ENDIF                                                                                                      
 3109   2 *              EXECUTE (FIND_NON_CC_LINE)                                                                                 
 3110   2                BLK = CCLINE(1,I)                                                                                          
 3111   2                PBUF = CCLINE(2,I)                                                                                         
 3112   2                SBLK = BLK                                                                                                 
 3113   2                CALL BLKIN(BLK,NBUF,BUFFER)                                                                                
 3114   2 *              IF (NBUF .EQ. 0)                                                                                           
 3115   3 *                 EXECUTE (READ_ERROR)                                                                                    
 3116   2 *              ENDIF                                                                                                      
 3117   1 *           ENDIF                                                                                                         
 3118   1             IBLK = SBLK                                                                                                   
 3119       C                                       C                                                                               
 3120       C                                       C---   Print loop                                                               
 3121       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 3122   1 *          |DO FOREVER                                                                                                    
 3123   2 *          |   IF (STOPIT)                                                                                                
 3124   3            |      CALL PRTCLS(STOPIT)                                                                                     
 3125   3 *          |      EXECUTE (RESTORE_HELD_SETUP)                                                                            
 3126   3 *          |      EXECUTE (FREE_FLAGS_EXIT)                                                                               
 3127   3            |      RETURN                                                                                                  
              <--------------                                                                                                       
 3128   2 *          |   ENDIF                                                                                                      
 3129   2 *          |   IF (RFM .EQ. 1)                                                                                            
 3130   3            |      I = FSZ                                                                                                 
 3131   2 *          |   ELSE                                                                                                       
 3132   3            |      I = LIB$EXTZV(0,8,BUFFER(PBUF))                                                                         
 3133   2 *          |   ENDIF                                                                                                      
 3134   2 *          |   IF (I)                                                                                                     
 3135   3            |      K = 1                                                                                                   
 3136   2 *          |   ELSE                                                                                                       
 3137   3            |      K = 0                                                                                                   
 3138   2 *          |   ENDIF                                                                                                      
 3139   2 *          |   IF ((PBUF + I + K - 1) .GT. NBUF .OR. (RFM .NE. 1 .AND.                                                    
 3140            1   |         (PBUF + K + I + 1) .GT. NBUF))                                                                       
 3141   3 *          |      UNDO IF (BLK .GT. EBK)                                                                                  
                     <-------                                                                                                       
                     |     +--------------------------------------------------------------------------------------------------------
 3142   3 *          |     |DO FOR J=PBUF,NBUF                                                                                      
 3143   4            |     |   BUFFER(J-PBUF+1) = BUFFER(J)                                                                         
 3144   3 *          |     |END DO FOR                                                                                              
                     |     +--------------------------------------------------------------------------------------------------------
 3145   3            |      IBLK = BLK                                                                                              
 3146   3            |      CALL BLKIN(BLK,J,BUFFER(NBUF-PBUF+2))                                                                   
 3147   3 *          |      IF (J .EQ. 0)                                                                                           
 3148   4 *          |         EXECUTE (READ_ERROR)                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   93


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3149   3 *          |      ENDIF                                                                                                   
 3150   3 *          |      IF (PBUF .GT. NBUF .AND. RFM .NE. 1)                                                                    
 3151   4            |         I = LIB$EXTZV(0,8,BUFFER(1))                                                                         
 3152   4 *          |         IF (I)                                                                                               
 3153   5            |            K = 1                                                                                             
 3154   4 *          |         ELSE                                                                                                 
 3155   5            |            K = 0                                                                                             
 3156   4 *          |         ENDIF                                                                                                
 3157   3 *          |      ENDIF                                                                                                   
 3158   3            |      INDSFT = PBUF - NBUF - 1                                                                                
 3159   3            |      NBUF = NBUF - PBUF + J + 1                                                                              
 3160   3            |      PBUF = 1                                                                                                
 3161   2 *          |   ENDIF                                                                                                      
 3162   2            |   J = PBUF + INDSFT                                                                                          
 3163   2 *          |   IF (RFM .NE. 1)                                                                                            
 3164   3            |      PBUF = PBUF + 2 + FSZ                                                                                   
 3165   3            |      I = I - FSZ                                                                                             
 3166   2 *          |   ENDIF                                                                                                      
 3167   2 *          |   IF (.NOT.RFLAG)                                                                                            
 3168   3 *          |      IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                                        
 3169   4 *          |         IF (BUFFER(PBUF) .EQ. '0')                                                                           
 3170   5            |            NUMBER = NUMBER - 1                                                                               
 3171   4 *          |         ELSE                                                                                                 
 3172   5            |            IF (BUFFER(PBUF) .EQ. '1') NUMBER = NUMBER - 2                                                    
 3173   4 *          |         ENDIF                                                                                                
 3174   3 *          |      ELSE                                                                                                    
 3175   4 *          |         IF (RAT .EQ. 3 .OR. RAT .EQ. -3)                                                                     
 3176   5            |            IF (LIB$EXTZV(7,1,BUFFER(PBUF-2)) .EQ. 0)                                                         
 3177            1   |                  NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-2))                                             
 3178   5            |            IF (LIB$EXTZV(7,1,BUFFER(PBUF-1)) .EQ. 0)                                                         
 3179            1   |                  NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-1))                                             
 3180   4 *          |         ENDIF                                                                                                
 3181   3 *          |      ENDIF                                                                                                   
 3182   2 *          |   ENDIF                                                                                                      
 3183   2            |   CALL PRTOUT(I,BUFFER(PBUF))                                                                                
 3184   2            |   IF (.NOT.RFLAG) NUMBER = NUMBER - 1                                                                        
 3185   2            |   PBUF = PBUF + I + K                                                                                        
 3186   2 *          |   UNDO IF ((.NOT.RFLAG .AND. NUMBER .LE. 0) .OR. (RFLAG .AND.                                                
 3187            1   |         (IBLK .GT. IENDPB .OR. (IBLK .LE. IENDPB .AND.                                                       
 3188            2   |         J .GE. (IENDPP + 512*(IENDPB - IBLK))))))                                                            
                     <----                                                                                                          
 3189   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 3190   1             CALL PRTCLS                                                                                                   
 3191   1 *           EXECUTE (RESTORE_HELD_SETUP)                                                                                  
 3192   1 *           EXECUTE (FREE_FLAGS_EXIT)                                                                                     
 3193     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   94


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3194     *        PROCEDURE (QUEUE_STOPPER)                                                                                        
 3195       C                                       CP    This procedure sets up an AST to allow the user to stop an                
 3196       C                                       CP    operation.                                                                
 3197   1             STOPIT = .FALSE.                                                                                              
 3198   1             CALL LIB$GET_EF(IOFLAG)                                                                                       
 3199   1 *           IF (IOFLAG .EQ. -1)                                                                                           
 3200   2                CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//                                                
 3201            1             'flag.  OPERATION ABORTED.',COMLIN,20)                                                               
 3202   2 *              EXECUTE (ERROR_EXIT)                                                                                       
 3203   1 *           ENDIF                                                                                                         
 3204   1             CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,                                                    
 3205            1          STOPSC,,INBUF,%VAL(1),,,,)                                                                              
 3206     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   95


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3207     *        PROCEDURE (READ_ERROR)                                                                                           
 3208       C                                       CP    This procedure terminates program execution with an error message.        
 3209       C                                       CP    It is used when an input error occurs.                                    
 3210   1             CALL RESTRM(INCHAN)                                                                                           
 3211   1             CALL BLKCLS                                                                                                   
 3212   1             CLOSE (UNIT=9)                                                                                                
 3213   1             CALL SYS$DASSGN(%VAL(INCHAN))                                                                                 
 3214   1             CALL LIB$PUT_OUTPUT(CRLF//'ERROR READING FILE')                                                               
 3215   1             CALL EXIT                                                                                                     
 3216     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   96


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3217     *        PROCEDURE (REFRESH_EXIT)                                                                                         
 3218       C                                       CP    This procedure refreshes the screen (puts up a new set of lines           
 3219       C                                       CP    corresponding to the current line position), resets the LEDs (#3          
 3220       C                                       CP    off).                                                                     
 3221   1             CALL WORKNG(.FALSE.)                                                                                          
 3222   1 *           IF (NLINES .LT. PAGEND)                                                                                       
                        +-----------------------------------------------------------------------------------------------------------
 3223   2 *             |DO FOREVER                                                                                                 
 3224   3 *             |   IF (BLK .GT. EBK)                                                                                       
 3225   4               |      PAGEND = NLINES                                                                                      
 3226   4 *             |      UNDO                                                                                                 
                        <-------                                                                                                    
 3227   3 *             |   ELSE                                                                                                    
 3228   4               |      CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                                     
 3229   4 *             |      IF (I .EQ. 0)                                                                                        
 3230   5 *             |         EXECUTE (READ_ERROR)                                                                              
 3231   4 *             |      ENDIF                                                                                                
 3232   4               |      NBUF = NBUF + I                                                                                      
 3233   4               |      PBUF = 1                                                                                             
 3234   4               |      CALL LINCON(.FALSE.)                                                                                 
 3235   4 *             |      UNDO IF (NLINES .GE. PAGEND)                                                                         
                        <-------                                                                                                    
 3236   3 *             |   ENDIF                                                                                                   
 3237   2 *             |END DO FOREVER                                                                                             
                        +-----------------------------------------------------------------------------------------------------------
 3238   1 *           ENDIF                                                                                                         
 3239   1             CALL LIB$ERASE_PAGE(1,1)                                                                                      
                     +--------------------------------------------------------------------------------------------------------------
 3240   1 *          |DO FOR I=LINEP,PAGEND                                                                                         
 3241   2 *          |   IF (LENLMT .GT. 0)                                                                                         
 3242   3 *          |      IF (LENLMT .GT. LINLEN(I))                                                                              
 3243   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                      
 3244   3 *          |      ELSE                                                                                                    
 3245   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)                                                         
 3246   3 *          |      ENDIF                                                                                                   
 3247   2 *          |   ELSE                                                                                                       
 3248   3 *          |      IF (LINLEN(I) .LE. -LENLMT)                                                                             
 3249   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                      
 3250   3 *          |      ELSE                                                                                                    
 3251   4            |         CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                       
 3252            1   |               LINES(I)(1-LENLMT:LINLEN(I))//CRLF)                                                            
 3253   3 *          |      ENDIF                                                                                                   
 3254   2 *          |   ENDIF                                                                                                      
 3255   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 3256   1 *           EXECUTE (WRITE_BLOCK_NUMBER)                                                                                  
 3257   1 *           EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                                 
 3258     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   97


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3259     *        PROCEDURE (RESTORE_HELD_SETUP)                                                                                   
 3260       C                                       CP    This routine is used in searches.  It restores the position and           
 3261       C                                       CP    arrays that have previously been saved by HOLD_CURRENT_SETUP.             
 3262   1             CALL WORKNG(.FALSE.)                                                                                          
 3263   1             NBUF = HNBUF                                                                                                  
 3264   1             PBUF = HPBUF                                                                                                  
 3265   1             NLINES = HLINES                                                                                               
 3266   1             LINEP = HLINEP                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 3267   1 *          |DO FOR I=1,NLINES                                                                                             
 3268   2            |   LINES(I) = HLIN(I)                                                                                         
 3269   2            |   LINLEN(I) = HLINLN(I)                                                                                      
 3270   2            |   CCLINE(1,I) = HCCLIN(1,I)                                                                                  
 3271   2            |   CCLINE(2,I) = HCCLIN(2,I)                                                                                  
 3272   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 3273   1 *           IF (NBUF .NE. 0)                                                                                              
                        +-----------------------------------------------------------------------------------------------------------
 3274   2 *             |DO FOR I=1,NBUF                                                                                            
 3275   3               |   BUFFER(I) = HBUFER(I)                                                                                   
 3276   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 3277   1 *           ENDIF                                                                                                         
 3278   1             BLK = HBLK                                                                                                    
 3279   1             SBLK = HSBLK                                                                                                  
 3280   1             LBLK = HLBLK                                                                                                  
 3281   1             LPBUF = HLPBUF                                                                                                
 3282     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   98


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3283     *        PROCEDURE (SCROLL_BLANK_LINE_POST)                                                                               
 3284       C                                       CP    This routine is used in scrolling backwards in non-FIXfiles.  It prints   
 3285       C                                       CP    a blank line then waits for one timer interval (which is set by the       
 3286       C                                       CP    scrolling speed), and then checks for the stop signal.                    
 3287   1 *           EXECUTE (SCROLL_DOWN)                                                                                         
 3288   1 *           EXECUTE (WAIT_FOR_SCROLL_AST)                                                                                 
 3289   1 *           IF (STOPIT)                                                                                                   
 3290   2 *              EXECUTE (VAR_BACK_SCROLL_EXIT)                                                                             
 3291   1 *           ENDIF                                                                                                         
 3292     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE   99


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3293     *        PROCEDURE (SCROLL_BLANK_LINE_PRE)                                                                                
 3294       C                                       CP    This routine is used in scrolling backward in FIX files.  It waits        
 3295       C                                       CP    one timer interval (set by scrolling speed), checks for the stop          
 3296       C                                       CP    signal, then writes one blank line.                                       
 3297   1 *           EXECUTE (WAIT_FOR_SCROLL)                                                                                     
 3298   1 *           IF (STOPIT)                                                                                                   
 3299   2 *              EXECUTE (BACK_SCROLL_EXIT)                                                                                 
 3300   1 *           ENDIF                                                                                                         
 3301   1 *           EXECUTE (SCROLL_DOWN)                                                                                         
 3302   1             CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,                                                    
 3303            1          STOPSC,,INBUF,%VAL(1),,,,)                                                                              
 3304     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  100


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3305     *        PROCEDURE (SCROLL_BLANK_LINE_VAR_PRE)                                                                            
 3306       C                                       CP    This routine is used in scrolling backward in non-FIX files.  It          
 3307       C                                       CP    waits for one timer interval (set by scrolling speed), checks for         
 3308       C                                       CP    the stop signal, and then writes one blank line.                          
 3309   1 *           EXECUTE (WAIT_FOR_SCROLL)                                                                                     
 3310   1 *           IF (STOPIT)                                                                                                   
 3311   2 *              EXECUTE (VAR_BACK_SCROLL_EXIT)                                                                             
 3312   1 *           ENDIF                                                                                                         
 3313   1 *           EXECUTE (SCROLL_DOWN)                                                                                         
 3314   1             CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,                                                    
 3315            1          STOPSC,,INBUF,%VAL(1),,,,)                                                                              
 3316     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  101


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3317     *        PROCEDURE (SCROLL_DOWN)                                                                                          
 3318       C                                       CP    This procedure scrolls the screen down one line and leaves the            
 3319       C                                       CP    cursor at the upper left hand corner.                                     
 3320   1             CALL SYS$CANCEL(%VAL(INCHAN))                                                                                 
 3321   1             CALL LIB$SET_CURSOR(1,1)                                                                                      
 3322   1             CALL LIB$DOWN_SCROLL()                                                                                        
 3323   1             CALL LIB$SET_CURSOR(1,1)                                                                                      
 3324     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  102


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3325     *        PROCEDURE (SCROLL_REFRESH_EXIT)                                                                                  
 3326       C                                       CP    This procedure scrolls to the proper line, resets the LED's (#3           
 3327       C                                       CP    off).                                                                     
 3328   1             CALL WORKNG(.FALSE.)                                                                                          
 3329   1 *           IF (NUMBER .GT. 0)                                                                                            
 3330       C                                       C                                                                               
 3331       C                                       C***   Forward scrolling                                                        
 3332       C                                       C                                                                               
 3333   2 *              IF (OLDEND .NE. PAGEND)                                                                                    
 3334       C                                       C                                                                               
 3335       C                                       C---   Make sure there is something to do                                       
 3336       C                                       C                                                                               
 3337       C                                       C---   Get extra lines if necessary                                             
 3338       C                                       C                                                                               
 3339   3 *                 IF (NLINES .LT. PAGEND)                                                                                 
                              +-----------------------------------------------------------------------------------------------------
 3340   4 *                   |DO FOREVER                                                                                           
 3341   5 *                   |   IF (BLK .GT. EBK)                                                                                 
 3342   6                     |      PAGEND = NLINES                                                                                
 3343   6 *                   |      UNDO                                                                                           
                              <-------                                                                                              
 3344   5 *                   |   ELSE                                                                                              
 3345   6                     |      CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                                               
 3346   6 *                   |      IF (I .EQ. 0)                                                                                  
 3347   7 *                   |         EXECUTE (READ_ERROR)                                                                        
 3348   6 *                   |      ENDIF                                                                                          
 3349   6                     |      NBUF = NBUF + I                                                                                
 3350   6                     |      PBUF = 1                                                                                       
 3351   6                     |      CALL LINCON(.FALSE.)                                                                           
 3352   6 *                   |      UNDO IF (NLINES .GE. PAGEND)                                                                   
                              <-------                                                                                              
 3353   5 *                   |   ENDIF                                                                                             
 3354   4 *                   |END DO FOREVER                                                                                       
                              +-----------------------------------------------------------------------------------------------------
 3355   3 *                 ENDIF                                                                                                   
 3356       C                                       C                                                                               
 3357       C                                       C---   Output new lines                                                         
 3358       C                                       C                                                                               
                           +--------------------------------------------------------------------------------------------------------
 3359   3 *                |DO FOR I=PAGLEN+1,COMLIN                                                                                
 3360   4                  |   CALL LIB$ERASE_LINE(I,1)                                                                             
 3361   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 3362   3                   CALL LIB$SET_CURSOR(PAGLEN+1,1)                                                                         
                           +--------------------------------------------------------------------------------------------------------
 3363   3 *                |DO FOR I=OLDEND+1,PAGEND                                                                                
 3364   4 *                |   IF (LENLMT .GT. 0)                                                                                   
 3365   5 *                |      IF (LINLEN(I) .GE. LENLMT)                                                                        
 3366   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)                                                   
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  103


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3367   5 *                |      ELSE                                                                                              
 3368   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                
 3369   5 *                |      ENDIF                                                                                             
 3370   4 *                |   ELSE                                                                                                 
 3371   5 *                |      IF (LINLEN(I) .LE. -LENLMT)                                                                       
 3372   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                                                
 3373   5 *                |      ELSE                                                                                              
 3374   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                 
 3375            1         |               LINES(I)(1-LENLMT:LINLEN(I))//CRLF)                                                      
 3376   5 *                |      ENDIF                                                                                             
 3377   4 *                |   ENDIF                                                                                                
 3378   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 3379   2 *              ENDIF                                                                                                      
 3380   1 *           ELSE                                                                                                          
 3381   2 *              IF (NUMBER .LT. 0)                                                                                         
 3382       C                                       C                                                                               
 3383       C                                       C***   Backward scrolling                                                       
 3384       C                                       C                                                                               
                           +--------------------------------------------------------------------------------------------------------
 3385   3 *                |DO FOR I=LINEP-NUMBER-1,LINEP,-1                                                                        
 3386   4 *                |   EXECUTE (SCROLL_DOWN)                                                                                
 3387   4 *                |   IF (ABS(LENLMT) .GE. LINLEN(I))                                                                      
 3388   5                  |      CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)))                                                         
 3389   4 *                |   ELSE                                                                                                 
 3390   5 *                |      IF (LENLMT .LT. 0)                                                                                
 3391       C              |                        C                                                                               
 3392       C              |                        C---   This assumes that LINLEN<=2*LENLMT                                       
 3393       C              |                        C                                                                               
 3394   6 *                |         EXECUTE (SCROLL_DOWN)                                                                          
 3395   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                                                 
 3396            1         |               LINES(I)(1-LENLMT:LINLEN(I)))                                                            
 3397   5 *                |      ELSE                                                                                              
 3398   6                  |         CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT))                                                         
 3399   5 *                |      ENDIF                                                                                             
 3400   4 *                |   ENDIF                                                                                                
 3401   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 3402   2 *              ENDIF                                                                                                      
 3403   2                CALL LIB$SET_CURSOR(PAGLEN+1,1)                                                                            
 3404   1 *           ENDIF                                                                                                         
 3405   1 *           EXECUTE (WRITE_BLOCK_NUMBER)                                                                                  
 3406   1 *           EXECUTE (HOME_PLUS_LEDS_EXIT)                                                                                 
 3407     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  104


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3408     *        PROCEDURE (SEARCH_ERROR_EXIT)                                                                                    
 3409       C                                       CP    This procedure stops execution of a search command with an error.         
 3410       C                                       CP    while restoring the held setup and getting rid of the I/O request         
 3411       C                                       CP    to the terminal                                                           
 3412   1 *           EXECUTE (CANCEL_STOPPER)                                                                                      
 3413   1             IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                                                                       
 3414   1             JJ = 1                                                                                                        
                     +--------------------------------------------------------------------------------------------------------------
 3415   1 *          |DO FOR I=1,10                                                                                                 
 3416   2 *          |   UNDO IF (SBFLEN(I) .EQ. 0 .OR. JJ .GT. (IABS(LENLMT) - 58))                                                
                     <----                                                                                                          
 3417   2            |   CAPLIN(JJ:) = SRCHBF(I)(:SBFLEN(I))                                                                        
 3418   2            |   JJ = SBFLEN(I) + JJ + 2                                                                                    
 3419   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 3420   1             IF (JJ .GT. (IABS(LENLMT) - 58)) JJ = IABS(LENLMT) - 58                                                       
 3421   1             CALL LIB$PUT_SCREEN(CAPLIN(:JJ-2)//'  Not found',COMLIN,                                                      
 3422            1          IABS(LENLMT)-JJ-34)                                                                                     
 3423   1             IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)                                                                   
 3424   1 *           EXECUTE (STOP_WITH_ERROR)                                                                                     
 3425     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  105


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3426     *        PROCEDURE (STOP_WITH_ERROR)                                                                                      
 3427       C                                       CP    This procedure stops execution of a command with an error exit,           
 3428       C                                       CP    while restoring the held setup and getting rid of the I/O request         
 3429       C                                       CP    to the terminal                                                           
 3430   1 *           EXECUTE (CANCEL_STOPPER)                                                                                      
 3431   1 *           EXECUTE (RESTORE_HELD_SETUP)                                                                                  
 3432   1 *           EXECUTE (ERROR_EXIT)                                                                                          
 3433     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  106


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3434     *        PROCEDURE (VAR_BACK_SCROLL_EXIT)                                                                                 
 3435       C                                       CP    This routine exits from scrolling backwards in non-FIX files.  It         
 3436       C                                       CP    sets the position to the correct place in the buffer, then converts       
 3437       C                                       CP    the rest of the buffer, sets the current line position, resets the        
 3438       C                                       CP    LEDs (#3 off) and returns.                                                
 3439   1             NBUF = PBUF                                                                                                   
 3440   1             PBUF = I - 1                                                                                                  
 3441   1 *           EXECUTE (BACK_SCROLL_EXIT)                                                                                    
 3442     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  107


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3443     *        PROCEDURE (WAIT_FOR_SCROLL)                                                                                      
 3444       C                                       CP    This procedure waits for the scrolling interval to pass.                  
 3445   1             CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)                                                                        
 3446   1             CALL SYS$WAITFR(%VAL(TIMFLG))                                                                                 
 3447     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  108


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3448     *        PROCEDURE (WAIT_FOR_SCROLL_AST)                                                                                  
 3449       C                                       CP    This procedure waits for the scrolling interval to pass after             
 3450       C                                       CP    queueing the stop command AST.                                            
 3451   1             CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,                                                    
 3452            1          STOPSC,,INBUF,%VAL(1),,,,)                                                                              
 3453   1             CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)                                                                        
 3454   1             CALL SYS$WAITFR(%VAL(TIMFLG))                                                                                 
 3455     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  109


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3456     *        PROCEDURE (WORKING)                                                                                              
 3457       C                                       CP    This procedure turns on LED 1 and starts up the working message.          
 3458   1 *           IF (VT100)                                                                                                    
 3459   2                CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;1q')                                                                    
 3460   2                IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')                                                   
 3461   2                IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                                                             
 3462            1             CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                                                                
 3463   1 *           ENDIF                                                                                                         
 3464   1             CALL WORKNG(.TRUE.)                                                                                           
 3465     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  110


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3466     *        PROCEDURE (WRITE_BLOCK_NUMBER)                                                                                   
 3467       C                                       CP    This procedure scrolls an extra line if needed (if dividing line          
 3468       C                                       CP    (BOX) switch is chosen, and writes out the block number in the            
 3469       C                                       CP    lower right corner.                                                       
 3470   1             IF (PAGLEN .EQ. (COMLIN - 2)) CALL LIB$PUT_SCREEN(CRLF)                                                       
 3471   1             CALL LIB$ERASE_LINE(COMLIN,1)                                                                                 
 3472       C                                       C                                                                               
 3473       C                                       C***   Output block number                                                      
 3474       C                                       C                                                                               
 3475   1             IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                                                                       
                     +--------------------------------------------------------------------------------------------------------------
 3476   1 *          |DO FOR I=LINEP,NLINES                                                                                         
 3477   2 *          |   UNDO IF (CCLINE(1,I) .NE. 0)                                                                               
                     <----                                                                                                          
 3478   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 3479   1             WRITE (UNIT=TEMPCH,FMT=2000)CCLINE(1,I)                                                                       
 3480   1   2000      FORMAT (I5)                                                                                                   
 3481   1             I = LIB$SKPC(' ',TEMPCH)                                                                                      
 3482   1             CALL LIB$PUT_SCREEN('Block '//TEMPCH(I:),COMLIN,                                                              
 3483            1          IABS(LENLMT)+I-11)                                                                                      
 3484   1             IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)                                                                   
 3485     *        END PROCEDURE                                                                                                    
 3486              END                                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  111


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 2193  BACKWARD_SCROLLING             
                               1936 

 2044  BACKWARD_SEARCH                
                               1896  1900 

 2022  BACK_SCROLL_EXIT               
                               2278  3299  3441 

 2441  CANCEL_COMMAND                 
                               2109  2188  2555  2597  2867  2904  3007 

 2449  CANCEL_STOPPER                 
                               1842  1975  2014  2163  2457  2592  2734  3054  3412  3430 

 2454  ERROR_EXIT                     
                               1834  1853  1881  1928  1943  3065  3202  3432 

 2468  FIND_NON_CC_LINE               
                               1855  3103  3109 

 2611  FORWARD_SCROLLING              
                               1934 

 2479  FORWARD_SEARCH                 
                               1894  1902 

 2730  FREE_FLAGS_EXIT                
                               2041  2226  2424  2681  2700  3126  3192 

 2738  GET_LAST_LINE                  
                               1841  1874  2039  2063  2162  2224  2423  2498  2591 

 2751  GET_START_LINE                 
                               2673  2693 

 2763  HIT_BEGINNING                  
                               2422  2943  3021 

 2771  HOLD_CURRENT_SETUP             
                               1836  1956  2077  2512  3067 

 2795  HOME_PLUS_LEDS_EXIT            
                               1917  1946  1977  2446  2736  3257  3406 

 2806  INPUT_SEVEN_BLOCKS             
                               1860  2579  2767  2911  3037 

 2845  JUMP_LINES                     
                               1840  1961  3106 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  112


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 3056  OUTPUT_RANGE                   
                               1983  1990 

 3194  QUEUE_STOPPER                  
                               1930  2793 

 3207  READ_ERROR                     
                               2031  2084  2088  2137  2142  2148  2181  2241  2249  2432  2533  2543 
                               2709  2719  2815  2826  2838  2861  2926  2953  3026  3098  3115  3148 
                               3230  3347 

 3217  REFRESH_EXIT                   
                               1846  1875  2000  2065  2164  2502  2593 

 3259  RESTORE_HELD_SETUP             
                               1976  2445  3125  3191  3431 

 3283  SCROLL_BLANK_LINE_POST         
                               2318  2335 

 3293  SCROLL_BLANK_LINE_PRE          
                               2299  2300  2303 

 3305  SCROLL_BLANK_LINE_VAR_PRE      
                               2349  2380  2381  2384 

 3317  SCROLL_DOWN                    
                               2204  2214  2282  2285  2339  2354  2360  2391  3287  3301  3313  3386 
                               3394 

 3325  SCROLL_REFRESH_EXIT            
                               1844  2067  2500 

 3408  SEARCH_ERROR_EXIT              
                               2080  2174  2525 

 3426  STOP_WITH_ERROR                
                               3424 

 3434  VAR_BACK_SCROLL_EXIT           
                               2412  3290  3311 

 3443  WAIT_FOR_SCROLL                
                               2276  2410  3297  3309 

 3448  WAIT_FOR_SCROLL_AST            
                               2222  2670  3288 

 3456  WORKING                        
                               1811 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        DOIT                  30-SEP-83      08:30:11      PAGE  113


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 3466  WRITE_BLOCK_NUMBER             
                               2040  2225  2680  2699  3256  3405 

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        GETDEF                30-SEP-83      08:30:11      PAGE  114


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3487              LOGICAL FUNCTION GETDEF(LINE,ISYM)                                                                               
 3488       C                                       C                                                                               
 3489       C                                       CDM   This routine translates a line into a symbol definition                   
 3490       C                                       CDM                                                                             
 3491       C                                       CDM   Programmer - Jon Vavrus   3 SEP 1981                                      
 3492       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
 3493       C                                       CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
 3494       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
 3495       C                                       CDM   Revised    - Jon Vavrus  28 MAY 1983                                      
 3496       C                                       CDM   Revised    - Jon Vavrus  17 AUG 1983                                      
 3497       C                                       CM                                                                              
 3498       C                                       CM         The routine is called with the line to be translated in the          
 3499       C                                       CM    character variable LINE.  The number of the symbol definition is          
 3500       C                                       CM    passed as ISYM.                                                           
 3501       C                                       C                                                                               
 3502       C                                       C***   CALLED ROUTINES                                                          
 3503       C                                       C                                                                               
 3504       C                                       CC    PRSCOM  Parses a command string                                           
 3505       C                                       C                                                                               
 3506       C                                       C***   COMMON AREAS                                                             
 3507       C                                       C                                                                               
 3508       C                                       CS    CHARS   Used to pass character variables; contains LINES a character      
 3509       C                                       CS            array of the output lines, and SRCHBF the search buffer, and      
 3510       C                                       CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
 3511       C                                       CS            the VT100 control sequences to set/unset reverse video            
 3512       C                                       C                                                                               
 3513       C                                       CS    DOITNM  Contains information transferred from the main program:           
 3514       C                                       CS                 INCHAN - input channel of the terminal                       
 3515       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 3516       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 3517       C                                       CS                          in the search buffer                                
 3518       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 3519       C                                       CS                 EBK    - EBK of input file                                   
 3520       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
 3521       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 3522       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
 3523       C                                       CS                          of the print range                                  
 3524       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
 3525       C                                       CS                 LRL    - length of the longest record in input file.         
 3526       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 3527       C                                       CS                 PAGEND - line number of last line output to screen           
 3528       C                                       CS                 PAGLEN - number of lines per page                            
 3529       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 3530       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 3531       C                                       C                                                                               
 3532       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
 3533       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
 3534       C                                       C                                                                               
 3535       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        GETDEF                30-SEP-83      08:30:11      PAGE  115


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3536       C                                       CS            symbol definitions DEFS, the number of such definitions           
 3537       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
 3538       C                                       CS            numbers NUDMEF                                                    
 3539       C                                       C                                                                               
 3540       C                                       CS    PRSCHR  Contains the current symbol's search buffers (CURBUF)             
 3541       C                                       C                                                                               
 3542       C                                       CS    PRSNUM  Contains the current symbol's definitions (CUR), flags            
 3543       C                                       CS            (CURFLG), and associated numbers (NUMCUR)                         
 3544       C                                       C                                                                               
 3545              CHARACTER*(*) LINE                                                                                               
 3546              CHARACTER*132 LINES(600)                                                                                         
 3547              CHARACTER*128 INLINE                                                                                             
 3548              CHARACTER*30 DEFBUF(10,10,60),SRCHBF(10),HLDBUF(10),CURBUF(10,10)                                                
 3549              CHARACTER*4 REVVID,REGVID                                                                                        
 3550              CHARACTER*2 CRLF                                                                                                 
 3551              CHARACTER*1 SYMS(60)                                                                                             
 3552              REAL*4 NUMDEF(10,60),NUMCUR(10)                                                                                  
 3553              INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND                                                                      
 3554              INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,PAGLEN,                                                 
 3555            1       LENSAV,HLDLEN(10),CUR(11,10),COMLIN                                                                        
 3556              LOGICAL*1 SBFFLG,VT100,DEFFLG(3,10,60),HLDFLG,CURFLG(3,10),MINFLG,                                               
 3557            1       NUMFLG,VT100A,RESULT                                                                                       
 3558                                                                                                                               
 3559              COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                                                                    
 3560              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 3561            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 3562              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
 3563              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
 3564              COMMON /PRSNUM/CUR,NUMCUR,CURFLG                                                                                 
 3565              COMMON /PRSCHR/CURBUF                                                                                            
 3566                                                                                                                               
 3567              RESULT = .TRUE.                                                                                                  
 3568       C                                       C                                                                               
 3569       C                                       C***   Store the current definition in case it is recursive                     
 3570       C                                       C                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 3571     *       |DO FOR JJ=1,10                                                                                                   
 3572   1         |   CUR(1,JJ) = DEFS(1,JJ,ISYM)                                                                                   
 3573   1 *       |   UNDO IF (CUR(1,JJ) .EQ. 0)                                                                                    
                  <----                                                                                                             
 3574   1         |   NUMCUR(JJ) = NUMDEF(JJ,ISYM)                                                                                  
 3575   1         |   CURFLG(1,JJ) = DEFFLG(1,JJ,ISYM)                                                                              
 3576   1         |   CURFLG(2,JJ) = DEFFLG(2,JJ,ISYM)                                                                              
 3577   1         |   CURFLG(3,JJ) = DEFFLG(3,JJ,ISYM)                                                                              
                  |  +--------------------------------------------------------------------------------------------------------------
 3578   1 *       |  |DO FOR I=1,10                                                                                                 
 3579   2         |  |   CUR(1+I,JJ) = DEFS(1+I,JJ,ISYM)                                                                            
 3580   2 *       |  |   UNDO IF (CUR(1+I,JJ) .EQ. 0)                                                                               
                  |  <----                                                                                                          
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        GETDEF                30-SEP-83      08:30:11      PAGE  116


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3581   2         |  |   CURBUF(I,JJ) = DEFBUF(I,JJ,ISYM)                                                                           
 3582   1 *       |  |END DO FOR                                                                                                    
                  |  +--------------------------------------------------------------------------------------------------------------
 3583     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
 3584              NCOM = 1                                                                                                         
 3585       C                                       C                                                                               
 3586       C                                       C***   Save search stuff                                                        
 3587       C                                       C                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 3588     *       |DO FOR JJ=1,10                                                                                                   
 3589   1         |   HLDLEN(JJ) = SBFLEN(JJ)                                                                                       
 3590   1         |   HLDBUF(JJ) = SRCHBF(JJ)                                                                                       
 3591   1 *       |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                                                   
                  <----                                                                                                             
 3592     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
 3593              HLDFLG = SBFFLG                                                                                                  
 3594              SBFFLG = .FALSE.                                                                                                 
 3595              LENBUF = LEN(LINE)                                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 3596     *       |DO FOREVER                                                                                                       
 3597       C     |                                 C                                                                               
 3598       C     |                                 C***   Parse out a command                                                      
 3599       C     |                                 C                                                                               
 3600   1         |   CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,NCOM,ISYM)                                                   
 3601   1 *       |   UNDO IF (NCOM .GT. 10)                                                                                        
                  <----                                                                                                             
 3602   1 *       |   IF (ICOM .EQ. 0 .AND. LENBUF .GT. 0)                                                                          
 3603   2         |      RESULT = .FALSE.                                                                                           
 3604   2 *       |      UNDO                                                                                                       
                  <-------                                                                                                          
 3605   1 *       |   ENDIF                                                                                                         
 3606   1         |   DEFS(1,NCOM,ISYM) = ICOM                                                                                      
 3607   1 *       |   UNDO IF (ICOM .EQ. 0)                                                                                         
                  <----                                                                                                             
 3608   1         |   DEFFLG(1,NCOM,ISYM) = NUMFLG                                                                                  
 3609   1         |   NUMDEF(NCOM,ISYM) = ANUMB                                                                                     
 3610   1         |   DEFFLG(2,NCOM,ISYM) = MINFLG                                                                                  
 3611       C     |                                 C                                                                               
 3612       C     |                                 C***   Search stuff if command is ^                                             
 3613       C     |                                 C                                                                               
 3614   1 *       |   IF (DEFS(1,NCOM,ISYM) .EQ. 3)                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 3615   2 *       |     |DO FOR JJ=1,10                                                                                             
 3616   3         |     |   DEFBUF(JJ,NCOM,ISYM) = SRCHBF(JJ)                                                                       
 3617   3         |     |   DEFS(1+JJ,NCOM,ISYM) = SBFLEN(JJ)                                                                       
 3618   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        GETDEF                30-SEP-83      08:30:11      PAGE  117


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3619   2         |      DEFFLG(3,NCOM,ISYM) = SBFFLG                                                                               
 3620   1 *       |   ELSE                                                                                                          
 3621   2         |      DEFFLG(3,NCOM,ISYM) = .FALSE.                                                                              
 3622   1 *       |   ENDIF                                                                                                         
 3623   1         |   NCOM = NCOM + 1                                                                                               
 3624     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
 3625       C                                       C                                                                               
 3626       C                                       C***   Restore search stuff                                                     
 3627       C                                       C                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 3628     *       |DO FOR JJ=1,10                                                                                                   
 3629   1         |   SBFLEN(JJ) = HLDLEN(JJ)                                                                                       
 3630   1         |   SRCHBF(JJ) = HLDBUF(JJ)                                                                                       
 3631     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
 3632              SBFFLG = HLDFLG                                                                                                  
 3633              GETDEF = RESULT                                                                                                  
 3634              RETURN                                                                                                           
              <-----                                                                                                                
 3635              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  118


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3636              SUBROUTINE LINCON(START)                                                                                         
 3637       C                                       CDM   This subroutine converts a buffer full of data into output lines in       
 3638       C                                       CDM   the output arrays.                                                        
 3639       C                                       CDM                                                                             
 3640       C                                       CDM   Programmer - Jon Vavrus  12 NOV 1980                                      
 3641       C                                       CDM   Revised    - Jon Vavrus  13 MAY 1981                                      
 3642       C                                       CDM   Revised    - Jon Vavrus  30 JUL 1981 (change CCLINE usage)                
 3643       C                                       CDM   Revised    - Jon Vavrus  26 AUG 1981                                      
 3644       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
 3645       C                                       CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
 3646       C                                       CDM   Revised    - Jon Vavrus  12 JAN 1983                                      
 3647       C                                       CM                                                                              
 3648       C                                       CM         The conversion is done one line per record with blank lines          
 3649       C                                       CM    being inserted to take care of FORTRAN carriage-control (which is         
 3650       C                                       CM    then stripped off the record)(+ carriage control is ignored), and         
 3651       C                                       CM    printer form-feeds (other printer control sequences are ignored).         
 3652       C                                       CM                                                                              
 3653       C                                       CM         If START is set to .TRUE. in the call, then it is assumed that       
 3654       C                                       CM    the buffer is completely new, and bears no relationship to the current    
 3655       C                                       CM    contents of the output arrays, thus the current contents of the arrays    
 3656       C                                       CM    are disregarded and written over.  If START is set to .FALSE. in the      
 3657       C                                       CM    call, the buffer is assumed to be full of data which should immediately   
 3658       C                                       CM    follows the information currently in the output arrays.  It is also       
 3659       C                                       CM    assumed (if START is .FALSE.) that the buffer pointer (PBUF) is           
 3660       C                                       CM    pointing at the correct byte.                                             
 3661       C                                       C                                                                               
 3662       C                                       C***   CALLED ROUTINES                                                          
 3663       C                                       C                                                                               
 3664       C                                       CC    INTASC  Converts a string of bytes into a character variable.             
 3665       C                                       CC    SFTLIN  Shifts the lines in the output arrays to free up space for        
 3666       C                                       CC            more lines to be converted.                                       
 3667       C                                       C                                                                               
 3668       C                                       C***   COMMON AREAS                                                             
 3669       C                                       C                                                                               
 3670       C                                       CS    CHARS   Contains the character array containing the actual output lines.  
 3671       C                                       C                                                                               
 3672       C                                       CS    DOITNM  Contains information transferred from the main program:           
 3673       C                                       CS                 INCHAN - input channel of the terminal                       
 3674       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 3675       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 3676       C                                       CS                          in the search buffer                                
 3677       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 3678       C                                       CS                 EBK    - EBK of input file                                   
 3679       C                                       CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
 3680       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 3681       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
 3682       C                                       CS                          of the print range                                  
 3683       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
 3684       C                                       CS                 LRL    - length of the longest record in input file.         
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  119


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3685       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 3686       C                                       CS                 PAGEND - line number of last line output to screen           
 3687       C                                       CS                 PAGLEN - number of lines per page                            
 3688       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 3689       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 3690       C                                       C                                                                               
 3691       C                                       CS    LNCN    Contains output arrays, and file pointers and information:        
 3692       C                                       CS                 LINLEN - array of output line lengths                        
 3693       C                                       CS                 LINEP  - top of screen line (or last line output by          
 3694       C                                       CS                          backward scroll)                                    
 3695       C                                       CS                 NLINES - number of lines in arrays                           
 3696       C                                       CS                 BUFFER - array of unconverted data                           
 3697       C                                       CS                 PBUF   - current position in BUFFER                          
 3698       C                                       CS                 NBUF   - number of bytes in BUFFER                           
 3699       C                                       CS                 BLK    - next block in file                                  
 3700       C                                       CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
 3701       C                                       CS                 IFSZ   - word extended record length for FIX files           
 3702       C                                       CS                 RFM    - files RFM                                           
 3703       C                                       CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
 3704       C                                       CS                 SBLK   - starting block of current batch of output lines     
 3705       C                                       CS                 CCLINE - array containing pointer to where the line's        
 3706       C                                       CS                          record starts in the file (CCLINE(1,x) = block      
 3707       C                                       CS                          #, CCLINE(2,x) = byte number in block).  If         
 3708       C                                       CS                          CCLINE(1,x) = 0 then it is a carriage control       
 3709       C                                       CS                          line.                                               
 3710       C                                       CS                 LBLK   - last block processed by LINCON                      
 3711       C                                       CS                 LPBUF  - last PBUF value processed by LINCON                 
 3712       C                                       C                                                                               
 3713              CHARACTER*132 LINES(600)                                                                                         
 3714              INTEGER*4 RFM,RAT,FSZ,BLK,PBUF,PBSAVE,SBLK,CCLINE(2,600),                                                        
 3715            1       INCHAN,TIME,RANGE(2,2),EBK,PAGEND,BUFDSC(2)                                                                
 3716              INTEGER*2 LINLEN(600),DIRECT,SBFLEN(10),RECBLK,PAGLEN,LENLMT,                                                    
 3717            1       COMLIN                                                                                                     
 3718              LOGICAL*1 BUFFER(3750),START,SBFFLG,VT100,VT100A                                                                 
 3719              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 3720            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 3721              COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,                                                  
 3722            1       RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                                                                             
 3723              COMMON /CHARS/LINES                                                                                              
 3724       C                                       C                                                                               
 3725       C                                       C***   Calculate start position if this is a new block                          
 3726       C                                       C                                                                               
 3727     *        IF (START)                                                                                                       
 3728   1             NLINES = 0                                                                                                    
 3729   1             LINEP = 1                                                                                                     
 3730   1             LPBUF = 0                                                                                                     
 3731   1             LBLK = SBLK                                                                                                   
 3732   1 *           IF (RAT .GT. 0)                                                                                               
 3733   2 *              IF (RFM .EQ. 1)                                                                                            
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  120


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3734   3                   PBUF = IFSZ*(512*(SBLK - 1)/IFSZ + 1)                                                                   
 3735   3                   PBUF = LIB$EXTZV(0,9,PBUF) + 1                                                                          
 3736   3                   IF (PBUF .EQ. (IFSZ + 1)) PBUF = 1                                                                      
 3737   2 *              ELSE                                                                                                       
 3738   3                   PBUF = 1                                                                                                
                           +--------------------------------------------------------------------------------------------------------
 3739   3 *                |DO FOREVER                                                                                              
 3740   4                  |   PBUF = PBUF + 1                                                                                      
 3741   4 *                |   CYCLE IF (BUFFER(PBUF) .NE. 0)                                                                       
                           |<---                                                                                                    
 3742   4                  |   I = PBUF + LIB$EXTZV(0,8,BUFFER(PBUF-1)) + 2                                                         
 3743   4                  |   IF (BUFFER(PBUF-1)) I = I + 1                                                                        
 3744   4 *                |   UNDO IF (BUFFER(I) .EQ. 0)                                                                           
                           <----                                                                                                    
 3745   3 *                |END DO FOREVER                                                                                          
                           +--------------------------------------------------------------------------------------------------------
 3746   3                   PBUF = PBUF - 1                                                                                         
 3747   2 *              ENDIF                                                                                                      
 3748   1 *           ELSE                                                                                                          
 3749   2                PBUF = 1                                                                                                   
 3750   1 *           ENDIF                                                                                                         
 3751     *        ENDIF                                                                                                            
 3752       C                                       C                                                                               
 3753       C                                       C***   Check for either FORTRAN or printer carriage control                     
 3754       C                                       C                                                                               
 3755       C                                       C***   FORTRAN                                                                  
 3756       C                                       C                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 3757     * 20    |DO FOREVER                                                                                                       
 3758   1 *       |   EXECUTE (NEW_LINE)                                                                                            
 3759   1 *       |   IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                                              
 3760   2 *       |      IF (RFM .EQ. 1)                                                                                            
 3761   3         |         I = BUFFER(PBUF)                                                                                        
 3762   2 *       |      ELSE                                                                                                       
 3763   3 *       |         IF (BUFFER(PBUF) .EQ. FSZ)                                                                              
 3764   4         |            I = 0                                                                                                
 3765   3 *       |         ELSE                                                                                                    
 3766   4         |            I = BUFFER(PBUF+FSZ+2)                                                                               
 3767   3 *       |         ENDIF                                                                                                   
 3768   2 *       |      ENDIF                                                                                                      
 3769   2 *       |      IF (I .EQ. '30'X)                                                                                          
 3770       C     |                                 C                                                                               
 3771       C     |                                 C***   30 octal is an ASCII 0                                                   
 3772       C     |                                 C                                                                               
 3773   3 *       |         EXECUTE (INSERT_BLANK_LINE)                                                                             
 3774   2 *       |      ELSE                                                                                                       
 3775   3 *       |         IF (I .EQ. '31'X)                                                                                       
 3776       C     |                                 C                                                                               
 3777       C     |                                 C***   31 octal is an ASCII 1                                                   
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  121


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3778       C     |                                 C                                                                               
 3779   4 *       |            EXECUTE (INSERT_BLANK_LINE)                                                                          
 3780   4 *       |            EXECUTE (INSERT_BLANK_LINE)                                                                          
 3781   3 *       |         ENDIF                                                                                                   
 3782   2 *       |      ENDIF                                                                                                      
 3783   1 *       |   ELSE                                                                                                          
 3784   2 *       |      IF (RAT .EQ. 3 .OR. RAT .EQ. -3)                                                                           
 3785       C     |                                 C                                                                               
 3786       C     |                                 C***   Printer pre-line line feeds                                              
 3787       C     |                                 C                                                                               
 3788   3 *       |         IF (LIB$EXTZV(7,1,BUFFER(PBUF+2)) .EQ. 0)                                                               
 3789   4         |            I = LIB$EXTZV(0,7,BUFFER(PBUF+2)) - 1                                                                
 3790   4 *       |            IF (I .NE. 0)                                                                                        
                  |              +--------------------------------------------------------------------------------------------------
 3791   5 *       |              |DO FOR J=1,I                                                                                      
 3792   6 *       |              |   EXECUTE (INSERT_BLANK_LINE)                                                                    
 3793   5 *       |              |END DO FOR                                                                                        
                  |              +--------------------------------------------------------------------------------------------------
 3794   4 *       |            ENDIF                                                                                                
 3795   4         |            PBSAVE = PBUF + 3                                                                                    
 3796   3 *       |         ENDIF                                                                                                   
 3797   2 *       |      ENDIF                                                                                                      
 3798   1 *       |   ENDIF                                                                                                         
 3799       C     |                                 C                                                                               
 3800       C     |                                 C***   Extract records into lines                                               
 3801       C     |                                 C                                                                               
 3802   1 *       |   IF (RFM .EQ. 1)                                                                                               
 3803       C     |                                 C                                                                               
 3804       C     |                                 C***   Fixed length records                                                     
 3805       C     |                                 C                                                                               
 3806   2 *       |      EXECUTE (SET_CCLINE)                                                                                       
 3807   2 *       |      IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                                           
 3808   3         |         LENGTH = FSZ - 1                                                                                        
 3809   3         |         PBUF = PBUF + 1                                                                                         
 3810   2 *       |      ELSE                                                                                                       
 3811   3         |         LENGTH = FSZ                                                                                            
 3812   2 *       |      ENDIF                                                                                                      
 3813   2         |      I = PBUF                                                                                                   
 3814   2 *       |      EXECUTE (CONVERT_TO_LINES)                                                                                 
 3815   2         |      PBUF = PBUF + LENGTH                                                                                       
 3816   2         |      IF (FSZ) PBUF = PBUF + 1                                                                                   
 3817   2 *       |      IF ((PBUF + IFSZ - 1) .GT. NBUF)                                                                           
 3818   3 *       |         EXECUTE (STORE_REMAINDER)                                                                               
 3819   2 *       |      ENDIF                                                                                                      
 3820   1 *       |   ELSE                                                                                                          
 3821       C     |                                 C                                                                               
 3822       C     |                                 C***   Variable length records                                                  
 3823       C     |                                 C                                                                               
 3824   2 *       |      EXECUTE (SET_CCLINE)                                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  122


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3825   2 *       |      IF (RAT .EQ. 2 .OR. RAT .EQ. -2)                                                                           
 3826   3         |         LENGTH = LIB$EXTZV(0,8,BUFFER(PBUF)) - 1 - FSZ                                                          
 3827   3         |         I = PBUF + 3 + FSZ                                                                                      
 3828   2 *       |      ELSE                                                                                                       
 3829   3         |         LENGTH = LIB$EXTZV(0,8,BUFFER(PBUF)) - FSZ                                                              
 3830   3         |         I = PBUF + 2 + FSZ                                                                                      
 3831   2 *       |      ENDIF                                                                                                      
 3832   2 *       |      IF (LENGTH .GT. 0)                                                                                         
 3833   3 *       |         EXECUTE (CONVERT_TO_LINES)                                                                              
 3834   3 *       |         IF (BUFFER(PBUF))                                                                                       
 3835   4         |            PBUF = I + LENGTH + 1                                                                                
 3836   3 *       |         ELSE                                                                                                    
 3837   4         |            PBUF = I + LENGTH                                                                                    
 3838   3 *       |         ENDIF                                                                                                   
 3839   2 *       |      ELSE                                                                                                       
 3840   3         |         IF (LENGTH .EQ. 0 .AND. (RAT .EQ. 2 .OR. RAT .EQ. -2))                                                  
 3841            1|               PBUF = PBUF + 2                                                                                   
 3842   3         |         PBUF = PBUF + 2 + FSZ                                                                                   
 3843   3         |         IF (FSZ) PBUF = PBUF + 1                                                                                
 3844   3         |         LINLEN(NLINES) = 1                                                                                      
 3845   3         |         LINES(NLINES) = ' '                                                                                     
 3846   2 *       |      ENDIF                                                                                                      
 3847       C     |                                 C                                                                               
 3848       C     |                                 C***   Printer post-line line feeds                                             
 3849       C     |                                 C                                                                               
 3850   2 *       |      IF (RAT .EQ. 3 .OR. RAT .EQ. -3)                                                                           
 3851   3 *       |         IF (LIB$EXTZV(7,1,BUFFER(PBSAVE)) .EQ. 0)                                                               
 3852   4         |            I = LIB$EXTZV(0,7,BUFFER(PBSAVE)) - 1                                                                
 3853   4 *       |            IF (I .GT. 0)                                                                                        
 3854   5 *       |               EXECUTE (NEW_LINE)                                                                                
                  |              +--------------------------------------------------------------------------------------------------
 3855   5 *       |              |DO FOR J=1,I                                                                                      
 3856   6 *       |              |   EXECUTE (INSERT_BLANK_LINE)                                                                    
 3857   5 *       |              |END DO FOR                                                                                        
                  |              +--------------------------------------------------------------------------------------------------
 3858   5         |               NLINES = NLINES - 1                                                                               
 3859   4 *       |            ENDIF                                                                                                
 3860   3 *       |         ENDIF                                                                                                   
 3861   2 *       |      ENDIF                                                                                                      
 3862   2 *       |      IF ((LIB$EXTZV(0,8,BUFFER(PBUF)) + PBUF + 1) .GT. NBUF)                                                    
 3863   3 *       |         EXECUTE (STORE_REMAINDER)                                                                               
 3864   2 *       |      ENDIF                                                                                                      
 3865   1 *       |   ENDIF                                                                                                         
 3866     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
 3867       C                                       C                                                                               
 3868       C                                       C****************************************************************************** 
 3869       C                                       C***********************   HERE FOLLOW THE PROCEDURES   *********************** 
 3870       C                                       C****************************************************************************** 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  123


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3871       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  124


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3872     *        PROCEDURE (CONVERT_TO_LINES)                                                                                     
 3873       C                                       CP    This procedure converts the LENGTH bytes in BUFFER into lines in LINES    
 3874       C                                       CP    (starting at NLINES).  It takes into account form feeds (generate 2       
 3875       C                                       CP    blank lines) and line feeds.                                              
 3876       C                                       C                                                                               
 3877       C                                       C***   Construct descriptor                                                     
 3878       C                                       C                                                                               
 3879   1             BUFDSC(1) = LENGTH                                                                                            
 3880   1             BUFDSC(2) = %LOC(BUFFER(I))                                                                                   
 3881   1             J = I                                                                                                         
 3882       C                                       C                                                                               
 3883       C                                       C***   Split string                                                             
 3884       C                                       C                                                                               
                     +--------------------------------------------------------------------------------------------------------------
 3885   1 *          |DO FOREVER                                                                                                    
 3886   2            |   IFF = LIB$LOCC(CHAR(12),BUFDSC)                                                                            
 3887   2            |   ILF = LIB$LOCC(CHAR(10),BUFDSC)                                                                            
 3888   2 *          |   IF (ILF .EQ. 0 .AND. IFF .EQ. 0)                                                                           
 3889   3            |      ILEN = BUFDSC(1)                                                                                        
 3890   3            |      IICHAR = ILEN                                                                                           
 3891   2 *          |   ELSE                                                                                                       
 3892   3 *          |      IF ((ILF .LT. IFF .AND. ILF .NE. 0) .OR. IFF .EQ. 0)                                                    
 3893       C        |                              C                                                                               
 3894       C        |                              C===   Line feed first                                                          
 3895       C        |                              C                                                                               
 3896   4            |         ILEN = ILF - 1                                                                                       
 3897   4            |         IICHAR = ILF                                                                                         
 3898       C        |                              C                                                                               
 3899       C        |                              C---   Get rid of <CR>                                                          
 3900       C        |                              C                                                                               
 3901   4            |         IF (BUFFER(J+ILEN-1) .EQ. 13) ILEN = ILEN - 1                                                        
 3902   3 *          |      ELSE                                                                                                    
 3903       C        |                              C                                                                               
 3904       C        |                              C===   FF first                                                                 
 3905       C        |                              C                                                                               
 3906   4            |         CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                                                                
 3907   4            |         CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                                                                
 3908   4 *          |         EXECUTE (INSERT_BLANK_LINE)                                                                          
 3909   4            |         CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                                                                
 3910   4            |         CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                                                                
 3911   4 *          |         EXECUTE (INSERT_BLANK_LINE)                                                                          
 3912   4            |         ILEN = IFF - 1                                                                                       
 3913   4            |         IICHAR = IFF                                                                                         
 3914   3 *          |      ENDIF                                                                                                   
 3915   2 *          |   ENDIF                                                                                                      
 3916   2            |   IF (ILEN .GT. 132) ILEN = 132                                                                              
 3917   2            |   BUFDSC(1) = BUFDSC(1) - IICHAR                                                                             
 3918   2            |   BUFDSC(2) = BUFDSC(2) + IICHAR                                                                             
 3919   2 *          |   IF ((J + IICHAR + 1) .LT. (I + LENGTH))                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  125


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3920       C        |                              C                                                                               
 3921       C        |                              C===   Not end of record                                                        
 3922       C        |                              C                                                                               
 3923   3            |      CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                                                                   
 3924   3            |      CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                                                                   
 3925   3            |      CCLINE(1,NLINES) = 0                                                                                    
 3926   3 *          |      EXECUTE (NEW_LINE)                                                                                      
 3927   3 *          |      IF (ILEN .EQ. 0)                                                                                        
 3928   4            |         LINES(NLINES-1) = ' '                                                                                
 3929   4            |         LINLEN(NLINES-1) = 1                                                                                 
 3930   3 *          |      ELSE                                                                                                    
 3931   4            |         CALL INTASC(ILEN,BUFFER(J),LINES(NLINES-1))                                                          
 3932   4            |         LINLEN(NLINES-1) = ILEN                                                                              
 3933   3 *          |      ENDIF                                                                                                   
 3934   2 *          |   ELSE                                                                                                       
 3935       C        |                              C                                                                               
 3936       C        |                              C===   End of record                                                            
 3937       C        |                              C                                                                               
 3938   3 *          |      IF (ILEN .EQ. 0)                                                                                        
 3939   4            |         LINES(NLINES) = ' '                                                                                  
 3940   4            |         LINLEN(NLINES) = 1                                                                                   
 3941   3 *          |      ELSE                                                                                                    
 3942   4            |         CALL INTASC(ILEN,BUFFER(J),LINES(NLINES))                                                            
 3943   4            |         LINLEN(NLINES) = ILEN                                                                                
 3944   3 *          |      ENDIF                                                                                                   
 3945   3 *          |      IF (ABS(RAT) .NE. 4 .AND. ILF .NE. 0 .AND. IFF .EQ. 0)                                                  
 3946   4            |         CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                                                                
 3947   4            |         CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                                                                
 3948   4            |         CCLINE(1,NLINES) = 0                                                                                 
 3949   4 *          |         EXECUTE (NEW_LINE)                                                                                   
 3950   4            |         LINES(NLINES) = ' '                                                                                  
 3951   4            |         LINLEN(NLINES) = 1                                                                                   
 3952   3 *          |      ENDIF                                                                                                   
 3953   2 *          |   ENDIF                                                                                                      
 3954   2            |   J = J + IICHAR                                                                                             
 3955   2 *          |   UNDO IF ((J + 1) .GE. (I + LENGTH))                                                                        
                     <----                                                                                                          
 3956   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 3957     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  126


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3958     *        PROCEDURE (INSERT_BLANK_LINE)                                                                                    
 3959       C                                       CP    This procedure inserts a blank line of length one character into the      
 3960       C                                       CP    proper arrays.                                                            
 3961   1             LINLEN(NLINES) = 1                                                                                            
 3962   1             LINES(NLINES) = ' '                                                                                           
 3963   1             CCLINE(1,NLINES) = 0                                                                                          
 3964   1 *           EXECUTE (NEW_LINE)                                                                                            
 3965     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  127


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 3966     *        PROCEDURE (NEW_LINE)                                                                                             
 3967       C                                       CP    This procedure takes care of shifting the translated lines in the         
 3968       C                                       CP    arrays to make more room.                                                 
 3969   1             NLINES = NLINES + 1                                                                                           
 3970   1 *           IF (NLINES .EQ. 600)                                                                                          
 3971   2 *              IF (START)                                                                                                 
 3972       C                                       C                                                                               
 3973       C                                       C***   START = .TRUE., therefore we should throw away the rest of the blocks    
 3974       C                                       C***   instead of trying to shift.                                              
 3975       C                                       C                                                                               
                           +--------------------------------------------------------------------------------------------------------
 3976   3 *                |DO FOR II=600,1,-1                                                                                      
 3977       C              |                        C                                                                               
 3978       C              |                        C===   Find out which block we are in                                           
 3979       C              |                        C                                                                               
 3980   4 *                |   IF (CCLINE(1,II) .NE. 0)                                                                             
 3981   5                  |      IIBLK = CCLINE(1,II) - 1                                                                          
 3982       C              |                        C                                                                               
 3983       C              |                        C===   Move to previous block                                                   
 3984       C              |                        C                                                                               
                           |     +--------------------------------------------------------------------------------------------------
 3985   5 *                |     |DO FOR JJ=II,1,-1                                                                                 
 3986   6 *                |     |   IF (CCLINE(1,JJ) .EQ. IIBLK)                                                                   
 3987       C              |     |                  C                                                                               
 3988       C              |     |                  C===   Throw away rest of blocks                                                
 3989       C              |     |                  C                                                                               
 3990   7                  |     |      NLINES = JJ - 1                                                                             
 3991   7                  |     |      NBUF = RECBLK*IIBLK                                                                         
 3992   7                  |     |      PBUF = RECBLK*(IIBLK - 1) + CCLINE(2,JJ)                                                    
 3993       C              |     |                  C                                                                               
 3994       C              |     |                  C===   Done so return                                                           
 3995       C              |     |                  C                                                                               
 3996   7 *                |     |      EXECUTE (STORE_REMAINDER)                                                                   
 3997   6 *                |     |   ENDIF                                                                                          
 3998   5 *                |     |END DO FOR                                                                                        
                           |     +--------------------------------------------------------------------------------------------------
 3999   4 *                |   ENDIF                                                                                                
 4000   3 *                |END DO FOR                                                                                              
                           +--------------------------------------------------------------------------------------------------------
 4001   2 *              ELSE                                                                                                       
 4002   3                   CALL SFTLIN(LINES)                                                                                      
 4003   2 *              ENDIF                                                                                                      
 4004   1 *           ENDIF                                                                                                         
 4005     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  128


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4006     *        PROCEDURE (SET_CCLINE)                                                                                           
 4007       C                                       CP    This procedure sets the block and pointer values in the array CCLINE.     
 4008       C                                       C                                                                               
 4009       C                                       C***   First set up proper block number and byte count                          
 4010       C                                       C                                                                               
 4011   1             J = PBUF + LPBUF                                                                                              
 4012   1             CCLINE(1,NLINES) = LBLK + J/RECBLK                                                                            
 4013       C                                       C                                                                               
 4014       C                                       C***   Get byte offset                                                          
 4015       C                                       C                                                                               
 4016   1 *           IF (RECBLK .EQ. 512) THEN                                                                                     
 4017   2                CCLINE(2,NLINES) = LIB$EXTZV(0,9,J)                                                                        
 4018   1 *           ELSE                                                                                                          
 4019   2                CCLINE(2,NLINES) = J - RECBLK*(J/RECBLK)                                                                   
 4020   1 *           ENDIF                                                                                                         
 4021   1             IF (J .NE. 0 .AND. CCLINE(2,NLINES) .EQ. 0)                                                                   
 4022            1          CCLINE(1,NLINES) = CCLINE(1,NLINES) - 1                                                                 
 4023   1             IF (CCLINE(2,NLINES) .EQ. 0) CCLINE(2,NLINES) = RECBLK                                                        
 4024     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  129


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4025     *        PROCEDURE (STORE_REMAINDER)                                                                                      
 4026       C                                       CP    This procedure moves the partial record at the end of BUFFER to           
 4027       C                                       CP    the beginning of BUFFER and sets NBUF, and PBUF accordingly.              
                     +--------------------------------------------------------------------------------------------------------------
 4028   1 *          |DO FOR I=PBUF,NBUF                                                                                            
 4029   2            |   BUFFER(I-PBUF+1) = BUFFER(I)                                                                               
 4030   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 4031   1             NBUF = NBUF - PBUF + 1                                                                                        
 4032   1             I = PBUF + LPBUF                                                                                              
 4033   1 *           IF (RECBLK .EQ. 512)                                                                                          
 4034   2                LPBUF = LIB$EXTZV(0,9,I)                                                                                   
 4035   1 *           ELSE                                                                                                          
 4036   2                LPBUF = PBUF - RECBLK*(I/RECBLK)                                                                           
 4037   1 *           ENDIF                                                                                                         
 4038   1             IF (LPBUF .EQ. 0) LPBUF = RECBLK                                                                              
 4039   1             LPBUF = LPBUF - 1                                                                                             
 4040   1             PBUF = 1                                                                                                      
                     +--------------------------------------------------------------------------------------------------------------
 4041   1 *          |DO FOR I=NLINES,1,-1                                                                                          
 4042   2 *          |   IF (CCLINE(1,I) .NE. 0)                                                                                    
 4043   3            |      LBLK = CCLINE(1,I)                                                                                      
 4044   3            |      IF (LPBUF .EQ. 0) LBLK = LBLK + 1                                                                       
 4045   3 *          |      UNDO                                                                                                    
                     <-------                                                                                                       
 4046   2 *          |   ENDIF                                                                                                      
 4047   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 4048   1             RETURN                                                                                                        
              <--------                                                                                                             
 4049     *        END PROCEDURE                                                                                                    
 4050              END                                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        LINCON                30-SEP-83      08:30:11      PAGE  130


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 3872  CONVERT_TO_LINES               
                               3814  3833 

 3958  INSERT_BLANK_LINE              
                               3773  3779  3780  3792  3856  3908  3911 

 3966  NEW_LINE                       
                               3758  3854  3926  3949  3964 

 4006  SET_CCLINE                     
                               3806  3824 

 4025  STORE_REMAINDER                
                               3818  3863  3996 

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        BRDCST                30-SEP-83      08:30:11      PAGE  131


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4051              SUBROUTINE BRDCST(MESSAGE)                                                                                       
 4052       C                                       C                                                                               
 4053       C                                       C***********************************************************************        
 4054       C                                       C*****************************   BRDCST   ******************************        
 4055       C                                       C***********************************************************************        
 4056       C                                       C                                                                               
 4057       C                                       CDM   This subroutine catches broadcast messages and stores them away in        
 4058       C                                       CDM   common.                                                                   
 4059       C                                       CDM                                                                             
 4060       C                                       CDM   Programmer - Jon Vavrus   4 APR 1983                                      
 4061       C                                       CM                                                                              
 4062       C                                       CM         This routine is called as an AST whenever a broadcast message        
 4063       C                                       CM    comes through to the terminal.  That message is then stored away          
 4064       C                                       CM    in the common area BRDCM1.  A flag is set and a count is updated          
 4065       C                                       CM    in BRDCM2.                                                                
 4066       C                                       CM                                                                              
 4067       C                                       CM         A message is also output on to the screen.                           
 4068       C                                       C                                                                               
 4069       C                                       C***   COMMON AREAS                                                             
 4070       C                                       C                                                                               
 4071       C                                       CS    BRDCM1  Contains character variables for broadcast handling.              
 4072       C                                       CS              BRDNOT holds the notice to be displayed on the screen.          
 4073       C                                       CS              BRDMSG which holds broadcast messages.                          
 4074       C                                       C                                                                               
 4075       C                                       CS    BRDCM2  Contains non-character information for broadcast handling.        
 4076       C                                       CS              BRDLEN the length of strings in BRDMSG.                         
 4077       C                                       CS              BRDCNT the count of strings in BRDMSG.                          
 4078       C                                       CS              BRDFLG a flag telling if there are unread messages.             
 4079       C                                       C                                                                               
 4080       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4081       C                                       CS                 INCHAN - input channel of the terminal                       
 4082       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4083       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4084       C                                       CS                          in the search buffer                                
 4085       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4086       C                                       CS                 EBK    - EBK of input file                                   
 4087       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
 4088       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4089       C                                       CS                 RANGE  - starting and ending block numbers and pointers      
 4090       C                                       CS                          of the print range.                                 
 4091       C                                       CS                 VT100  - flag set .TRUE. if terminal is a VT100              
 4092       C                                       CS                 LRL    - length of longest record in input file              
 4093       C                                       CS                 LENLMT - maximum length of output (if <0 then WRAP set)      
 4094       C                                       CS                 PAGEND - Line number of last line output to screen.          
 4095       C                                       CS                 PAGLEN - number of lines per page                            
 4096       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 4097       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 4098       C                                       C                                                                               
 4099              CHARACTER*(*) MESSAGE                                                                                            
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        BRDCST                30-SEP-83      08:30:11      PAGE  132


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4100              CHARACTER*128 BRDMSG(20)                                                                                         
 4101              CHARACTER*22 BRDNOT                                                                                              
 4102              INTEGER*4 TIME,EBK,RANGE(2,2),PAGEND                                                                             
 4103              INTEGER*2 DIRECT,SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,                                                         
 4104            1       BRDCNT,BRDLEN(20)                                                                                          
 4105              LOGICAL*1 SBFFLG,VT100,VT100A,BRDFLG                                                                             
 4106                                                                                                                               
 4107              COMMON /BRDCM1/BRDNOT,BRDMSG                                                                                     
 4108              COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                                                              
 4109              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4110            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 4111                                                                                                                               
 4112              BRDCNT = BRDCNT + 1                                                                                              
 4113     *        IF (BRDCNT .LE. 20) THEN                                                                                         
 4114   1             BRDFLG = .TRUE.                                                                                               
 4115   1             BRDMSG(BRDCNT) = MESSAGE                                                                                      
 4116   1             BRDLEN(BRDCNT) = LEN(MESSAGE)                                                                                 
 4117     *        ELSE                                                                                                             
                     +--------------------------------------------------------------------------------------------------------------
 4118   1 *          |DO FOR I=2,20                                                                                                 
 4119   2            |   BRDMSG(I-1) = BRDMSG(I)                                                                                    
 4120   2            |   BRDLEN(I-1) = BRDLEN(I)                                                                                    
 4121   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 4122   1             BRDMSG(20) = MESSAGE                                                                                          
 4123   1             BRDLEN(20) = LEN(MESSAGE)                                                                                     
 4124     *        ENDIF                                                                                                            
 4125     *        IF (VT100)                                                                                                       
 4126   1             CALL LIB$PUT_SCREEN(CHAR(27)//'7')                                                                            
 4127   1             CALL LIB$PUT_SCREEN(BRDNOT,COMLIN,IABS(LENLMT)-28)                                                            
 4128     *        ENDIF                                                                                                            
 4129              RETURN                                                                                                           
              <-----                                                                                                                
 4130              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  133


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4131                                                                                                                              
 4132              SUBROUTINE CONVUP(LENGTH,LOWER,UPPER)                                                                            
 4133       C                                       C                                                                               
 4134       C                                       C***********************************************************************        
 4135       C                                       C*****************************   CONVUP   ******************************        
 4136       C                                       C***********************************************************************        
 4137       C                                       C                                                                               
 4138       C                                       CDM   This subroutine converts a string from lower to upper case.               
 4139       C                                       CDM   Both of the strings are passed in non-descriptor form.                    
 4140       C                                       CDM                                                                             
 4141       C                                       CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
 4142       C                                       CM                                                                              
 4143       C                                       CM         The routine takes a string of bytes starting at the location         
 4144       C                                       CM    given for LOWER and converts any alphabetic characters in the first       
 4145       C                                       CM    LENGTH bytes to upper-case, returning the converted string of bytes       
 4146       C                                       CM    starting at the location given for UPPER.                                 
 4147       C                                       C                                                                               
 4148              INTEGER*2 LENGTH                                                                                                 
 4149              LOGICAL*1 LOWER(1),UPPER(1)                                                                                      
 4150                                                                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 4151     *       |DO FOR I=1,LENGTH                                                                                                
 4152       C     |                                 C                                                                               
 4153       C     |                                 C***   141 octal is lowercase a in ASCII, 172 octal is lowercase z in           
 4154       C     |                                 C***   ASCII.  40 octal is the spacing between the upper and lowercase          
 4155       C     |                                 C***   alphabets in ASCII.                                                      
 4156       C     |                                 C                                                                               
 4157   1 *       |   IF (LOWER(I) .GE. '141'O .AND. LOWER(I) .LE. '172'O) THEN                                                     
 4158   2         |      UPPER(I) = LOWER(I) - '40'O                                                                                
 4159   1 *       |   ELSE                                                                                                          
 4160   2         |      UPPER(I) = LOWER(I)                                                                                        
 4161   1 *       |   ENDIF                                                                                                         
 4162     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
 4163              RETURN                                                                                                           
              <-----                                                                                                                
 4164              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  134


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4165                                                                                                                              
 4166              SUBROUTINE EXITR                                                                                                 
 4167       C                                       C                                                                               
 4168       C                                       C***********************************************************************        
 4169       C                                       C*******************************   EXITR   *****************************        
 4170       C                                       C***********************************************************************        
 4171       C                                       C                                                                               
 4172       C                                       CDM   This subroutine is invoked on image exit and cancels any                  
 4173       C                                       CDM   AST, and closes the file and re-stores the terminal.                      
 4174       C                                       CDM                                                                             
 4175       C                                       CDM   Programmer - Jon Vavrus  13 JAN 1983                                      
 4176       C                                       CM                                                                              
 4177       C                                       CM    Should be set up by a call to SYS$DCLEXH(BLOCK) where block               
 4178       C                                       CM    is a 4 longword array with this routines address as the second            
 4179       C                                       CM    longword, 1 as the third longword, and the address of any                 
 4180       C                                       CM    writable location (longword) as the fourth.                               
 4181       C                                       C                                                                               
 4182       C                                       C***   COMMON STORAGE                                                           
 4183       C                                       C                                                                               
 4184       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4185       C                                       CS                 INCHAN - input channel of the terminal                       
 4186       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4187       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4188       C                                       CS                          in the search buffer                                
 4189       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4190       C                                       CS                 EBK    - EBK of input file                                   
 4191       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
 4192       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4193       C                                       CS                 RANGE  - starting and ending block numbers and pointers      
 4194       C                                       CS                          of the print range.                                 
 4195       C                                       CS                 VT100  - flag set .TRUE. if terminal is a VT100              
 4196       C                                       C                                                                               
 4197       C                                       CS    STOPCM  Used to pass information back and forth to/from the stop          
 4198       C                                       CS            scrolling AST.  STOPIT is a flag set .TRUE. if scrolling          
 4199       C                                       CS            should be stopped, INBUF is the input character, IOFLAG and       
 4200       C                                       CS            TIMFLG are event flags, and IOSB is the I/O IOSB.                 
 4201       C                                       C                                                                               
 4202              INTEGER*4 TIMFLG,TIME,EBK,RANGE(2,2)                                                                             
 4203              INTEGER*2 IOSB(4),DIRECT,SBFLEN(10),RECBLK                                                                       
 4204              LOGICAL*1 STOPIT,INBUF,SBFFLG,VT100                                                                              
 4205                                                                                                                               
 4206              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4207            1       VT100                                                                                                      
 4208              COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                                                                   
 4209                                                                                                                               
 4210     *        IF (IOFLAG .GT. 0)                                                                                               
 4211   1             CALL SYS$CANCEL(%VAL(INCHAN))                                                                                 
 4212   1             CALL LIB$FREE_EF(IOFLAG)                                                                                      
 4213     *        ENDIF                                                                                                            
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        EXITR                 30-SEP-83      08:30:11      PAGE  135


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4214              CALL WORKNG(.FALSE.)                                                                                             
 4215              CALL RESTRM(INCHAN)                                                                                              
 4216              CALL BLKCLS                                                                                                      
 4217              IF (VT100) CALL LIB$PUT_SCREEN(CHAR(27)//'[0q')                                                                  
 4218              CALL SYS$DASSGN(%VAL(INCHAN))                                                                                    
 4219              RETURN                                                                                                           
              <-----                                                                                                                
 4220              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  136


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4221                                                                                                                              
 4222              SUBROUTINE INTASC(LENGTH,DATA,STRING)                                                                            
 4223       C                                       C                                                                               
 4224       C                                       C***********************************************************************        
 4225       C                                       C******************************   INTASC   *****************************        
 4226       C                                       C***********************************************************************        
 4227       C                                       C                                                                               
 4228       C                                       CDM   This subroutine converts a string of ascii coded bytes to a character     
 4229       C                                       CDM   variable                                                                  
 4230       C                                       CDM                                                                             
 4231       C                                       CDM   Programmer - Jon Vavrus    JUL 1980                                       
 4232       C                                       CM                                                                              
 4233       C                                       CM         The subroutine is called with LENGTH (the number of bytes to be      
 4234       C                                       CM    converted), DATA (the starting location of the data), and STRING (a       
 4235       C                                       CM    character variable to recieve the translation).  After translation the    
 4236       C                                       CM    LENGTH+1 character of STRING is set to a blank.                           
 4237       C                                       C                                                                               
 4238              CHARACTER*(*) STRING                                                                                             
 4239              INTEGER*2 LENGTH                                                                                                 
 4240              LOGICAL*1 DATA(200)                                                                                              
 4241                                                                                                                               
 4242              DECODE (LENGTH,100,DATA)STRING                                                                                   
 4243       100    FORMAT (A<LENGTH>)                                                                                               
 4244              STRING(LENGTH+1:LENGTH+1) = ' '                                                                                  
 4245              RETURN                                                                                                           
              <-----                                                                                                                
 4246              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  137


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4247                                                                                                                              
 4248              SUBROUTINE REDOIT(COMAND,NUMFLG,TANUMB,MINFLG)                                                                   
 4249       C                                       C                                                                               
 4250       C                                       C***********************************************************************        
 4251       C                                       C*****************************   REDOIT   ******************************        
 4252       C                                       C***********************************************************************        
 4253       C                                       C                                                                               
 4254       C                                       CDM   This routine calls DOIT                                                   
 4255       C                                       CDM                                                                             
 4256       C                                       CDM   Programmer - Jon Vavrus  26 AUG 1981                                      
 4257       C                                       CM                                                                              
 4258       C                                       CM         The routine simply calls DOIT with the same argument list.           
 4259       C                                       CM    This allows DOIT to call itself.                                          
 4260       C                                       C                                                                               
 4261       C                                       C***   CALLED ROUTINES                                                          
 4262       C                                       C                                                                               
 4263       C                                       C     DOIT    Executes commands                                                 
 4264       C                                       C                                                                               
 4265              INTEGER*4 COMAND                                                                                                 
 4266              LOGICAL*1 MINFLG,NUMFLG                                                                                          
 4267                                                                                                                               
 4268       C                                       C      CALL DOIT(COMAND,NUMFLG,TANUMB,MINFLG)                                   
 4269              RETURN                                                                                                           
              <-----                                                                                                                
 4270              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  138


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4271                                                                                                                              
 4272              SUBROUTINE SFTLIN(LINES)                                                                                         
 4273       C                                       C                                                                               
 4274       C                                       C***********************************************************************        
 4275       C                                       C*****************************   SFTLIN   ******************************        
 4276       C                                       C***********************************************************************        
 4277       C                                       C                                                                               
 4278       C                                       CDM   This subroutine shifts the output lines stored in the line storage        
 4279       C                                       CDM   arrays in order to make room at the end of the arrays for more lines.     
 4280       C                                       CDM                                                                             
 4281       C                                       CDM    Programmer - Jon Vavrus  13 NOV 1980                                     
 4282       C                                       CDM    Revised    - Jon Vavrus  12 MAY 1981                                     
 4283       C                                       CDM    Revised    - Jon Vavrus  29 JUL 1981 (change CCLINE usage)               
 4284       C                                       CDM    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                     
 4285       C                                       CM                                                                              
 4286       C                                       CM         The routine requires LINES (the character array of actual            
 4287       C                                       CM    output lines) to be passed as an argument, all the other arrays are       
 4288       C                                       CM    passed through common area LNCN.  The normal shift is to make room        
 4289       C                                       CM    for 100 more lines at the end, however, if there are less then 500        
 4290       C                                       CM    lines already then the shift frees up 599 of the 600 lines.  When         
 4291       C                                       CM    the shift occurs lines shifted off the front of the arrays are lost.      
 4292       C                                       C                                                                               
 4293       C                                       C***   COMMON AREAS                                                             
 4294       C                                       C                                                                               
 4295       C                                       CS    LNCN    Contains output arrays, and file pointers and information:        
 4296       C                                       CS                 LINLEN - array of output line lengths                        
 4297       C                                       CS                 LINEP  - top of screen line (or last line output by          
 4298       C                                       CS                          backward scroll)                                    
 4299       C                                       CS                 NLINES - number of lines in arrays                           
 4300       C                                       CS                 BUFFER - array of unconverted data                           
 4301       C                                       CS                 PBUF   - current position in BUFFER                          
 4302       C                                       CS                 NBUF   - number of bytes in BUFFER                           
 4303       C                                       CS                 BLK    - next block in file                                  
 4304       C                                       CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
 4305       C                                       CS                 IFSZ   - word extended record length for FIX files           
 4306       C                                       CS                 RFM    - files RFM                                           
 4307       C                                       CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
 4308       C                                       CS                 SBLK   - starting block of current batch of output lines     
 4309       C                                       CS                 CCLINE - array containing pointer to where the line's        
 4310       C                                       CS                          record starts in the file (CCLINE(1,x) = block      
 4311       C                                       CS                          #, CCLINE(2,x) = byte number in block).  If         
 4312       C                                       CS                          CCLINE(1,x) = 0 then it is a carriage control       
 4313       C                                       CS                          line.                                               
 4314       C                                       CS                 LBLK   - last block processed by LINCON                      
 4315       C                                       CS                 LPBUF  - last value of PBUF processed by LINCON              
 4316       C                                       C                                                                               
 4317              CHARACTER*132 LINES(600)                                                                                         
 4318              INTEGER*4 RFM,RAT,FSZ,PBUF,BLK,SBLK,CCLINE(2,600)                                                                
 4319              INTEGER*2 LINLEN(600)                                                                                            
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        SFTLIN                30-SEP-83      08:30:11      PAGE  139


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4320              LOGICAL*1 BUFFER(3750)                                                                                           
 4321                                                                                                                               
 4322              COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,                                                  
 4323            1       RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                                                                             
 4324                                                                                                                               
 4325     *        IF (LINEP .GT. 500) THEN                                                                                         
 4326   1             J = 500                                                                                                       
 4327     *        ELSE                                                                                                             
 4328   1             J = LINEP - 1                                                                                                 
 4329     *        ENDIF                                                                                                            
                  +-----------------------------------------------------------------------------------------------------------------
 4330     *       |DO FOR I=J,600                                                                                                   
 4331   1         |   LINLEN(I-J+1) = LINLEN(I)                                                                                     
 4332   1         |   LINES(I-J+1) = LINES(I)                                                                                       
 4333   1         |   CCLINE(1,I-J+1) = CCLINE(1,I)                                                                                 
 4334   1         |   CCLINE(2,I-J+1) = CCLINE(2,I)                                                                                 
 4335     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
                  +-----------------------------------------------------------------------------------------------------------------
 4336     *       |DO FOR I=1,J-1                                                                                                   
 4337   1 *       |   IF (CCLINE(1,I) .NE. 0)                                                                                       
 4338   2         |      SBLK = CCLINE(1,I)                                                                                         
 4339   2 *       |      UNDO                                                                                                       
                  <-------                                                                                                          
 4340   1 *       |   ENDIF                                                                                                         
 4341     *       |END DO FOR                                                                                                       
                  +-----------------------------------------------------------------------------------------------------------------
 4342              LINEP = LINEP - J + 1                                                                                            
 4343              NLINES = 600 - J + 1                                                                                             
 4344              RETURN                                                                                                           
              <-----                                                                                                                
 4345              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  140


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4346                                                                                                                              
 4347              SUBROUTINE STOPSC                                                                                                
 4348       C                                       C                                                                               
 4349       C                                       C***********************************************************************        
 4350       C                                       C*****************************   STOPSC   ******************************        
 4351       C                                       C***********************************************************************        
 4352       C                                       C                                                                               
 4353       C                                       CDM   This subroutine is the AST used to stop the scrolling function.           
 4354       C                                       CDM                                                                             
 4355       C                                       CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
 4356       C                                       CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
 4357       C                                       CDM   Revised    - Jon Vavrus  26 AUG 1981                                      
 4358       C                                       CDM   Revised    - Jon Vavrus   6 NOV 1981                                      
 4359       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
 4360       C                                       CM                                                                              
 4361       C                                       CM         The routine is executed whenever anything is typed while a           
 4362       C                                       CM    scroll is in progress.  If the character typed is "(" or a symbol         
 4363       C                                       CM    defined as "(", all timer requests are cancelled, the timer event         
 4364       C                                       CM    flag is set, and STOPIT is set to .TRUE..  If the character typed         
 4365       C                                       CM    is not one of the above, then the I/O is requeued with STPSC2 as          
 4366       C                                       CM    its AST (STPSC2 just calls this routine), and the character is in-        
 4367       C                                       CM    serted into the input buffer.                                             
 4368       C                                       C                                                                               
 4369       C                                       C***   CALLED ROUTINES                                                          
 4370       C                                       C                                                                               
 4371       C                                       CC    STPSC2  Routine which simply calls this one.                              
 4372       C                                       C                                                                               
 4373       C                                       C***   COMMON AREAS                                                             
 4374       C                                       C                                                                               
 4375       C                                       C                                                                               
 4376       C                                       CS    STOPCM  Used to pass information back and forth to/from the main          
 4377       C                                       CS            process.  STOPIT is a flag set .TRUE. if scrolling should         
 4378       C                                       CS            be stopped, INBUF is the input character, IOFLAG and TIMFLG       
 4379       C                                       CS            are event flags, and IOSB is the I/O IOSB.                        
 4380       C                                       C                                                                               
 4381       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4382       C                                       CS                 INCHAN - input channel of the terminal                       
 4383       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4384       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4385       C                                       CS                          in the search buffer                                
 4386       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4387       C                                       CS                 EBK    - EBK of input file                                   
 4388       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
 4389       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4390       C                                       CS                 RANGE  - starting and ending block numbers and pointers      
 4391       C                                       CS                          of the print range.                                 
 4392       C                                       CS                 VT100  - flag set .TRUE. if terminal is a VT100              
 4393       C                                       CS                 LRL    - length of longest record in input file              
 4394       C                                       CS                 LENLMT - maximum length of output (if <0 then WRAP set)      
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        STOPSC                30-SEP-83      08:30:11      PAGE  141


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4395       C                                       CS                 PAGEND - Line number of last line output to screen.          
 4396       C                                       CS                 PAGLEN - number of lines per page                            
 4397       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 4398       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 4399       C                                       C                                                                               
 4400       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
 4401       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
 4402       C                                       C                                                                               
 4403       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
 4404       C                                       CS            symbol definitions DEFS, the number of such definitions           
 4405       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
 4406       C                                       CS            numbers NUMDEF                                                    
 4407       C                                       C                                                                               
 4408       C                                       C***   INPUT VARIABLES                                                          
 4409       C                                       C                                                                               
 4410       C                                       CI    INBUF   One byte buffer used for the QIO input request.                   
 4411       C                                       C                                                                               
 4412       C                                       C***   INPUT UNIT                                                               
 4413       C                                       C                                                                               
 4414       C                                       CR    INCHAN  Channel number of the terminal.                                   
 4415       C                                       C                                                                               
 4416              EXTERNAL STPSC2                                                                                                  
 4417              CHARACTER*128 INLINE                                                                                             
 4418              CHARACTER*30 DEFBUF(10,10,60)                                                                                    
 4419              CHARACTER*1 SYMS(60)                                                                                             
 4420              REAL*4 NUMDEF(10,60)                                                                                             
 4421              INTEGER*4 TIMFLG,TIME,EBK,RANGE(2,2),PAGEND                                                                      
 4422              INTEGER*2 IOSB(4),DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,                                                
 4423            1       LENSAV,PAGLEN,COMLIN                                                                                       
 4424              LOGICAL*1 INBUF,STOPIT,ERROUT(5),SBFFLG,VT100,DEFFLG(3,10,60),                                                   
 4425            1       VT100A                                                                                                     
 4426                                                                                                                               
 4427              COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                                                                   
 4428              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4429            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 4430              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
 4431              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
 4432                                                                                                                               
 4433              DATA ERROUT/7,27,'[','3','q'/                                                                                    
 4434     *        IF (IOSB(1) .NE. '830'X .AND. IOSB(1) .NE. '2C'X)                                                                
 4435       C                                       C                                                                               
 4436       C                                       C***   Is the character a (                                                     
 4437       C                                       C                                                                               
 4438   1 *           IF (INBUF .EQ. '(') THEN                                                                                      
 4439   2                CALL SYS$CANTIM(,)                                                                                         
 4440   2                STOPIT = .TRUE.                                                                                            
 4441   2                CALL SYS$SETEF(%VAL(TIMFLG))                                                                               
 4442   1 *           ELSE                                                                                                          
 4443       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        STOPSC                30-SEP-83      08:30:11      PAGE  142


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4444       C                                       C***   Is the character a symbol defined as (                                   
 4445       C                                       C                                                                               
                        +-----------------------------------------------------------------------------------------------------------
 4446   2 *             |DO FOR I=1,NDEFS                                                                                           
 4447   3 *             |   IF (ICHAR(SYMS(I)) .EQ. INBUF .AND. DEFS(1,1,I) .EQ. 6) THEN                                            
 4448   4               |      CALL SYS$CANTIM(,)                                                                                   
 4449   4               |      STOPIT = .TRUE.                                                                                      
 4450   4               |      CALL SYS$SETEF(%VAL(TIMFLG))                                                                         
 4451   4               |      RETURN                                                                                               
              <-----------------                                                                                                    
 4452   3 *             |   ENDIF                                                                                                   
 4453   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 4454       C                                       C                                                                               
 4455       C                                       C***   If character is not a control character add it to INLINE (input          
 4456       C                                       C***   buffer)                                                                  
 4457       C                                       C                                                                               
 4458   2 *              IF (INBUF .GE. 32 .AND. INBUF .LE. 126)                                                                    
 4459   3                   LENSAV = LENSAV + 1                                                                                     
 4460   3                   INLINE(LENSAV:LENSAV) = CHAR(INBUF)                                                                     
 4461   2 *              ELSE                                                                                                       
 4462       C                                       C                                                                               
 4463       C                                       C***   If it is a <DEL> then remove the last character                          
 4464       C                                       C                                                                               
 4465   3 *                 IF (INBUF .EQ. 127 .AND. LENSAV .GE. 1)                                                                 
 4466   4                      LENSAV = LENSAV - 1                                                                                  
 4467   3 *                 ELSE                                                                                                    
 4468       C                                       C                                                                               
 4469       C                                       C***   If it is a ^X or ^U then delete entire buffer                            
 4470       C                                       C                                                                               
 4471   4 *                    IF (INBUF .EQ. 24 .OR. INBUF .EQ. 21)                                                                
 4472   5                         LENSAV = 0                                                                                        
 4473   4 *                    ENDIF                                                                                                
 4474   3 *                 ENDIF                                                                                                   
 4475   2 *              ENDIF                                                                                                      
 4476       C                                       C                                                                               
 4477       C                                       C***   Requeue request                                                          
 4478       C                                       C                                                                               
 4479   2                CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,                                                 
 4480            1             STPSC2,,INBUF,%VAL(1),,,,)                                                                           
 4481   1 *           ENDIF                                                                                                         
 4482     *        ENDIF                                                                                                            
 4483              RETURN                                                                                                           
              <-----                                                                                                                
 4484              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  143


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4485                                                                                                                              
 4486              SUBROUTINE STPSC2                                                                                                
 4487       C                                       C                                                                               
 4488       C                                       C***********************************************************************        
 4489       C                                       C*****************************   STPSC2   ******************************        
 4490       C                                       C***********************************************************************        
 4491       C                                       C                                                                               
 4492       C                                       CDM   This subroutine is the AST for the I/O request from STOPSC, if            
 4493       C                                       CDM   invoked it will call STOPSC and exit.                                     
 4494       C                                       CDM                                                                             
 4495       C                                       CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
 4496       C                                       C                                                                               
 4497       C                                       C***   CALLED ROUTINES                                                          
 4498       C                                       C                                                                               
 4499       C                                       C     STOPSC   Actual AST routine.                                              
 4500       C                                       C                                                                               
 4501       C                                       C      CALL STOPSC                                                              
 4502              RETURN                                                                                                           
              <-----                                                                                                                
 4503              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  144


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4504                                                                                                                              
 4505              SUBROUTINE TMAST2                                                                                                
 4506       C                                       C                                                                               
 4507       C                                       C****************************************************************************** 
 4508       C                                       C*********************************   TMAST2   ********************************* 
 4509       C                                       C****************************************************************************** 
 4510       C                                       C                                                                               
 4511       C                                       C                                                                               
 4512       C                                       CDM   This routine is simply a means for TIMAST to refer to itself.  All it     
 4513       C                                       CDM   does is call TIMAST.                                                      
 4514       C                                       CDM                                                                             
 4515       C                                       CDM   Programmer  Jon Vavrus -  3 SEP 1982                                      
 4516       C                                       CDM   Revised     Jon Vavrus - 21 SEP 1983 (changed name with TIMAST)           
 4517       C                                       C                                                                               
 4518       C                                       C***   CALLED ROUTINES                                                          
 4519       C                                       C                                                                               
 4520       C                                       C     TIMAST    - Routine to actually output the next message.                  
 4521       C                                       C                                                                               
 4522       C                                       C      CALL TIMAST                                                              
 4523              RETURN                                                                                                           
              <-----                                                                                                                
 4524              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  145


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4525                                                                                                                              
 4526              SUBROUTINE TIMAST                                                                                                
 4527       C                                       C                                                                               
 4528       C                                       C****************************************************************************** 
 4529       C                                       C*********************************   TIMAST   ********************************* 
 4530       C                                       C****************************************************************************** 
 4531       C                                       C                                                                               
 4532       C                                       CDM   This routine outputs the proper "WORKING" message at the bottom of the    
 4533       C                                       CDM   screen and requeues itself as a timer AST (through TMAST2).               
 4534       C                                       CDM                                                                             
 4535       C                                       CDM   Programmer  Jon Vavrus -  8 SEP 1982                                      
 4536       C                                       CDM   Revised     Jon Vavrus - 21 SEP 1983 (changed name with TMAST2)           
 4537       C                                       C                                                                               
 4538       C                                       C***   CALLED ROUTINES                                                          
 4539       C                                       C                                                                               
 4540       C                                       CC    TMAST2   - Routine which calls this one.                                  
 4541       C                                       C                                                                               
 4542       C                                       C***   COMMON AREAS                                                             
 4543       C                                       C                                                                               
 4544       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4545       C                                       CS                 INCHAN - input channel of the terminal                       
 4546       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4547       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4548       C                                       CS                          in the search buffer                                
 4549       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4550       C                                       CS                 EBK    - EBK of input file                                   
 4551       C                                       CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
 4552       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4553       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
 4554       C                                       CS                          of the print range                                  
 4555       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
 4556       C                                       CS                 LRL    - length of the longest record in input file.         
 4557       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 4558       C                                       CS                 PAGEND - line number of last line output to screen           
 4559       C                                       CS                 PAGLEN - number of lines per page                            
 4560       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 4561       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 4562       C                                       C                                                                               
 4563       C                                       CS    TASTNM  Used to pass the ROW and COLUMN for the message, the flag         
 4564       C                                       CS            ONEFLG, the timer delta time DELTA, and the timer event flag      
 4565       C                                       CS            TIMREF.                                                           
 4566       C                                       C                                                                               
 4567              EXTERNAL TMAST2                                                                                                  
 4568              INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,TIMREF,DELTA(2)                                                      
 4569              INTEGER*2 SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,DIRECT,ROW,COLUMN                                               
 4570              LOGICAL*1 SBFFLG,VT100,VT100A,START,ONEFLG                                                                       
 4571                                                                                                                               
 4572              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4573            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        TIMAST                30-SEP-83      08:30:11      PAGE  146


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4574              COMMON /TASTNM/ROW,COLUMN,ONEFLG,DELTA,TIMREF                                                                    
 4575                                                                                                                               
 4576     *        IF (ONEFLG) THEN                                                                                                 
 4577   1 *           IF (VT100A)                                                                                                   
 4578   2                CALL LIB$PUT_SCREEN(CHAR(27)//'[7mWORKING'//CHAR(27)//'[0m',                                               
 4579            1             ROW,COLUMN)                                                                                          
 4580   1 *           ELSE                                                                                                          
 4581   2                CALL LIB$PUT_SCREEN('WORKING',ROW,COLUMN)                                                                  
 4582   1 *           ENDIF                                                                                                         
 4583   1             ONEFLG = .FALSE.                                                                                              
 4584     *        ELSE                                                                                                             
 4585   1 *           IF (VT100A)                                                                                                   
 4586   2                CALL LIB$PUT_SCREEN(CHAR(27)//'[1mWORKING'//CHAR(27)//'[0m',                                               
 4587            1             ROW,COLUMN)                                                                                          
 4588   1 *           ELSE                                                                                                          
 4589   2                CALL LIB$PUT_SCREEN('working',ROW,COLUMN)                                                                  
 4590   1 *           ENDIF                                                                                                         
 4591   1             ONEFLG = .TRUE.                                                                                               
 4592     *        ENDIF                                                                                                            
 4593       C                                       C                                                                               
 4594       C                                       C***   Queue AST                                                                
 4595       C                                       C                                                                               
 4596              CALL SYS$SETIMR(%VAL(TIMREF),DELTA,TMAST2,%VAL(1))                                                               
 4597              RETURN                                                                                                           
              <-----                                                                                                                
 4598              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)                              30-SEP-83      08:30:11      PAGE  147


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4599                                                                                                                              
 4600              SUBROUTINE WORKNG(START)                                                                                         
 4601       C                                       C                                                                               
 4602       C                                       C****************************************************************************** 
 4603       C                                       C*********************************   WORKNG   ********************************* 
 4604       C                                       C****************************************************************************** 
 4605       C                                       C                                                                               
 4606       C                                       CDM   This subroutine puts out the flashing "WORKING" message.                  
 4607       C                                       CDM                                                                             
 4608       C                                       CDM   Programmer  Jon Vavrus -  8 SEP 1982                                      
 4609       C                                       CM                                                                              
 4610       C                                       CM    The message is displayed at screen position COMLIN(from DOITNM),          
 4611       C                                       CM    IABS(LENLMT)-19(DOITNM also) if START (logical) is .TRUE., and is         
 4612       C                                       CM    stopped if START is .FALSE..  The changing of the display is done         
 4613       C                                       CM    through the use of a system timer AST.                                    
 4614       C                                       C                                                                               
 4615       C                                       C***   COMMON AREAS                                                             
 4616       C                                       C                                                                               
 4617       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4618       C                                       CS                 INCHAN - input channel of the terminal                       
 4619       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4620       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4621       C                                       CS                          in the search buffer                                
 4622       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4623       C                                       CS                 EBK    - EBK of input file                                   
 4624       C                                       CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
 4625       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4626       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
 4627       C                                       CS                          of the print range                                  
 4628       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
 4629       C                                       CS                 LRL    - length of the longest record in input file.         
 4630       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 4631       C                                       CS                 PAGEND - line number of last line output to screen           
 4632       C                                       CS                 PAGLEN - number of lines per page                            
 4633       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 4634       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 4635       C                                       C                                                                               
 4636       C                                       CS    TASTNM  Used to pass the ROW and COLUMN for the message, the flag         
 4637       C                                       CS            ONEFLG, the timer delta time DELTA, and the timer event flag      
 4638       C                                       CS            TIMREF.                                                           
 4639       C                                       C                                                                               
 4640       C                                       C***   CALLED ROUTINES                                                          
 4641       C                                       C                                                                               
 4642       C                                       CC    TIMAST  Timer AST.                                                        
 4643       C                                       C                                                                               
 4644              EXTERNAL TIMAST                                                                                                  
 4645              INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,TIMREF,DELTA(2)                                                      
 4646              INTEGER*2 SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,DIRECT,ROW,COLUMN                                               
 4647              LOGICAL*1 SBFFLG,VT100,VT100A,START,ONEFLG                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        WORKNG                30-SEP-83      08:30:11      PAGE  148


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4648                                                                                                                               
 4649              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4650            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 4651              COMMON /TASTNM/ROW,COLUMN,ONEFLG,DELTA,TIMREF                                                                    
 4652                                                                                                                               
 4653              DATA DELTA/-20000000,-1/                                                                                         
 4654                                                                                                                               
 4655     *        IF (START) THEN                                                                                                  
 4656       C                                       C                                                                               
 4657       C                                       C***   Set up to start                                                          
 4658       C                                       C                                                                               
 4659   1             ONEFLG = .FALSE.                                                                                              
 4660   1             CALL LIB$GET_EF(TIMREF)                                                                                       
 4661   1             ROW = COMLIN                                                                                                  
 4662   1             COLUMN = IABS(LENLMT) - 19                                                                                    
 4663       C                                       C                                                                               
 4664       C                                       C***   Output message                                                           
 4665       C                                       C                                                                               
 4666   1 *           IF (VT100A)                                                                                                   
 4667   2                CALL LIB$PUT_SCREEN(CHAR(27)//'[7mWORKING'//CHAR(27)//'[0m',                                               
 4668            1             ROW,COLUMN)                                                                                          
 4669   1 *           ELSE                                                                                                          
 4670   2                CALL LIB$PUT_SCREEN('WORKING',ROW,COLUMN)                                                                  
 4671   1 *           ENDIF                                                                                                         
 4672       C                                       C                                                                               
 4673       C                                       C***   Queue AST                                                                
 4674       C                                       C                                                                               
 4675   1             CALL SYS$SETIMR(%VAL(TIMREF),DELTA,TIMAST,%VAL(1))                                                            
 4676     *        ELSE                                                                                                             
 4677   1 *           IF (TIMREF .GT. 0)                                                                                            
 4678       C                                       C                                                                               
 4679       C                                       C***   Make sure not invoked at wrong time by EXITR                             
 4680       C                                       C                                                                               
 4681       C                                       C***   Done working, cancel timer requests and clear message                    
 4682       C                                       C                                                                               
 4683   2                CALL SYS$CANTIM(%VAL(1),)                                                                                  
 4684   2                CALL LIB$PUT_SCREEN('       ',ROW,COLUMN)                                                                  
 4685   2                CALL LIB$SET_CURSOR(1,1)                                                                                   
 4686   2                CALL LIB$FREE_EF(TIMREF)                                                                                   
 4687   1 *           ENDIF                                                                                                         
 4688     *        ENDIF                                                                                                            
 4689              RETURN                                                                                                           
              <-----                                                                                                                
 4690              END                                                                                                              

       0 DIAGNOSTICS GENERATED
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  149


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4691              SUBROUTINE PRSCOM(LINE,LENLIN,ICOM,NUMFLG,ANUMB,MINFLG,NDEF,NSYM)                                                
 4692       C                                       CDM   This routine parses a command line.                                       
 4693       C                                       CDM                                                                             
 4694       C                                       CDM   Programmer - Jon Vavrus  26 AUG 1981                                      
 4695       C                                       CDM   Revised    - Jon Vavrus   3 SEP 1981                                      
 4696       C                                       CDM   Revised    - Jon Vavrus  23 SEP 1981                                      
 4697       C                                       CDM   Revised    - Jon Vavrus  30 DEC 1981 (put LED #1 turn-on in DOIT)         
 4698       C                                       CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
 4699       C                                       CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
 4700       C                                       CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
 4701       C                                       CDM   Revised    - Jon Vavrus  30 NOV 1982                                      
 4702       C                                       CDM   Revised    - Jon Vavrus  28 MAY 1983 (Allow real scroll speeds)           
 4703       C                                       CDM   Revised    - Jon Vavrus   7 SEP 1983                                      
 4704       C                                       CDM   Revised    - Jon Vavrus  21 SEP 1983                                      
 4705       C                                       CM                                                                              
 4706       C                                       CM         The routine parses a command line.  It is passed the command line    
 4707       C                                       CM    in LINE its length in LENLIN.  The command number is returned in          
 4708       C                                       CM    ICOM, if it is "minussed" the flag MINFLG is set, if there is a number    
 4709       C                                       CM    preceding it the number is stored in ANUMB and the flag NUMFLG is         
 4710       C                                       CM    set.  If ICOM = 0 then no command was found/legal (error "beep" +         
 4711       C                                       CM    LED 3 are taken care of).  If a defined symbol is found its commands      
 4712       C                                       CM    are executed and ICOM = -1.  After execution the procedure sets LINE      
 4713       C                                       CM    and LENLIN to the after parse values.  Note:  If a definition symbol      
 4714       C                                       CM    encountered, it's internal commands will be executed should NDEF or       
 4715       C                                       CM    NSYM be zero, otherwise its definition will be inserted into the          
 4716       C                                       CM    definition arrays  beginning at command NDEF of definition NSYM.          
 4717       C                                       C                                                                               
 4718       C                                       C***   CALLED ROUTINES                                                          
 4719       C                                       C                                                                               
 4720       C                                       CC    DOIT    Executes commands                                                 
 4721       C                                       C                                                                               
 4722       C                                       C***   COMMON AREAS                                                             
 4723       C                                       C                                                                               
 4724       C                                       CS    CHARS   Used to pass character variables; contains LINES a character      
 4725       C                                       CS            array of the output lines, and SRCHBF the search buffer, and      
 4726       C                                       CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
 4727       C                                       CS            the VT100 control sequences to set/unset reverse video            
 4728       C                                       C                                                                               
 4729       C                                       CS    DOITNM  Contains information transferred from the main program:           
 4730       C                                       CS                 INCHAN - input channel of the terminal                       
 4731       C                                       CS                 TIME   - scrolling speed in -10000000*seconds/line           
 4732       C                                       CS                 SBFFLG - flag indicating whether there is a string           
 4733       C                                       CS                          in the search buffer                                
 4734       C                                       CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
 4735       C                                       CS                 EBK    - EBK of input file                                   
 4736       C                                       CS                 SBFLEN - length of string(s) in search buffer(s)             
 4737       C                                       CS                 RECBLK - number of bytes used per block in FIX-BLK files     
 4738       C                                       CS                 RANGE  - beginning and ending block numbers and pointers     
 4739       C                                       CS                          of the print range                                  
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  150


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4740       C                                       CS                 VT100  - flag set .TRUE. if terminal is VT100.               
 4741       C                                       CS                 LRL    - length of the longest record in input file.         
 4742       C                                       CS                 LENLMT - maximum output length (if <0 then WRAP set)         
 4743       C                                       CS                 PAGEND - line number of last line output to screen           
 4744       C                                       CS                 PAGLEN - number of lines per page                            
 4745       C                                       CS                 COMLIN - line number for command input (bottom of screen)    
 4746       C                                       CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
 4747       C                                       C                                                                               
 4748       C                                       CS    INPUTC  Contains the input character buffer INLINE and the defined        
 4749       C                                       CS            symbols SYMS and the definition search buffers DEFBUF             
 4750       C                                       C                                                                               
 4751       C                                       CS    INPUTN  Contains the input character buffer length LENSAV, and the        
 4752       C                                       CS            symbol definitions DEFS, the number of such definitions           
 4753       C                                       CS            (NDEFS), the definition flags DEFFLG, and the definition          
 4754       C                                       CS            numbers NUMDEF                                                    
 4755       C                                       C                                                                               
 4756       C                                       CS    PRSCHR  Contains the current symbol's search buffers (CURBUF)             
 4757       C                                       C                                                                               
 4758       C                                       CS    PRSNUM  Contains the current symbol's definitions (CUR), flags            
 4759       C                                       CS            (CURFLG), and associated numbers (NUMCUR)                         
 4760       C                                       C                                                                               
 4761       C                                       C***   OUTPUT UNITS                                                             
 4762       C                                       C                                                                               
 4763       C                                       CW    9       Output to terminal.  Carriage-control LIST if file is either      
 4764       C                                       CW            CR, FTN, or PRN; otherwise no carriage-control.                   
 4765       C                                       C                                                                               
 4766              CHARACTER*(*) LINE                                                                                               
 4767              CHARACTER*132 LINES(600)                                                                                         
 4768              CHARACTER*128 INLINE                                                                                             
 4769              CHARACTER*30 SRCHBF(10),DEFBUF(10,10,60),CURBUF(10,10)                                                           
 4770              CHARACTER*11 SWIT                                                                                                
 4771              CHARACTER*8 NARROW                                                                                               
 4772              CHARACTER*4 REVVID,REGVID,WRAP                                                                                   
 4773              CHARACTER*3 BOX                                                                                                  
 4774              CHARACTER*2 CRLF                                                                                                 
 4775              CHARACTER*1 SYMS(60),COMAND(13),QUOTE                                                                            
 4776              REAL*4 NUMDEF(10,60),NUMCUR(10)                                                                                  
 4777              INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND                                                                      
 4778              INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,LENSAV,                                                 
 4779            1       PAGLEN,CUR(11,10),COMLIN                                                                                   
 4780              LOGICAL*1 SBFFLG,NUMFLG,MINFLG,ESC,VT100,BELL,DEFFLG(3,10,60),                                                   
 4781            1       CURFLG(3,10),VT100A                                                                                        
 4782                                                                                                                               
 4783              COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,                                                
 4784            1       VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A                                                               
 4785              COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                                                                    
 4786              COMMON /INPUTC/INLINE,SYMS,DEFBUF                                                                                
 4787              COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                                                                   
 4788              COMMON /PRSNUM/CUR,NUMCUR,CURFLG                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  151


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4789              COMMON /PRSCHR/CURBUF                                                                                            
 4790                                                                                                                               
 4791              DATA NUMCOM,COMAND/13,'$','%','^','!','#','(',')','*',' ','&','@',                                               
 4792            1       '+','<'/                                                                                                   
 4793              DATA BELL,ESC/7,27/                                                                                              
 4794       C                                       C                                                                               
 4795       C                                       C***   Setup things                                                             
 4796       C                                       C                                                                               
 4797              NSRCH = 0                                                                                                        
 4798     *        IF (SBFFLG)                                                                                                      
                     +--------------------------------------------------------------------------------------------------------------
 4799   1 *          |DO FOR I=1,10                                                                                                 
 4800   2 *          |   UNDO IF (SBFLEN(I) .EQ. 0)                                                                                 
                     <----                                                                                                          
 4801   2            |   NSRCH = NSRCH + 1                                                                                          
 4802   1 *          |END DO FOR                                                                                                    
                     +--------------------------------------------------------------------------------------------------------------
 4803     *        ENDIF                                                                                                            
 4804              NUMFLG = .FALSE.                                                                                                 
 4805              MINFLG = .FALSE.                                                                                                 
 4806                                                                                                                               
                  +-----------------------------------------------------------------------------------------------------------------
 4807     * 100   |DO FOREVER                                                                                                       
 4808       C     |                                 C                                                                               
 4809       C     |                                 C***   Trim leading blanks                                                      
 4810       C     |                                 C                                                                               
 4811   1 *       |   IF (LENLIN .GT. 0)                                                                                            
 4812   2         |      K = LIB$SKPC(' ',LINE(:LENLIN))                                                                            
 4813   2 *       |      IF (K .EQ. 0)                                                                                              
 4814   3         |         LENLIN = 0                                                                                              
 4815   2 *       |      ELSE                                                                                                       
 4816   3         |         LINE = LINE(K:LENLIN)                                                                                   
 4817   3         |         LENLIN = LENLIN - K + 1                                                                                 
 4818   2 *       |      ENDIF                                                                                                      
 4819   1 *       |   ENDIF                                                                                                         
 4820   1 *       |   IF (LENLIN .EQ. 0)                                                                                            
 4821   2 *       |      EXECUTE (NO_COMMAND)                                                                                       
 4822   1 *       |   ENDIF                                                                                                         
 4823       C     |                                 C                                                                               
 4824       C     |                                 C***   Check for " or '                                                         
 4825       C     |                                 C                                                                               
 4826   1 *       |   IF (LINE(1:1) .EQ. '"')                                                                                       
 4827   2 *       |      IF (LENLIN .EQ. 1)                                                                                         
 4828   3 *       |         EXECUTE (INVALID_COMMAND)                                                                               
 4829   2 *       |      ENDIF                                                                                                      
 4830   2         |      K = 1                                                                                                      
                  |     +-----------------------------------------------------------------------------------------------------------
 4831   2 *       |     |DO FOREVER                                                                                                 
 4832   3         |     |   J = INDEX(LINE(K+1:LENLIN),'"') + K                                                                     
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  152


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4833   3 *       |     |   IF (K .EQ. J)                                                                                           
 4834   4 *       |     |      EXECUTE (INVALID_COMMAND)                                                                            
 4835   3 *       |     |   ENDIF                                                                                                   
 4836   3 *       |     |   IF (LINE(J+1:J+1) .NE. '"')                                                                             
 4837   4         |     |      NSRCH = 1                                                                                            
 4838   4 *       |     |      EXECUTE (INSERT_SEARCH_STRING)                                                                       
 4839   4 *       |     |      UNDO                                                                                                 
                  |     <-------                                                                                                    
 4840   3 *       |     |   ENDIF                                                                                                   
 4841   3         |     |   K = J + 1                                                                                               
 4842   2 *       |     |END DO FOREVER                                                                                             
                  |     +-----------------------------------------------------------------------------------------------------------
 4843   1 *       |   ELSE IF (LINE(1:1) .EQ. '''')                                                                                 
 4844   2 *       |      IF (LENLIN .EQ. 1)                                                                                         
 4845   3 *       |         EXECUTE (INVALID_COMMAND)                                                                               
 4846   2 *       |      ENDIF                                                                                                      
 4847   2         |      K = 1                                                                                                      
                  |     +-----------------------------------------------------------------------------------------------------------
 4848   2 *       |     |DO FOREVER                                                                                                 
 4849   3         |     |   J = INDEX(LINE(K+1:LENLIN),'''') + K                                                                    
 4850   3 *       |     |   IF (K .EQ. J)                                                                                           
 4851   4 *       |     |      EXECUTE (INVALID_COMMAND)                                                                            
 4852   3 *       |     |   ENDIF                                                                                                   
 4853   3 *       |     |   IF (LINE(J+1:J+1) .NE. '''')                                                                            
 4854   4         |     |      NSRCH = NSRCH + 1                                                                                    
 4855   4 *       |     |      EXECUTE (INSERT_SEARCH_STRING)                                                                       
 4856   4 *       |     |      UNDO                                                                                                 
                  |     <-------                                                                                                    
 4857   3 *       |     |   ENDIF                                                                                                   
 4858   3         |     |   K = J + 1                                                                                               
 4859   2 *       |     |END DO FOREVER                                                                                             
                  |     +-----------------------------------------------------------------------------------------------------------
 4860       C     |                                 C                                                                               
 4861       C     |                                 C***   Check for minus sign                                                     
 4862       C     |                                 C                                                                               
 4863   1 *       |   ELSE IF (LINE(1:1) .EQ. '-')                                                                                  
 4864   2 *       |      IF (LENLIN .EQ. 1)                                                                                         
 4865   3 *       |         EXECUTE (NO_COMMAND)                                                                                    
 4866   2 *       |      ENDIF                                                                                                      
 4867   2         |      I = LIB$SKPC(' ',LINE(2:LENLIN)) + 1                                                                       
 4868   2 *       |      IF (I .EQ. 1)                                                                                              
 4869   3 *       |         EXECUTE (NO_COMMAND)                                                                                    
 4870   2 *       |      ENDIF                                                                                                      
 4871       C     |                                 C                                                                               
 4872       C     |                                 C---   Check for --&                                                            
 4873       C     |                                 C                                                                               
 4874   2 *       |      IF (LINE(I:I) .EQ. '-')                                                                                    
 4875   3 *       |         IF (LENLIN .EQ. I)                                                                                      
 4876   4 *       |            EXECUTE (NO_COMMAND)                                                                                 
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  153


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4877   3 *       |         ENDIF                                                                                                   
 4878   3         |         J = LIB$SKPC(' ',LINE(I+1:LENLIN)) + I                                                                  
 4879   3 *       |         IF (I .EQ. J)                                                                                           
 4880   4 *       |            EXECUTE (NO_COMMAND)                                                                                 
 4881   3 *       |         ENDIF                                                                                                   
 4882   3 *       |         IF (LINE(J:J) .EQ. '&')                                                                                 
 4883   4         |            ICOM = 9                                                                                             
 4884   4         |            LINE = LINE(J+1:LENLIN)                                                                              
 4885   4         |            LENLIN = LENLIN - J                                                                                  
 4886   4         |            RETURN                                                                                               
              <-----------------                                                                                                    
 4887   3 *       |         ELSE                                                                                                    
 4888   4         |            MINFLG = .NOT.MINFLG                                                                                 
 4889   4         |            LINE = LINE(I:LENLIN)                                                                                
 4890   4         |            LENLIN = LENLIN - I + 1                                                                              
 4891   3 *       |         ENDIF                                                                                                   
 4892       C     |                                 C                                                                               
 4893       C     |                                 C---   Check for number                                                         
 4894       C     |                                 C                                                                               
 4895   2 *       |      ELSE IF (ICHAR(LINE(I:I)) .GE. ICHAR('0') .AND.                                                            
 4896            1|            ICHAR(LINE(I:I)) .LE. ICHAR('9'))                                                                    
 4897   3 *       |         EXECUTE (GET_NUMBER)                                                                                    
 4898   2 *       |      ELSE                                                                                                       
 4899       C     |                                 C                                                                               
 4900       C     |                                 C---   Otherwise it is minus flag                                               
 4901       C     |                                 C                                                                               
 4902   3         |         MINFLG = .NOT.MINFLG                                                                                    
 4903   3         |         LINE = LINE(I:LENLIN)                                                                                   
 4904   3         |         LENLIN = LENLIN - I + 1                                                                                 
 4905   2 *       |      ENDIF                                                                                                      
 4906       C     |                                 C                                                                               
 4907       C     |                                 C***   Check for number                                                         
 4908       C     |                                 C                                                                               
 4909   1 *       |   ELSE IF (ICHAR(LINE(1:1)) .GE. ICHAR('0') .AND.                                                               
 4910            1|         ICHAR(LINE(1:1)) .LE. ICHAR('9'))                                                                       
 4911   2 *       |      EXECUTE (GET_NUMBER)                                                                                       
 4912   1 *       |   ELSE IF (LINE(1:1) .EQ. '+')                                                                                  
 4913   2 *       |      IF (LENLIN .EQ. 1)                                                                                         
 4914   3         |         ICOM = 12                                                                                               
 4915   3         |         LENLIN = 0                                                                                              
 4916   3         |         RETURN                                                                                                  
              <--------------                                                                                                       
 4917   2 *       |      ENDIF                                                                                                      
 4918   2         |      I = LIB$SKPC(' ',LINE(2:LENLIN)) + 1                                                                       
 4919   2 *       |      IF (I .EQ. 1)                                                                                              
 4920   3         |         ICOM = 12                                                                                               
 4921   3         |         LENLIN = 0                                                                                              
 4922   3         |         RETURN                                                                                                  
              <--------------                                                                                                       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  154


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 4923   2 *       |      ENDIF                                                                                                      
 4924   2 *       |      IF (ICHAR(LINE(I:I)) .LE. ICHAR('9') .AND.                                                                 
 4925            1|            ICHAR(LINE(I:I)) .GE. ICHAR('0'))                                                                    
 4926   3 *       |         EXECUTE (GET_NUMBER)                                                                                    
 4927   2 *       |      ELSE                                                                                                       
 4928   3         |         LINE = LINE(I:LENLIN)                                                                                   
 4929   3         |         LENLIN = LENLIN - I + 1                                                                                 
 4930   3         |         ICOM = 12                                                                                               
 4931   3         |         RETURN                                                                                                  
              <--------------                                                                                                       
 4932   2 *       |      ENDIF                                                                                                      
 4933   1 *       |   ELSE                                                                                                          
 4934       C     |                                 C                                                                               
 4935       C     |                                 C***   Otherwise it must be a command                                           
 4936       C     |                                 C                                                                               
                  |     +-----------------------------------------------------------------------------------------------------------
 4937   2 *       |     |DO FOR ICOM=1,NUMCOM                                                                                       
 4938   3 *       |     |   IF (LINE(1:1) .EQ. COMAND(ICOM))                                                                        
 4939   4         |     |      LINE = LINE(2:)                                                                                      
 4940   4         |     |      LENLIN = LENLIN - 1                                                                                  
 4941   4         |     |      RETURN                                                                                               
              <-----------------                                                                                                    
 4942   3 *       |     |   ENDIF                                                                                                   
 4943   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 4944       C     |                                 C                                                                               
 4945       C     |                                 C***   Not a command symbol, check for definition                               
 4946       C     |                                 C                                                                               
                  |     +-----------------------------------------------------------------------------------------------------------
 4947   2 *       |     |DO FOR J=1,NDEFS                                                                                           
 4948   3 *       |     |   IF (SYMS(J) .EQ. LINE(1:1))                                                                             
 4949   4 *       |     |      IF (NUMFLG)                                                                                          
 4950   5         |     |         NUMBER = ANUMB                                                                                    
 4951   4 *       |     |      ELSE                                                                                                 
 4952   5         |     |         NUMBER = 1                                                                                        
 4953   4 *       |     |      ENDIF                                                                                                
 4954   4         |     |      LINE = LINE(2:LENLIN)                                                                                
 4955   4         |     |      LENLIN = LENLIN - 1                                                                                  
 4956   4 *       |     |      IF (NDEF .EQ. 0 .OR. NSYM .EQ. 0)                                                                    
 4957       C     |     |                           C                                                                               
 4958       C     |     |                           C---   Executable definition                                                    
 4959       C     |     |                           C                                                                               
                  |     |        +--------------------------------------------------------------------------------------------------
 4960   5 *       |     |        |DO FOR L=1,NUMBER                                                                                 
                  |     |        |  +-----------------------------------------------------------------------------------------------
 4961   6 *       |     |        |  |DO FOR K=1,10                                                                                  
 4962   7 *       |     |        |  |   UNDO IF (DEFS(1,K,J) .EQ. 0)                                                                
                  |     |        |  <----                                                                                           
 4963   7 *       |     |        |  |   IF (DEFFLG(3,K,J))                                                                          
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  155


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

                  |     |        |  |     +-----------------------------------------------------------------------------------------
 4964   8 *       |     |        |  |     |DO FOR JJ=1,10                                                                           
 4965   9         |     |        |  |     |   SRCHBF(JJ) = DEFBUF(JJ,K,J)                                                           
 4966   9         |     |        |  |     |   SBFLEN(JJ) = DEFS(1+JJ,K,J)                                                           
 4967   9 *       |     |        |  |     |   UNDO IF (SBFLEN(JJ) .EQ. 0)                                                           
                  |     |        |  |     <----                                                                                     
 4968   8 *       |     |        |  |     |END DO FOR                                                                               
                  |     |        |  |     +-----------------------------------------------------------------------------------------
 4969   8         |     |        |  |      SBFFLG = .TRUE.                                                                          
 4970   7 *       |     |        |  |   ENDIF                                                                                       
 4971   7         |     |        |  |   CALL DOIT(DEFS(1,K,J),DEFFLG(1,K,J),NUMDEF(K,J),                                            
 4972            1|     |        |  |         DEFFLG(2,K,J))                                                                        
 4973   6 *       |     |        |  |END DO FOR                                                                                     
                  |     |        |  +-----------------------------------------------------------------------------------------------
 4974   5 *       |     |        |END DO FOR                                                                                        
                  |     |        +--------------------------------------------------------------------------------------------------
 4975   5         |     |         ICOM = -1                                                                                         
 4976   5         |     |         RETURN                                                                                            
              <--------------------                                                                                                 
 4977   4 *       |     |      ELSE                                                                                                 
 4978       C     |     |                           C                                                                               
 4979       C     |     |                           C---   Definition insertion                                                     
 4980       C     |     |                           C                                                                               
                  |     |        +--------------------------------------------------------------------------------------------------
 4981   5 *       |     |        |DO FOR L=1,NUMBER                                                                                 
 4982   6 *       |     |        |   IF (J .EQ. NSYM) THEN                                                                          
 4983       C     |     |        |                  C                                                                               
 4984       C     |     |        |                  C===   If symbol is the one being defined then use current stuff                
 4985       C     |     |        |                  C                                                                               
                  |     |        |     +--------------------------------------------------------------------------------------------
 4986   7 *       |     |        |     |DO FOR JJ=1,10                                                                              
 4987   8 *       |     |        |     |   IF (NDEF .GT. 10)                                                                        
 4988   9         |     |        |     |      ICOM = 0                                                                              
 4989   9         |     |        |     |      RETURN                                                                                
              <--------------------------------                                                                                     
 4990   8 *       |     |        |     |   ENDIF                                                                                    
 4991   8         |     |        |     |   DEFS(1,NDEF,NSYM) = CUR(1,JJ)                                                            
 4992   8 *       |     |        |     |   UNDO IF (CUR(1,JJ) .EQ. 0)                                                               
                  |     |        |     <----                                                                                        
 4993   8         |     |        |     |   NUMDEF(NDEF,NSYM) = NUMCUR(JJ)                                                           
 4994   8         |     |        |     |   DEFFLG(1,NDEF,NSYM) = CURFLG(1,JJ)                                                       
 4995   8         |     |        |     |   DEFFLG(2,NDEF,NSYM) = CURFLG(2,JJ)                                                       
 4996   8         |     |        |     |   DEFFLG(3,NDEF,NSYM) = CURFLG(3,JJ)                                                       
                  |     |        |     |  +-----------------------------------------------------------------------------------------
 4997   8 *       |     |        |     |  |DO FOR K=1,10                                                                            
 4998   9         |     |        |     |  |   DEFS(1+K,NDEF,NSYM) = CUR(1+K,JJ)                                                     
 4999   9 *       |     |        |     |  |   UNDO IF (CUR(1+K,JJ) .EQ. 0)                                                          
                  |     |        |     |  <----                                                                                     
 5000   9         |     |        |     |  |   DEFBUF(K,NDEF,NSYM) = CURBUF(K,JJ)                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  156


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5001   8 *       |     |        |     |  |END DO FOR                                                                               
                  |     |        |     |  +-----------------------------------------------------------------------------------------
 5002   8         |     |        |     |   NDEF = NDEF + 1                                                                          
 5003   7 *       |     |        |     |END DO FOR                                                                                  
                  |     |        |     +--------------------------------------------------------------------------------------------
 5004   6 *       |     |        |   ELSE                                                                                           
                  |     |        |     +--------------------------------------------------------------------------------------------
 5005   7 *       |     |        |     |DO FOR K=1,10                                                                               
 5006   8 *       |     |        |     |   IF (NDEF .GT. 10)                                                                        
 5007   9         |     |        |     |      ICOM = 0                                                                              
 5008   9         |     |        |     |      RETURN                                                                                
              <--------------------------------                                                                                     
 5009   8 *       |     |        |     |   ENDIF                                                                                    
 5010   8 *       |     |        |     |   UNDO IF (DEFS(1,K,J) .EQ. 0)                                                             
                  |     |        |     <----                                                                                        
 5011   8         |     |        |     |   DEFFLG(1,NDEF,NSYM) = DEFFLG(1,K,J)                                                      
 5012   8         |     |        |     |   DEFFLG(2,NDEF,NSYM) = DEFFLG(2,K,J)                                                      
 5013   8         |     |        |     |   DEFFLG(3,NDEF,NSYM) = DEFFLG(3,K,J)                                                      
                  |     |        |     |  +-----------------------------------------------------------------------------------------
 5014   8 *       |     |        |     |  |DO FOR JJ=1,10                                                                           
 5015   9         |     |        |     |  |   DEFBUF(JJ,NDEF,NSYM) = DEFBUF(JJ,K,J)                                                 
 5016   9         |     |        |     |  |   DEFS(1+JJ,NDEF,NSYM) = DEFS(1+JJ,K,J)                                                 
 5017   9 *       |     |        |     |  |   UNDO IF (DEFS(1+JJ,NDEF,NSYM) .EQ. 0)                                                 
                  |     |        |     |  <----                                                                                     
 5018   8 *       |     |        |     |  |END DO FOR                                                                               
                  |     |        |     |  +-----------------------------------------------------------------------------------------
 5019   8         |     |        |     |   NUMDEF(NDEF,NSYM) = NUMDEF(K,J)                                                          
 5020   8         |     |        |     |   DEFS(1,NDEF,NSYM) = DEFS(1,K,J)                                                          
 5021   8         |     |        |     |   NDEF = NDEF + 1                                                                          
 5022   7 *       |     |        |     |END DO FOR                                                                                  
                  |     |        |     +--------------------------------------------------------------------------------------------
 5023   6 *       |     |        |   ENDIF                                                                                          
 5024   5 *       |     |        |END DO FOR                                                                                        
                  |     |        +--------------------------------------------------------------------------------------------------
 5025   5 *       |     |         CYCLE 100                                                                                         
                  |<---------------                                                                                                 
 5026   4 *       |     |      ENDIF                                                                                                
 5027   3 *       |     |   ENDIF                                                                                                   
 5028   2 *       |     |END DO FOR                                                                                                 
                  |     +-----------------------------------------------------------------------------------------------------------
 5029       C     |                                 C                                                                               
 5030       C     |                                 C***   If it gets here it didn't match anything                                 
 5031       C     |                                 C                                                                               
 5032   2 *       |      EXECUTE (INVALID_COMMAND)                                                                                  
 5033   1 *       |   ENDIF                                                                                                         
 5034     *       |END DO FOREVER                                                                                                   
                  +-----------------------------------------------------------------------------------------------------------------
 5035       C                                       C                                                                               
 5036       C                                       C************************************************************************       
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  157


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5037       C                                       C********************   HERE FOLLOW THE PROCEDURES   ********************       
 5038       C                                       C************************************************************************       
 5039       C                                       C                                                                               
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  158


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5040     *        PROCEDURE (GET_NUMBER)                                                                                           
 5041       C                                       CP    This procedure converts the number which starts the line into a           
 5042       C                                       CP    real (floating point) number in ANUMB.                                    
 5043   1 *           IF (LENLIN .EQ. 1)                                                                                            
 5044   2 *              EXECUTE (NO_COMMAND)                                                                                       
 5045   1 *           ELSE                                                                                                          
                        +-----------------------------------------------------------------------------------------------------------
 5046   2 *             |DO FOR I=2,LENLIN                                                                                          
 5047   3 *             |   UNDO IF (.NOT.(LINE(I:I) .EQ. ' ' .OR. (ICHAR(LINE(I:I))                                                
 5048            1      |         .GE. ICHAR('0') .AND. ICHAR(LINE(I:I)) .LE. ICHAR('9'))                                           
 5049            2      |         .OR. LINE(I:I) .EQ. '.'))                                                                         
                        <----                                                                                                       
 5050   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 5051   2                READ (UNIT=LINE(:I-1),FMT=200,IOSTAT=J) ANUMB                                                              
 5052   2   200          FORMAT (F<I-1>.0)                                                                                          
 5053   2 *              IF (J .EQ. 0)                                                                                              
 5054   3                   LINE = LINE(I:LENLIN)                                                                                   
 5055   3                   LENLIN = LENLIN - I + 1                                                                                 
 5056   3                   NUMFLG = .TRUE.                                                                                         
 5057   2 *              ELSE                                                                                                       
 5058   3 *                 EXECUTE (INVALID_COMMAND)                                                                               
 5059   2 *              ENDIF                                                                                                      
 5060   1 *           ENDIF                                                                                                         
 5061     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  159


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5062     *        PROCEDURE (INSERT_SEARCH_STRING)                                                                                 
 5063       C                                       CP    This procedure inserts a search string (LINE(2:J-1)) in the search        
 5064       C                                       CP    buffers as string NSRCH.                                                  
 5065       C                                       C                                                                               
 5066       C                                       C***   Only ten strings                                                         
 5067       C                                       C                                                                               
 5068   1 *           IF (NSRCH .GT. 10)                                                                                            
                        +-----------------------------------------------------------------------------------------------------------
 5069   2 *             |DO FOR I=1,9                                                                                               
 5070   3               |   SRCHBF(I) = SRCHBF(I+1)                                                                                 
 5071   3               |   SBFLEN(I) = SBFLEN(I+1)                                                                                 
 5072   2 *             |END DO FOR                                                                                                 
                        +-----------------------------------------------------------------------------------------------------------
 5073   2                NSRCH = 10                                                                                                 
 5074   1 *           ENDIF                                                                                                         
 5075   1             SRCHBF(NSRCH) = LINE(2:J-1)                                                                                   
 5076   1             SBFLEN(NSRCH) = J - 2                                                                                         
 5077   1             LENLIN = LENLIN - J                                                                                           
 5078   1             QUOTE = LINE(1:1)                                                                                             
 5079   1             IF (LENLIN .GT. 0) LINE = LINE(J+1:)                                                                          
 5080       C                                       C                                                                               
 5081       C                                       C***   Get rid of double quotes                                                 
 5082       C                                       C                                                                               
 5083   1             J = 1                                                                                                         
                     +--------------------------------------------------------------------------------------------------------------
 5084   1 *          |DO FOREVER                                                                                                    
 5085   2            |   I = INDEX(SRCHBF(NSRCH)(J:SBFLEN(NSRCH)),QUOTE) + J - 1                                                    
 5086   2 *          |   UNDO IF (I .EQ. (J - 1))                                                                                   
                     <----                                                                                                          
 5087   2            |   SRCHBF(NSRCH) = SRCHBF(NSRCH)(:I)//SRCHBF(NSRCH)(I+2:)                                                     
 5088   2            |   SBFLEN(NSRCH) = SBFLEN(NSRCH) - 1                                                                          
 5089   2            |   J = I + 1                                                                                                  
 5090   1 *          |END DO FOREVER                                                                                                
                     +--------------------------------------------------------------------------------------------------------------
 5091   1             SBFLEN(NSRCH+1) = 0                                                                                           
 5092   1             SBFFLG = .TRUE.                                                                                               
 5093     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  160


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5094     *        PROCEDURE (INVALID_COMMAND)                                                                                      
 5095       C                                       CP    This procedure takes care of invalid command syntax.                      
 5096   1             CALL LIB$PUT_SCREEN(CHAR(BELL))                                                                               
 5097   1 *           IF (VT100)                                                                                                    
 5098   2                CALL LIB$PUT_SCREEN(CHAR(ESC)//'[3q')                                                                      
 5099   1 *           ENDIF                                                                                                         
 5100   1             ICOM = 0                                                                                                      
 5101   1             RETURN                                                                                                        
              <--------                                                                                                             
 5102     *        END PROCEDURE                                                                                                    
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  161


 LINE NST
  NUM LVL S INPUT S-FORTRAN STATEMENT

 5103     *        PROCEDURE (NO_COMMAND)                                                                                           
 5104       C                                       CP    This procedure handles a "empty" line.                                    
 5105   1             ICOM = 0                                                                                                      
 5106   1             LENLIN = 0                                                                                                    
 5107   1             RETURN                                                                                                        
              <--------                                                                                                             
 5108     *        END PROCEDURE                                                                                                    
 5109              END                                                                                                              
 
 CFG, INC.      S-FORTRAN PROCESSOR VERSION 1.6(9)        PRSCOM                30-SEP-83      08:30:11      PAGE  162


                                        PROCEDURE CROSS-REFERENCE TABLE

 LINE   PROCEDURE NAME                              REFERENCE LINES

 5040  GET_NUMBER                     
                               4897  4911  4926 

 5062  INSERT_SEARCH_STRING           
                               4838  4855 

 5094  INVALID_COMMAND                
                               4828  4834  4845  4851  5032  5058 

 5103  NO_COMMAND                     
                               4821  4865  4869  4876  4880  5044 

       0 DIAGNOSTICS GENERATED

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   1
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          PROGRAM LOOK                                                             1
0002    CD    This program is designed to look at long printout files.  It has          
0003    CD    the features that it can jump to any place in the file (either back-      
0004    CD    wards or forwards) without having to read in any of the intermediate      
0005    CD    data.  It can also search (either forward or backward) for strings,       
0006    CD    and scroll at different speeds.                                           
0007    CD                                                                              
0008    CD        When run on a VT100 the program is puts the terminal in some          
0009    CD    rather strange modes, so if the program exits abnormally (by ^Y or        
0010    CD    by the system crashing, for example) one should push the SET-UP key       
0011    CD    followed by a shift-R (capital R) to restore the terminals default        
0012    CD    modes.                                                                    
0013    CD                                                                              
0014    CDM        Either of the following will actually start running the program;     
0015    CDM   typing RUN JPL:[JLV.LOOK]LOOK, or defining a symbol to run the            
0016    CDM   program (i.e. LOOK:==$JPL:[JLV.LOOK]LOOK.EXE) and then typing the         
0017    CDM   symbol.  The later method has the advantage that one can enter the        
0018    CDM   name of the file to be looked at and/or the symbol definition file's      
0019    CDM   name (see below) on the command line (for example:                        
0020    CDM                    LOOK PRINT.LIS/DEFINITIONS=LOOKCOM.DAT                   
0021    CDM   will run the program (if LOOK is defined as above) on the file            
0022    CDM   PRINT.LIS with the symbol definitions taken from LOOKCOM.DAT              
0023    CDM   (the DEFINITIONS switch can go before or after the main file's            
0024    CDM   name and can be abbreviated all the way to a D)).  If the switch          
0025    CDM   /NARROW is on the command line, then the screen will not be converted     
0026    CDM   into 132 column mode (this, of course, only applies to VT100 terminals).  
0027    CDM   If the switch /WRAP is present then the lines will be printed with        
0028    CDM   terminal wrapping, instead of being cut to the width of the terminal.     
0029    CDM   If the switch /BOX is present then one line of output is sacrificed       
0030    CDM   to allow a line to be drawn dividing the file text from the command       
0031    CDM   input line.                                                               
0032    CDM                                                                             
0033    CDM        The following commands are the "basic" command set of the            
0034    CDM   program:                                                                  
0035    CDM             n$         - jump by n lines (positive or negative)             
0036    CDM             n%         - jump by n blocks (positive or negative)            
0037    CDM             ^          - search (forward) for the string(s) in the search   
0038    CDM                          buffers (up to 10) and display from that line if   
0039    CDM                          found, if not found ring the terminal bell and     
0040    CDM                          turn on LED 3 (VT100's only).  Matches are found   
0041    CDM                          irregardless of lower/uppercase differences.       
0042    CDM             -^         - search (backward) for string(s), same rules as     
0043    CDM                          forward search.                                    
0044    CDM             - "string" 'string' ... ^                                       
0045    CDM                        - load search buffers with the given strings and     
0046    CDM                          search (backward) for them, same rules as          
0047    CDM                          forward search.                                    
0048    CDM             "string"   - clear the search buffers and save the given        
0049    CDM                          string as the only search string.  A string        
0050    CDM                          can consist of any characters, to include a        
0051    CDM                          quotation mark (") one must put two of them in     
0052    CDM                          a row ("").                                        
0053    CDM             'string' 'string' ...                                           
0054    CDM                        - add the given string(s) to the search buffers.     
0055    CDM                          A string can consist of any characters, to         
0056    CDM                          include a single quote (') one must put two of     
0057    CDM                          them in a row ('').                                

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   2
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    CDM             !          - set reverse switch, all commands will now work     
0059    CDM                          in reverse (i.e. n$ will jump -n lines, etc.)      
0060    CDM             #          - scroll                                             
0061    CDM             -#         - scroll backward                                    
0062    CDM             (          - stop scrolling (only valid command when            
0063    CDM                          scrolling is in operation),                        
0064    CDM                          or cancel current line jump, search, or            
0065    CDM                          & command.                                         
0066    CDM             n)         - set scrolling speed to n lines per second          
0067    CDM                          (positive or negative, integer or real)            
0068    CDM                          (originally set to 2).                             
0069    CDM                          NOTE:  there is a maximum speed that will not      
0070    CDM                          be exceeded (varies with situation) even if        
0071    CDM                          scrolling speed is set at a fast value.            
0072    CDM             n*         - mark the nth line from the top of the screen       
0073    CDM                          as the boundary of the print range.  The print     
0074    CDM                          range is defined by the last two such marked       
0075    CDM                          lines.                                             
0076    CDM             n&         - print the range of lines from the top of the       
0077    CDM                          screen to the nth line from the top of the         
0078    CDM                          screen (n can be either positive or negative).     
0079    CDM                          onto device SYS$PRINT.  if n is 0 or absent        
0080    CDM                          then the range marked with the * command is        
0081    CDM                          used, if available, otherwise 23 is used for       
0082    CDM                          n.  The format of the printout will be that        
0083    CDM                          of the original file, not necessarily what         
0084    CDM                          is shown on the screen (i.e. FORTRAN carriage-     
0085    CDM                          control, and all printer control will work as      
0086    CDM                          they are supposed to).                             
0087    CDM             n-&        - same as n&, except output is put into a file       
0088    CDM                          named LOOKPRINT.LIS in the default directory       
0089    CDM                          (File format will be the same as the original      
0090    CDM                          file, except organization will be sequential)      
0091    CDM                          (appended to the latest version if a previous n-&  
0092    CDM                          or n--& command has been given, otherwise a new    
0093    CDM                          version is created).                               
0094    CDM             n--&       - same as n-&, except always creates a new version   
0095    CDM                          of the output file.                                
0096    CDM             @          - exit the program.                                  
0097    CDM             +          - re-writes the screen.                              
0098    CDM             <          - repeat the last command.                           
0099    CDM                                                                             
0100    CDM        If an invalid command is typed the terminal bell is rung and on      
0101    CDM   a VT100 LED #3 is turned on.  The line is parsed in such a way that a     
0102    CDM   valid command will be executed even if followed by an invalid command.    
0103    CDM   Note that no command is executed until a standard line terminator is      
0104    CDM   received (ASCII code of 1 to 31).  Note that commands are limited to      
0105    CDM   34 characters when entered in response to the prompt.  In order to        
0106    CDM   enter longer commands one can use the "command mode" DEFINE command       
0107    CDM   (see below) and then execute the symbol.  Also all search strings         
0108    CDM   are limited to 30 characters.                                             
0109    CDM                                                                             
0110    CDM        If the user types ^Z (Control-Z) whenever the program is not         
0111    CDM   currently executing a command, the program will enter "command" mode.     
0112    CDM   This mode allows the user to use any of the following commands:           
0113    CDM             DEFINE s := a1 a2 ...                                           
0114    CDM                            - which defines a symbol s in the same man-      

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   3
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115    CDM                              ner as a line in the definitions file (see     
0116    CDM                              below), including line continuations.          
0117    CDM             EXIT           - returns to the normal "look" mode.             
0118    CDM             HELP a         - where a is one of the commands shown above.    
0119    CDM             SET [NO]switch - with switch being any of WRAP, BOX, WIDE       
0120    CDM                              or NARROW.  These have the same affect as      
0121    CDM                              the command line switches of the same          
0122    CDM                              names (WIDE is the same as NONARROW),          
0123    CDM                              with the NO qualifier turning them off.        
0124    CDM             SHOW [s]       - where s is a defined symbol.  This will        
0125    CDM                              show what commands a symbol is defined         
0126    CDM                              as. (if s is omitted, all defined symbols      
0127    CDM                              are shown).                                    
0128    CDM             @filename      - Inputs the file filename as a definitions      
0129    CDM                              file.                                          
0130    CDM                                                                             
0131    CDM        The user is also allowed to define symbols for a command or          
0132    CDM   commands.  Valid symbols consist of the characters a-z (lower and         
0133    CDM   upper-case are equivalent), _, =, `, ~, [, ], {, }, ;, :,                 
0134    CDM   ,(comma), >, ?, /, \,and  |.  Symbol definitions are given in             
0135    CDM   a symbol definition file which is read at the start of execution          
0136    CDM   (or by the "command" level @ command), or by the "command" level          
0137    CDM   DEFINE command.  This file is either given by the /DEFINITIONS            
0138    CDM   switch, or a file named LOOKCOM.DAT is searched for in the fol-           
0139    CDM   lowing places:  The default directory (the file is used only if           
0140    CDM   the user owns it), the user's username directory on JPL,                  
0141    CDM   CIT, and SYS2 in that order.                                              
0142    CDM                                                                             
0143    CDM        In the symbol definition file the user can place both commands       
0144    CDM   and definitions.  Commands will be executed on encounter, and def-        
0145    CDM   initions will be placed in the definitons list.  Definitions have         
0146    CDM   the following form:                                                       
0147    CDM                 symbol := command1 command2 command3 ... command9           
0148    CDM   Up to ten commands can be contained in each symbol (exception - a         
0149    CDM   symbol for the stop scrolling command should have only the one command    
0150    CDM   in it ( ( )) and will be executed (when the symbol is typed) in the       
0151    CDM   order they appear in the definition.  A - (minus sign) as the last        
0152    CDM   character in a line means the definition is continued on the next         
0153    CDM   line.  The following are default symbol definitions (they can be          
0154    CDM   overriden by the symbol definition file):                                 
0155    CDM             U := 23$                                                        
0156    CDM             D := -23$                                                       
0157    CDM             S := #                                                          
0158    CDM             Q := (                                                          
0159    CDM             J := 20%                                                        
0160    CDM             B := -20%                                                       
0161    CDM             P := 23&                                                        
0162    CDM             A := 23-&                                                       
0163    CDM             L := 23--&                                                      
0164    CDM             E := @                                                          
0165    CDM             M := *                                                          
0166    CDM             C := +                                                          
0167    CDM             R := <                                                          
0168    CDM                                                                             
0169    CDM   Note, that only the first character of a symbol is significant in the     
0170    CDM   symbol definition file.  Also when input as a command the symbol should   
0171    CDM   be input as only one character.                                           

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   4
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0172    CDM                                                                             
0173    CDM        A line enclosed by braces ({ }) will be treated as a "command"       
0174    CDM   level command (such as SET WIDE, @filename, etc.).                        
0175    CDM                                                                             
0176    CDM        The LEDs on a VT100 terminal are used to convey various bits of      
0177    CDM   information.  Their meanings are as follows:                              
0178    CDM             1 - on indicates a command is being executed (useful since      
0179    CDM                 some of the commands don't affect the screen until          
0180    CDM                 completion).                                                
0181    CDM             2 - on indicates that reverse is on (an odd number of !         
0182    CDM                 commands have been executed).                               
0183    CDM             3 - on indicates an invalid command was encountered (either     
0184    CDM                 input from the terminal, or while executeing a def-         
0185    CDM                 inition), or a search failed.                               
0186    CDM             4 - on indicates that a range of lines has been marked for      
0187    CDM                 printing                                                    
0188    CDM                                                                             
0189    CDM                                                                             
0190    CDM   NOTE:  If while using the program (on variable length record files)       
0191    CDM          one gets garbage on the screen, try moving either one block        
0192    CDM          forward or backward to realign the record boundaries.  Also        
0193    CDM          when working with FORTRAN carriage-control files the + (plus)      
0194    CDM          carriage-control character is ignored, and when working with       
0195    CDM          printer files, all carriage-control with the exception of          
0196    CDM          line feeds is ignored, and at least one line feed before each      
0197    CDM          record is assumed.                                                 
0198    CDM                                                                             
0199    CDM   Programmer - Jon Vavrus  12 NOV 1980                                      
0200    CDM   Revised    - Jon Vavrus  30 MAR 1981                                      
0201    CDM   Revised    - Jon Vavrus   4 MAY 1981                                      
0202    CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
0203    CDM   Revised    - Jon Vavrus  31 JUL 1981 (changed CCLINE usage)               
0204    CDM   Revised    - Jon Vavrus  27 AUG 1981                                      
0205    CDM   Revised    - Jon Vavrus   3 SEP 1981                                      
0206    CDM   Revised    - Jon Vavrus  30 DEC 1981 (added ^X)                           
0207    CDM   Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)            
0208    CDM   Revised    - Jon Vavrus  15 JUL 1982 (extract some proc's add             
0209    CDM                                         "command" level to symbol file)     
0210    CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
0211    CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
0212    CDM   Revised    - Jon Vavrus   4 APR 1983 (broadcast stuff)                    
0213    CDM   Revised    - Jon Vavrus  13 APR 1983                                      
0214    CDM   Revised    - Jon Vavrus  17 MAY 1983                                      
0215    CDM   Revised    - Jon Vavrus  28 MAY 1983                                      
0216    CDM   Revised    - Jon Vavrus   9 SEP 1983                                      
0217    CDM   Revised    - Jon Vavrus  27 SEP 1983                                      
0218    CM                                                                              
0219    CM    ------------------------------------------------------------------------- 
0220    CM                                                                              
0221    CM         The program works by calculating or finding a record boundary        
0222    CM    near the current position and extracting actual records from there.       
0223    CM    This is done for fixed files by calculating the record boundary from      
0224    CM    the start of the file (or start of the block for blocked files),          
0225    CM    keeping in mind the fact that records are extended to an even number      
0226    CM    of bytes (word aligned).  For variable length records a record length     
0227    CM    count word is looked for (a byte containing a number equal to or          
0228    CM    less than 133 plus the record header size (FSZ), followed by a zeroed     

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   5
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0229    CM    byte), which points to another record length count word.                  
0230    CM                                                                              
0231    CM         When the current line position needs to be converted to a            
0232    CM    position in terms of blocks and bytes, the program calculates the         
0233    CM    byte count from the last line in the output arrays to the current         
0234    CM    line, then using this plus the block number of the next block to be       
0235    CM    read in the position is calculated.  This is fairly straight forward      
0236    CM    for all but fixed blocked files, in which the count of unused bytes       
0237    CM    in each block must be taken into account.  For variable length record     
0238    CM    files a further check on position is made by trying to match the          
0239    CM    line pointed to and the lines around it to a specific area in the         
0240    CM    block.                                                                    
0241    CM                                                                              
0242    CM         Command input is handled by a QIO request to the terminal.  This     
0243    CM    input is terminated by the standard terminators, whihc are not echoed.    
0244    CM    Input is done with conversion to upper case (to make life easier), and    
0245    CM    with no translation of ^U, ^R, and <DEL> (all of which is done by the     
0246    CM    program).  One will note that while scrolling, the QIO is alternately     
0247    CM    requested and cancelled with each output to the terminal, this is done    
0248    CM    so that the terminal will not get simultaneous read and write requests.   
0249    CM                                                                              
0250    CM         Scrolling speed is controlled by the use of the SYS$SETIMR and       
0251    CM    SYS$WAITFR system services.  Thus the QIO AST for the stop scrolling      
0252    CM    command must cancel the timer request, and also set the event flag.       
0253    CM                                                                              
0254    CM         Symbol definitions are kept in several arrays (DEFS - command        
0255    CM    number and length of any search buffers, NUMDEF - associated numbers,     
0256    CM    DEFBUF - search buffers, and DEFFLG - associated command flags).          
0257    CM    The total number of defined symbols is thus limited to 60.                
0258    C                                                                               
0259    C***   CALLED ROUTINES                                                          
0260    C                                                                               
0261    CC    BLKIN   Reads in one block of data from the input file.                   
0262    CC    BLKOPN  Opens a file for block input.                                     
0263    CC    BLKSIN  Reads in 7 blocks of data from the input file.                    
0264    CC    BRDCST  Fields braodcast messages.                                        
0265    CC    COMLVL  Executes "command level" commands.                                
0266    CC    DODEF   Processes a symbol file.                                          
0267    CC    DOIT    Executes a command.                                               
0268    CC    INTASC  Converts a string of bytes into a character variable              
0269    CC    LINCON  Converts data in the input buffer into lines in the output        
0270    CC            arrays.                                                           
0271    CC    PRSCOM  Parses a command line.                                            
0272    CC    TTBRDINI Initializes broadcast handler.                                   
0273    C                                                                               
0274    C***   COMMON AREAS                                                             
0275    C                                                                               
0276    CS    BRDCM1  Contains character variables for broadcast handling.              
0277    CS              BRDNOT holds the notice to be displayed on the screen.          
0278    CS              BRDMSG which holds broadcast messages.                          
0279    C                                                                               
0280    CS    BRDCM2  Contains non-character information for broadcast handling.        
0281    CS              BRDLEN the length of strings in BRDMSG.                         
0282    CS              BRDCNT the count of strings in BRDMSG.                          
0283    CS              BRDFLG a flag telling if there are unread messages.             
0284    C                                                                               
0285    CS    CHARS   Used to pass character variables; contains LINES a character      

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   6
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0286    CS            array of the output lines, and SRCHBF the search buffer, and      
0287    CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
0288    CS            the VT100 control sequences to set/unset reverse video            
0289    C                                                                               
0290    CS    DOITNM  Contains information transferred from the main program:           
0291    CS                 INCHAN - input channel of the terminal                       
0292    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0293    CS                 SBFFLG - flag indicating whether there is a string           
0294    CS                          in the search buffer                                
0295    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0296    CS                 EBK    - EBK of input file                                   
0297    CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
0298    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0299    CS                 RANGE  - beginning and ending block numbers and pointers     
0300    CS                          of the print range                                  
0301    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0302    CS                 LRL    - length of the longest record in input file.         
0303    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0304    CS                 PAGEND - line number of last line output to screen           
0305    CS                 PAGLEN - number of lines per page                            
0306    CS                 COMLIN - line number for command input (bottom of screen)    
0307    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0308    C                                                                               
0309    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0310    CS            symbols SYMS and the definition search buffers DEFBUF             
0311    C                                                                               
0312    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0313    CS            symbol definitions DEFS, the number of such definitions           
0314    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0315    CS            numbers NUMDEF                                                    
0316    C                                                                               
0317    CS    LNCN    Contains output arrays, and file pointers and information:        
0318    CS                 LINLEN - array of output line lengths                        
0319    CS                 LINEP  - top of screen line (or last line output by          
0320    CS                          backward scroll)                                    
0321    CS                 NLINES - number of lines in arrays                           
0322    CS                 BUFFER - array of unconverted data                           
0323    CS                 PBUF   - current position in BUFFER                          
0324    CS                 NBUF   - number of bytes in BUFFER                           
0325    CS                 BLK    - next block in file                                  
0326    CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
0327    CS                 IFSZ   - word extended record length for FIX files           
0328    CS                 RFM    - files RFM                                           
0329    CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
0330    CS                 SBLK   - starting block of current batch of output lines     
0331    CS                 CCLINE - array containing pointer to where the line's        
0332    CS                          record starts in the file (CCLINE(1,x) = block      
0333    CS                          #, CCLINE(2,x) = byte number in block).  If         
0334    CS                          CCLINE(1,x) = 0 then it is a carriage control       
0335    CS                          line.                                               
0336    CS                 LBLK   - last block processed by LINCON                      
0337    CS                 LPBUF  - last value of PBUF processed by LINCON              
0338    C                                                                               
0339    CS    OWNER   Used to pass the file owner's UIC back to the main program        
0340    CS            from a FORTRAN OPEN.                                              
0341    C                                                                               
0342    C***   INPUT VARIABLS                                                           

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   7
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0343    C                                                                               
0344    CI    FILE    Used to input the symbol file's name.                             
0345    C                                                                               
0346    C***   INPUT/OUTPUT VARIABLES                                                   
0347    C                                                                               
0348    CIO   LINE    Used to get an error message from SYS$GETMSG and to input         
0349    CIO           a line from the symbol file, or to output error message,          
0350    CIO           and as the terminal input buffer.                                 
0351    C                                                                               
0352    C***   OUTPUT VARIABLES                                                         
0353    C                                                                               
0354    CO    FILE    Output with error message on open failure.                        
0355    CO    LINES   Output array, contains converted lines of output.                 
0356    C                                                                               
0357    C***   INPUT UNITS                                                              
0358    C                                                                               
0359    CR    INCHAN  Input channel number of the terminal.                             
0360    CR    30      Symbol file (file containing symbol definitions).                 
0361    C                                                                               
0362    C***   OUTPUT UNITS                                                             
0363    C                                                                               
0364    CW    6       Output to terminal.  Used for error messages.                     
0365    CW    9       Output to terminal.  Carriage-control LIST.                       
0366    C                                                                               
0367          PARAMETER NULL1=CHAR(0)//CHAR(0)//CHAR(0)//CHAR(0)                     367
0368          PARAMETER NULLS=NULL1//NULL1//NULL1                                    368
0369          EXTERNAL GETOWN,EXITR,BRDCST                                           369
0370          CHARACTER*1024 LINE                                                    370
0371          CHARACTER*135 DIVLIN                                                   371
0372          CHARACTER*132 LINES(600),CLINE                                         372
0373          CHARACTER*128 INLINE,BRDMSG(20)                                        373
0374          CHARACTER*122 BLANK                                                    374
0375          CHARACTER*64 FILE,SYMFIL                                               375
0376          CHARACTER*30 SRCHBF(10),TEMP(10),DEFBUF(10,10,60)                      376
0377          CHARACTER*22 BRDNOT                                                    377
0378          CHARACTER*12 CHUSER                                                    378
0379          CHARACTER*11 DEFSW                                                     379
0380          CHARACTER*8 NARROW                                                     380
0381          CHARACTER*4 REVVID,REGVID,WRAP                                         381
0382          CHARACTER*3 BOX                                                        382
0383          CHARACTER*2 CRLF,MSGNUM                                                383
0384          CHARACTER*1 SYMS(60),COMAND(12)                                        384
0385          REAL*4 NUMDEF(10,60)                                                   385
0386          INTEGER*4 GETLIS(10),ERR,RFM,RAT,FSZ,TERM(2),INCHAN,                   386
0387         1          SYS$ASSIGN,SYS$SETIMR,TIME,PBUF,EBK,SYS$TRNLOG,                 
0388         2          BLK,SBLK,RANGE(2,2),CCLINE(2,600),PAGEND,DSCBLK(4)              
0389          INTEGER*2 GROUP,MEMBER,OWNER(2),IOSB(4),LINLEN(600),DIRECT,            389
0390         1          SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,LENSAV,PAGLEN,          
0391         2          HLDLEN(10),COMLIN,OUTLEN,BRDCNT,BRDLEN(20)                      
0392          LOGICAL*1 BUFFER(3750),USER(12),SBFFLG,END(16),NUMFLG,MINFLG,          392
0393         1          ESC,WIDE,BSP,VT100,BELL,CR,LF,DELETE(11),FILEOK,                
0394         2          DEFFLG(3,10,60),HLDFLG,VT100A,DONE,BRDFLG                       
0395                                                                                 395
0396          COMMON /OWNER/OWNER                                                    396
0397          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,      397
0398         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0399          COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                          399

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   8
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0400          COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,        400
0401         1             RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                               
0402          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                      402
0403          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                         403
0404          COMMON /BRDCM1/BRDNOT,BRDMSG                                           404
0405          COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                    405
0406    C                                                                               
0407    C***   Initialize many things......                                             
0408    C                                                                               
0409          DATA BRDCNT,BRDFLG/0,.FALSE./		! Broadcast info.                       409
0410          DATA FILEOK/.TRUE./                                                    410
0411          DATA GETLIS/'202000C'X,0,0,'3080002'X,0,0,'3070002'X,0,0,0/            411
0412          DATA END/'FE'X,'FF'X,'FF'X,'FF'X,11*0,'80'X/,TERM(1)/16/               412
0413          DATA BUFFER/3750*1/			! Empty buffer                                   413
0414          DATA BLANK,ESC,BELL,BSP,CR,LF		! ASCII values                          414
0415         1     /' ',0027,0007,008,13,10/                                            
0416          DATA REGVID,REVVID/' [0m',' [7m'/                                      416
0417          DATA DELETE/27,'[','0','m',8,32,8,27,'[','7','m'/                      417
0418          DATA SYMFIL/' '/				! No definition file                               418
0419          DATA NARROW , WRAP , BOX , DEFSW		! Valid command switches             419
0420         1   /'NARROW','WRAP','BOX','DEFINITIONS'/                                  
0421          DATA VT100A/.FALSE./			! Not an AVO VT100                              421
0422          DATA WIDE/0/,LENLMT/132/			! Wide mode                                 422
0423          DATA SBFFLG/.FALSE./			! No search buffer                              423
0424          DATA RANGE/0,0,0,0/			! No print range                                 424
0425          DATA TIME/-5000000/			! Scrolling speed                                425
0426          DATA DIRECT/1/				! Forward movement                                   426
0427          DATA OUTLEN/0/				! Wrap mode                                          427
0428          DATA PAGLEN,COMLIN/23,24/			! 23 lines of output                       428
0429          DATA NDEFS,(SYMS(I),DEFS(1,1,I),NUMDEF(1,I),DEFFLG(1,1,I),             429
0430         1     DEFFLG(2,1,I),DEFFLG(3,1,I),DEFS(1,2,I),I=1,13)/13,                  
0431         2     'U',   1,   23.,.TRUE., .FALSE.,.FALSE.,0,                           
0432         3     'D',   1,  -23.,.TRUE., .FALSE.,.FALSE.,0,                           
0433         4     'S',   5,    0.,.FALSE.,.FALSE.,.FALSE.,0,                           
0434         5     'Q',   6,    0.,.FALSE.,.FALSE.,.FALSE.,0,                           
0435         6     'J',   2,   20.,.TRUE., .FALSE.,.FALSE.,0,                           
0436         7     'B',   2,  -20.,.TRUE., .FALSE.,.FALSE.,0,                           
0437         8     'E',  11,    0.,.FALSE.,.FALSE.,.FALSE.,0,                           
0438         9     'P',  10,   23.,.TRUE., .FALSE.,.FALSE.,0,                           
0439         A     'A',  10,   23.,.TRUE., .TRUE., .FALSE.,0,                           
0440         B     'L',   9,   23.,.TRUE., .FALSE.,.FALSE.,0,                           
0441         C     'M',   8,    0.,.FALSE.,.FALSE.,.FALSE.,0,                           
0442         D     'C',  12,    0.,.FALSE.,.FALSE.,.FALSE.,0,                           
0443         E     'R',  13,    0.,.FALSE.,.FALSE.,.FALSE.,0/                           
0444    C          Default key definitions:                                             
0445    C          Key command   number     minus  search  0 to terminate               
0446                                                                                 446
0447          WRITE (UNIT=CRLF,FMT=100)CR,LF                                         447
0448    100   FORMAT (2A1)                                                           448
0449          WRITE (UNIT=REVVID(1:1),FMT=100)ESC                                    449
0450          REGVID(1:1) = REVVID(1:1)                                              450
0451          TERM(2) = %LOC(END(1))                                                 451
0452    C                                                                               
0453    C***   Set things up                                                            
0454    C                                                                               
0455    C     EXECUTE (PROCESS_COM_LINE)                                             455
0456          ASSIGN 50010 TO KKK022                                                 455

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page   9
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0457          GO TO 79802                                                               
0458    50010 CONTINUE                                                                  
0459    C     EXECUTE (OPEN_PRINTOUT)                                                456
0460          ASSIGN 50020 TO KKK024                                                 456
0461          GO TO 79804                                                               
0462    50020 CONTINUE                                                                  
0463    C     EXECUTE (SETUP_TERM)                                                   457
0464          ASSIGN 50030 TO KKK026                                                 457
0465          GO TO 79806                                                               
0466    50030 CONTINUE                                                                  
0467    C     EXECUTE (GET_FIRST_SCREEN)                                             458
0468          ASSIGN 50040 TO KKK028                                                 458
0469          GO TO 79808                                                               
0470    50040 CONTINUE                                                                  
0471    C     EXECUTE (PROCESS_SYMBOL_FILE)                                          459
0472          ASSIGN 50050 TO KKK030                                                 459
0473          GO TO 79810                                                               
0474    50050 CONTINUE                                                                  
0475    C                                                                               
0476    C---   Set up to catch broadcast messages                                       
0477    C                                                                               
0478          IF (.NOT.(VT100))GO TO 50070                                           463
0479          IF (.NOT.(VT100A))GO TO 50090                                          464
0480              BRDNOT = CHAR(BELL)//CHAR(BELL)//CHAR(ESC)//'[0;1;5m'//            465
0481         1             'MESSAGES'//CHAR(ESC)//'8'                                   
0482              I = 20                                                             467
0483          GO TO 50080                                                            468
0484    50090 CONTINUE                                                                  
0485              BRDNOT = CHAR(BELL)//CHAR(BELL)//'MESSAGES'//CHAR(ESC)//'8'        469
0486              I = 12                                                             470
0487    50080 CONTINUE                                                               471
0488          GO TO 50060                                                            472
0489    50070 CONTINUE                                                                  
0490            BRDNOT = CHAR(BELL)//CHAR(BELL)//'MESSAGES'                          473
0491            I = 10                                                               474
0492    50060 CONTINUE                                                               475
0493          BRDNOT = BRDNOT(:I)//NULLS                                             476
0494          CALL TTBRDINI(BRDCST)                                                  477
0495    C                                                                               
0496    C***   Set up command input QIO request                                         
0497    C                                                                               
0498     1400 CONTINUE                                                               481
0499    50099 CONTINUE                                                                  
0500    C                                                                               
0501    C---   Output dividing line if wanted                                           
0502    C                                                                               
0503          IF (PAGLEN .NE. (COMLIN - 2))GO TO 50120                               485
0504          IF (.NOT.(VT100A))GO TO 50140                                          486
0505               CALL LIB$PUT_SCREEN(DIVLIN(:IABS(LENLMT)+3)//DIVLIN(1:1)//        487
0506         1                         '(A',COMLIN-1,1)                                 
0507          GO TO 50130                                                            489
0508    50140 CONTINUE                                                                  
0509               CALL LIB$PUT_SCREEN(DIVLIN(:80),COMLIN-1,1)                       490
0510    50130 CONTINUE                                                               491
0511    50120 CONTINUE                                                               492
0512           IF (OUTLEN .GT. 0) CALL LIB$PUT_SCREEN(BLANK(:OUTLEN),COMLIN,10)      493
0513           IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                               494

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  10
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0514          IF (LENSAV .LE. 0)GO TO 50160                                          495
0515             LINE(1+LENBUF:) = INLINE                                            496
0516             LENBUF = LENSAV + LENBUF                                            497
0517             LENSAV = 0                                                          498
0518    50160 CONTINUE                                                               499
0519    C                                                                               
0520    C---   Output "messages" message (without bells)                                
0521    C                                                                               
0522          IF (.NOT.(BRDFLG))GO TO 50180                                          503
0523             IF (VT100) CALL LIB$PUT_SCREEN(CHAR(27)//'7')                       504
0524             CALL LIB$PUT_SCREEN(BRDNOT(3:),COMLIN,IABS(LENLMT)-28)              505
0525    50180 CONTINUE                                                               506
0526    C                                                                               
0527          IF (LENBUF .LE. 0)GO TO 50200                                          508
0528             CALL LIB$PUT_SCREEN('Command: '//LINE(:LENBUF),COMLIN,1)            509
0529          GO TO 50190                                                            510
0530    50200 CONTINUE                                                                  
0531             CALL LIB$PUT_SCREEN('Command: ',COMLIN,1)                           511
0532    50190 CONTINUE                                                               512
0533           LENBUF = LENBUF + 1                                                   513
0534           J = 35 - LENBUF                                                       514
0535    C                                                                               
0536    C***   Input loop                                                               
0537    C                                                                               
0538    50209 CONTINUE                                                               518
0539            CALL SYS$QIOW(,%VAL(INCHAN),%VAL('1331'X),IOSB,,,                    519
0540         1                %REF(LINE(LENBUF:)),%VAL(J),,TERM,,)                      
0541            LENBUF = IOSB(2) + LENBUF                                            521
0542          IF (ICHAR(LINE(LENBUF:LENBUF)) .NE. 127)GO TO 50230                    522
0543    C                                                                               
0544    C---   Check for delete                                                         
0545    C                                                                               
0546          IF (LENBUF .LE. 1)GO TO 50250                                          526
0547                LENBUF = LENBUF - 1                                              527
0548          IF (.NOT.(VT100A))GO TO 50270                                          528
0549                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,DELETE,             529
0550         1                      %VAL(11),,,,)                                       
0551          GO TO 50260                                                            531
0552    50270 CONTINUE                                                                  
0553                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,DELETE(5),          532
0554         1                      %VAL(3),,,,)                                        
0555    50260 CONTINUE                                                               534
0556    50250 CONTINUE                                                               535
0557          GO TO 50220                                                            536
0558    50230 CONTINUE                                                                  
0559    C                                                                               
0560    C---   Check for ^U/^X                                                          
0561    C                                                                               
0562          IF (.NOT.(ICHAR(LINE(LENBUF:LENBUF)) .EQ. 21 .OR.                      540
0563         X          ICHAR(LINE(LENBUF:LENBUF)) .EQ. 24))GO TO 50290                 
0564                LENBUF = 1                                                       542
0565    C     EXECUTE (ERASE_COMMAND)                                                543
0566          ASSIGN 50300 TO KKK032                                                 543
0567          GO TO 79812                                                               
0568    50300 CONTINUE                                                                  
0569          GO TO 50280                                                            544
0570    50290 CONTINUE                                                                  

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  11
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0571    C                                                                               
0572    C---   Check for ^R                                                             
0573    C                                                                               
0574          IF (ICHAR(LINE(LENBUF:LENBUF)) .NE. 18)GO TO 50320                     548
0575    C     EXECUTE (ERASE_COMMAND)                                                549
0576          ASSIGN 50330 TO KKK032                                                 549
0577          GO TO 79812                                                               
0578    50330 CONTINUE                                                                  
0579                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,%REF(LINE),         550
0580         1                      %VAL(LENBUF-1),,,,)                                 
0581          GO TO 50310                                                            552
0582    50320 CONTINUE                                                                  
0583    C                                                                               
0584    C---   Check for ^Z                                                             
0585    C                                                                               
0586          IF (ICHAR(LINE(LENBUF:LENBUF)) .NE. 26)GO TO 50350                     556
0587    C                                                                               
0588    C===   Erase screen                                                             
0589    C                                                                               
0590                  CALL LIB$ERASE_PAGE(1,1)                                       560
0591          IF (.NOT.(BRDFLG))GO TO 50370                                          561
0592                    IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                      562
0593          IF (BRDCNT .NE. 1)GO TO 50390                                          563
0594                      CALL LIB$PUT_OUTPUT('THERE IS A BROADCAST '//              564
0595         1                 'MESSAGE'//CHAR(BELL),1,1)                               
0596          GO TO 50380                                                            566
0597    50390 CONTINUE                                                                  
0598                      WRITE (UNIT=MSGNUM,FMT='(I2)') BRDCNT                      567
0599          IF (BRDCNT .GE. 10)GO TO 50410                                         568
0600                        CALL LIB$PUT_OUTPUT('THERE ARE'//MSGNUM//                569
0601         1                   ' BROADCAST MESSAGES'//CHAR(BELL),1,1)                 
0602          GO TO 50400                                                            571
0603    50410 CONTINUE                                                                  
0604                        CALL LIB$PUT_OUTPUT('THERE ARE '//MSGNUM//               572
0605         1                   ' BROADCAST MESSAGES'//CHAR(BELL),1,1)                 
0606    50400 CONTINUE                                                               574
0607    50380 CONTINUE                                                               575
0608                    CALL LIB$SET_CURSOR(3,1)                                     576
0609    50370 CONTINUE                                                               577
0610                  IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                        578
0611    50419 CONTINUE                                                               579
0612                     CALL LIB$GET_INPUT(CLINE,'Command: ',LENGTH)                580
0613                     CALL COMLVL(CLINE(:LENGTH),DONE)                            581
0614          IF (DONE)GO TO 50421                                                   582
0615          GO TO 50419                                                            583
0616    50421 CONTINUE                                                                  
0617                    CALL DOIT(-1,.TRUE.,0.,.FALSE.)                              584
0618                    CALL DOIT(-12,.FALSE.,0.,.FALSE.)                            585
0619                    LENBUF = LENBUF - 1                                          586
0620          GO TO 50100                                                            587
0621    50350 CONTINUE                                                               588
0622                    LENBUF = LENBUF - 1                                          589
0623          GO TO 50211                                                            590
0624    50310 CONTINUE                                                               592
0625    50280 CONTINUE                                                               593
0626    50220 CONTINUE                                                               594
0627          GO TO 50209                                                            595

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  12
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0628    50211 CONTINUE                                                                  
0629           OUTLEN = LENBUF                                                       596
0630           IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                               597
0631           CALL LIB$SET_CURSOR(1,1)                                              598
0632    C                                                                               
0633    C***   Execute commands                                                         
0634    C                                                                               
0635           CALL STR$TRANSLATE(LINE,LINE,' ','	')                                 602
0636           CALL STR$TRIM(LINE(:LENBUF),LINE(:LENBUF),LENBUF)                     603
0637    50429 CONTINUE                                                               604
0638            CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,0,0)                605
0639          IF (ICOM .EQ. 0)GO TO 50431                                            606
0640            IF (ICOM .GT. 0) CALL DOIT(ICOM,NUMFLG,ANUMB,MINFLG)                 607
0641          IF (ICOM .EQ. 5)GO TO 50431                                            608
0642          GO TO 50429                                                            609
0643    50431 CONTINUE                                                                  
0644    50100 GO TO 50099                                                            610
0645    C                                                                               
0646    C***********************************************************************        
0647    C****************************   PROCEDURES   ***************************        
0648    C***********************************************************************        
0649    C                                                                               
0650    C                                                                               
0651    C                                                                               
0652    C.......................................................................        
0653    C     PROCEDURE (ERASE_COMMAND)                                              616
0654    79812 CONTINUE                                                               616
0655    CP    This procedure erase the command part of the bottom line.                 
0656          IF (.NOT.(VT100A))GO TO 50450                                          618
0657              CALL LIB$PUT_SCREEN(REGVID//BLANK(:LENBUF)//REVVID,COMLIN,10)      619
0658          GO TO 50440                                                            620
0659    50450 CONTINUE                                                                  
0660              CALL LIB$PUT_SCREEN(BLANK(:LENBUF),COMLIN,10)                      621
0661    50440 CONTINUE                                                               622
0662            CALL LIB$SET_CURSOR(COMLIN,10)                                       623
0663          GO TO KKK032                                                           624
0664    C                                                                               
0665    C                                                                               
0666    C.......................................................................        
0667    C     PROCEDURE (GET_FIRST_SCREEN)                                           625
0668    79808 CONTINUE                                                               625
0669    CP    This procedure inputs and formats the first screen-full of output.        
0670    C                                                                               
0671    C***   Read in first bunch of data and output                                   
0672    C                                                                               
0673            BLK = 1                                                              630
0674            SBLK = BLK                                                           631
0675          IF (EBK .LE. 6)GO TO 50470                                             632
0676              CALL BLKSIN(BLK,NBUF,BUFFER(1))                                    633
0677          IF (NBUF .NE. 0)GO TO 50490                                            634
0678    C     EXECUTE (READ_ERROR)                                                   635
0679          ASSIGN 50500 TO KKK034                                                 635
0680          GO TO 79814                                                               
0681    50500 CONTINUE                                                                  
0682    50490 CONTINUE                                                               636
0683          GO TO 50460                                                            637
0684    50470 CONTINUE                                                                  

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  13
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0685              NBUF = 0                                                           638
0686           I=1                                                                   639
0687          GO TO 50509                                                               
0688    50510  I= I+(1)                                                                 
0689          IF ( I.GT.EBK)GO TO 50511                                                 
0690    50509 CONTINUE                                                                  
0691               CALL BLKIN(BLK,J,BUFFER(NBUF+1))                                  640
0692          IF (J .NE. 0)GO TO 50530                                               641
0693    C     EXECUTE (READ_ERROR)                                                   642
0694          ASSIGN 50540 TO KKK034                                                 642
0695          GO TO 79814                                                               
0696    50540 CONTINUE                                                                  
0697    50530 CONTINUE                                                               643
0698               NBUF = NBUF + J                                                   644
0699          GO TO 50510                                                            645
0700    50511 CONTINUE                                                                  
0701    50460 CONTINUE                                                               646
0702            CALL LINCON(.TRUE.)                                                  647
0703            J = PAGLEN                                                           648
0704          IF (NLINES .GE. PAGLEN)GO TO 50560                                     649
0705    50569 CONTINUE                                                               650
0706          IF (BLK .LE. EBK)GO TO 50590                                           651
0707                 J = NLINES                                                      652
0708          GO TO 50571                                                            653
0709    50590 CONTINUE                                                               654
0710               CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                  655
0711          IF (I .NE. 0)GO TO 50610                                               656
0712    C     EXECUTE (READ_ERROR)                                                   657
0713          ASSIGN 50620 TO KKK034                                                 657
0714          GO TO 79814                                                               
0715    50620 CONTINUE                                                                  
0716    50610 CONTINUE                                                               658
0717               NBUF = NBUF + I                                                   659
0718               CALL LINCON(.FALSE.)                                              660
0719          IF (NLINES .GE. PAGLEN)GO TO 50571                                     661
0720          GO TO 50569                                                            662
0721    50571 CONTINUE                                                                  
0722    50560 CONTINUE                                                               663
0723            CALL LIB$ERASE_PAGE(1,1)                                             664
0724            CALL LIB$SET_CURSOR(1,1)                                             665
0725           I=1                                                                   666
0726          GO TO 50629                                                               
0727    50630  I= I+(1)                                                                 
0728          IF ( I.GT.J)GO TO 50631                                                   
0729    50629 CONTINUE                                                                  
0730          IF (LENLMT .GE. 0)GO TO 50650                                          667
0731          IF (LINLEN(I) .GT. (-LENLMT))GO TO 50670                               668
0732                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                 669
0733          GO TO 50660                                                            670
0734    50670 CONTINUE                                                                  
0735                 CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                  671
0736         1                           LINES(I)(1-LENLMT:LINLEN(I))//CRLF)            
0737    50660 CONTINUE                                                               673
0738          GO TO 50640                                                            674
0739    50650 CONTINUE                                                                  
0740          IF (LINLEN(I) .GE. LENLMT)GO TO 50690                                  675
0741                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                 676

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  14
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0742          GO TO 50680                                                            677
0743    50690 CONTINUE                                                                  
0744                 CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)                    678
0745    50680 CONTINUE                                                               679
0746    50640 CONTINUE                                                               680
0747          GO TO 50630                                                            681
0748    50631 CONTINUE                                                                  
0749            PAGEND = J                                                           682
0750            IF (PAGLEN .EQ. 22) CALL LIB$PUT_SCREEN(CRLF)                        683
0751            IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                              684
0752            CALL LIB$PUT_SCREEN('Block 1',24,IABS(LENLMT)-6)                     685
0753            IF (VT100A) CALL LIB$PUT_SCREEN(REGVID)                              686
0754            CALL LIB$SET_CURSOR(1,1)                                             687
0755          GO TO KKK028                                                           688
0756    C                                                                               
0757    C                                                                               
0758    C.......................................................................        
0759    C     PROCEDURE (MAIN_DIR_SEARCH)                                            689
0760    79816 CONTINUE                                                               689
0761    CP    This routine searches the directories of the users username on the        
0762    CP    various disks (JPL, CIT, and SYS2 in that order) for the                  
0763    CP    symbol file (LOOKCOM.DAT), and if found opens it.                         
0764            CALL INTASC(I,USER,CHUSER)                                           693
0765            SYMFIL='JPL:['//CHUSER(:INDEX(CHUSER,' ')-1)//']LOOKCOM.DAT'         694
0766            OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1000,              695
0767         1        ACCESS='SEQUENTIAL',FORM='FORMATTED')                             
0768          GO TO 50700                                                            697
0769     1000 CONTINUE                                                               698
0770                SYMFIL(1:3) = 'CIT'                                              699
0771                OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1100,          700
0772         1            ACCESS='SEQUENTIAL',FORM='FORMATTED')                         
0773          GO TO 50701                                                            702
0774     1100 CONTINUE                                                                  
0775                SYMFIL = 'SYS2'//SYMFIL(4:)                                      703
0776                OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=1200,          704
0777         1            ACCESS='SEQUENTIAL',FORM='FORMATTED')                         
0778          GO TO 50701                                                            706
0779     1200 CONTINUE                                                                  
0780                FILEOK = .FALSE.                                                 707
0781    50701 CONTINUE                                                               708
0782    50700 CONTINUE                                                                  
0783          GO TO KKK036                                                           709
0784    C                                                                               
0785    C                                                                               
0786    C.......................................................................        
0787    C     PROCEDURE (NO_INPUT_EXIT)                                              710
0788    79818 CONTINUE                                                               710
0789    CP    This routine is an error routine if something goes wrong with getting     
0790    CP    input from the terminal.                                                  
0791            CALL LIB$PUT_OUTPUT(' CANNOT INPUT FROM SYS$INPUT.')                 713
0792            CALL EXIT                                                            714
0793          GO TO KKK038                                                           715
0794    C                                                                               
0795    C                                                                               
0796    C.......................................................................        
0797    C     PROCEDURE (OPEN_PRINTOUT)                                              716
0798    79804 CONTINUE                                                               716

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  15
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0799    CP    This procedure opens the input file.                                      
0800    C                                                                               
0801    C***  Try to open printout file                                                 
0802    C                                                                               
0803            J = LIB$SKPC(' ',LINE)                                               721
0804            FILE = LINE(J:)                                                      722
0805            I = INDEX(FILE,' ') - 1                                              723
0806            CALL BLKOPN(FILE(:I),ERR,RFM,RAT,FSZ,EBK,LRL)                        724
0807          IF (ERR .EQ. 1)GO TO 50720                                             725
0808              IF (I .LE. 0) I = 1                                                726
0809              CALL SYS$GETMSG(%VAL(ERR),J,LINE,%VAL(15),)                        727
0810              CALL LIB$PUT_OUTPUT('****   UNABLE TO OPEN FILE '//FILE(:I))       728
0811              CALL LIB$PUT_OUTPUT(LINE(:J))                                      729
0812              CALL EXIT                                                          730
0813    50720 CONTINUE                                                               731
0814          IF (.NOT.(RFM .EQ. 1 .AND. FSZ))GO TO 50740                            732
0815              IFSZ = FSZ + 1                                                     733
0816          GO TO 50730                                                            734
0817    50740 CONTINUE                                                                  
0818              IFSZ = FSZ                                                         735
0819    50730 CONTINUE                                                               736
0820          IF (.NOT.(RAT .LT. 0 .AND. RFM .EQ. 1))GO TO 50760                     737
0821              RECBLK = IFSZ*(512/IFSZ)                                           738
0822          GO TO 50750                                                            739
0823    50760 CONTINUE                                                                  
0824              RECBLK = 512                                                       740
0825    50750 CONTINUE                                                               741
0826          GO TO KKK024                                                           742
0827    C                                                                               
0828    C                                                                               
0829    C.......................................................................        
0830    C     PROCEDURE (PROCESS_COM_LINE)                                           743
0831    79802 CONTINUE                                                               743
0832    CP    This procedure processes the command line.                                
0833    C                                                                               
0834    C***  Get file name off command line or prompt for it                           
0835    C***  Also check for /DEFINITIONS switch                                        
0836    C                                                                               
0837            CALL LIB$GET_FOREIGN(LINE,'Filename: ',LENGTH)                       749
0838            CALL STR$UPCASE(LINE(:LENGTH),LINE(:LENGTH))                         750
0839    C                                                                               
0840    C***  Get rid of tabs                                                           
0841    C                                                                               
0842            CALL STR$TRANSLATE(LINE(:LENGTH),LINE(:LENGTH),' ','	')              754
0843    C                                                                               
0844    C***  Get the switches                                                          
0845    C                                                                               
0846    50769 CONTINUE                                                               758
0847             I = INDEX(LINE(:LENGTH),'/') + 1                                    759
0848          IF (I .EQ. 1)GO TO 50771                                               760
0849             J = INDEX(LINE(I:LENGTH),'/') + I - 2                               761
0850             IF (J .EQ. (I - 2)) J = LENGTH                                      762
0851             K = INDEX(LINE(I:LENGTH),' ') + I - 2                               763
0852             IF (K .EQ. (I - 2)) K = LENGTH                                      764
0853             IF (K .LT. J) J = K                                                 765
0854    C                                                                               
0855    C---   WRAP                                                                     

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  16
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0856    C                                                                               
0857          IF ((J - I) .GT. 3)GO TO 50800                                         770
0858          IF (LINE(I:J) .NE. WRAP(:J-I+1))GO TO 50820                            771
0859                  LENLMT = -LENLMT                                               772
0860          GO TO 50781                                                            773
0861    50820 CONTINUE                                                               774
0862    50800 CONTINUE                                                               775
0863    C                                                                               
0864    C---   NARROW                                                                   
0865    C                                                                               
0866          IF ((J - I) .GT. 5)GO TO 50840                                         779
0867          IF (LINE(I:J) .NE. NARROW(:J-I+1))GO TO 50860                          780
0868                  WIDE = 1                                                       781
0869          IF (LENLMT .GE. 0)GO TO 50880                                          782
0870                    LENLMT = -80                                                 783
0871          GO TO 50870                                                            784
0872    50880 CONTINUE                                                                  
0873                    LENLMT = 80                                                  785
0874    50870 CONTINUE                                                               786
0875          GO TO 50781                                                            787
0876    50860 CONTINUE                                                               788
0877    50840 CONTINUE                                                               789
0878    C                                                                               
0879    C---   BOX                                                                      
0880    C                                                                               
0881          IF ((J - I) .GT. 2)GO TO 50900                                         793
0882          IF (LINE(I:J) .NE. BOX(:J-I+1))GO TO 50920                             794
0883                  PAGLEN = 22                                                    795
0884          GO TO 50781                                                            796
0885    50920 CONTINUE                                                               797
0886    50900 CONTINUE                                                               798
0887    C                                                                               
0888    C---   Definitions file                                                         
0889    C                                                                               
0890              K = INDEX(LINE,'=')                                                802
0891          IF (.NOT.(K .NE. 0 .AND. K .NE. J .AND. (K - I) .LE. 11))GO TO 509     803
0892         X40                                                                        
0893          IF (LINE(I:K-1) .NE. DEFSW(:K-I))GO TO 50960                           804
0894                  SYMFIL = LINE(K+1:J)                                           805
0895                  L = INDEX(SYMFIL,']') + 1                                      806
0896          IF (INDEX(SYMFIL(L:),'.') .NE. 0)GO TO 50980                           807
0897                    L = INDEX(SYMFIL,';')                                        808
0898          IF (L .NE. 0)GO TO 51000                                               809
0899                      SYMFIL = LINE(K+1:J)//'.'                                  810
0900          GO TO 50990                                                            811
0901    51000 CONTINUE                                                                  
0902                      SYMFIL = SYMFIL(:L-1)//'.'//SYMFIL(L:)                     812
0903    50990 CONTINUE                                                               813
0904    50980 CONTINUE                                                               814
0905          GO TO 50781                                                            815
0906    50960 CONTINUE                                                               816
0907    50940 CONTINUE                                                               817
0908              CALL LIB$PUT_OUTPUT(' ****   INVALID SWITCH   ****')               818
0909              CALL EXIT                                                          819
0910    50781 CONTINUE                                                               820
0911             LINE = LINE(:I-2)//LINE(J+1:)                                       821
0912             LENGTH = LENGTH - J + I - 2                                         822

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  17
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0913          GO TO 50769                                                            823
0914    50771 CONTINUE                                                                  
0915          GO TO KKK022                                                           824
0916    C                                                                               
0917    C                                                                               
0918    C.......................................................................        
0919    C     PROCEDURE (PROCESS_SYMBOL_FILE)                                        825
0920    79810 CONTINUE                                                               825
0921    CP    This procedure processes the symbol/command file.                         
0922      300 CONTINUE                                                               827
0923          IF (SYMFIL .NE. ' ')GO TO 51030                                        828
0924    C                                                                               
0925    C***  Get user information to try and find a definitions file                   
0926    C                                                                               
0927               GETLIS(2) = %LOC(USER(1))                                         832
0928               GETLIS(3) = %LOC(I)                                               833
0929               GETLIS(5) = %LOC(GROUP)                                           834
0930               GETLIS(8) = %LOC(MEMBER)                                          835
0931               CALL SYS$GETJPI(,,,GETLIS,,,)                                     836
0932               OPEN (UNIT=30,NAME='LOOKCOM.DAT',TYPE='OLD',READONLY,ERR=400,     837
0933         1           ACCESS='SEQUENTIAL',FORM='FORMATTED',USEROPEN=GETOWN)          
0934          IF (.NOT.(OWNER(1) .NE. GROUP .OR. OWNER(2) .NE. MEMBER))GO TO 510     839
0935         X50                                                                        
0936                 CLOSE (UNIT=30)                                                 840
0937    C     EXECUTE (MAIN_DIR_SEARCH)                                              841
0938          ASSIGN 51060 TO KKK036                                                 841
0939          GO TO 79816                                                               
0940    51060 CONTINUE                                                                  
0941    51050 CONTINUE                                                               842
0942          GO TO 51070                                                            843
0943      400 CONTINUE                                                               844
0944    C     EXECUTE (MAIN_DIR_SEARCH)                                              845
0945          ASSIGN 51080 TO KKK036                                                 845
0946          GO TO 79816                                                               
0947    51080 CONTINUE                                                                  
0948    51070 CONTINUE                                                               846
0949          GO TO 51020                                                            847
0950    51030 CONTINUE                                                                  
0951               OPEN (UNIT=30,NAME=SYMFIL,TYPE='OLD',READONLY,ERR=500,            848
0952         1           ACCESS='SEQUENTIAL',FORM='FORMATTED')                          
0953          GO TO 51090                                                            850
0954      500 CONTINUE                                                               851
0955                   CALL LIB$PUT_SCREEN(REVVID//'Could not open file '//          852
0956         1              SYMFIL(:INDEX(SYMFIL,' ')-1)//REGVID//CHAR(BELL),           
0957         2              24,20)                                                      
0958          GO TO 51011                                                            855
0959    51090 CONTINUE                                                               856
0960    51020 CONTINUE                                                               857
0961    C                                                                               
0962    C***   Read in lines and interpret them                                         
0963    C                                                                               
0964             IF (FILEOK) CALL DODEF                                              861
0965    51011 CONTINUE                                                               862
0966          GO TO KKK030                                                           863
0967    C                                                                               
0968    C                                                                               
0969    C.......................................................................        

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  18
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0970    C     PROCEDURE (READ_ERROR)                                                 864
0971    79814 CONTINUE                                                               864
0972    CP    This procedure is executed if an error occurs while reading the           
0973    CP    input file.                                                               
0974            CALL LIB$PUT_OUTPUT(' ERROR READING FILE')                           867
0975            CALL EXIT                                                            868
0976          GO TO KKK034                                                           869
0977    C                                                                               
0978    C                                                                               
0979    C.......................................................................        
0980    C     PROCEDURE (SETUP_TERM)                                                 870
0981    79806 CONTINUE                                                               870
0982    CP    This procedure opens and sets up the terminal.                            
0983    C                                                                               
0984    C***   Open a channel to SYS$INPUT                                              
0985    C                                                                               
0986          IF (SYS$TRNLOG('TT',I,SRCHBF(1),,,))GO TO 51110                        875
0987    C     EXECUTE (NO_INPUT_EXIT)                                                876
0988          ASSIGN 51120 TO KKK038                                                 876
0989          GO TO 79818                                                               
0990    51120 CONTINUE                                                                  
0991    51110 CONTINUE                                                               877
0992          IF (INDEX(SRCHBF(1)(:I),'LPA0') .EQ. 0)GO TO 51140                     878
0993          IF (SYS$TRNLOG('SYS$INPUT',I,SRCHBF(1),,,))GO TO 51160                 879
0994    C     EXECUTE (NO_INPUT_EXIT)                                                880
0995          ASSIGN 51170 TO KKK038                                                 880
0996          GO TO 79818                                                               
0997    51170 CONTINUE                                                                  
0998    51160 CONTINUE                                                               881
0999    51140 CONTINUE                                                               882
1000          IF (ICHAR(SRCHBF(1)) .NE. 27)GO TO 51190                               883
1001              I = I - 4                                                          884
1002              SRCHBF(1) = SRCHBF(1)(5:)                                          885
1003    51190 CONTINUE                                                               886
1004          IF (SYS$ASSIGN(SRCHBF(1)(:I),INCHAN,,))GO TO 51210                     887
1005    C     EXECUTE (NO_INPUT_EXIT)                                                888
1006          ASSIGN 51220 TO KKK038                                                 888
1007          GO TO 79818                                                               
1008    51220 CONTINUE                                                                  
1009    51210 CONTINUE                                                               889
1010    C                                                                               
1011    C***   Set terminal characteristics                                             
1012    C                                                                               
1013            CALL SETERM(INCHAN,WIDE,LENLMT)                                      893
1014    C                                                                               
1015    C***   Declare exit handler                                                     
1016    C                                                                               
1017            DSCBLK(2) = %LOC(EXITR)                                              897
1018            DSCBLK(3) = 1                                                        898
1019            DSCBLK(4) = %LOC(I)                                                  899
1020            CALL SYS$DCLEXH(DSCBLK)                                              900
1021    C                                                                               
1022    C***   If wanted format dividing line                                           
1023    C                                                                               
1024          IF (.NOT.(VT100A))GO TO 51240                                          904
1025              DIVLIN(1:1) = REVVID(1:1)                                          905
1026              DIVLIN(2:) = '(0qqqqqqqqqqqqqqqqqqqqqqqqqqq'//                     906

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  19
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1027         1         'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'//        
1028         2         'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'           
1029          GO TO 51230                                                            909
1030    51240 CONTINUE                                                                  
1031              DIVLIN = '--------------------------------'//                      910
1032         1         '---------------------------------------------------'            
1033    51230 CONTINUE                                                               912
1034          GO TO KKK026                                                           913
1035          END                                                                    914




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                 4189   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                 577   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                3568   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 OWNER                                    4   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 CHARS                                79510   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 LNCN                                  9798   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  7 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  8 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  9 BRDCM1                                2582   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
 10 BRDCM2                                  43   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               297934


ENTRY POINTS

    Address  Type  Name          

  0-00000000       LOOK          


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  2-00000830  R*4  ANUMB           2-000007ED  L*1  BELL            2-000006C6  CHAR BLANK           6-00001366  I*4  BLK           
  2-000007E3  CHAR BOX            10-00000028  I*2  BRDCNT         10-0000002A  L*1  BRDFLG          9-00000000  CHAR BRDNOT        
  2-000007EC  L*1  BSP             2-000007C0  CHAR CHUSER          2-00000642  CHAR CLINE           4-00000042  I*2  COMLIN        
  2-000007EE  L*1  CR              5-0001368C  CHAR CRLF            2-000007CC  CHAR DEFSW           4-00000009  I*2  DIRECT        
  2-000005BB  CHAR DIVLIN          2-000007F2  L*1  DONE            4-0000000B  I*4  EBK             2-000007FC  I*4  ERR           
  2-000007EA  L*1  ESC             2-00000740  CHAR FILE            2-000007F0  L*1  FILEOK          6-0000136A  I*4  FSZ           
  2-000007F4  I*2  GROUP           2-000007F1  L*1  HLDFLG          2-00000804  I*4  I               2-0000082C  I*4  ICOM          
  6-0000136E  I*4  IFSZ            4-00000000  I*4  INCHAN          7-00000000  CHAR INLINE          2-00000820  I*4  J             
  2-00000840  I*4  K               2-00000808  I*4  KKK022          2-0000080C  I*4  KKK024          2-00000810  I*4  KKK026        
  2-00000814  I*4  KKK028          2-00000818  I*4  KKK030          2-00000824  I*4  KKK032          2-00000834  I*4  KKK034        
  2-00000838  I*4  KKK036          2-0000083C  I*4  KKK038          2-00000844  I*4  L               6-0000263E  I*4  LBLK          
  2-0000081C  I*4  LENBUF          2-00000828  I*4  LENGTH          4-0000003A  I*2  LENLMT          8-00000000  I*2  LENSAV        
  2-000007EF  L*1  LF              2-000001BB  CHAR LINE            6-000004B0  I*4  LINEP           6-00002642  I*4  LPBUF         
  4-00000036  I*4  LRL             2-000007F6  I*2  MEMBER          2-000007E9  L*1  MINFLG          2-000007E6  CHAR MSGNUM        

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  20
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  2-000007D7  CHAR NARROW          6-00001362  I*4  NBUF            8-00003392  I*4  NDEFS           6-000004B4  I*4  NLINES        
  2-000007E8  L*1  NUMFLG          2-000007F8  I*2  OUTLEN          4-0000003C  I*4  PAGEND          4-00000040  I*2  PAGLEN        
  6-0000135E  I*4  PBUF            6-00001376  I*4  RAT             4-00000023  I*2  RECBLK          5-00013692  CHAR REGVID        
  5-0001368E  CHAR REVVID          6-00001372  I*4  RFM             4-00000008  L*1  SBFFLG          6-0000137A  I*4  SBLK          
  2-00000780  CHAR SYMFIL          2-00000800  I*4  SYS$SETIMR      4-00000004  I*4  TIME            4-00000035  L*1  VT100         
  4-00000044  L*1  VT100A          2-000007EB  L*1  WIDE            2-000007DF  CHAR WRAP          


ARRAYS

    Address  Type  Name                Bytes  Dimensions

 10-00000000  I*2  BRDLEN                 40  (20)
  9-00000016  CHAR BRDMSG               2560  (20)
  6-000004B8  L*1  BUFFER               3750  (3750)
  6-0000137E  I*4  CCLINE               4800  (2, 600)
  2-00000188  CHAR COMAND                 12  (12)
  7-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  8-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  8-00000002  I*2  DEFS                13200  (11, 10, 60)
  2-000001B0  L*1  DELETE                 11  (11)
  2-00000030  I*4  DSCBLK                 16  (4)
  2-000001A0  L*1  END                    16  (16)
  2-00000000  I*4  GETLIS                 40  (10)
  2-00000048  I*2  HLDLEN                 20  (10)
  2-00000040  I*2  IOSB                    8  (4)
  5-00000000  CHAR LINES               79200  (600)
  6-00000000  I*2  LINLEN               1200  (600)
  8-00003A9E  R*4  NUMDEF               2400  (10, 60)
  3-00000000  I*2  OWNER                   4  (2)
  4-00000025  I*4  RANGE                  16  (2, 2)
  4-0000000F  I*2  SBFLEN                 20  (10)
  5-00013560  CHAR SRCHBF                300  (10)
  7-00000080  CHAR SYMS                   60  (60)
  2-0000005C  CHAR TEMP                  300  (10)
  2-00000028  I*4  TERM                    8  (2)
  2-00000194  L*1  USER                   12  (12)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  1-000000C8  100'          **      300       0-00000ECA  400       0-00000EE5  500       0-000009D4  1000      0-000009EB  1100    
  0-00000A15  1200          **      1400      0-0000007D  50010     0-00000088  50020     0-00000093  50030     0-0000009E  50040   
  0-000000A9  50050     0-00000140  50060     0-00000122  50070     0-00000120  50080     0-000000FC  50090     0-0000016C  50099   
  0-000005E3  50100     0-000001F1  50120     0-000001F1  50130     0-000001D4  50140     0-00000250  50160     0-0000028D  50180   
  0-000002D1  50190     0-000002C8  50200     0-000002DC  50209     0-00000576  50211     0-00000573  50220     0-0000036C  50230   
  0-00000369  50250     0-00000369  50260     0-00000357  50270     0-00000573  50280     0-000003A9  50290     0-000003A6  50300   
  0-00000573  50310     0-000003EF  50320     0-000003D0  50330     0-0000056E  50350     0-00000520  50370     0-00000517  50380   
  0-00000477  50390     0-00000517  50400     0-000004DF  50410     0-00000531  50419     0-00000557  50421     0-000005C2  50429   
  0-000005E3  50431     0-00000640  50440     0-0000062A  50450     0-000006DA  50460     0-0000068D  50470     0-0000068B  50490   
  0-0000068B  50500     0-000006A6  50509     0-00000699  50510     0-000006DA  50511     0-000006D0  50530     0-000006D0  50540   
  0-0000075F  50560     0-000006FB  50569     0-0000075F  50571     0-00000712  50590     0-0000073C  50610     0-0000073C  50620   
  0-00000784  50629     0-00000777  50630     0-00000914  50631     0-00000911  50640     0-0000087E  50650     0-0000087B  50660   
  0-000007F8  50670     0-00000911  50680     0-000008D1  50690     0-00000A18  50700     0-00000A18  50701     0-00000AF9  50720   
  0-00000B1D  50730     0-00000B16  50740     0-00000B4B  50750     0-00000B42  50760     0-00000BA5  50769     0-00000E5C  50771   

LOOK                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  21
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  0-00000E0E  50781     0-00000C7F  50800     0-00000C7F  50820     0-00000CC1  50840     0-00000CC1  50860     0-00000CBE  50870   
  0-00000CB9  50880     0-00000CF2  50900     0-00000CF2  50920     0-00000DFE  50940     0-00000DFE  50960     0-00000DF8  50980   
  0-00000DF8  50990     0-00000DBA  51000     0-00000F49  51011     0-00000F3D  51020     0-00000ED7  51030     0-00000EC8  51050   
  0-00000EC8  51060     0-00000ED5  51070     0-00000ED5  51080     0-00000F3D  51090     0-00000F86  51110     0-00000F86  51120   
  0-00000FB9  51140     0-00000FB9  51160     0-00000FB9  51170     0-00000FD7  51190     0-00000FFD  51210     0-00000FFD  51220   
  0-00001052  51230     0-00001042  51240     0-00000B56  79802     0-00000A3E  79804     0-00000F6F  79806     0-00000654  79808   
  0-00000E67  79810     0-000005E6  79812     0-00000F54  79814     0-0000097D  79816     0-00000A23  79818   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        BLKIN                                   BLKOPN                                  BLKSIN                          
        BRDCST                                  COMLVL                                  DODEF                           
        DOIT                                    EXITR                                   FOR$CLOSE                       
        FOR$EXIT                                FOR$OPEN                                GETOWN                          
        INTASC                                  LIB$ERASE_PAGE                          LIB$GET_FOREIGN                 
        LIB$GET_INPUT                      I*4  LIB$INDEX                               LIB$PUT_OUTPUT                  
        LIB$PUT_SCREEN                          LIB$SET_CURSOR                     I*4  LIB$SKPC                        
        LINCON                                  PRSCOM                                  SETERM                          
        STR$TRANSLATE                           STR$TRIM                                STR$UPCASE                      
   I*4  SYS$ASSIGN                              SYS$DCLEXH                              SYS$GETJPI                      
        SYS$GETMSG                              SYS$QIOW                           I*4  SYS$TRNLOG                      
        TTBRDINI                        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  22
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE COMLVL(CLINE,DONE)                                          915
0002    CDM   This routine implements the "command" mode of look, by processing         
0003    CDM   one command which is passed to it.                                        
0004    CDM                                                                             
0005    CDM    Programmer - Jon Vavrus  26 AUG 1981                                     
0006    CDM    Revised    - Jon Vavrus   3 SEP 1981                                     
0007    CDM    Revised    - Jon Vavrus  18 SEP 1981                                     
0008    CDM    Revised    - Jon Vavrus   3 MAR 1982 (added SETNAR/SETWID)               
0009    CDM    Revised    - Jon Vavrus   4 MAY 1982 (handles non-AVO VT100's)           
0010    CDM    Revised    - Jon Vavrus  15 JUL 1982 (changed to handle only one         
0011    CDM                                          command)                           
0012    CDM    Revised    - Jon Vavrus  18 AUG 1982 (Bigger arrays)                     
0013    CDM    Revised    - Jon Vavrus   9 SEP 1982                                     
0014    CDM    Revised    - Jon Vavrus   4 APR 1983 (add broadcast and spawn stuff)     
0015    CDM    Revised    - Jon Vavrus  17 MAY 1983                                     
0016    CDM    Revised    - Jon Vavrus  28 MAY 1983 (check defined symbols)             
0017    CDM    Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                    
0018    CDM    Revised    - Jon Vavrus  27 SEP 1983                                     
0019    CM                                                                              
0020    CM         This routine allows the use of the following commands:               
0021    CM              DEFINE s := a1 a2 ...                                           
0022    CM                             - which defines a symbol s in the same man-      
0023    CM                               ner as a line in the definitions file (see     
0024    CM                               below), including line continuations.          
0025    CM              EXIT           - returns to the normal "look" mode.             
0026    CM              HELP a         - where a is one of the commands shown above.    
0027    CM              READ           - outputs the broadcast messages (if any)        
0028    CM                               which have been received.                      
0029    CM              SET [NO]switch - with switch being any of WRAP, BOX, WIDE       
0030    CM                               or NARROW.  These have the same affect as      
0031    CM                               the command line switches of the same          
0032    CM                               names (WIDE is the same as NONARROW),          
0033    CM                               with the NO qualifier turning them off.        
0034    CM              SHOW [s]       - where s is a defined symbol.  This will        
0035    CM                               show what commands a symbol is defined         
0036    CM                               as. (if s is omitted, all defined symbols      
0037    CM                               are shown).                                    
0038    CM              SPAWN          - starts a sub-process up to allow the user      
0039    CM                               to do DCL commands.                            
0040    CM              @filename      - Inputs the file filename as a definitions      
0041    CM                               file.                                          
0042    CM                                                                              
0043    CM          Upon return DONE is set .TRUE. if the command was EXIT, .FALSE.     
0044    CM      otherwise.                                                              
0045    C                                                                               
0046    C***   CALLED ROUTINES                                                          
0047    C                                                                               
0048    CC    CLRWRP  Sets the terminal NOWRAP                                          
0049    CC    DODEF   Processes a symbol file                                           
0050    CC    GETDEF  Translates a line into a symbol definition                        
0051    CC    SETNAR  Set VT100 terminal to 80 columns                                  
0052    CC    SETWID  Set VT100 terminal to 132 columns                                 
0053    CC    SETWRP  Sets the terminal WRAP                                            
0054    CC    TTSPAWN Spawns a sub-process (needed to get rid of broadcast              
0055    CC            trap                                                              
0056    C                                                                               
0057    C***   COMMON AREAS                                                             

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  23
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    C                                                                               
0059    CS    BRDCM1  Contains character variables for broadcast handling.              
0060    CS              BRDNOT holds the notice to be displayed on the screen.          
0061    CS              BRDMSG which holds broadcast messages.                          
0062    C                                                                               
0063    CS    BRDCM2  Contains non-character information for broadcast handling.        
0064    CS              BRDLEN the length of strings in BRDMSG.                         
0065    CS              BRDCNT the count of strings in BRDMSG.                          
0066    CS              BRDFLG a flag telling if there are unread messages.             
0067    C                                                                               
0068    CS    CHARS   Used to pass character variables; contains LINES a character      
0069    CS            array of the output lines, and SRCHBF the search buffer, and      
0070    CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
0071    CS            the VT100 control sequences to set/unset reverse video            
0072    C                                                                               
0073    CS    DOITNM  Contains information transferred from the main program:           
0074    CS                 INCHAN - input channel of the terminal                       
0075    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0076    CS                 SBFFLG - flag indicating whether there is a string           
0077    CS                          in the search buffer                                
0078    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0079    CS                 EBK    - EBK of input file                                   
0080    CS                 SBFLEN - length of string(s) in search buffer(s)             
0081    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0082    CS                 RANGE  - beginning and ending block numbers and pointers     
0083    CS                          of the print range                                  
0084    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0085    CS                 LRL    - length of the longest record in input file.         
0086    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0087    CS                 PAGEND - line number of last line output to screen           
0088    CS                 PAGLEN - number of lines per page                            
0089    CS                 COMLIN - line number for command input (bottom of screen)    
0090    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0091    C                                                                               
0092    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0093    CS            symbols SYMS and the definition search buffers DEFBUF             
0094    C                                                                               
0095    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0096    CS            symbol definitions DEFS, the number of such definitions           
0097    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0098    CS            numbers NUDMEF                                                    
0099    C                                                                               
0100          CHARACTER*(*) CLINE                                                   1014
0101          CHARACTER*1024 LINE                                                   1015
0102          CHARACTER*132 LINES(600)                                              1016
0103          CHARACTER*128 INLINE,BRDMSG(20)                                       1017
0104          CHARACTER*64 IMAGE                                                    1018
0105          CHARACTER*30 DEFBUF(10,10,60),SRCHBF(10)                              1019
0106          CHARACTER*22 BRDNOT                                                   1020
0107          CHARACTER*6 DEFINE,NARROW                                             1021
0108          CHARACTER*5 SPAWN                                                     1022
0109          CHARACTER*4 EXIT,HELP,SHOW,REVVID,REGVID,WRAP,WIDE,READ               1023
0110          CHARACTER*3 SET,BOX                                                   1024
0111          CHARACTER*2 CRLF                                                      1025
0112          CHARACTER*1 SYMS(60),COMAND(13),ALLSYM(42)                            1026
0113          REAL*4 NUMDEF(10,60)                                                  1027
0114          INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,GETLIS(4),TTSPAWN         1028

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  24
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115          INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,PAGLEN,      1029
0116         1          LENSAV,COMLIN,BRDCNT,BRDLEN(20)                                 
0117          LOGICAL GETDEF                                                        1031
0118          LOGICAL*1 SBFFLG,VT100,DEFFLG(3,10,60),NO,VT100A,DONE,BRDFLG,         1032
0119         1          OKFLAG                                                          
0120                                                                                1034
0121          COMMON /BRDCM1/BRDNOT,BRDMSG                                          1035
0122          COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                   1036
0123          COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                         1037
0124          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     1038
0125         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0126          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                     1040
0127          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                        1041
0128                                                                                1042
0129          DATA NUMCOM,COMAND/13,'$','%','^','!','#','(',')','*',' ','&','@',    1043
0130         1                   '+','<'/                                               
0131          DATA NUMALL,ALLSYM/42,'A','B','C','D','E','F','G','H','I','J','K',    1045
0132         1                   'L','M','N','O','P','Q','R','S','T','U','V',           
0133         2                   'W','X','Y','Z','_','=','`','~','[',']','{',           
0134         3                   '}',';',':',',','>','?','/','\','|'/                   
0135          DATA GETLIS(1),GETLIS(4)/'2070040'X,0/,IMAGE/'{'/                     1049
0136          DATA BOX , SET , WRAP , EXIT , HELP , SHOW , WIDE , DEFINE/           1050
0137         1    'BOX','SET','WRAP','EXIT','HELP','SHOW','WIDE','DEFINE'/              
0138          DATA READ , SPAWN , NARROW/                                           1052
0139         1    'READ','SPAWN','NARROW'/                                              
0140                                                                                1054
0141          IF (LEN(CLINE) .NE. 0)GO TO 50020                                     1055
0142    C     EXECUTE (ERROR)                                                       1056
0143          ASSIGN 50030 TO KKK022                                                1056
0144          GO TO 79802                                                               
0145    50030 CONTINUE                                                                  
0146    50020 CONTINUE                                                              1057
0147    C                                                                               
0148    C***   Get any continuation lines                                               
0149    C                                                                               
0150          CALL STR$TRIM(LINE,CLINE,LENGTH)                                      1061
0151    50039 CONTINUE                                                              1062
0152          IF (LINE(LENGTH:LENGTH) .NE. '-')GO TO 50041                          1063
0153           CALL LIB$GET_INPUT(LINE(LENGTH:),'-',J)                              1064
0154           LENGTH = LENGTH + J                                                  1065
0155          GO TO 50039                                                           1066
0156    50041 CONTINUE                                                                  
0157          CALL STR$TRANSLATE(LINE(:LENGTH),LINE(:LENGTH),' ','	')               1067
0158          CALL STR$UPCASE(LINE(:LENGTH),LINE(:LENGTH))                          1068
0159    C                                                                               
0160    C***   Trim leading blanks                                                      
0161    C                                                                               
0162          I = LIB$SKPC(' ',LINE)                                                1072
0163          IF (I .GT. LENGTH)GO TO 50060                                         1073
0164            LINE = LINE(I:LENGTH)                                               1074
0165            I = INDEX(LINE,' ') - 1                                             1075
0166    C                                                                               
0167    C***   Check for set                                                            
0168    C                                                                               
0169          IF (I .GT. 3)GO TO 50080                                              1079
0170          IF (LINE(:I) .NE. SET(:I))GO TO 50100                                 1080
0171                J = LIB$SKPC(' ',LINE(I+1:)) + I                                1081

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  25
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0172          IF (J .GE. I)GO TO 50120                                              1082
0173    C     EXECUTE (ERROR)                                                       1083
0174          ASSIGN 50130 TO KKK022                                                1083
0175          GO TO 79802                                                               
0176    50130 CONTINUE                                                                  
0177    50120 CONTINUE                                                              1084
0178                LINE = LINE(J:)                                                 1085
0179                I = INDEX(LINE,' ') - 1                                         1086
0180    C                                                                               
0181    C---   NO?                                                                      
0182    C                                                                               
0183                NO = .FALSE.                                                    1090
0184          IF (I .LE. 2)GO TO 50150                                              1091
0185          IF (LINE(:2) .NE. 'NO')GO TO 50170                                    1092
0186                    NO = .TRUE.                                                 1093
0187                    LINE = LINE(3:)                                             1094
0188                    I = I - 2                                                   1095
0189    50170 CONTINUE                                                              1096
0190    50150 CONTINUE                                                              1097
0191    C                                                                               
0192    C---   BOX?                                                                     
0193    C                                                                               
0194          IF (I .GT. 3)GO TO 50190                                              1101
0195          IF (LINE(:I) .NE. BOX(:I))GO TO 50210                                 1102
0196          IF (.NOT.(NO))GO TO 50230                                             1103
0197                      PAGLEN = COMLIN - 1                                       1104
0198          GO TO 50220                                                           1105
0199    50230 CONTINUE                                                                  
0200                      PAGLEN = COMLIN - 2                                       1106
0201    50220 CONTINUE                                                              1107
0202    C     EXECUTE (OK_RETURN)                                                   1108
0203          ASSIGN 50240 TO KKK024                                                1108
0204          GO TO 79804                                                               
0205    50240 CONTINUE                                                                  
0206    50210 CONTINUE                                                              1109
0207    50190 CONTINUE                                                              1110
0208    C                                                                               
0209    C---   WRAP?                                                                    
0210    C                                                                               
0211          IF (I .GT. 4)GO TO 50260                                              1114
0212          IF (WRAP(:I) .NE. LINE(:I))GO TO 50280                                1115
0213          IF (.NOT.(NO))GO TO 50300                                             1116
0214                      LENLMT = IABS(LENLMT)                                     1117
0215                      CALL CLRWRP(INCHAN)                                       1118
0216          GO TO 50290                                                           1119
0217    50300 CONTINUE                                                                  
0218                      LENLMT = -IABS(LENLMT)                                    1120
0219                      CALL SETWRP(INCHAN)                                       1121
0220    50290 CONTINUE                                                              1122
0221    C     EXECUTE (OK_RETURN)                                                   1123
0222          ASSIGN 50310 TO KKK024                                                1123
0223          GO TO 79804                                                               
0224    50310 CONTINUE                                                                  
0225    50280 CONTINUE                                                              1124
0226    C                                                                               
0227    C---   WIDE?                                                                    
0228    C                                                                               

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  26
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0229          IF (.NOT.(WIDE(:I) .EQ. LINE(:I) .AND. VT100))GO TO 50330             1128
0230          IF (.NOT.(NO))GO TO 50350                                             1129
0231    C     EXECUTE (SET_NARROW)                                                  1130
0232          ASSIGN 50360 TO KKK026                                                1130
0233          GO TO 79806                                                               
0234    50360 CONTINUE                                                                  
0235          GO TO 50340                                                           1131
0236    50350 CONTINUE                                                                  
0237    C     EXECUTE (SET_WIDE)                                                    1132
0238          ASSIGN 50370 TO KKK028                                                1132
0239          GO TO 79808                                                               
0240    50370 CONTINUE                                                                  
0241    50340 CONTINUE                                                              1133
0242    C     EXECUTE (OK_RETURN)                                                   1134
0243          ASSIGN 50380 TO KKK024                                                1134
0244          GO TO 79804                                                               
0245    50380 CONTINUE                                                                  
0246    50330 CONTINUE                                                              1135
0247    50260 CONTINUE                                                              1136
0248    C                                                                               
0249    C---   NARROW?                                                                  
0250    C                                                                               
0251          IF (I .GT. 6)GO TO 50400                                              1140
0252          IF (.NOT.(LINE(:I) .EQ. NARROW(:I) .AND. VT100))GO TO 50420           1141
0253          IF (.NOT.(NO))GO TO 50440                                             1142
0254    C     EXECUTE (SET_WIDE)                                                    1143
0255          ASSIGN 50450 TO KKK028                                                1143
0256          GO TO 79808                                                               
0257    50450 CONTINUE                                                                  
0258          GO TO 50430                                                           1144
0259    50440 CONTINUE                                                                  
0260    C     EXECUTE (SET_NARROW)                                                  1145
0261          ASSIGN 50460 TO KKK026                                                1145
0262          GO TO 79806                                                               
0263    50460 CONTINUE                                                                  
0264    50430 CONTINUE                                                              1146
0265    C     EXECUTE (OK_RETURN)                                                   1147
0266          ASSIGN 50470 TO KKK024                                                1147
0267          GO TO 79804                                                               
0268    50470 CONTINUE                                                                  
0269    50420 CONTINUE                                                              1148
0270    50400 CONTINUE                                                              1149
0271    C     EXECUTE (ERROR)                                                       1150
0272          ASSIGN 50480 TO KKK022                                                1150
0273          GO TO 79802                                                               
0274    50480 CONTINUE                                                                  
0275    50100 CONTINUE                                                              1151
0276    50080 CONTINUE                                                              1152
0277    C                                                                               
0278    C***   Check for EXIT                                                           
0279    C                                                                               
0280          IF (I .GT. 4)GO TO 50500                                              1156
0281          IF (LINE(:I) .NE. EXIT(:I))GO TO 50520                                1157
0282                DONE = .TRUE.                                                   1158
0283                RETURN                                                          1159
0284    50520 CONTINUE                                                              1160
0285    C                                                                               

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  27
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0286    C***   Check for HELP                                                           
0287    C                                                                               
0288          IF (LINE(:I) .NE. HELP(:I))GO TO 50540                                1164
0289    C                                                                               
0290    C---   Open help file                                                           
0291    C                                                                               
0292                CALL LBR$INI_CONTROL(J,1)                                       1168
0293          IF (IMAGE .NE. '{')GO TO 50560                                        1169
0294                  GETLIS(2) = %LOC(IMAGE)                                       1170
0295                  GETLIS(3) = %LOC(K)                                           1171
0296                  CALL SYS$GETJPI(,,,GETLIS,,,)                                 1172
0297                  L = INDEX(IMAGE,']')                                          1173
0298          IF (L .NE. 0)GO TO 50580                                              1174
0299                    IMAGE = 'LOOK.HLB'                                          1175
0300          GO TO 50570                                                           1176
0301    50580 CONTINUE                                                                  
0302                    IMAGE = IMAGE(:L)//'LOOK.HLB'                               1177
0303    50570 CONTINUE                                                              1178
0304    50560 CONTINUE                                                              1179
0305          IF (LBR$OPEN(J,IMAGE))GO TO 50600                                     1180
0306                  CALL LIB$PUT_OUTPUT('***   COULD NOT OPEN HELP LIBRARY')      1181
0307                  DONE = .FALSE.                                                1182
0308                  RETURN                                                        1183
0309    50600 CONTINUE                                                              1184
0310    C                                                                               
0311    C---   Output message, close file                                               
0312    C                                                                               
0313                K = INDEX(LINE(I+1:),'*') + I + 1                               1188
0314          IF (K .EQ. (I + 1))GO TO 50620                                        1189
0315                  LINE = 'ASTERISK '//LINE(K:)                                  1190
0316          GO TO 50610                                                           1191
0317    50620 CONTINUE                                                                  
0318                  K = INDEX(LINE(I+1:),'%') + I + 1                             1192
0319          IF (K .EQ. (I + 1))GO TO 50640                                        1193
0320                    LINE = 'PERCENT '//LINE(K:)                                 1194
0321          GO TO 50630                                                           1195
0322    50640 CONTINUE                                                                  
0323                    K = INDEX(LINE(I+1:),'!') + I + 1                           1196
0324          IF (K .EQ. (I + 1))GO TO 50660                                        1197
0325                      LINE = 'EXCLAMATION '//LINE(K:)                           1198
0326          GO TO 50650                                                           1199
0327    50660 CONTINUE                                                                  
0328                      K = LIB$SKPC(' ',LINE(I+1:)) + I                          1200
0329          IF (I .NE. K)GO TO 50680                                              1201
0330                        LINE = 'INFO'                                           1202
0331          GO TO 50670                                                           1203
0332    50680 CONTINUE                                                                  
0333                        LINE = LINE(K:)                                         1204
0334    50670 CONTINUE                                                              1205
0335    50650 CONTINUE                                                              1206
0336    50630 CONTINUE                                                              1207
0337    50610 CONTINUE                                                              1208
0338                CALL STR$TRIM(LINE,LINE,I)                                      1209
0339                K = INDEX(LINE,' ') - 1                                         1210
0340          IF (K .NE. I)GO TO 50700                                              1211
0341                  CALL LBR$GET_HELP(J,,,,LINE)                                  1212
0342          GO TO 50690                                                           1213

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  28
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0343    50700 CONTINUE                                                                  
0344                  I = LIB$SKPC(' ',LINE(K+1:)) + K                              1214
0345                  CALL LBR$GET_HELP(J,,,,LINE(:K),LINE(I:))                     1215
0346    50690 CONTINUE                                                              1216
0347                CALL LBR$CLOSE(J)                                               1217
0348    C     EXECUTE (OK_RETURN)                                                   1218
0349          ASSIGN 50710 TO KKK024                                                1218
0350          GO TO 79804                                                               
0351    50710 CONTINUE                                                                  
0352    50540 CONTINUE                                                              1219
0353    C                                                                               
0354    C***   Check for show                                                           
0355    C                                                                               
0356          IF (LINE(:I) .NE. SHOW(:I))GO TO 50730                                1223
0357                J = LIB$SKPC(' ',LINE(I+1:)) + I                                1224
0358          IF (LINE(J+1:) .EQ. ' ')GO TO 50750                                   1225
0359    C     EXECUTE (ERROR)                                                       1226
0360          ASSIGN 50760 TO KKK022                                                1226
0361          GO TO 79802                                                               
0362    50760 CONTINUE                                                                  
0363    50750 CONTINUE                                                              1227
0364          IF (J .NE. I)GO TO 50780                                              1228
0365          DO 50790  ISYM=1,NDEFS                                                1229
0366    C     EXECUTE (SHOW_SYMBOL)                                                 1230
0367          ASSIGN 50800 TO KKK030                                                1230
0368          GO TO 79810                                                               
0369    50800 CONTINUE                                                                  
0370    50790 CONTINUE                                                              1231
0371    C     EXECUTE (OK_RETURN)                                                   1232
0372          ASSIGN 50810 TO KKK024                                                1232
0373          GO TO 79804                                                               
0374    50810 CONTINUE                                                                  
0375          GO TO 50770                                                           1233
0376    50780 CONTINUE                                                                  
0377          DO 50820  ISYM=1,NDEFS                                                1234
0378          IF (LINE(J:J) .NE. SYMS(ISYM))GO TO 50840                             1235
0379    C     EXECUTE (SHOW_SYMBOL)                                                 1236
0380          ASSIGN 50850 TO KKK030                                                1236
0381          GO TO 79810                                                               
0382    50850 CONTINUE                                                                  
0383    C     EXECUTE (OK_RETURN)                                                   1237
0384          ASSIGN 50860 TO KKK024                                                1237
0385          GO TO 79804                                                               
0386    50860 CONTINUE                                                                  
0387    50840 CONTINUE                                                              1238
0388    50820 CONTINUE                                                              1239
0389    C     EXECUTE (ERROR)                                                       1240
0390          ASSIGN 50870 TO KKK022                                                1240
0391          GO TO 79802                                                               
0392    50870 CONTINUE                                                                  
0393    50770 CONTINUE                                                              1241
0394    50730 CONTINUE                                                              1242
0395    C                                                                               
0396    C***   Check for read                                                           
0397    C                                                                               
0398          IF (LINE(:I) .NE. READ(:I))GO TO 50890                                1246
0399          IF (BRDCNT .NE. 0)GO TO 50910                                         1247

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  29
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0400                  CALL LIB$PUT_OUTPUT(CRLF//'No broadcast messages have '       1248
0401         1                            //'been received.'//CRLF)                     
0402          GO TO 50900                                                           1250
0403    50910 CONTINUE                                                                  
0404                  CALL LIB$PUT_OUTPUT(CRLF//'The following messages '//         1251
0405         1                            'have been received:')                        
0406          IF (BRDCNT .GT. 20)GO TO 50930                                        1253
0407                    J = BRDCNT                                                  1254
0408          GO TO 50920                                                           1255
0409    50930 CONTINUE                                                                  
0410                    J = 20                                                      1256
0411    50920 CONTINUE                                                              1257
0412          DO 50940  I=1,J                                                       1258
0413    C                                                                               
0414    C---   Remove bells from message                                                
0415    C                                                                               
0416    50949 CONTINUE                                                              1262
0417                    K = INDEX(BRDMSG(I)(:BRDLEN(I)),CHAR(7))                    1263
0418          IF (K .EQ. 0)GO TO 50951                                              1264
0419                    BRDMSG(I) = BRDMSG(I)(:K-1)//BRDMSG(I)(K+1:)                1265
0420                    BRDLEN(I) = BRDLEN(I) - 1                                   1266
0421          GO TO 50949                                                           1267
0422    50951 CONTINUE                                                                  
0423    C                                                                               
0424    C---   Output message                                                           
0425    C                                                                               
0426                   CALL LIB$PUT_OUTPUT(BRDMSG(I)(:BRDLEN(I)))                   1271
0427    50940 CONTINUE                                                              1272
0428          IF (BRDCNT .LE. 20)GO TO 50970                                        1273
0429                    CALL LIB$PUT_OUTPUT(CRLF//                                  1274
0430         1               'There were too many messages!  The buffer over-'          
0431         2               //'flowed, there were un-seen messages'//CRLF)             
0432          GO TO 50960                                                           1277
0433    50970 CONTINUE                                                                  
0434                    CALL LIB$PUT_OUTPUT(CRLF)                                   1278
0435    50960 CONTINUE                                                              1279
0436                  BRDCNT = 0                                                    1280
0437    50900 CONTINUE                                                              1281
0438                BRDFLG = .FALSE.                                                1282
0439    C     EXECUTE (OK_RETURN)                                                   1283
0440          ASSIGN 50980 TO KKK024                                                1283
0441          GO TO 79804                                                               
0442    50980 CONTINUE                                                                  
0443    50890 CONTINUE                                                              1284
0444    50500 CONTINUE                                                              1285
0445    C                                                                               
0446    C***  SPAWN?                                                                    
0447    C                                                                               
0448          IF (I .GT. 5)GO TO 51000                                              1289
0449          IF (SPAWN(:I) .NE. LINE(:I))GO TO 51020                               1290
0450                IF (.NOT.TTSPAWN()) CALL LIB$PUT_OUTPUT                         1291
0451         1          ('Unable to spawn sub-process')                                 
0452    C     EXECUTE (OK_RETURN)                                                   1293
0453          ASSIGN 51030 TO KKK024                                                1293
0454          GO TO 79804                                                               
0455    51030 CONTINUE                                                                  
0456    51020 CONTINUE                                                              1294

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  30
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0457    51000 CONTINUE                                                              1295
0458    C                                                                               
0459    C***   DEFINE?                                                                  
0460    C                                                                               
0461          IF (I .GT. 6)GO TO 51050                                              1299
0462          IF (DEFINE(:I) .NE. LINE(:I))GO TO 51070                              1300
0463                J = LIB$SKPC(' ',LINE(I+1:)) + I                                1301
0464          IF (J .NE. I)GO TO 51090                                              1302
0465    C     EXECUTE (ERROR)                                                       1303
0466          ASSIGN 51100 TO KKK022                                                1303
0467          GO TO 79802                                                               
0468    51100 CONTINUE                                                                  
0469    51090 CONTINUE                                                              1304
0470                LINE = LINE(J:)                                                 1305
0471                CALL STR$TRIM(LINE,LINE,LENGTH)                                 1306
0472                I = INDEX(LINE,':=') - 1                                        1307
0473                J = INDEX(LINE,'"') - 1                                         1308
0474                K = INDEX(LINE,'''') - 1                                        1309
0475          IF (.NOT.(I .LT. 1 .OR. (J .LT. I .AND. J .GE. 0) .OR. (K .LT. I      1310
0476         X          .AND. K .GE. 0)))GO TO 51120                                    
0477    C                                                                               
0478    C---   If no := then error                                                      
0479    C                                                                               
0480    C     EXECUTE (ERROR)                                                       1315
0481          ASSIGN 51130 TO KKK022                                                1315
0482          GO TO 79802                                                               
0483    51130 CONTINUE                                                                  
0484    51120 CONTINUE                                                              1316
0485    C                                                                               
0486    C---   Make sure that it is definable                                           
0487    C                                                                               
0488                OKFLAG = .FALSE.                                                1320
0489          DO 51140  L=1,NUMALL                                                  1321
0490                 IF (LINE(1:1) .EQ. ALLSYM(L)) OKFLAG = .TRUE.                  1322
0491    51140 CONTINUE                                                              1323
0492          IF (.NOT.(OKFLAG))GO TO 51160                                         1324
0493    C     EXECUTE (DEFINE_SYMBOL)                                               1325
0494          ASSIGN 51170 TO KKK032                                                1325
0495          GO TO 79812                                                               
0496    51170 CONTINUE                                                                  
0497    C     EXECUTE (OK_RETURN)                                                   1326
0498          ASSIGN 51180 TO KKK024                                                1326
0499          GO TO 79804                                                               
0500    51180 CONTINUE                                                                  
0501          GO TO 51150                                                           1327
0502    51160 CONTINUE                                                                  
0503    C     EXECUTE (ERROR)                                                       1328
0504          ASSIGN 51190 TO KKK022                                                1328
0505          GO TO 79802                                                               
0506    51190 CONTINUE                                                                  
0507    51150 CONTINUE                                                              1329
0508    51070 CONTINUE                                                              1330
0509    51050 CONTINUE                                                              1331
0510    C                                                                               
0511    C***   Check for @                                                              
0512    C                                                                               
0513          IF (LINE(1:1) .NE. '@')GO TO 51210                                    1335

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  31
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0514              OPEN (UNIT=30,NAME=LINE(2:I),TYPE='OLD',ERR=700,READONLY)         1336
0515              CALL DODEF                                                        1337
0516          GO TO 51220                                                           1338
0517      700 CONTINUE                                                              1339
0518                  I = INDEX(LINE,' ') - 1                                       1340
0519                  CALL LIB$PUT_OUTPUT('***   UNABLE TO OPEN '//LINE(:I))        1341
0520    51220 CONTINUE                                                              1342
0521    C     EXECUTE (OK_RETURN)                                                   1343
0522          ASSIGN 51230 TO KKK024                                                1343
0523          GO TO 79804                                                               
0524    51230 CONTINUE                                                                  
0525    51210 CONTINUE                                                              1344
0526    C     EXECUTE (ERROR)                                                       1345
0527          ASSIGN 51240 TO KKK022                                                1345
0528          GO TO 79802                                                               
0529    51240 CONTINUE                                                                  
0530    50060 CONTINUE                                                              1346
0531          DONE = .FALSE.                                                        1347
0532          RETURN                                                                1348
0533    C                                                                               
0534    C                                                                               
0535    C.......................................................................        
0536    C     PROCEDURE (DEFINE_SYMBOL)                                             1349
0537    79812 CONTINUE                                                              1349
0538    CP    This procedure defines a symbol.                                          
0539    C                                                                               
0540    C***   See if symbol is already defined                                         
0541    C                                                                               
0542      900 CONTINUE                                                              1354
0543           II=1                                                                 1355
0544          GO TO 51259                                                               
0545    51260  II= II+(1)                                                               
0546          IF ( II.GT.NDEFS)GO TO 51261                                              
0547    51259 CONTINUE                                                                  
0548          IF (SYMS(II) .EQ. LINE(1:1))GO TO 51251                               1356
0549          GO TO 51260                                                           1357
0550    51261 CONTINUE                                                                  
0551             NDEFS = NDEFS + 1                                                  1358
0552             II = NDEFS                                                         1359
0553             SYMS(II) = LINE(1:1)                                               1360
0554    51251 CONTINUE                                                              1361
0555            LINE = LINE(I+3:)                                                   1362
0556            LENGTH = LENGTH - I - 2                                             1363
0557    C                                                                               
0558    C***   Actually get definitions                                                 
0559    C                                                                               
0560          IF (GETDEF(LINE(:LENGTH),II))GO TO 51280                              1367
0561    C     EXECUTE (ERROR)                                                       1368
0562          ASSIGN 51290 TO KKK022                                                1368
0563          GO TO 79802                                                               
0564    51290 CONTINUE                                                                  
0565    51280 CONTINUE                                                              1369
0566          GO TO KKK032                                                          1370
0567    C                                                                               
0568    C                                                                               
0569    C.......................................................................        
0570    C     PROCEDURE (ERROR)                                                     1371

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  32
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0571    79802 CONTINUE                                                              1371
0572    CP    This writes an error message                                              
0573            CALL STR$TRIM(LINE,LINE,I)                                          1373
0574            IF (I .NE. 0) CALL LIB$PUT_OUTPUT(LINE(:I)//' ??')                  1374
0575            DONE = .FALSE.                                                      1375
0576            RETURN                                                              1376
0577    C                                                                               
0578    C                                                                               
0579    C.......................................................................        
0580    C     PROCEDURE (OK_RETURN)                                                 1378
0581    79804 CONTINUE                                                              1378
0582    CP    This procedure sets DONE to false and returns.                            
0583            DONE = .FALSE.                                                      1380
0584            RETURN                                                              1381
0585    C                                                                               
0586    C                                                                               
0587    C.......................................................................        
0588    C     PROCEDURE (SET_NARROW)                                                1383
0589    79806 CONTINUE                                                              1383
0590    CP    This procedure sets the terminal to 80 column mode.                       
0591            LENLMT = 80*LENLMT/IABS(LENLMT)                                     1385
0592            CALL SETNAR(INCHAN)                                                 1386
0593          IF (VT100A)GO TO 51310                                                1387
0594              COMLIN = 24                                                       1388
0595              PAGLEN = PAGLEN + 10                                              1389
0596    51310 CONTINUE                                                              1390
0597          GO TO KKK026                                                          1391
0598    C                                                                               
0599    C                                                                               
0600    C.......................................................................        
0601    C     PROCEDURE (SET_WIDE)                                                  1392
0602    79808 CONTINUE                                                              1392
0603    CP    This procedure sets the terminal to 132 column mode.                      
0604            LENLMT = 132*LENLMT/IABS(LENLMT)                                    1394
0605            CALL SETWID(INCHAN)                                                 1395
0606          IF (VT100A)GO TO 51330                                                1396
0607              COMLIN = 14                                                       1397
0608              PAGLEN = PAGLEN - 10                                              1398
0609    51330 CONTINUE                                                              1399
0610          GO TO KKK028                                                          1400
0611    C                                                                               
0612    C                                                                               
0613    C.......................................................................        
0614    C     PROCEDURE (SHOW_SYMBOL)                                               1401
0615    79810 CONTINUE                                                              1401
0616    CP    This procedure writes out the definition for one symbol                   
0617            LINE = SYMS(ISYM)//' := '                                           1403
0618            L = 6                                                               1404
0619           K=1                                                                  1405
0620          GO TO 51339                                                               
0621    51340  K= K+(1)                                                                 
0622          IF ( K.GT.10)GO TO 51341                                                  
0623    51339 CONTINUE                                                                  
0624          IF (DEFS(1,K,ISYM) .EQ. 0)GO TO 51341                                 1406
0625    C                                                                               
0626    C***   Convert the number                                                       
0627    C                                                                               

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  33
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0628          IF (.NOT.(DEFFLG(1,K,ISYM)))GO TO 51360                               1410
0629               WRITE (UNIT=LINE(L:),FMT=1000)NUMDEF(K,ISYM)                     1411
0630    1000       FORMAT (F10.3)                                                   1412
0631               M = LIB$SKPC(' ',LINE(L:))                                       1413
0632               LINE(L:) = LINE(L+M-1:)                                          1414
0633               L = 11 + L - M                                                   1415
0634               IF (LINE(L-3:L-1) .EQ. '000') L = L - 4                          1416
0635    51360 CONTINUE                                                              1417
0636    C                                                                               
0637    C***   Is it --&?                                                               
0638    C                                                                               
0639          IF (DEFS(1,K,ISYM) .NE. 9)GO TO 51380                                 1421
0640               LINE(L:) = '--& '                                                1422
0641               L = L + 4                                                        1423
0642          GO TO 51340                                                           1424
0643    51380 CONTINUE                                                              1425
0644    C                                                                               
0645    C***   Set minus if necessary                                                   
0646    C                                                                               
0647          IF (.NOT.(DEFFLG(2,K,ISYM)))GO TO 51400                               1429
0648               LINE(L:) = '-'                                                   1430
0649               L = L + 1                                                        1431
0650    51400 CONTINUE                                                              1432
0651    C                                                                               
0652    C***   Search?                                                                  
0653    C                                                                               
0654          IF (DEFS(1,K,ISYM) .NE. 3)GO TO 51420                                 1436
0655          IF (.NOT.(DEFFLG(3,K,ISYM)))GO TO 51440                               1437
0656                 LINE(L:) = '"'//DEFBUF(1,K,ISYM)(:DEFS(2,K,ISYM))              1438
0657                 KK = L                                                         1439
0658                 L = L + 3 + DEFS(2,K,ISYM)                                     1440
0659    51449 CONTINUE                                                              1441
0660                  LL = INDEX(LINE(KK+1:),'"') + KK                              1442
0661          IF (LL .EQ. KK)GO TO 51451                                            1443
0662                  LINE(LL:) = '"'//LINE(LL:)                                    1444
0663                  L = L + 1                                                     1445
0664                  KK = LL + 2                                                   1446
0665          GO TO 51449                                                           1447
0666    51451 CONTINUE                                                                  
0667                 LINE(L-2:L-2) = '"'                                            1448
0668           JJ=2                                                                 1449
0669          GO TO 51459                                                               
0670    51460  JJ= JJ+(1)                                                               
0671          IF ( JJ.GT.10)GO TO 51461                                                 
0672    51459 CONTINUE                                                                  
0673          IF (DEFS(1+JJ,K,ISYM) .EQ. 0)GO TO 51461                              1450
0674                  LINE(L:) = ''''//DEFBUF(JJ,K,ISYM)(:DEFS(1+JJ,K,ISYM))        1451
0675                  KK = L                                                        1452
0676                  L = L + 3 + DEFS(1+JJ,K,ISYM)                                 1453
0677    51469 CONTINUE                                                              1454
0678                   LL = INDEX(LINE(KK+1:),'''') + KK                            1455
0679          IF (LL .EQ. KK)GO TO 51471                                            1456
0680                   LINE(LL:) = ''''//LINE(LL:)                                  1457
0681                   L = L + 1                                                    1458
0682                   KK = LL + 2                                                  1459
0683          GO TO 51469                                                           1460
0684    51471 CONTINUE                                                                  

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  34
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0685                  LINE(L-2:L-2) = ''''                                          1461
0686          GO TO 51460                                                           1462
0687    51461 CONTINUE                                                                  
0688                 LINE(L-1:) = '^'                                               1463
0689                 L = L + 1                                                      1464
0690          GO TO 51430                                                           1465
0691    51440 CONTINUE                                                                  
0692                 LINE(L:) = '^ '                                                1466
0693                 L = L + 2                                                      1467
0694    51430 CONTINUE                                                              1468
0695          GO TO 51340                                                           1469
0696    51420 CONTINUE                                                              1470
0697    C                                                                               
0698    C***   Set LINE                                                                 
0699    C                                                                               
0700           M=1                                                                  1474
0701          GO TO 51479                                                               
0702    51480  M= M+(1)                                                                 
0703          IF ( M.GT.NUMCOM)GO TO 51481                                              
0704    51479 CONTINUE                                                                  
0705          IF (DEFS(1,K,ISYM) .NE. M)GO TO 51500                                 1475
0706                LINE(L:) = COMAND(M)                                            1476
0707                L = L + 2                                                       1477
0708          GO TO 51481                                                           1478
0709    51500 CONTINUE                                                              1479
0710          GO TO 51480                                                           1480
0711    51481 CONTINUE                                                                  
0712          GO TO 51340                                                           1481
0713    51341 CONTINUE                                                                  
0714    C                                                                               
0715    C***   Output line                                                              
0716    C                                                                               
0717            M = 1                                                               1485
0718            L = L - 1                                                           1486
0719    51509 CONTINUE                                                              1487
0720          IF ((L - M) .GE. IABS(LENLMT))GO TO 51530                             1488
0721               CALL LIB$PUT_OUTPUT(LINE(M:L-1))                                 1489
0722          GO TO 51511                                                           1490
0723    51530 CONTINUE                                                              1491
0724               CALL LIB$PUT_OUTPUT(LINE(M:M+IABS(LENLMT)-1))                    1492
0725             M = M + IABS(LENLMT)                                               1494
0726          GO TO 51509                                                           1495
0727    51511 CONTINUE                                                                  
0728          GO TO KKK030                                                          1496
0729          END                                                                   1497

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  35
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                 4101   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                 326   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                1972   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 BRDCM1                                2582   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 BRDCM2                                  43   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 CHARS                                79510   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  7 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  8 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               286197


ENTRY POINTS

    Address  Type  Name          

  0-00000000       COMLVL        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  2-000004B3  CHAR BOX             4-00000028  I*2  BRDCNT          4-0000002A  L*1  BRDFLG          3-00000000  CHAR BRDNOT        
 AP-00000004@ CHAR CLINE           6-00000042  I*2  COMLIN          5-0001368C  CHAR CRLF            2-00000487  CHAR DEFINE        
  6-00000009  I*2  DIRECT         AP-00000008@ L*1  DONE            6-0000000B  I*4  EBK             2-00000498  CHAR EXIT          
  2-0000049C  CHAR HELP            2-000004CC  I*4  I               2-000004F0  I*4  II              2-00000447  CHAR IMAGE         
  6-00000000  I*4  INCHAN          7-00000000  CHAR INLINE          2-000004E4  I*4  ISYM            2-000004C8  I*4  J             
  2-00000500  I*4  JJ              2-000004DC  I*4  K               2-000004F8  I*4  KK              2-000004C0  I*4  KKK022        
  2-000004D0  I*4  KKK024          2-000004D4  I*4  KKK026          2-000004D8  I*4  KKK028          2-000004E8  I*4  KKK030        
  2-000004EC  I*4  KKK032          2-000004E0  I*4  L               2-000004C4  I*4  LENGTH          6-0000003A  I*2  LENLMT        
  8-00000000  I*2  LENSAV          2-00000047  CHAR LINE            2-000004FC  I*4  LL              6-00000036  I*4  LRL           
  2-000004F4  I*4  M               2-0000048D  CHAR NARROW          8-00003392  I*4  NDEFS           2-000004B6  L*1  NO            
  2-000004BC  I*4  NUMALL          2-000004B8  I*4  NUMCOM          2-000004B7  L*1  OKFLAG          6-0000003C  I*4  PAGEND        
  6-00000040  I*2  PAGLEN          2-000004AC  CHAR READ            6-00000023  I*2  RECBLK          5-00013692  CHAR REGVID        
  5-0001368E  CHAR REVVID          6-00000008  L*1  SBFFLG          2-000004B0  CHAR SET             2-000004A0  CHAR SHOW          
  2-00000493  CHAR SPAWN           6-00000004  I*4  TIME            6-00000035  L*1  VT100           6-00000044  L*1  VT100A        
  2-000004A8  CHAR WIDE            2-000004A4  CHAR WRAP          


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  2-0000001D  CHAR ALLSYM                 42  (42)
  4-00000000  I*2  BRDLEN                 40  (20)
  3-00000016  CHAR BRDMSG               2560  (20)
  2-00000010  CHAR COMAND                 13  (13)
  7-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  8-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  8-00000002  I*2  DEFS                13200  (11, 10, 60)
  2-00000000  I*4  GETLIS                 16  (4)

COMLVL                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  36
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  5-00000000  CHAR LINES               79200  (600)
  8-00003A9E  R*4  NUMDEF               2400  (10, 60)
  6-00000025  I*4  RANGE                  16  (2, 2)
  6-0000000F  I*2  SBFLEN                 20  (10)
  5-00013560  CHAR SRCHBF                300  (10)
  7-00000080  CHAR SYMS                   60  (60)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  0-0000098F  700           **      900       1-00000059  1000'     0-00000026  50020     0-00000026  50030     0-0000002E  50039   
  0-0000006F  50041     0-000009EB  50060     0-000002B1  50080     0-000002B1  50100     0-0000013E  50120     0-0000013E  50130   
  0-00000191  50150     0-00000191  50170     0-000001CB  50190     0-000001CB  50210     0-000001C0  50220     0-000001B4  50230   
  0-000001CB  50240     0-00000264  50260     0-0000022A  50280     0-0000021F  50290     0-00000203  50300     0-0000022A  50310   
  0-00000264  50330     0-00000259  50340     0-0000024E  50350     0-0000024C  50360     0-00000259  50370     0-00000264  50380   
  0-000002A6  50400     0-000002A6  50420     0-0000029B  50430     0-00000290  50440     0-0000028E  50450     0-0000029B  50460   
  0-000002A6  50470     0-000002B1  50480     0-00000820  50500     0-000002CB  50520     0-00000564  50540     0-00000346  50560   
  0-00000346  50570     0-0000031F  50580     0-0000035F  50600     0-000004CF  50610     0-000003C9  50620     0-000004CF  50630   
  0-00000427  50640     0-000004CF  50650     0-00000484  50660     0-000004CF  50670     0-000004B5  50680     0-00000550  50690   
  0-000004F8  50700     0-00000564  50710     0-00000657  50730     0-000005BA  50750     0-000005BA  50760     0-00000657  50770   
  0-000005F5  50780         **      50790     0-000005E1  50800     0-000005F3  50810         **      50820     0-00000645  50840   
  0-0000063A  50850     0-00000645  50860     0-00000657  50870     0-00000820  50890     0-0000080F  50900     0-000006AE  50910   
  0-000006F2  50920     0-000006EE  50930         **      50940     0-0000070E  50949     0-00000782  50951     0-00000809  50960   
  0-00000800  50970     0-00000820  50980     0-00000852  51000     0-00000852  51020     0-00000852  51030     0-00000961  51050   
  0-00000961  51070     0-0000089E  51090     0-0000089E  51100     0-00000914  51120     0-00000914  51130         **      51140   
  0-00000961  51150     0-00000956  51160     0-00000949  51170     0-00000954  51180     0-00000961  51190     0-000009E0  51210   
  0-000009D5  51220     0-000009E0  51230     0-000009EB  51240     0-00000A30  51251     0-00000A02  51259     0-000009F5  51260   
  0-00000A14  51261     0-00000A78  51280     0-00000A78  51290     0-00000B01  51310     0-00000B3E  51330     0-00000B7E  51339   
  0-00000B72  51340     0-00000F6B  51341     0-00000C55  51360     0-00000C86  51380     0-00000CAF  51400     0-00000F1B  51420   
  0-00000F18  51430     0-00000EFA  51440     0-00000D31  51449     0-00000D91  51451     0-00000DC4  51459     0-00000DB8  51460   
  0-00000EDE  51461     0-00000E5A  51469     0-00000EBA  51471     0-00000F2A  51479     0-00000F21  51480     0-00000F68  51481   
  0-00000F66  51500     0-00000F72  51509     0-00000FFA  51511     0-00000FB1  51530     0-00000A83  79802     0-00000ACB  79804   
  0-00000ACF  79806     0-00000B0C  79808     0-00000B49  79810     0-000009EF  79812   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        CLRWRP                                  DODEF                                   FOR$OPEN                        
   L*4  GETDEF                                  LBR$CLOSE                               LBR$GET_HELP                    
        LBR$INI_CONTROL                    I*4  LBR$OPEN                                LIB$GET_INPUT                   
   I*4  LIB$INDEX                               LIB$PUT_OUTPUT                     I*4  LIB$SKPC                        
        SETNAR                                  SETWID                                  SETWRP                          
        STR$TRANSLATE                           STR$TRIM                                STR$UPCASE                      
        SYS$GETJPI                         I*4  TTSPAWN                         

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  37
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE DODEF                                                      1498
0002    CDM   This routine processes the file open on unit 30 as a "symbol" file.       
0003    CDM                                                                             
0004    CDM   Programmer - Jon Vavrus  15 JUL 1982                                      
0005    CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
0006    CDM   Revised    - Jon Vavrus  17 AUG 1983 (GETDEF changed)                     
0007    CDM   Revised    - Jon Vavrus  21 SEP 1983                                      
0008    CM                                                                              
0009    CM         The routine reads unit 30.  Each line is tested for:                 
0010    CM              s :=     which is taken as a symbol definition                  
0011    CM              {    }   which is taken as a "command" level command line       
0012    CM              or anything else which is taken as a command line.              
0013    C                                                                               
0014    C***   COMMON AREAS                                                             
0015    C                                                                               
0016    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0017    CS            symbols SYMS and the definition search buffers DEFBUF             
0018    C                                                                               
0019    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0020    CS            symbol definitions DEFS, the number of such definitions           
0021    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0022    CS            numbers NUMDEF                                                    
0023    C                                                                               
0024    C***   CALLED ROUTINES                                                          
0025    C                                                                               
0026    CC    DOIT    Executes a command.                                               
0027    CC    GETDEF  Translates a line into a symbol definition                        
0028    CC    PRSCOM  Parses a command line                                             
0029    C                                                                               
0030          CHARACTER*1024 LINE                                                   1527
0031          CHARACTER*128 INLINE                                                  1528
0032          CHARACTER*30 DEFBUF(10,10,60)                                         1529
0033          CHARACTER*1 SYMS(60)                                                  1530
0034          REAL*4 NUMDEF(10,60)                                                  1531
0035          INTEGER*2 DEFS(11,10,60),LENSAV                                       1532
0036          LOGICAL GETDEF                                                        1533
0037          LOGICAL*1 DEFFLG(3,10,60)                                             1534
0038                                                                                1535
0039          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                     1536
0040          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                        1537
0041                                                                                1538
0042      600 CONTINUE                                                              1539
0043    50009 CONTINUE                                                                  
0044           READ (30,700,END=800)LINE                                            1540
0045    700    FORMAT (A)                                                           1541
0046          GO TO 50020                                                           1542
0047      800 CONTINUE                                                              1543
0048          GO TO 50011                                                           1544
0049    50020 CONTINUE                                                              1545
0050           CALL STR$UPCASE(LINE,LINE)                                           1546
0051           CALL STR$TRANSLATE(LINE,LINE,' ','	')                                1547
0052           CALL STR$TRIM(LINE,LINE,LENBUF)                                      1548
0053           I = INDEX(LINE(:LENBUF),':=') - 1                                    1549
0054           J = INDEX(LINE(:LENBUF),'"') - 1                                     1550
0055           K = INDEX(LINE(:LENBUF),'''') - 1                                    1551
0056          IF (.NOT.(I .LT. 1 .OR. (J .LT. I .AND. J .GE. 0) .OR. (K .LT. I .    1552
0057         XAND.      K .GE. 0)))GO TO 50040                                          

DODEF                          					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  38
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    C                                                                               
0059    C***   If no := then it must be a command line, or a " in front of :=           
0060    C***   (this must mean a command line with a search, or the user screwed up)    
0061    C                                                                               
0062    C---   First test for { }                                                       
0063    C                                                                               
0064             I = INDEX(LINE(:LENBUF),'{') + 1                                   1560
0065          IF (.NOT.(I .EQ. 1 .OR. (J .LT. I .AND. J .GE. 0)))GO TO 50060        1561
0066    50069 CONTINUE                                                              1562
0067                CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,0,0)           1563
0068          IF (ICOM .EQ. 0)GO TO 50071                                           1564
0069                CALL DOIT(ICOM,NUMFLG,ANUMB,MINFLG)                             1565
0070          GO TO 50069                                                           1566
0071    50071 CONTINUE                                                                  
0072          GO TO 50050                                                           1567
0073    50060 CONTINUE                                                                  
0074          DO 50080  J=LENBUF,I,-1                                               1568
0075          IF (LINE(J:J) .EQ. '}')GO TO 50081                                    1569
0076    50080 CONTINUE                                                              1570
0077    50081 CONTINUE                                                                  
0078          IF (J .LE. I)GO TO 50100                                              1571
0079                 CALL COMLVL(LINE(I:J-1),I)                                     1572
0080                 CALL DOIT(-1,.TRUE.,0.,.FALSE.)                                1573
0081                 CALL DOIT(-12,.FALSE.,0.,.FALSE.)                              1574
0082    50100 CONTINUE                                                              1575
0083    50050 CONTINUE                                                              1576
0084          GO TO 50030                                                           1577
0085    50040 CONTINUE                                                                  
0086    50109 CONTINUE                                                              1578
0087    C                                                                               
0088    C***   Take care of continuations                                               
0089    C                                                                               
0090          IF (LINE(LENBUF:LENBUF) .NE. '-')GO TO 50111                          1582
0091              READ (30,700,END=800)LINE(LENBUF:)                                1583
0092              CALL STR$UPCASE(LINE,LINE)                                        1584
0093              CALL STR$TRANSLATE(LINE,LINE,' ','	')                             1585
0094              CALL STR$TRIM(LINE,LINE,LENBUF)                                   1586
0095          GO TO 50109                                                           1587
0096    50111 CONTINUE                                                                  
0097             J = LIB$SKPC(' ',LINE(:LENBUF))                                    1588
0098    C                                                                               
0099    C***   See if symbol is already defined                                         
0100    C                                                                               
0101      900 CONTINUE                                                              1592
0102          DO 50130  II=1,NDEFS                                                  1593
0103          IF (SYMS(II) .EQ. LINE(J:J))GO TO 50121                               1594
0104    50130 CONTINUE                                                              1595
0105              NDEFS = NDEFS + 1                                                 1596
0106              II = NDEFS                                                        1597
0107              SYMS(II) = LINE(J:J)                                              1598
0108    50121 CONTINUE                                                              1599
0109             LINE = LINE(I+3:)                                                  1600
0110             LENBUF = LENBUF - I - 2                                            1601
0111    C                                                                               
0112    C***   Actually get definitions                                                 
0113    C                                                                               
0114          IF (.NOT.GETDEF(LINE(:LENBUF),II))GO TO 50010                         1605

DODEF                          					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  39
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115    50030 CONTINUE                                                              1606
0116    50010 GO TO 50009                                                           1607
0117    50011 CONTINUE                                                                  
0118    C                                                                               
0119    C***   Close the symbol file                                                    
0120    C                                                                               
0121          CLOSE (UNIT=30)                                                       1611
0122          RETURN                                                                1612
0123          END                                                                   1613




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  676   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                  39   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                1380   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               199689


ENTRY POINTS

    Address  Type  Name          

  0-00000000       DODEF         


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  2-00000418  R*4  ANUMB           2-00000404  I*4  I               2-00000410  I*4  ICOM            2-00000420  I*4  II            
  3-00000000  CHAR INLINE          2-00000408  I*4  J               2-0000040C  I*4  K               2-00000400  I*4  LENBUF        
  4-00000000  I*2  LENSAV          2-00000000  CHAR LINE            2-0000041C  I*4  MINFLG          4-00003392  I*4  NDEFS         
  2-00000414  I*4  NUMFLG        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  3-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  4-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  4-00000002  I*2  DEFS                13200  (11, 10, 60)
  4-00003A9E  R*4  NUMDEF               2400  (10, 60)
  3-00000080  CHAR SYMS                   60  (60)

DODEF                          					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  40
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

      **      600       1-00000025  700'      0-00000033  800           **      900       0-00000009  50009     0-00000297  50010   
  0-0000029A  50011     0-00000036  50020     0-00000297  50030     0-00000174  50040     0-00000171  50050     0-00000101  50060   
  0-000000E6  50069     0-000000FF  50071         **      50080     0-00000137  50081     0-00000171  50100     0-00000174  50109   
  0-000001E3  50111     0-0000025E  50121         **      50130   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name            Type  Name            Type  Name            Type  Name            Type  Name            Type  Name          

        COMLVL                DOIT                  FOR$CLOSE        L*4  GETDEF           I*4  LIB$INDEX        I*4  LIB$SKPC      
        PRSCOM                STR$TRANSLATE         STR$TRIM              STR$UPCASE    

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  41
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE DOIT(COMAND,NUMFLG,TANUMB,MINFLG)                          1614
0002    CDM   This subroutine executes the commands passed by the main program or       
0003    CDM   rings the terminal bell and turns LED 3 on (error signal) if the          
0004    CDM   command is invalid.                                                       
0005    CDM                                                                             
0006    CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
0007    CDM   Revised    - Jon Vavrus  30 MAR 1981                                      
0008    CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
0009    CDM   Revised    - Jon Vavrus  21 JUL 1981                                      
0010    CDM   Revised    - Jon Vavrus  31 JUL 1981 (change CCLINE usage)                
0011    CDM   Revised    - Jon Vavrus  27 AUG 1981                                      
0012    CDM   Revised    - Jon Vavrus  10 SEP 1981                                      
0013    CDM   Revised    - Jon Vavrus  23 SEP 1981                                      
0014    CDM   Revised    - Jon Vavrus   6 NOV 1981                                      
0015    CDM   Revised    - Jon Vavrus  30 DEC 1981 (make LED's work right)              
0016    CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
0017    CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
0018    CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
0019    CDM   Revised    - Jon Vavrus  30 NOV 1982                                      
0020    CDM   Revised    - Jon Vavrus  12 JAN 1983                                      
0021    CDM   Revised    - Jon Vavrus   4 APR 1983 (Take care of "Quitting")            
0022    CM                                                                              
0023    CM         The routine is called with the numeric code for the command          
0024    CM    (COMAND) which if negative, means that it is not to be "saved" for        
0025    CM    possible command #13 execution; a flag set .TRUE. if there is an          
0026    CM    associated number (NUMFLG); a number (TANUMB); and a flag set             
0027    CM    .TRUE. if there is an associated minus sign.                              
0028    CM                                                                              
0029    CM         For VT100's the given command is executed after which LED 1 is       
0030    CM    turned off (indicating operation finished), LED 3 is turned off           
0031    CM    if successful and on if not (error indication), LED 2 is turned           
0032    CM    on if the reverse option is currently set or off if not (reverse          
0033    CM    indicator), and LED 4 is turned on if the search buffer now contains      
0034    CM    something (buffer indicator).                                             
0035    CM                                                                              
0036    CM         The valid commands types are:                                        
0037    CM              1 - jump TANUMB lines (positive or negative)                    
0038    CM              2 - jump by TANUMB blocks (positive or negative)                
0039    CM              3 - search (forward) for string(s) in SRCHBF array and          
0040    CM                  display from that line if found, if not found the           
0041    CM                  terminal bell is rung and LED 3 is turned on.  Matches      
0042    CM                  are found regardless of lower/uppercase differences.        
0043    CM                  Search backward if MINFLG = .TRUE..  Repeat TANUMB          
0044    CM                  times if NUMFLG = .TRUE..                                   
0045    CM              4 - set reverse switch, all commands will now work in re-       
0046    CM                  verse (i.e. n$ will jump -n lines, etc.).  Repeat           
0047    CM                  TANUMB times if NUMFLG = .TRUE..                            
0048    CM              5 - scroll (backwards if MINFLG = .TRUE.)                       
0049    CM              6 - stop scrolling or cancel current line jump, search,         
0050    CM                  or & command.                                               
0051    CM              7 - set scrolling speed to TANUMB lines per second (positive    
0052    CM                  or negative) (originally set to 2).                         
0053    CM                  NOTE:  there is a maximum speed that will not be ex-        
0054    CM                  ceeded (varies with situation) even if scrolling            
0055    CM                  speed is set at a high value.                               
0056    CM              8 - mark the TANUMB line form the top of the screen as one      
0057    CM                  of the boundaries of the print range.  The last two so      

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  42
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    CM                  marked lines define the print range.                        
0059    CM              9 - output TANUMB lines to the file LOOKPRINT.LIS in the        
0060    CM                  default directory (file format will be the same as the      
0061    CM                  original file, with sequential organization).  Creates      
0062    CM                  a new file.  If no number is specified (or is zero)         
0063    CM                  and there is a valid print range marked, then that          
0064    CM                  range will be output, if no valid print range then          
0065    CM                  23 lines are output.                                        
0066    CM             10 - same as 9 except the lines are output to SYS$PRINT.         
0067    CM                  If MINFLG = .TRUE. then output goes to LOOKPRINT.LIS        
0068    CM                  file (new file if no previous command created one           
0069    CM                  during this job, otherwise appended to the end of the       
0070    CM                  existing file).                                             
0071    CM             11 - exit the program.                                           
0072    CM             12 - re-write the screen                                         
0073    CM             13 - re-execute the last command that was passed to DOIT         
0074    CM                  with a positive value (except for 13)                       
0075    C                                                                               
0076    C***   CALLED ROUTINES                                                          
0077    C                                                                               
0078    CC    BLKCLS  Closes the input file.                                            
0079    CC    BLKIN   Reads in one block of data.                                       
0080    CC    BLKSIN  Reads in 7 blocks of data.                                        
0081    CC    CONVUP  Converts a string to upper-case.                                  
0082    CC    INTASC  Converts a given character variable to upper-case.                
0083    CC    LINCON  Converts data to output lines in the output arrays.               
0084    CC    PRTCLS  Closes the printer output file used in & commands.                
0085    CC    PRTOPN  Opens the printer output file.                                    
0086    CC    PRTOUT  Outputs a record to the printer output file.                      
0087    CC    REDOIT  Calls DOIT, allows for recursion.                                 
0088    CC    STOPSC  AST routine to cause "stop" command to work.                      
0089    CC    WORKNG  Writes flashing "WORKING" message.                                
0090    C                                                                               
0091    C***   COMMON AREAS                                                             
0092    C                                                                               
0093    CS    CHARS   Used to pass character variables; contains LINES a character      
0094    CS            array of the output lines, and SRCHBF the search buffer, and      
0095    CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
0096    CS            the VT100 control sequences to set/unset reverse video.           
0097    C                                                                               
0098    CS    DOITNM  Contains information transferred from the main program:           
0099    CS                 INCHAN - input channel of the terminal                       
0100    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0101    CS                 SBFFLG - flag indicating whether there is a string           
0102    CS                          in the search buffer                                
0103    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0104    CS                 EBK    - EBK of input file                                   
0105    CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
0106    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0107    CS                 RANGE  - starting and ending block numbers and pointers      
0108    CS                          of print range                                      
0109    CS                 VT100  - flag set .TRUE. if terminal is a VT100              
0110    CS                 LRL    - length of longest record in input file              
0111    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0112    CS                 PAGEND - line number of last line output to screen.          
0113    CS                 PAGLEN - number of lines per page                            
0114    CS                 COMLIN - line number for command input (bottom of screen)    

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  43
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0116    C                                                                               
0117    CS    LNCN    Contains output arrays, and file pointers and information:        
0118    CS                 LINLEN - array of output line lengths                        
0119    CS                 LINEP  - top of screen line (or last line output by          
0120    CS                          backward scroll)                                    
0121    CS                 NLINES - number of lines in arrays                           
0122    CS                 BUFFER - array of unconverted data                           
0123    CS                 PBUF   - current position in BUFFER                          
0124    CS                 NBUF   - number of bytes in BUFFER                           
0125    CS                 BLK    - next block in file                                  
0126    CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
0127    CS                 IFSZ   - word extended record length for FIX files           
0128    CS                 RFM    - files RFM                                           
0129    CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
0130    CS                 SBLK   - starting block of current batch of output lines     
0131    CS                 CCLINE - array containing pointer to where the line's        
0132    CS                          record starts in the file (CCLINE(1,x) = block      
0133    CS                          #, CCLINE(2,x) = byte number in block).  If         
0134    CS                          CCLINE(1,x) = 0 then it is a carriage control       
0135    CS                          line.                                               
0136    CS                 LBLK   - last block processed by LINCON                      
0137    CS                 LPBUF  - last value of PBUF processed by LINCON              
0138    C                                                                               
0139    CS    STOPCM  Used to pass information back and forth to/from the stop          
0140    CS            scrolling AST.  STOPIT is a flag set .TRUE. if scrolling          
0141    CS            should be stopped, INBUF is the input character, IOFLAG and       
0142    CS            TIMFLG are event flags, and IOSB is the I/O IOSB.                 
0143    C                                                                               
0144    C***   INPUT VARIABLES                                                          
0145    C                                                                               
0146    CI    INBUF   One byte buffer used to get stop scrolling command.               
0147    C                                                                               
0148    C***   OUTPUT VARIABLES                                                         
0149    C                                                                               
0150    CO    BUFFER  Buffer holding input data.  During back scrolling output          
0151    CO            is done directly from here.                                       
0152    CO    ESC     Used to output an ASCII <ESC>.                                    
0153    CO    LINES   Lines of output converted by LINCON.                              
0154    C                                                                               
0155    C***   INPUT UNITS                                                              
0156    C                                                                               
0157    CR    INCHAN  Channel number of the terminal.                                   
0158    C                                                                               
0159    C***   OUTPUT UNITS                                                             
0160    C                                                                               
0161    CW    9       Output to the terminal (no carriage-control).                     
0162    CW    20      Output for the List, Print, and Append commands                   
0163    C                                                                               
0164          EXTERNAL STOPSC                                                       1777
0165          CHARACTER*132 LINES(600),HLIN(600),CAPLIN                             1778
0166          CHARACTER*33 CHAR                                                     1779
0167          CHARACTER*30 SRCHBF(10)                                               1780
0168          CHARACTER*5 TEMPCH                                                    1781
0169          CHARACTER*4 REVVID,REGVID                                             1782
0170          CHARACTER*2 CRLF                                                      1783
0171          INTEGER*4 TIME,BLK,PBUF,EBK,HNBUF,HPBUF,FSZ,RFM,RAT,TIMFLG,           1784

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  44
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0172         1          DELTIM(2),SBLK,PAUSTM(2),PRINT,HBLK,HSBLK,                      
0173         2          RANGE(2,2),CCLINE(2,600),HLBLK,HLPBUF,HCCLIN(2,600),            
0174         3          PAGEND,OLDEND,SAVCOM,IDESCR(2),STRPOS(10)                       
0175          INTEGER*2 IOSB(4),LINLEN(600),HLINLN(600),HLINES,HLINEP,DIRECT,       1788
0176         1          SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMAND,COMLIN                   
0177          LOGICAL*1 SBFFLG,INBUF,BUFFER(3750),FIRST,NUMFLG,MINFLG,              1790
0178         1          HBUFER(150),STOPIT,ESC,TEMP(30),CAPBUF(3750),VT100,             
0179         2          BELL,BSP,RFLAG,SECOND,SAVFLG(2),VT100A                          
0180                                                                                1793
0181          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     1794
0182         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0183          COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,       1796
0184         1             RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                               
0185          COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                         1798
0186          COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                        1799
0187                                                                                1800
0188          DATA ESC,BELL,BSP/27,7,8/                                             1801
0189          DATA DELTIM(2)/-1/                                                    1802
0190          DATA PAUSTM/-30000000,-1/                                             1803
0191          DATA OPNFIL/.FALSE./                                                  1804
0192                                                                                1805
0193          ANUMB = TANUMB                                                        1806
0194    C                                                                               
0195    C***   Turn LED #1 on                                                           
0196    C                                                                               
0197          IF (COMAND .EQ. 13)GO TO 50020                                        1810
0198    C     EXECUTE (WORKING)                                                     1811
0199          ASSIGN 50030 TO KKK022                                                1811
0200          GO TO 79802                                                               
0201    50030 CONTINUE                                                                  
0202    50020 CONTINUE                                                              1812
0203    C                                                                               
0204    C***   Save command                                                             
0205    C                                                                               
0206          IF (COMAND .GE. 0)GO TO 50050                                         1816
0207            ICOM = -COMAND                                                      1817
0208          GO TO 50040                                                           1818
0209    50050 CONTINUE                                                                  
0210          IF (COMAND .EQ. 13)GO TO 50070                                        1819
0211              SAVFLG(1) = NUMFLG                                                1820
0212              SAVFLG(2) = MINFLG                                                1821
0213              SAVCOM = COMAND                                                   1822
0214              SAVNUM = TANUMB                                                   1823
0215    50070 CONTINUE                                                              1824
0216            ICOM = COMAND                                                       1825
0217    50040 CONTINUE                                                              1826
0218          GO TO 50080                                                           1827
0219    50090 CONTINUE                                                              1828
0220    C                                                                               
0221    C***   Line jump                                                                
0222    C                                                                               
0223            NUMBER = ANUMB*DIRECT                                               1832
0224          IF (NUMFLG)GO TO 50110                                                1833
0225    C     EXECUTE (ERROR_EXIT)                                                  1834
0226          ASSIGN 50120 TO KKK024                                                1834
0227          GO TO 79804                                                               
0228    50120 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  45
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0229    50110 CONTINUE                                                              1835
0230    C     EXECUTE (HOLD_CURRENT_SETUP)                                          1836
0231          ASSIGN 50130 TO KKK026                                                1836
0232          GO TO 79806                                                               
0233    50130 CONTINUE                                                                  
0234    C                                                                               
0235    C***   Execute line jumps                                                       
0236    C                                                                               
0237    C     EXECUTE (JUMP_LINES)                                                  1840
0238          ASSIGN 50140 TO KKK028                                                1840
0239          GO TO 79808                                                               
0240    50140 CONTINUE                                                                  
0241    C     EXECUTE (GET_LAST_LINE)                                               1841
0242          ASSIGN 50150 TO KKK030                                                1841
0243          GO TO 79810                                                               
0244    50150 CONTINUE                                                                  
0245    C     EXECUTE (CANCEL_STOPPER)                                              1842
0246          ASSIGN 50160 TO KKK032                                                1842
0247          GO TO 79812                                                               
0248    50160 CONTINUE                                                                  
0249          IF (IABS(NUMBER) .GT. PAGLEN)GO TO 50180                              1843
0250    C     EXECUTE (SCROLL_REFRESH_EXIT)                                         1844
0251          ASSIGN 50190 TO KKK034                                                1844
0252          GO TO 79814                                                               
0253    50190 CONTINUE                                                                  
0254          GO TO 50170                                                           1845
0255    50180 CONTINUE                                                                  
0256    C     EXECUTE (REFRESH_EXIT)                                                1846
0257          ASSIGN 50200 TO KKK036                                                1846
0258          GO TO 79816                                                               
0259    50200 CONTINUE                                                                  
0260    50170 CONTINUE                                                              1847
0261          GO TO 50081                                                           1848
0262    50210 CONTINUE                                                                  
0263    C                                                                               
0264    C***   Block jumps                                                              
0265    C                                                                               
0266          IF (NUMFLG)GO TO 50230                                                1852
0267    C     EXECUTE (ERROR_EXIT)                                                  1853
0268          ASSIGN 50240 TO KKK024                                                1853
0269          GO TO 79804                                                               
0270    50240 CONTINUE                                                                  
0271    50230 CONTINUE                                                              1854
0272    C     EXECUTE (FIND_NON_CC_LINE)                                            1855
0273          ASSIGN 50250 TO KKK038                                                1855
0274          GO TO 79818                                                               
0275    50250 CONTINUE                                                                  
0276            BLK = CCLINE(1,I) + ANUMB*DIRECT                                    1856
0277            IF (BLK .LE. 0) BLK = 1                                             1857
0278            IF (BLK .GT. EBK) BLK = EBK                                         1858
0279            IBLK = BLK                                                          1859
0280    C     EXECUTE (INPUT_SEVEN_BLOCKS)                                          1860
0281          ASSIGN 50260 TO KKK040                                                1860
0282          GO TO 79820                                                               
0283    50260 CONTINUE                                                                  
0284            CALL LINCON(.TRUE.)                                                 1861
0285    C                                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  46
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0286    C***   If input was at end of file, must find line position                     
0287    C                                                                               
0288          IF (BLK .LE. EBK)GO TO 50280                                          1865
0289          DO 50290  LINEP=1,NLINES                                              1866
0290          IF (CCLINE(1,LINEP) .EQ. IBLK)GO TO 50291                             1867
0291    50290 CONTINUE                                                              1868
0292    50291 CONTINUE                                                                  
0293          IF (NLINES .GE. (LINEP + PAGLEN - 1))GO TO 50310                      1869
0294                LINEP = NLINES - PAGLEN + 1                                     1870
0295                IF (LINEP .LE. 0) LINEP = 1                                     1871
0296    50310 CONTINUE                                                              1872
0297    50280 CONTINUE                                                              1873
0298    C     EXECUTE (GET_LAST_LINE)                                               1874
0299          ASSIGN 50320 TO KKK030                                                1874
0300          GO TO 79810                                                               
0301    50320 CONTINUE                                                                  
0302    C     EXECUTE (REFRESH_EXIT)                                                1875
0303          ASSIGN 50330 TO KKK036                                                1875
0304          GO TO 79816                                                               
0305    50330 CONTINUE                                                                  
0306          GO TO 50081                                                           1876
0307    50340 CONTINUE                                                                  
0308    C                                                                               
0309    C***   Searches                                                                 
0310    C                                                                               
0311          IF (SBFFLG)GO TO 50360                                                1880
0312    C     EXECUTE (ERROR_EXIT)                                                  1881
0313          ASSIGN 50370 TO KKK024                                                1881
0314          GO TO 79804                                                               
0315    50370 CONTINUE                                                                  
0316    50360 CONTINUE                                                              1882
0317    C                                                                               
0318    C***   Loop ANUMB times                                                         
0319    C                                                                               
0320          IF (.NOT.(NUMFLG))GO TO 50390                                         1886
0321              NUMBER = ANUMB                                                    1887
0322          GO TO 50380                                                           1888
0323    50390 CONTINUE                                                                  
0324              NUMBER = 1                                                        1889
0325    50380 CONTINUE                                                              1890
0326          DO 50400  III=1,NUMBER                                                1891
0327          IF (.NOT.(MINFLG))GO TO 50420                                         1892
0328          IF (DIRECT .NE. -1)GO TO 50440                                        1893
0329    C     EXECUTE (FORWARD_SEARCH)                                              1894
0330          ASSIGN 50450 TO KKK042                                                1894
0331          GO TO 79822                                                               
0332    50450 CONTINUE                                                                  
0333          GO TO 50430                                                           1895
0334    50440 CONTINUE                                                                  
0335    C     EXECUTE (BACKWARD_SEARCH)                                             1896
0336          ASSIGN 50460 TO KKK044                                                1896
0337          GO TO 79824                                                               
0338    50460 CONTINUE                                                                  
0339    50430 CONTINUE                                                              1897
0340          GO TO 50410                                                           1898
0341    50420 CONTINUE                                                                  
0342          IF (DIRECT .NE. -1)GO TO 50480                                        1899

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  47
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0343    C     EXECUTE (BACKWARD_SEARCH)                                             1900
0344          ASSIGN 50490 TO KKK044                                                1900
0345          GO TO 79824                                                               
0346    50490 CONTINUE                                                                  
0347          GO TO 50470                                                           1901
0348    50480 CONTINUE                                                                  
0349    C     EXECUTE (FORWARD_SEARCH)                                              1902
0350          ASSIGN 50500 TO KKK042                                                1902
0351          GO TO 79822                                                               
0352    50500 CONTINUE                                                                  
0353    50470 CONTINUE                                                              1903
0354    50410 CONTINUE                                                              1904
0355    50400 CONTINUE                                                              1905
0356          GO TO 50081                                                           1906
0357    50510 CONTINUE                                                                  
0358    C                                                                               
0359    C***   Reversing operation                                                      
0360    C                                                                               
0361            IF (MINFLG) DIRECT = -DIRECT                                        1910
0362          IF (.NOT.(NUMFLG))GO TO 50530                                         1911
0363              NUMBER = ANUMB                                                    1912
0364              DIRECT = -1**NUMBER*DIRECT                                        1913
0365          GO TO 50520                                                           1914
0366    50530 CONTINUE                                                                  
0367              DIRECT = -DIRECT                                                  1915
0368    50520 CONTINUE                                                              1916
0369    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         1917
0370          ASSIGN 50540 TO KKK046                                                1917
0371          GO TO 79826                                                               
0372    50540 CONTINUE                                                                  
0373          GO TO 50081                                                           1918
0374    50550 CONTINUE                                                                  
0375    C                                                                               
0376    C***   Scrolling                                                                
0377    C                                                                               
0378            CALL WORKNG(.FALSE.)                                                1922
0379            IF (NUMFLG) TIME = (-10000000./ANUMB)*DIRECT                        1923
0380            CALL LIB$GET_EF(TIMFLG)                                             1924
0381          IF (TIMFLG .NE. -1)GO TO 50570                                        1925
0382              CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//       1926
0383         1            'flags.  SCROLLING ABORTED.',COMLIN,20)                       
0384    C     EXECUTE (ERROR_EXIT)                                                  1928
0385          ASSIGN 50580 TO KKK024                                                1928
0386          GO TO 79804                                                               
0387    50580 CONTINUE                                                                  
0388    50570 CONTINUE                                                              1929
0389    C     EXECUTE (QUEUE_STOPPER)                                               1930
0390          ASSIGN 50590 TO KKK048                                                1930
0391          GO TO 79828                                                               
0392    50590 CONTINUE                                                                  
0393            DELTIM(1) = TIME*DIRECT                                             1931
0394          IF (.NOT.((DELTIM(1) .LT. 0 .AND. .NOT.MINFLG) .OR. (DELTIM(1) .GT    1932
0395         X. 0       .AND. MINFLG)))GO TO 50610                                      
0396    C     EXECUTE (FORWARD_SCROLLING)                                           1934
0397          ASSIGN 50620 TO KKK050                                                1934
0398          GO TO 79830                                                               
0399    50620 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  48
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0400          GO TO 50600                                                           1935
0401    50610 CONTINUE                                                                  
0402    C     EXECUTE (BACKWARD_SCROLLING)                                          1936
0403          ASSIGN 50630 TO KKK052                                                1936
0404          GO TO 79832                                                               
0405    50630 CONTINUE                                                                  
0406    50600 CONTINUE                                                              1937
0407          GO TO 50081                                                           1938
0408    50640 CONTINUE                                                                  
0409    C                                                                               
0410    C***   Set scrolling speed                                                      
0411    C                                                                               
0412          IF (NUMFLG)GO TO 50660                                                1942
0413    C     EXECUTE (ERROR_EXIT)                                                  1943
0414          ASSIGN 50670 TO KKK024                                                1943
0415          GO TO 79804                                                               
0416    50670 CONTINUE                                                                  
0417    50660 CONTINUE                                                              1944
0418            TIME = (-10000000./ANUMB)*DIRECT                                    1945
0419    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         1946
0420          ASSIGN 50680 TO KKK046                                                1946
0421          GO TO 79826                                                               
0422    50680 CONTINUE                                                                  
0423          GO TO 50081                                                           1947
0424    50690 CONTINUE                                                                  
0425    C                                                                               
0426    C***   Mark command                                                             
0427    C                                                                               
0428          IF (.NOT.(NUMFLG))GO TO 50710                                         1951
0429              NUMBER = ANUMB*DIRECT                                             1952
0430          GO TO 50700                                                           1953
0431    50710 CONTINUE                                                                  
0432              NUMBER = 0                                                        1954
0433    50700 CONTINUE                                                              1955
0434    C     EXECUTE (HOLD_CURRENT_SETUP)                                          1956
0435          ASSIGN 50720 TO KKK026                                                1956
0436          GO TO 79806                                                               
0437    50720 CONTINUE                                                                  
0438    C                                                                               
0439    C***   Point to line we want                                                    
0440    C                                                                               
0441            JNUMB = 0                                                           1960
0442    C     EXECUTE (JUMP_LINES)                                                  1961
0443          ASSIGN 50730 TO KKK028                                                1961
0444          GO TO 79808                                                               
0445    50730 CONTINUE                                                                  
0446            LINEP = LINEP + JNUMB                                               1962
0447            IF (LINEP .GT. NLINES) LINEP = NLINES                               1963
0448          DO 50740  I=LINEP,NLINES                                              1964
0449          IF (CCLINE(1,I) .EQ. 0)GO TO 50760                                    1965
0450          IF (RANGE(1,1) .EQ. 0)GO TO 50780                                     1966
0451                 RANGE(1,2) = RANGE(1,1)                                        1967
0452                 RANGE(2,2) = RANGE(2,1)                                        1968
0453    50780 CONTINUE                                                              1969
0454               RANGE(1,1) = CCLINE(1,I)                                         1970
0455               RANGE(2,1) = CCLINE(2,I)                                         1971
0456          GO TO 50741                                                           1972

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  49
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0457    50760 CONTINUE                                                              1973
0458    50740 CONTINUE                                                              1974
0459    50741 CONTINUE                                                                  
0460    C     EXECUTE (CANCEL_STOPPER)                                              1975
0461          ASSIGN 50790 TO KKK032                                                1975
0462          GO TO 79812                                                               
0463    50790 CONTINUE                                                                  
0464    C     EXECUTE (RESTORE_HELD_SETUP)                                          1976
0465          ASSIGN 50800 TO KKK054                                                1976
0466          GO TO 79834                                                               
0467    50800 CONTINUE                                                                  
0468    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         1977
0469          ASSIGN 50810 TO KKK046                                                1977
0470          GO TO 79826                                                               
0471    50810 CONTINUE                                                                  
0472          GO TO 50081                                                           1978
0473    50820 CONTINUE                                                                  
0474    C                                                                               
0475    C***   Print, List, and Append commands                                         
0476    C                                                                               
0477            PRINT = 1                                                           1982
0478    C     EXECUTE (OUTPUT_RANGE)                                                1983
0479          ASSIGN 50830 TO KKK056                                                1983
0480          GO TO 79836                                                               
0481    50830 CONTINUE                                                                  
0482          GO TO 50081                                                           1984
0483    50840 CONTINUE                                                                  
0484          IF (.NOT.(MINFLG))GO TO 50860                                         1985
0485              PRINT = 0                                                         1986
0486          GO TO 50850                                                           1987
0487    50860 CONTINUE                                                                  
0488              PRINT = -1                                                        1988
0489    50850 CONTINUE                                                              1989
0490    C     EXECUTE (OUTPUT_RANGE)                                                1990
0491          ASSIGN 50870 TO KKK056                                                1990
0492          GO TO 79836                                                               
0493    50870 CONTINUE                                                                  
0494          GO TO 50081                                                           1991
0495    50880 CONTINUE                                                                  
0496    C                                                                               
0497    C***   Exit                                                                     
0498    C                                                                               
0499            CALL EXIT                                                           1995
0500          GO TO 50081                                                           1996
0501    50890 CONTINUE                                                                  
0502    C                                                                               
0503    C***   Re-write screen                                                          
0504    C                                                                               
0505    C     EXECUTE (REFRESH_EXIT)                                                2000
0506          ASSIGN 50900 TO KKK036                                                2000
0507          GO TO 79816                                                               
0508    50900 CONTINUE                                                                  
0509    C                                                                               
0510    C***   Repeat last command                                                      
0511    C                                                                               
0512          GO TO 50081                                                           2004
0513    50910 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  50
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0514          IF (.NOT.(NUMFLG))GO TO 50930                                         2005
0515              III = ANUMB                                                       2006
0516          GO TO 50920                                                           2007
0517    50930 CONTINUE                                                                  
0518              III = 1                                                           2008
0519    50920 CONTINUE                                                              2009
0520          DO 50940  IIII=1,III                                                  2010
0521             CALL REDOIT(SAVCOM,SAVFLG(1),SAVNUM,SAVFLG(2))                     2011
0522    50940 CONTINUE                                                              2012
0523          GO TO 50081                                                           2013
0524    50080 IF (ICOM.LT.1)GO TO 50081                                                 
0525          IF (ICOM.GT.13)GO TO 50081                                                
0526          GO TO (50090,50210,50340,50510,50550,50081,50640,50690,50820,50840        
0527         X,50880,50890,50910),ICOM                                                  
0528    50081 CONTINUE                                                                  
0529    C     EXECUTE (CANCEL_STOPPER)                                              2014
0530          ASSIGN 50950 TO KKK032                                                2014
0531          GO TO 79812                                                               
0532    50950 CONTINUE                                                                  
0533          CALL WORKNG(.FALSE.)                                                  2015
0534          RETURN                                                                2016
0535    C                                                                               
0536    C****************************************************************************** 
0537    C***********************   HERE FOLLOW THE PROCEDURES   *********************** 
0538    C****************************************************************************** 
0539    C                                                                               
0540    C                                                                               
0541    C                                                                               
0542    C.......................................................................        
0543    C     PROCEDURE (BACK_SCROLL_EXIT)                                          2022
0544    79838 CONTINUE                                                              2022
0545    CP    This routine exits from scrolling backward in FIX files.  It converts     
0546    CP    the data at the current position into output lines, frees the event       
0547    CP    event flags, resets the LEDs (#3 off) and returns.                        
0548            II = PBUF                                                           2026
0549            SBLK = BLK - 1                                                      2027
0550          IF (BLK .GT. EBK)GO TO 50970                                          2028
0551              CALL BLKIN(BLK,I,BUFFER(513))                                     2029
0552          IF (I .NE. 0)GO TO 50990                                              2030
0553    C     EXECUTE (READ_ERROR)                                                  2031
0554          ASSIGN 51000 TO KKK060                                                2031
0555          GO TO 79840                                                               
0556    51000 CONTINUE                                                                  
0557    50990 CONTINUE                                                              2032
0558              NBUF = 512 + I                                                    2033
0559    50970 CONTINUE                                                              2034
0560            CALL LINCON(.TRUE.)                                                 2035
0561           LINEP=1                                                              2036
0562          GO TO 51009                                                               
0563    51010  LINEP= LINEP+(1)                                                         
0564          IF ( LINEP.GT.NLINES)GO TO 51011                                          
0565    51009 CONTINUE                                                                  
0566          IF (CCLINE(1,LINEP) .EQ. SBLK .AND. CCLINE(2,LINEP).EQ.II)GO TO 51    2037
0567         X011                                                                       
0568          GO TO 51010                                                           2038
0569    51011 CONTINUE                                                                  
0570    C     EXECUTE (GET_LAST_LINE)                                               2039

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  51
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0571          ASSIGN 51020 TO KKK030                                                2039
0572          GO TO 79810                                                               
0573    51020 CONTINUE                                                                  
0574    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          2040
0575          ASSIGN 51030 TO KKK062                                                2040
0576          GO TO 79842                                                               
0577    51030 CONTINUE                                                                  
0578    C     EXECUTE (FREE_FLAGS_EXIT)                                             2041
0579          ASSIGN 51040 TO KKK064                                                2041
0580          GO TO 79844                                                               
0581    51040 CONTINUE                                                                  
0582            RETURN                                                              2042
0583    C                                                                               
0584    C                                                                               
0585    C.......................................................................        
0586    C     PROCEDURE (BACKWARD_SEARCH)                                           2044
0587    79824 CONTINUE                                                              2044
0588    CP    This procedure searches backward through the file for a string. IF        
0589    CP    found the position is located there, the screen refreshed and the         
0590    CP    LEDs reset (#3 off), otherwise the screen is left alone, the position     
0591    CP    is not changed, and the LEDs are reset (#3 on).  In either case the       
0592    CP    a return from DOIT is executed.                                           
0593    C                                                                               
0594    C***   First search lines in buffer                                             
0595    C                                                                               
0596     1650 CONTINUE                                                              2053
0597          IF (LINEP .EQ. 1)GO TO 51070                                          2054
0598           I=LINEP-1                                                            2055
0599          GO TO 51079                                                               
0600    51080  I= I+(-1)                                                                
0601          IF ( I.LT.1)GO TO 51081                                                   
0602    51079 CONTINUE                                                                  
0603                CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))              2056
0604           JJ=1                                                                 2057
0605          GO TO 51089                                                               
0606    51090  JJ= JJ+(1)                                                               
0607          IF ( JJ.GT.10)GO TO 51091                                                 
0608    51089 CONTINUE                                                                  
0609          IF (SBFLEN(JJ) .EQ. 0)GO TO 51091                                     2058
0610          IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ)))                 2059
0611         X    .EQ. 0)GO TO 51110                                                    
0612                   NUMBER = I - LINEP                                           2061
0613                   LINEP = I                                                    2062
0614    C     EXECUTE (GET_LAST_LINE)                                               2063
0615          ASSIGN 51120 TO KKK030                                                2063
0616          GO TO 79810                                                               
0617    51120 CONTINUE                                                                  
0618          IF (IABS(NUMBER) .LE. PAGLEN)GO TO 51140                              2064
0619    C     EXECUTE (REFRESH_EXIT)                                                2065
0620          ASSIGN 51150 TO KKK036                                                2065
0621          GO TO 79816                                                               
0622    51150 CONTINUE                                                                  
0623          GO TO 51130                                                           2066
0624    51140 CONTINUE                                                                  
0625    C     EXECUTE (SCROLL_REFRESH_EXIT)                                         2067
0626          ASSIGN 51160 TO KKK034                                                2067
0627          GO TO 79814                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  52
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0628    51160 CONTINUE                                                                  
0629    51130 CONTINUE                                                              2068
0630          GO TO 51051                                                           2069
0631    51110 CONTINUE                                                              2070
0632          GO TO 51090                                                           2071
0633    51091 CONTINUE                                                                  
0634          GO TO 51080                                                           2072
0635    51081 CONTINUE                                                                  
0636    51070 CONTINUE                                                              2073
0637    C                                                                               
0638    C***   Then start searching backward if not found                               
0639    C                                                                               
0640    C     EXECUTE (HOLD_CURRENT_SETUP)                                          2077
0641          ASSIGN 51170 TO KKK026                                                2077
0642          GO TO 79806                                                               
0643    51170 CONTINUE                                                                  
0644             IBLK = SBLK - 1                                                    2078
0645          IF (IBLK .GT. 0)GO TO 51190                                           2079
0646    C     EXECUTE (SEARCH_ERROR_EXIT)                                           2080
0647          ASSIGN 51200 TO KKK066                                                2080
0648          GO TO 79846                                                               
0649    51200 CONTINUE                                                                  
0650    51190 CONTINUE                                                              2081
0651             CALL BLKIN(IBLK,NBUF,BUFFER)                                       2082
0652          IF (NBUF .NE. 0)GO TO 51220                                           2083
0653    C     EXECUTE (READ_ERROR)                                                  2084
0654          ASSIGN 51230 TO KKK060                                                2084
0655          GO TO 79840                                                               
0656    51230 CONTINUE                                                                  
0657    51220 CONTINUE                                                              2085
0658             CALL BLKIN(IBLK,I,BUFFER(NBUF+1))                                  2086
0659          IF (I .NE. 0)GO TO 51250                                              2087
0660    C     EXECUTE (READ_ERROR)                                                  2088
0661          ASSIGN 51260 TO KKK060                                                2088
0662          GO TO 79840                                                               
0663    51260 CONTINUE                                                                  
0664    51250 CONTINUE                                                              2089
0665          IF (I .LE. 140)GO TO 51280                                            2090
0666               NBUF = NBUF + 140                                                2091
0667          GO TO 51270                                                           2092
0668    51280 CONTINUE                                                                  
0669               NBUF = NBUF + I                                                  2093
0670    51270 CONTINUE                                                              2094
0671             IBLK = SBLK                                                        2095
0672    C                                                                               
0673    C===   Search loop                                                              
0674    C                                                                               
0675    51289 CONTINUE                                                              2099
0676              CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))                             2100
0677           JJ=1                                                                 2101
0678          GO TO 51299                                                               
0679    51300  JJ= JJ+(1)                                                               
0680          IF ( JJ.GT.10)GO TO 51301                                                 
0681    51299 CONTINUE                                                                  
0682          IF (SBFLEN(JJ) .EQ. 0)GO TO 51301                                     2102
0683               IDESCR(1) = NBUF                                                 2103
0684               IDESCR(2) = %LOC(CAPBUF(1))                                      2104

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  53
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0685               I = 1                                                            2105
0686    51309 CONTINUE                                                              2106
0687                K = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))                   2107
0688          IF (.NOT.(STOPIT))GO TO 51330                                         2108
0689    C     EXECUTE (CANCEL_COMMAND)                                              2109
0690          ASSIGN 51340 TO KKK068                                                2109
0691          GO TO 79848                                                               
0692    51340 CONTINUE                                                                  
0693    51330 CONTINUE                                                              2110
0694          IF (K .NE. 0)GO TO 51360                                              2111
0695                  STRPOS(JJ) = I - 1                                            2112
0696          GO TO 51311                                                           2113
0697    51360 CONTINUE                                                              2114
0698                IDESCR(1) = IDESCR(1) - K                                       2115
0699                I = I + K                                                       2116
0700                IDESCR(2) = %LOC(CAPBUF(I))                                     2117
0701          GO TO 51309                                                           2118
0702    51311 CONTINUE                                                                  
0703          GO TO 51300                                                           2119
0704    51301 CONTINUE                                                                  
0705              I = 0                                                             2120
0706           K=1                                                                  2121
0707          GO TO 51369                                                               
0708    51370  K= K+(1)                                                                 
0709          IF ( K.GT.10)GO TO 51371                                                  
0710    51369 CONTINUE                                                                  
0711          IF (SBFLEN(K) .EQ. 0)GO TO 51371                                      2122
0712          IF (STRPOS(K) .LE. I)GO TO 51390                                      2123
0713                 JJ = K                                                         2124
0714                 I = STRPOS(K)                                                  2125
0715    51390 CONTINUE                                                              2126
0716          GO TO 51370                                                           2127
0717    51371 CONTINUE                                                                  
0718    C                                                                               
0719    C===   Found                                                                    
0720    C                                                                               
0721          IF (I .EQ. 0)GO TO 51410                                              2131
0722                BLK = IBLK - 2                                                  2132
0723                IF (BLK .LE. 0) BLK = 1                                         2133
0724                SBLK = BLK                                                      2134
0725                CALL BLKIN(BLK,NBUF,BUFFER)                                     2135
0726          IF (NBUF .NE. 0)GO TO 51430                                           2136
0727    C     EXECUTE (READ_ERROR)                                                  2137
0728          ASSIGN 51440 TO KKK060                                                2137
0729          GO TO 79840                                                               
0730    51440 CONTINUE                                                                  
0731    51430 CONTINUE                                                              2138
0732          IF (BLK .GT. EBK)GO TO 51460                                          2139
0733                  CALL BLKIN(BLK,I,BUFFER(NBUF+1))                              2140
0734          IF (I .NE. 0)GO TO 51480                                              2141
0735    C     EXECUTE (READ_ERROR)                                                  2142
0736          ASSIGN 51490 TO KKK060                                                2142
0737          GO TO 79840                                                               
0738    51490 CONTINUE                                                                  
0739    51480 CONTINUE                                                              2143
0740                  NBUF = NBUF + I                                               2144
0741          IF (BLK .GT. EBK)GO TO 51510                                          2145

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  54
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0742                    CALL BLKIN(BLK,I,BUFFER(NBUF+1))                            2146
0743          IF (I .NE. 0)GO TO 51530                                              2147
0744    C     EXECUTE (READ_ERROR)                                                  2148
0745          ASSIGN 51540 TO KKK060                                                2148
0746          GO TO 79840                                                               
0747    51540 CONTINUE                                                                  
0748    51530 CONTINUE                                                              2149
0749                    NBUF = NBUF + I                                             2150
0750    51510 CONTINUE                                                              2151
0751    51460 CONTINUE                                                              2152
0752                CALL LINCON(.TRUE.)                                             2153
0753    C                                                                               
0754    C===   Find right line                                                          
0755    C                                                                               
0756           J=NLINES                                                             2157
0757          GO TO 51549                                                               
0758    51550  J= J+(-1)                                                                
0759          IF ( J.LT.1)GO TO 51551                                                   
0760    51549 CONTINUE                                                                  
0761                 CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))             2158
0762          IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))                 2159
0763         X    .EQ. 0)GO TO 51570                                                    
0764                   LINEP = J                                                    2161
0765    C     EXECUTE (GET_LAST_LINE)                                               2162
0766          ASSIGN 51580 TO KKK030                                                2162
0767          GO TO 79810                                                               
0768    51580 CONTINUE                                                                  
0769    C     EXECUTE (CANCEL_STOPPER)                                              2163
0770          ASSIGN 51590 TO KKK032                                                2163
0771          GO TO 79812                                                               
0772    51590 CONTINUE                                                                  
0773    C     EXECUTE (REFRESH_EXIT)                                                2164
0774          ASSIGN 51600 TO KKK036                                                2164
0775          GO TO 79816                                                               
0776    51600 CONTINUE                                                                  
0777          GO TO 51051                                                           2165
0778    51570 CONTINUE                                                              2166
0779          GO TO 51550                                                           2167
0780    51551 CONTINUE                                                                  
0781    C                                                                               
0782    C===   Not found                                                                
0783    C                                                                               
0784    51410 CONTINUE                                                              2171
0785              IBLK = IBLK - 2                                                   2172
0786          IF (IBLK .GT. 0)GO TO 51620                                           2173
0787    C     EXECUTE (SEARCH_ERROR_EXIT)                                           2174
0788          ASSIGN 51630 TO KKK066                                                2174
0789          GO TO 79846                                                               
0790    51630 CONTINUE                                                                  
0791    51620 CONTINUE                                                              2175
0792           I=1                                                                  2176
0793          GO TO 51639                                                               
0794    51640  I= I+(1)                                                                 
0795          IF ( I.GT.30)GO TO 51641                                                  
0796    51639 CONTINUE                                                                  
0797               TEMP(I) = CAPBUF(I)                                              2177
0798          GO TO 51640                                                           2178

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  55
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0799    51641 CONTINUE                                                                  
0800              CALL BLKIN(IBLK,NBUF,BUFFER)                                      2179
0801          IF (NBUF .NE. 0)GO TO 51660                                           2180
0802    C     EXECUTE (READ_ERROR)                                                  2181
0803          ASSIGN 51670 TO KKK060                                                2181
0804          GO TO 79840                                                               
0805    51670 CONTINUE                                                                  
0806    51660 CONTINUE                                                              2182
0807           I=1                                                                  2183
0808          GO TO 51679                                                               
0809    51680  I= I+(1)                                                                 
0810          IF ( I.GT.30)GO TO 51681                                                  
0811    51679 CONTINUE                                                                  
0812               BUFFER(NBUF+I) = TEMP(I)                                         2184
0813          GO TO 51680                                                           2185
0814    51681 CONTINUE                                                                  
0815              NBUF = NBUF + 30                                                  2186
0816          IF (.NOT.(STOPIT))GO TO 51700                                         2187
0817    C     EXECUTE (CANCEL_COMMAND)                                              2188
0818          ASSIGN 51710 TO KKK068                                                2188
0819          GO TO 79848                                                               
0820    51710 CONTINUE                                                                  
0821    51700 CONTINUE                                                              2189
0822          GO TO 51289                                                           2190
0823    51051 CONTINUE                                                              2191
0824          GO TO KKK044                                                          2192
0825    C                                                                               
0826    C                                                                               
0827    C.......................................................................        
0828    C     PROCEDURE (BACKWARD_SCROLLING)                                        2193
0829    79832 CONTINUE                                                              2193
0830    CP    This procedure handles scrolling backward through the file.               
0831            IF (.NOT.MINFLG) DELTIM(1) = -DELTIM(1)                             2195
0832    C                                                                               
0833    C***   Scroll through line buffer                                               
0834    C                                                                               
0835          IF (LINEP .EQ. 1)GO TO 51730                                          2199
0836           LINEP=LINEP-1                                                        2200
0837          GO TO 51739                                                               
0838    51740  LINEP= LINEP+(-1)                                                        
0839          IF ( LINEP.LT.1)GO TO 51741                                               
0840    51739 CONTINUE                                                                  
0841          IF (LENLMT .GE. 0)GO TO 51760                                         2201
0842                 K = -LENLMT                                                    2202
0843           L=1                                                                  2203
0844          GO TO 51769                                                               
0845    51770  L= L+(1)                                                                 
0846          IF ( L.GT.LINLEN(LINEP)/K+1)GO TO 51771                                   
0847    51769 CONTINUE                                                                  
0848    C     EXECUTE (SCROLL_DOWN)                                                 2204
0849          ASSIGN 51780 TO KKK070                                                2204
0850          GO TO 79850                                                               
0851    51780 CONTINUE                                                                  
0852          GO TO 51770                                                           2205
0853    51771 CONTINUE                                                                  
0854          IF (K .GE. LINLEN(LINEP))GO TO 51800                                  2206
0855                   CALL LIB$PUT_SCREEN(LINES(LINEP)(:K)//CRLF//                 2207

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  56
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0856         1              LINES(LINEP)(K+1:LINLEN(LINEP))//CRLF,1,1)                  
0857          GO TO 51790                                                           2209
0858    51800 CONTINUE                                                                  
0859                   CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,      2210
0860         1                             1,1)                                         
0861    51790 CONTINUE                                                              2212
0862          GO TO 51750                                                           2213
0863    51760 CONTINUE                                                                  
0864    C     EXECUTE (SCROLL_DOWN)                                                 2214
0865          ASSIGN 51810 TO KKK070                                                2214
0866          GO TO 79850                                                               
0867    51810 CONTINUE                                                                  
0868          IF (LINLEN(LINEP) .LE. LENLMT)GO TO 51830                             2215
0869                   CALL LIB$PUT_SCREEN(LINES(LINEP)(:LENLMT)//CRLF,1,1)         2216
0870          GO TO 51820                                                           2217
0871    51830 CONTINUE                                                                  
0872                   CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,      2218
0873         1                             1,1)                                         
0874    51820 CONTINUE                                                              2220
0875    51750 CONTINUE                                                              2221
0876    C     EXECUTE (WAIT_FOR_SCROLL_AST)                                         2222
0877          ASSIGN 51840 TO KKK072                                                2222
0878          GO TO 79852                                                               
0879    51840 CONTINUE                                                                  
0880          IF (.NOT.(STOPIT))GO TO 51860                                         2223
0881    C     EXECUTE (GET_LAST_LINE)                                               2224
0882          ASSIGN 51870 TO KKK030                                                2224
0883          GO TO 79810                                                               
0884    51870 CONTINUE                                                                  
0885    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          2225
0886          ASSIGN 51880 TO KKK062                                                2225
0887          GO TO 79842                                                               
0888    51880 CONTINUE                                                                  
0889    C     EXECUTE (FREE_FLAGS_EXIT)                                             2226
0890          ASSIGN 51890 TO KKK064                                                2226
0891          GO TO 79844                                                               
0892    51890 CONTINUE                                                                  
0893                 RETURN                                                         2227
0894    51860 CONTINUE                                                              2228
0895          GO TO 51740                                                           2229
0896    51741 CONTINUE                                                                  
0897    51730 CONTINUE                                                              2230
0898    C                                                                               
0899    C***   Scroll through file                                                      
0900    C                                                                               
0901           I=1                                                                  2234
0902          GO TO 51899                                                               
0903    51900  I= I+(1)                                                                 
0904          IF ( I.GT.NLINES)GO TO 51901                                              
0905    51899 CONTINUE                                                                  
0906          IF (CCLINE(1,I) .NE. 0)GO TO 51901                                    2235
0907          GO TO 51900                                                           2236
0908    51901 CONTINUE                                                                  
0909            BLK = CCLINE(1,I) - 1                                               2237
0910          IF (BLK .LE. 0)GO TO 51920                                            2238
0911              CALL BLKIN(BLK,PBUF,BUFFER)                                       2239
0912          IF (PBUF .NE. 0)GO TO 51940                                           2240

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  57
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0913    C     EXECUTE (READ_ERROR)                                                  2241
0914          ASSIGN 51950 TO KKK060                                                2241
0915          GO TO 79840                                                               
0916    51950 CONTINUE                                                                  
0917    51940 CONTINUE                                                              2242
0918          GO TO 51910                                                           2243
0919    51920 CONTINUE                                                                  
0920              PBUF = 0                                                          2244
0921              BLK = 1                                                           2245
0922    51910 CONTINUE                                                              2246
0923            CALL BLKIN(BLK,NBUF,BUFFER(PBUF+1))                                 2247
0924          IF (NBUF .NE. 0)GO TO 51970                                           2248
0925    C     EXECUTE (READ_ERROR)                                                  2249
0926          ASSIGN 51980 TO KKK060                                                2249
0927          GO TO 79840                                                               
0928    51980 CONTINUE                                                                  
0929    51970 CONTINUE                                                              2250
0930            IF (PBUF .NE. 0) BLK = BLK - 1                                      2251
0931            PBUF = PBUF + CCLINE(2,I)                                           2252
0932            NBUF = PBUF                                                         2253
0933            ISAVE = PBUF                                                        2254
0934    51989 CONTINUE                                                              2255
0935          IF (RFM .NE. 1)GO TO 52010                                            2256
0936    C                                                                               
0937    C---   Fixed length records                                                     
0938    C                                                                               
0939    C===   Establish output record length                                           
0940    C                                                                               
0941          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 52030                    2262
0942          IF (.NOT.((FSZ - 1) .LT. LENLMT .OR. LENLMT .LT. 0))GO TO 52050       2263
0943                   LENREC = FSZ - 1                                             2264
0944          GO TO 52040                                                           2265
0945    52050 CONTINUE                                                                  
0946                   LENREC = LENLMT                                              2266
0947    52040 CONTINUE                                                              2267
0948          GO TO 52020                                                           2268
0949    52030 CONTINUE                                                                  
0950          IF (.NOT.(FSZ .LT. LENLMT .OR. LENLMT .LT. 0))GO TO 52070             2269
0951                   LENREC = FSZ                                                 2270
0952          GO TO 52060                                                           2271
0953    52070 CONTINUE                                                                  
0954                   LENREC = LENLMT                                              2272
0955    52060 CONTINUE                                                              2273
0956    52020 CONTINUE                                                              2274
0957    52079 CONTINUE                                                              2275
0958    C     EXECUTE (WAIT_FOR_SCROLL)                                             2276
0959          ASSIGN 52090 TO KKK074                                                2276
0960          GO TO 79854                                                               
0961    52090 CONTINUE                                                                  
0962          IF (.NOT.(STOPIT))GO TO 52110                                         2277
0963    C     EXECUTE (BACK_SCROLL_EXIT)                                            2278
0964          ASSIGN 52120 TO KKK058                                                2278
0965          GO TO 79838                                                               
0966    52120 CONTINUE                                                                  
0967    52110 CONTINUE                                                              2279
0968                PBUF = PBUF - IFSZ                                              2280
0969          IF (PBUF .LE. 0)GO TO 52081                                           2281

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  58
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0970    C     EXECUTE (SCROLL_DOWN)                                                 2282
0971          ASSIGN 52130 TO KKK070                                                2282
0972          GO TO 79850                                                               
0973    52130 CONTINUE                                                                  
0974          IF (.NOT.(LENLMT .LT. 0 .AND. RECLEN .GT. (-LENLMT)))GO TO 52150      2283
0975           K=1                                                                  2284
0976          GO TO 52159                                                               
0977    52160  K= K+(1)                                                                 
0978          IF ( K.GT.(-LENLMT)/RECLEN)GO TO 52161                                    
0979    52159 CONTINUE                                                                  
0980    C     EXECUTE (SCROLL_DOWN)                                                 2285
0981          ASSIGN 52170 TO KKK070                                                2285
0982          GO TO 79850                                                               
0983    52170 CONTINUE                                                                  
0984          GO TO 52160                                                           2286
0985    52161 CONTINUE                                                                  
0986    52150 CONTINUE                                                              2287
0987          IF (.NOT.(RAT .NE. 2 .AND. RAT .NE. -2))GO TO 52190                   2288
0988                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,BUFFER(PBUF),      2289
0989         1                      %VAL(LENREC),,,,)                                   
0990                  CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),         2291
0991         1                     IOSB,STOPSC,,INBUF,%VAL(1),,,,)                      
0992          GO TO 52180                                                           2293
0993    52190 CONTINUE                                                                  
0994                  CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,                   2294
0995         1                      BUFFER(PBUF+1),%VAL(LENREC),,,,)                    
0996                  CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),         2296
0997         1                     IOSB,STOPSC,,INBUF,%VAL(1),,,,)                      
0998          IF (BUFFER(PBUF) .NE. '1')GO TO 52210                                 2298
0999    C     EXECUTE (SCROLL_BLANK_LINE_PRE)                                       2299
1000          ASSIGN 52220 TO KKK076                                                2299
1001          GO TO 79856                                                               
1002    52220 CONTINUE                                                                  
1003    C     EXECUTE (SCROLL_BLANK_LINE_PRE)                                       2300
1004          ASSIGN 52230 TO KKK076                                                2300
1005          GO TO 79856                                                               
1006    52230 CONTINUE                                                                  
1007          GO TO 52200                                                           2301
1008    52210 CONTINUE                                                                  
1009          IF (BUFFER(PBUF) .NE. '0')GO TO 52250                                 2302
1010    C     EXECUTE (SCROLL_BLANK_LINE_PRE)                                       2303
1011          ASSIGN 52260 TO KKK076                                                2303
1012          GO TO 79856                                                               
1013    52260 CONTINUE                                                                  
1014    52250 CONTINUE                                                              2304
1015    52200 CONTINUE                                                              2305
1016    52180 CONTINUE                                                              2306
1017          GO TO 52079                                                           2307
1018    52081 CONTINUE                                                                  
1019          GO TO 52000                                                           2308
1020    52010 CONTINUE                                                                  
1021    C                                                                               
1022    C---   Variable length records                                                  
1023    C                                                                               
1024           I=PBUF                                                               2312
1025          GO TO 52269                                                               
1026    52270  I= I+(-1)                                                                

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  59
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1027          IF ( I.LT.2)GO TO 52271                                                   
1028    52269 CONTINUE                                                                  
1029          IF (I)GO TO 52290                                                     2313
1030          IF (BUFFER(I) .NE. 0)GO TO 52310                                      2314
1031          IF (I .GT. ISAVE)GO TO 52270                                          2315
1032                    LEN = LIB$EXTZV(0,8,BUFFER(I-1))                            2316
1033          IF ((LEN - FSZ) .NE. 0)GO TO 52330                                    2317
1034    C     EXECUTE (SCROLL_BLANK_LINE_POST)                                      2318
1035          ASSIGN 52340 TO KKK078                                                2318
1036          GO TO 79858                                                               
1037    52340 CONTINUE                                                                  
1038                      ISAVE = I - 4 - FSZ                                       2319
1039          GO TO 52270                                                           2320
1040    52330 CONTINUE                                                              2321
1041          IF (.NOT.(LEN))GO TO 52360                                            2322
1042                      ILEN = LEN + 1                                            2323
1043          GO TO 52350                                                           2324
1044    52360 CONTINUE                                                                  
1045                      ILEN = LEN                                                2325
1046    52350 CONTINUE                                                              2326
1047          IF (.NOT.(BUFFER(I+ILEN+2) .EQ. 0 .AND. LEN .LE. LRL .AND.            2327
1048         X          LIB$EXTZV(0,8,BUFFER(I+ILEN+1)) .LE. LRL))GO TO 52380           
1049                      ISAVE = I - 4 - FSZ                                       2329
1050          IF (.NOT.(RAT .EQ. 3 .OR. RAT .EQ. -3))GO TO 52400                    2330
1051          IF (LIB$EXTZV(7,1,BUFFER(I+2)) .NE. 0)GO TO 52420                     2331
1052                          J = LIB$EXTZV(0,7,BUFFER(I+2)) - 1                    2332
1053          IF (J .LE. 0)GO TO 52440                                              2333
1054           K=1                                                                  2334
1055          GO TO 52449                                                               
1056    52450  K= K+(1)                                                                 
1057          IF ( K.GT.J)GO TO 52451                                                   
1058    52449 CONTINUE                                                                  
1059    C     EXECUTE (SCROLL_BLANK_LINE_POST)                                      2335
1060          ASSIGN 52460 TO KKK078                                                2335
1061          GO TO 79858                                                               
1062    52460 CONTINUE                                                                  
1063          GO TO 52450                                                           2336
1064    52451 CONTINUE                                                                  
1065    52440 CONTINUE                                                              2337
1066    52420 CONTINUE                                                              2338
1067    C     EXECUTE (SCROLL_DOWN)                                                 2339
1068          ASSIGN 52470 TO KKK070                                                2339
1069          GO TO 79850                                                               
1070    52470 CONTINUE                                                                  
1071                        CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,             2340
1072         1                       BUFFER(I+FSZ+1),%VAL(LEN-FSZ),,,,)                 
1073                        CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),                 2342
1074         1                           %VAL('1171'X),IOSB,STOPSC,,INBUF,              
1075         2                           %VAL(1),,,,)                                   
1076          IF (LIB$EXTZV(7,1,BUFFER(I+1)) .NE. 0)GO TO 52490                     2345
1077                          J = LIB$EXTZV(0,7,BUFFER(I+1))                        2346
1078          IF (J .EQ. 0)GO TO 52510                                              2347
1079           K=1                                                                  2348
1080          GO TO 52519                                                               
1081    52520  K= K+(1)                                                                 
1082          IF ( K.GT.J)GO TO 52521                                                   
1083    52519 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  60
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1084    C     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                   2349
1085          ASSIGN 52530 TO KKK080                                                2349
1086          GO TO 79860                                                               
1087    52530 CONTINUE                                                                  
1088          GO TO 52520                                                           2350
1089    52521 CONTINUE                                                                  
1090    52510 CONTINUE                                                              2351
1091    52490 CONTINUE                                                              2352
1092          GO TO 52390                                                           2353
1093    52400 CONTINUE                                                                  
1094    C     EXECUTE (SCROLL_DOWN)                                                 2354
1095          ASSIGN 52540 TO KKK070                                                2354
1096          GO TO 79850                                                               
1097    52540 CONTINUE                                                                  
1098          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 52560                    2355
1099          IF (LEN .EQ. 1)GO TO 52580                                            2356
1100          IF (LENLMT .GE. 0)GO TO 52600                                         2357
1101          IF (LENLMT .LE. (1 + FSZ - LEN))GO TO 52620                           2358
1102           M=1                                                                  2359
1103          GO TO 52629                                                               
1104    52630  M= M+(1)                                                                 
1105          IF ( M.GT.(FSZ-LEN)/LENLMT)GO TO 52631                                    
1106    52629 CONTINUE                                                                  
1107    C     EXECUTE (SCROLL_DOWN)                                                 2360
1108          ASSIGN 52640 TO KKK070                                                2360
1109          GO TO 79850                                                               
1110    52640 CONTINUE                                                                  
1111          GO TO 52630                                                           2361
1112    52631 CONTINUE                                                                  
1113                                M = LEN - FSZ - 1                               2362
1114          GO TO 52610                                                           2363
1115    52620 CONTINUE                                                                  
1116                                M = -LENLMT                                     2364
1117    52610 CONTINUE                                                              2365
1118          GO TO 52590                                                           2366
1119    52600 CONTINUE                                                                  
1120          IF (LENLMT .LE. (LEN - FSZ - 1))GO TO 52660                           2367
1121                                M = LEN - FSZ - 1                               2368
1122          GO TO 52650                                                           2369
1123    52660 CONTINUE                                                                  
1124                                M = LENLMT                                      2370
1125    52650 CONTINUE                                                              2371
1126    52590 CONTINUE                                                              2372
1127                            CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,          2373
1128         1                                ,BUFFER(I+FSZ+2),%VAL(M),,,,)             
1129    52580 CONTINUE                                                              2375
1130                          CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),               2376
1131         1                             %VAL('1171'X),IOSB,STOPSC,,                  
1132         2                             INBUF,%VAL(1),,,,)                           
1133          IF (BUFFER(I+FSZ+1) .NE. '1')GO TO 52680                              2379
1134    C     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                   2380
1135          ASSIGN 52690 TO KKK080                                                2380
1136          GO TO 79860                                                               
1137    52690 CONTINUE                                                                  
1138    C     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                   2381
1139          ASSIGN 52700 TO KKK080                                                2381
1140          GO TO 79860                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  61
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1141    52700 CONTINUE                                                                  
1142          GO TO 52670                                                           2382
1143    52680 CONTINUE                                                                  
1144          IF (BUFFER(I+FSZ+1) .NE. '0')GO TO 52720                              2383
1145    C     EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)                                   2384
1146          ASSIGN 52730 TO KKK080                                                2384
1147          GO TO 79860                                                               
1148    52730 CONTINUE                                                                  
1149    52720 CONTINUE                                                              2385
1150    52670 CONTINUE                                                              2386
1151          GO TO 52550                                                           2387
1152    52560 CONTINUE                                                                  
1153          IF (LENLMT .GE. 0)GO TO 52750                                         2388
1154          IF (LENLMT .LE. (FSZ - LEN))GO TO 52770                               2389
1155           M=1                                                                  2390
1156          GO TO 52779                                                               
1157    52780  M= M+(1)                                                                 
1158          IF ( M.GT.(FSZ-LEN-1)/LENLMT)GO TO 52781                                  
1159    52779 CONTINUE                                                                  
1160    C     EXECUTE (SCROLL_DOWN)                                                 2391
1161          ASSIGN 52790 TO KKK070                                                2391
1162          GO TO 79850                                                               
1163    52790 CONTINUE                                                                  
1164          GO TO 52780                                                           2392
1165    52781 CONTINUE                                                                  
1166                              M = LEN - FSZ                                     2393
1167          GO TO 52760                                                           2394
1168    52770 CONTINUE                                                                  
1169                              M = -LENLMT                                       2395
1170    52760 CONTINUE                                                              2396
1171          GO TO 52740                                                           2397
1172    52750 CONTINUE                                                                  
1173          IF (LENLMT .LE. (LEN - FSZ))GO TO 52810                               2398
1174                              M = LEN - FSZ                                     2399
1175          GO TO 52800                                                           2400
1176    52810 CONTINUE                                                                  
1177                              M = LENLMT                                        2401
1178    52800 CONTINUE                                                              2402
1179    52740 CONTINUE                                                              2403
1180                          CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,           2404
1181         1                              BUFFER(I+FSZ+1),%VAL(M),,,,)                
1182                          CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),               2406
1183         1                             %VAL('1171'X),IOSB,STOPSC,,                  
1184         2                             INBUF,%VAL(1),,,,)                           
1185    52550 CONTINUE                                                              2409
1186    C     EXECUTE (WAIT_FOR_SCROLL)                                             2410
1187          ASSIGN 52820 TO KKK074                                                2410
1188          GO TO 79854                                                               
1189    52820 CONTINUE                                                                  
1190          IF (.NOT.(STOPIT))GO TO 52840                                         2411
1191    C     EXECUTE (VAR_BACK_SCROLL_EXIT)                                        2412
1192          ASSIGN 52850 TO KKK082                                                2412
1193          GO TO 79862                                                               
1194    52850 CONTINUE                                                                  
1195    52840 CONTINUE                                                              2413
1196    52390 CONTINUE                                                              2414
1197    52380 CONTINUE                                                              2415

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  62
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1198    52310 CONTINUE                                                              2416
1199    52290 CONTINUE                                                              2417
1200          GO TO 52270                                                           2418
1201    52271 CONTINUE                                                                  
1202    52000 CONTINUE                                                              2419
1203             BLK = BLK - 2                                                      2420
1204          IF (BLK .GT. 0)GO TO 52870                                            2421
1205    C     EXECUTE (HIT_BEGINNING)                                               2422
1206          ASSIGN 52880 TO KKK084                                                2422
1207          GO TO 79864                                                               
1208    52880 CONTINUE                                                                  
1209    C     EXECUTE (GET_LAST_LINE)                                               2423
1210          ASSIGN 52890 TO KKK030                                                2423
1211          GO TO 79810                                                               
1212    52890 CONTINUE                                                                  
1213    C     EXECUTE (FREE_FLAGS_EXIT)                                             2424
1214          ASSIGN 52900 TO KKK064                                                2424
1215          GO TO 79844                                                               
1216    52900 CONTINUE                                                                  
1217               RETURN                                                           2425
1218    52870 CONTINUE                                                              2426
1219           I=1                                                                  2427
1220          GO TO 52909                                                               
1221    52910  I= I+(1)                                                                 
1222          IF ( I.GT.150)GO TO 52911                                                 
1223    52909 CONTINUE                                                                  
1224              HBUFER(I) = BUFFER(I)                                             2428
1225          GO TO 52910                                                           2429
1226    52911 CONTINUE                                                                  
1227             CALL BLKIN(BLK,PBUF,BUFFER)                                        2430
1228          IF (PBUF .NE. 0)GO TO 52930                                           2431
1229    C     EXECUTE (READ_ERROR)                                                  2432
1230          ASSIGN 52940 TO KKK060                                                2432
1231          GO TO 79840                                                               
1232    52940 CONTINUE                                                                  
1233    52930 CONTINUE                                                              2433
1234           I=1                                                                  2434
1235          GO TO 52949                                                               
1236    52950  I= I+(1)                                                                 
1237          IF ( I.GT.150)GO TO 52951                                                 
1238    52949 CONTINUE                                                                  
1239              BUFFER(PBUF+I) = HBUFER(I)                                        2435
1240          GO TO 52950                                                           2436
1241    52951 CONTINUE                                                                  
1242             ISAVE = PBUF                                                       2437
1243             NBUF = PBUF + 150                                                  2438
1244          GO TO 51989                                                           2439
1245    C                                                                               
1246    C                                                                               
1247    C.......................................................................        
1248    C     PROCEDURE (CANCEL_COMMAND)                                            2441
1249    79848 CONTINUE                                                              2441
1250    CP    This routine is used to terminate either line jumps or searches on        
1251    CP    input of a (.                                                             
1252            CALL LIB$FREE_EF(IOFLAG)                                            2444
1253    C     EXECUTE (RESTORE_HELD_SETUP)                                          2445
1254          ASSIGN 52960 TO KKK054                                                2445

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  63
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1255          GO TO 79834                                                               
1256    52960 CONTINUE                                                                  
1257    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         2446
1258          ASSIGN 52970 TO KKK046                                                2446
1259          GO TO 79826                                                               
1260    52970 CONTINUE                                                                  
1261            RETURN                                                              2447
1262    C                                                                               
1263    C                                                                               
1264    C.......................................................................        
1265    C     PROCEDURE (CANCEL_STOPPER)                                            2449
1266    79812 CONTINUE                                                              2449
1267    CP    This routine gets rid of the stopping AST.                                
1268            CALL SYS$CANCEL(%VAL(INCHAN))                                       2451
1269            CALL LIB$FREE_EF(IOFLAG)                                            2452
1270          GO TO KKK032                                                          2453
1271    C                                                                               
1272    C                                                                               
1273    C.......................................................................        
1274    C     PROCEDURE (ERROR_EXIT)                                                2454
1275    79804 CONTINUE                                                              2454
1276    CP    This routine rings the terminal bell then resets the LEDs (#3 on)         
1277    CP    and returns.                                                              
1278    C     EXECUTE (CANCEL_STOPPER)                                              2457
1279          ASSIGN 52980 TO KKK032                                                2457
1280          GO TO 79812                                                               
1281    52980 CONTINUE                                                                  
1282            CALL WORKNG(.FALSE.)                                                2458
1283            CALL LIB$PUT_SCREEN(CHAR(BELL))                                     2459
1284          IF (.NOT.(VT100))GO TO 53000                                          2460
1285              CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;3q')                           2461
1286              IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')          2462
1287              IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                    2463
1288         1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                             
1289    53000 CONTINUE                                                              2465
1290            RETURN                                                              2466
1291    C                                                                               
1292    C                                                                               
1293    C.......................................................................        
1294    C     PROCEDURE (FIND_NON_CC_LINE)                                          2468
1295    79818 CONTINUE                                                              2468
1296    CP    This procedure locates a non-carriage-control line near LINEP             
1297     1550 CONTINUE                                                              2470
1298           I=LINEP                                                              2471
1299          GO TO 53019                                                               
1300    53020  I= I+(1)                                                                 
1301          IF ( I.GT.NLINES)GO TO 53021                                              
1302    53019 CONTINUE                                                                  
1303          IF (CCLINE(1,I) .NE. 0)GO TO 53011                                    2472
1304          GO TO 53020                                                           2473
1305    53021 CONTINUE                                                                  
1306           I=LINEP-1                                                            2474
1307          GO TO 53029                                                               
1308    53030  I= I+(-1)                                                                
1309          IF ( I.LT.1)GO TO 53031                                                   
1310    53029 CONTINUE                                                                  
1311          IF (CCLINE(1,I) .NE. 0)GO TO 53011                                    2475

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  64
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1312          GO TO 53030                                                           2476
1313    53031 CONTINUE                                                                  
1314    53011 CONTINUE                                                              2477
1315          GO TO KKK038                                                          2478
1316    C                                                                               
1317    C                                                                               
1318    C.......................................................................        
1319    C     PROCEDURE (FORWARD_SEARCH)                                            2479
1320    79822 CONTINUE                                                              2479
1321    CP    This routine searchs forward through the file for a given string.         
1322    CP    If it is found the screen is reset to that position, and the LEDs are     
1323    CP    reset (#3 off), otherwise the position and screen remain unchanged        
1324    CP    and the LEDs are reset (#3 on).  In either case a return from DOIT        
1325    CP    is executed.                                                              
1326    C                                                                               
1327    C***   First search lines in buffer                                             
1328    C                                                                               
1329     1750 CONTINUE                                                              2488
1330          IF (LINEP .GE. NLINES)GO TO 53060                                     2489
1331           I=LINEP+1                                                            2490
1332          GO TO 53069                                                               
1333    53070  I= I+(1)                                                                 
1334          IF ( I.GT.NLINES)GO TO 53071                                              
1335    53069 CONTINUE                                                                  
1336           JJ=1                                                                 2491
1337          GO TO 53079                                                               
1338    53080  JJ= JJ+(1)                                                               
1339          IF ( JJ.GT.10)GO TO 53081                                                 
1340    53079 CONTINUE                                                                  
1341          IF (SBFLEN(JJ) .EQ. 0)GO TO 53081                                     2492
1342                 CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))             2493
1343          IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ))) .EQ.            2494
1344         X    0)GO TO 53100                                                         
1345                   NUMBER = I - LINEP                                           2496
1346                   LINEP = I                                                    2497
1347    C     EXECUTE (GET_LAST_LINE)                                               2498
1348          ASSIGN 53110 TO KKK030                                                2498
1349          GO TO 79810                                                               
1350    53110 CONTINUE                                                                  
1351          IF ((NUMBER+LINEP) .GE. PAGEND)GO TO 53130                            2499
1352    C     EXECUTE (SCROLL_REFRESH_EXIT)                                         2500
1353          ASSIGN 53140 TO KKK034                                                2500
1354          GO TO 79814                                                               
1355    53140 CONTINUE                                                                  
1356          GO TO 53120                                                           2501
1357    53130 CONTINUE                                                                  
1358    C     EXECUTE (REFRESH_EXIT)                                                2502
1359          ASSIGN 53150 TO KKK036                                                2502
1360          GO TO 79816                                                               
1361    53150 CONTINUE                                                                  
1362    53120 CONTINUE                                                              2503
1363          GO TO 53041                                                           2504
1364    53100 CONTINUE                                                              2505
1365          GO TO 53080                                                           2506
1366    53081 CONTINUE                                                                  
1367          GO TO 53070                                                           2507
1368    53071 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  65
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1369    53060 CONTINUE                                                              2508
1370    C                                                                               
1371    C***   Then search file                                                         
1372    C                                                                               
1373    C     EXECUTE (HOLD_CURRENT_SETUP)                                          2512
1374          ASSIGN 53160 TO KKK026                                                2512
1375          GO TO 79806                                                               
1376    53160 CONTINUE                                                                  
1377             IBLK = BLK                                                         2513
1378          IF (NBUF .LE. 0)GO TO 53180                                           2514
1379               I = NBUF + 1                                                     2515
1380          GO TO 53170                                                           2516
1381    53180 CONTINUE                                                                  
1382               I = 1                                                            2517
1383    53170 CONTINUE                                                              2518
1384             IDESCR(2) = %LOC(CAPBUF(1))                                        2519
1385    53189 CONTINUE                                                              2520
1386    C                                                                               
1387    C---   Input some buffer                                                        
1388    C                                                                               
1389          IF (IBLK .LE. EBK)GO TO 53210                                         2524
1390    C     EXECUTE (SEARCH_ERROR_EXIT)                                           2525
1391          ASSIGN 53220 TO KKK066                                                2525
1392          GO TO 79846                                                               
1393    53220 CONTINUE                                                                  
1394    53210 CONTINUE                                                              2526
1395          IF (IBLK .GE. (EBK - 6))GO TO 53240                                   2527
1396    C                                                                               
1397    C===   Not near the end of the file                                             
1398    C                                                                               
1399                CALL BLKSIN(IBLK,J,BUFFER(I))                                   2531
1400          IF (J .NE. 0)GO TO 53260                                              2532
1401    C     EXECUTE (READ_ERROR)                                                  2533
1402          ASSIGN 53270 TO KKK060                                                2533
1403          GO TO 79840                                                               
1404    53270 CONTINUE                                                                  
1405    53260 CONTINUE                                                              2534
1406          GO TO 53230                                                           2535
1407    53240 CONTINUE                                                                  
1408    C                                                                               
1409    C===   Near the end of the file                                                 
1410    C                                                                               
1411                J = 0                                                           2539
1412           II=IBLK                                                              2540
1413          GO TO 53279                                                               
1414    53280  II= II+(1)                                                               
1415          IF ( II.GT.EBK)GO TO 53281                                                
1416    53279 CONTINUE                                                                  
1417                 CALL BLKIN(IBLK,JJ,BUFFER(J+I))                                2541
1418          IF (JJ .NE. 0)GO TO 53300                                             2542
1419    C     EXECUTE (READ_ERROR)                                                  2543
1420          ASSIGN 53310 TO KKK060                                                2543
1421          GO TO 79840                                                               
1422    53310 CONTINUE                                                                  
1423    53300 CONTINUE                                                              2544
1424                 J = J + JJ                                                     2545
1425          GO TO 53280                                                           2546

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  66
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1426    53281 CONTINUE                                                                  
1427    53230 CONTINUE                                                              2547
1428              NBUF = J + I - 1                                                  2548
1429              CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))                             2549
1430              IDESCR(1) = NBUF                                                  2550
1431           JJ=1                                                                 2551
1432          GO TO 53319                                                               
1433    53320  JJ= JJ+(1)                                                               
1434          IF ( JJ.GT.10)GO TO 53321                                                 
1435    53319 CONTINUE                                                                  
1436          IF (SBFLEN(JJ) .EQ. 0)GO TO 53321                                     2552
1437               STRPOS(JJ) = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))           2553
1438          IF (.NOT.(STOPIT))GO TO 53340                                         2554
1439    C     EXECUTE (CANCEL_COMMAND)                                              2555
1440          ASSIGN 53350 TO KKK068                                                2555
1441          GO TO 79848                                                               
1442    53350 CONTINUE                                                                  
1443    53340 CONTINUE                                                              2556
1444          GO TO 53320                                                           2557
1445    53321 CONTINUE                                                                  
1446              I = NBUF                                                          2558
1447           K=1                                                                  2559
1448          GO TO 53359                                                               
1449    53360  K= K+(1)                                                                 
1450          IF ( K.GT.10)GO TO 53361                                                  
1451    53359 CONTINUE                                                                  
1452          IF (SBFLEN(K) .EQ. 0)GO TO 53361                                      2560
1453          IF (.NOT.(STRPOS(K) .NE. 0 .AND. STRPOS(K) .LT. I))GO TO 53380        2561
1454                 I = STRPOS(K)                                                  2562
1455                 JJ = K                                                         2563
1456    53380 CONTINUE                                                              2564
1457          GO TO 53360                                                           2565
1458    53361 CONTINUE                                                                  
1459          IF (I .EQ. NBUF)GO TO 53400                                           2566
1460    C                                                                               
1461    C===   Found it                                                                 
1462    C                                                                               
1463                IBLK = IBLK - (NBUF - I)/512 - 2                                2570
1464                IF (IBLK .LE. 0) IBLK = 1                                       2571
1465          IF (IBLK .GT. (EBK - 6))GO TO 53420                                   2572
1466                  BLK = IBLK                                                    2573
1467                  I = 1                                                         2574
1468          GO TO 53410                                                           2575
1469    53420 CONTINUE                                                                  
1470                  BLK = EBK - 6                                                 2576
1471                  I = 0                                                         2577
1472    53410 CONTINUE                                                              2578
1473    C     EXECUTE (INPUT_SEVEN_BLOCKS)                                          2579
1474          ASSIGN 53430 TO KKK040                                                2579
1475          GO TO 79820                                                               
1476    53430 CONTINUE                                                                  
1477                CALL LINCON(.TRUE.)                                             2580
1478          IF (I .NE. 0)GO TO 53450                                              2581
1479           I=1                                                                  2582
1480          GO TO 53459                                                               
1481    53460  I= I+(1)                                                                 
1482          IF ( I.GT.NLINES)GO TO 53461                                              

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  67
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1483    53459 CONTINUE                                                                  
1484          IF (CCLINE(1,I) .EQ. IBLK)GO TO 53461                                 2583
1485          GO TO 53460                                                           2584
1486    53461 CONTINUE                                                                  
1487    53450 CONTINUE                                                              2585
1488           J=I                                                                  2586
1489          GO TO 53469                                                               
1490    53470  J= J+(1)                                                                 
1491          IF ( J.GT.NLINES)GO TO 53471                                              
1492    53469 CONTINUE                                                                  
1493                 CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))             2587
1494          IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))                 2588
1495         X    .EQ. 0)GO TO 53490                                                    
1496                   LINEP = J                                                    2590
1497    C     EXECUTE (GET_LAST_LINE)                                               2591
1498          ASSIGN 53500 TO KKK030                                                2591
1499          GO TO 79810                                                               
1500    53500 CONTINUE                                                                  
1501    C     EXECUTE (CANCEL_STOPPER)                                              2592
1502          ASSIGN 53510 TO KKK032                                                2592
1503          GO TO 79812                                                               
1504    53510 CONTINUE                                                                  
1505    C     EXECUTE (REFRESH_EXIT)                                                2593
1506          ASSIGN 53520 TO KKK036                                                2593
1507          GO TO 79816                                                               
1508    53520 CONTINUE                                                                  
1509          GO TO 53041                                                           2594
1510    53490 CONTINUE                                                              2595
1511          IF (.NOT.(STOPIT))GO TO 53540                                         2596
1512    C     EXECUTE (CANCEL_COMMAND)                                              2597
1513          ASSIGN 53550 TO KKK068                                                2597
1514          GO TO 79848                                                               
1515    53550 CONTINUE                                                                  
1516    53540 CONTINUE                                                              2598
1517          GO TO 53470                                                           2599
1518    53471 CONTINUE                                                                  
1519    C                                                                               
1520    C===   Not found                                                                
1521    C                                                                               
1522    53400 CONTINUE                                                              2603
1523              I = 31                                                            2604
1524           J=1                                                                  2605
1525          GO TO 53559                                                               
1526    53560  J= J+(1)                                                                 
1527          IF ( J.GT.30)GO TO 53561                                                  
1528    53559 CONTINUE                                                                  
1529               BUFFER(J) = CAPBUF(NBUF-30+J)                                    2606
1530          GO TO 53560                                                           2607
1531    53561 CONTINUE                                                                  
1532          GO TO 53189                                                           2608
1533    53041 CONTINUE                                                              2609
1534          GO TO KKK042                                                          2610
1535    C                                                                               
1536    C                                                                               
1537    C.......................................................................        
1538    C     PROCEDURE (FORWARD_SCROLLING)                                         2611
1539    79830 CONTINUE                                                              2611

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  68
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1540    CP    This procedure executes scrolling in a forward direction.                 
1541            LINEP = PAGEND                                                      2613
1542            FIRST = .TRUE.                                                      2614
1543          IF (PAGLEN .NE. (COMLIN - 2))GO TO 53580                              2615
1544              SECOND = .TRUE.                                                   2616
1545          GO TO 53570                                                           2617
1546    53580 CONTINUE                                                                  
1547              SECOND = .FALSE.                                                  2618
1548    53570 CONTINUE                                                              2619
1549    53589 CONTINUE                                                              2620
1550    C                                                                               
1551    C***   Scroll through line buffer                                               
1552    C                                                                               
1553          IF (LINEP .EQ. NLINES)GO TO 53591                                     2624
1554           I=LINEP+1                                                            2625
1555          GO TO 53599                                                               
1556    53600  I= I+(1)                                                                 
1557          IF ( I.GT.NLINES)GO TO 53601                                              
1558    53599 CONTINUE                                                                  
1559              CALL SYS$CANCEL(%VAL(INCHAN))                                     2626
1560          IF (.NOT.(FIRST))GO TO 53620                                          2627
1561                FIRST = .FALSE.                                                 2628
1562           J=PAGLEN+1                                                           2629
1563          GO TO 53629                                                               
1564    53630  J= J+(1)                                                                 
1565          IF ( J.GT.COMLIN)GO TO 53631                                              
1566    53629 CONTINUE                                                                  
1567                 CALL LIB$ERASE_LINE(J,1)                                       2630
1568          GO TO 53630                                                           2631
1569    53631 CONTINUE                                                                  
1570          IF (LENLMT .GE. 0)GO TO 53650                                         2632
1571          IF (LINLEN(I) .GT. -LENLMT)GO TO 53670                                2633
1572                    CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)        2634
1573          GO TO 53660                                                           2635
1574    53670 CONTINUE                                                                  
1575                    CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//              2636
1576         1               LINES(I)(1-LENLMT:LINLEN(I)),PAGLEN+1,1)                   
1577    53660 CONTINUE                                                              2638
1578          GO TO 53640                                                           2639
1579    53650 CONTINUE                                                                  
1580          IF (LINLEN(I) .LE. LENLMT)GO TO 53690                                 2640
1581                    CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),PAGLEN+1,1)           2641
1582          GO TO 53680                                                           2642
1583    53690 CONTINUE                                                                  
1584                    CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)        2643
1585    53680 CONTINUE                                                              2644
1586    53640 CONTINUE                                                              2645
1587          GO TO 53610                                                           2646
1588    53620 CONTINUE                                                                  
1589          IF (.NOT.(SECOND))GO TO 53710                                         2647
1590                  SECOND = .FALSE.                                              2648
1591                  IF (LENLMT .LT. 0 .AND. LINLEN(I) .GT. (-LENLMT))             2649
1592         1            CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                            
1593          GO TO 53700                                                           2651
1594    53710 CONTINUE                                                                  
1595                  CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                            2652
1596    53700 CONTINUE                                                              2653

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  69
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1597          IF (LENLMT .GE. 0)GO TO 53730                                         2654
1598          IF (LINLEN(I) .GT. -LENLMT)GO TO 53750                                2655
1599                    CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)          2656
1600          GO TO 53740                                                           2657
1601    53750 CONTINUE                                                                  
1602                    CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//              2658
1603         1               LINES(I)(1-LENLMT:LINLEN(I)),COMLIN,1)                     
1604    53740 CONTINUE                                                              2660
1605          GO TO 53720                                                           2661
1606    53730 CONTINUE                                                                  
1607          IF (LINLEN(I) .LE. LENLMT)GO TO 53770                                 2662
1608                    CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),COMLIN,1)             2663
1609          GO TO 53760                                                           2664
1610    53770 CONTINUE                                                                  
1611                    CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)          2665
1612    53760 CONTINUE                                                              2666
1613    53720 CONTINUE                                                              2667
1614    53610 CONTINUE                                                              2668
1615              CALL LIB$SET_CURSOR(1,1)                                          2669
1616    C     EXECUTE (WAIT_FOR_SCROLL_AST)                                         2670
1617          ASSIGN 53780 TO KKK072                                                2670
1618          GO TO 79852                                                               
1619    53780 CONTINUE                                                                  
1620          IF (.NOT.(STOPIT))GO TO 53800                                         2671
1621                PAGEND = I                                                      2672
1622    C     EXECUTE (GET_START_LINE)                                              2673
1623          ASSIGN 53810 TO KKK086                                                2673
1624          GO TO 79866                                                               
1625    53810 CONTINUE                                                                  
1626          IF (FIRST)GO TO 53830                                                 2674
1627                  CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                            2675
1628                  IF (PAGLEN .EQ. (COMLIN - 2))                                 2676
1629         1            CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                            
1630                  CALL LIB$SET_CURSOR(1,1)                                      2678
1631    53830 CONTINUE                                                              2679
1632    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          2680
1633          ASSIGN 53840 TO KKK062                                                2680
1634          GO TO 79842                                                               
1635    53840 CONTINUE                                                                  
1636    C     EXECUTE (FREE_FLAGS_EXIT)                                             2681
1637          ASSIGN 53850 TO KKK064                                                2681
1638          GO TO 79844                                                               
1639    53850 CONTINUE                                                                  
1640                RETURN                                                          2682
1641    53800 CONTINUE                                                              2683
1642          GO TO 53600                                                           2684
1643    53601 CONTINUE                                                                  
1644    C                                                                               
1645    C***   Input to line buffer                                                     
1646    C                                                                               
1647    C                                                                               
1648    C---   End of file                                                              
1649    C                                                                               
1650          IF (BLK .LE. EBK)GO TO 53870                                          2691
1651               PAGEND = NLINES                                                  2692
1652    C     EXECUTE (GET_START_LINE)                                              2693
1653          ASSIGN 53880 TO KKK086                                                2693

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  70
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1654          GO TO 79866                                                               
1655    53880 CONTINUE                                                                  
1656               CALL SYS$CANCEL(%VAL(INCHAN))                                    2694
1657          IF (FIRST)GO TO 53900                                                 2695
1658                 CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)                             2696
1659                 CALL LIB$SET_CURSOR(1,1)                                       2697
1660    53900 CONTINUE                                                              2698
1661    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          2699
1662          ASSIGN 53910 TO KKK062                                                2699
1663          GO TO 79842                                                               
1664    53910 CONTINUE                                                                  
1665    C     EXECUTE (FREE_FLAGS_EXIT)                                             2700
1666          ASSIGN 53920 TO KKK064                                                2700
1667          GO TO 79844                                                               
1668    53920 CONTINUE                                                                  
1669               RETURN                                                           2701
1670    53870 CONTINUE                                                              2702
1671          IF (BLK .GE. (EBK - 6))GO TO 53940                                    2703
1672    C                                                                               
1673    C---   Not near the end of the file                                             
1674    C                                                                               
1675               CALL BLKSIN(BLK,I,BUFFER(NBUF+1))                                2707
1676          IF (I .NE. 0)GO TO 53960                                              2708
1677    C     EXECUTE (READ_ERROR)                                                  2709
1678          ASSIGN 53970 TO KKK060                                                2709
1679          GO TO 79840                                                               
1680    53970 CONTINUE                                                                  
1681    53960 CONTINUE                                                              2710
1682          GO TO 53930                                                           2711
1683    53940 CONTINUE                                                                  
1684    C                                                                               
1685    C---   Near the end of the file                                                 
1686    C                                                                               
1687               I = 0                                                            2715
1688           J=BLK                                                                2716
1689          GO TO 53979                                                               
1690    53980  J= J+(1)                                                                 
1691          IF ( J.GT.EBK)GO TO 53981                                                 
1692    53979 CONTINUE                                                                  
1693                CALL BLKIN(BLK,II,BUFFER(NBUF+I+1))                             2717
1694          IF (II .NE. 0)GO TO 54000                                             2718
1695    C     EXECUTE (READ_ERROR)                                                  2719
1696          ASSIGN 54010 TO KKK060                                                2719
1697          GO TO 79840                                                               
1698    54010 CONTINUE                                                                  
1699    54000 CONTINUE                                                              2720
1700                I = I + II                                                      2721
1701          GO TO 53980                                                           2722
1702    53981 CONTINUE                                                                  
1703    53930 CONTINUE                                                              2723
1704             NBUF = NBUF + I                                                    2724
1705             LINEP = NLINES                                                     2725
1706             PBUF = 1                                                           2726
1707             CALL LINCON(.FALSE.)                                               2727
1708          GO TO 53589                                                           2728
1709    53591 CONTINUE                                                                  
1710          GO TO KKK050                                                          2729

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  71
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1711    C                                                                               
1712    C                                                                               
1713    C.......................................................................        
1714    C     PROCEDURE (FREE_FLAGS_EXIT)                                           2730
1715    79844 CONTINUE                                                              2730
1716    CP    This routine exits from scrolling.  It frees the event flags, cancels     
1717    CP    any input requests to the terminal, resets the LEDs (#3 off) and          
1718    CP    returns.                                                                  
1719    C     EXECUTE (CANCEL_STOPPER)                                              2734
1720          ASSIGN 54020 TO KKK032                                                2734
1721          GO TO 79812                                                               
1722    54020 CONTINUE                                                                  
1723            CALL LIB$FREE_EF(TIMFLG)                                            2735
1724    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         2736
1725          ASSIGN 54030 TO KKK046                                                2736
1726          GO TO 79826                                                               
1727    54030 CONTINUE                                                                  
1728          GO TO KKK064                                                          2737
1729    C                                                                               
1730    C                                                                               
1731    C.......................................................................        
1732    C     PROCEDURE (GET_LAST_LINE)                                             2738
1733    79810 CONTINUE                                                              2738
1734    CP    This procedure determines PAGEND given LINEP                              
1735            OLDEND = PAGEND                                                     2740
1736          IF (LENLMT .GE. 0)GO TO 54050                                         2741
1737              I = PAGLEN                                                        2742
1738           PAGEND=LINEP                                                         2743
1739          GO TO 54059                                                               
1740    54060  PAGEND= PAGEND+(1)                                                       
1741          IF ( PAGEND.GT.LINEP+PAGLEN)GO TO 54061                                   
1742    54059 CONTINUE                                                                  
1743               I = I + (LINLEN(PAGEND) - 1)/LENLMT - 1                          2744
1744          IF (I .LE. 0)GO TO 54061                                              2745
1745          GO TO 54060                                                           2746
1746    54061 CONTINUE                                                                  
1747          GO TO 54040                                                           2747
1748    54050 CONTINUE                                                                  
1749              PAGEND = LINEP + PAGLEN - 1                                       2748
1750    54040 CONTINUE                                                              2749
1751          GO TO KKK030                                                          2750
1752    C                                                                               
1753    C                                                                               
1754    C.......................................................................        
1755    C     PROCEDURE (GET_START_LINE)                                            2751
1756    79866 CONTINUE                                                              2751
1757    CP    This procedure determines LINEP given a value for PAGEND                  
1758          IF (LENLMT .GE. 0)GO TO 54080                                         2753
1759              I = PAGLEN                                                        2754
1760           LINEP=PAGEND                                                         2755
1761          GO TO 54089                                                               
1762    54090  LINEP= LINEP+(-1)                                                        
1763          IF ( LINEP.LT.PAGEND-PAGLEN)GO TO 54091                                   
1764    54089 CONTINUE                                                                  
1765               I = I + (LINLEN(LINEP) - 1)/LENLMT - 1                           2756
1766          IF (I .LE. 0)GO TO 54091                                              2757
1767          GO TO 54090                                                           2758

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  72
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1768    54091 CONTINUE                                                                  
1769          GO TO 54070                                                           2759
1770    54080 CONTINUE                                                                  
1771              LINEP = PAGEND - PAGLEN + 1                                       2760
1772    54070 CONTINUE                                                              2761
1773          GO TO KKK086                                                          2762
1774    C                                                                               
1775    C                                                                               
1776    C.......................................................................        
1777    C     PROCEDURE (HIT_BEGINNING)                                             2763
1778    79864 CONTINUE                                                              2763
1779    CP    This procedure is executed if the position goes past the beginning        
1780    CP    of the file.  Everything is reset to the beginning of the file.           
1781            BLK = 1                                                             2766
1782    C     EXECUTE (INPUT_SEVEN_BLOCKS)                                          2767
1783          ASSIGN 54100 TO KKK040                                                2767
1784          GO TO 79820                                                               
1785    54100 CONTINUE                                                                  
1786            CALL LINCON(.TRUE.)                                                 2768
1787            LINEP = 1                                                           2769
1788          GO TO KKK084                                                          2770
1789    C                                                                               
1790    C                                                                               
1791    C.......................................................................        
1792    C     PROCEDURE (HOLD_CURRENT_SETUP)                                        2771
1793    79806 CONTINUE                                                              2771
1794    CP    This routine is used in searches.  It holds all the information           
1795    CP    needed to recreate the current position and array conditions.             
1796           I=1                                                                  2774
1797          GO TO 54109                                                               
1798    54110  I= I+(1)                                                                 
1799          IF ( I.GT.NLINES)GO TO 54111                                              
1800    54109 CONTINUE                                                                  
1801             HLIN(I) = LINES(I)                                                 2775
1802             HLINLN(I) = LINLEN(I)                                              2776
1803             HCCLIN(1,I) = CCLINE(1,I)                                          2777
1804             HCCLIN(2,I) = CCLINE(2,I)                                          2778
1805          GO TO 54110                                                           2779
1806    54111 CONTINUE                                                                  
1807            HLINES = NLINES                                                     2780
1808            HLINEP = LINEP                                                      2781
1809          IF (NBUF .EQ. 0)GO TO 54130                                           2782
1810           I=1                                                                  2783
1811          GO TO 54139                                                               
1812    54140  I= I+(1)                                                                 
1813          IF ( I.GT.NBUF)GO TO 54141                                                
1814    54139 CONTINUE                                                                  
1815               HBUFER(I) = BUFFER(I)                                            2784
1816          GO TO 54140                                                           2785
1817    54141 CONTINUE                                                                  
1818    54130 CONTINUE                                                              2786
1819            HPBUF = PBUF                                                        2787
1820            HNBUF = NBUF                                                        2788
1821            HBLK = BLK                                                          2789
1822            HSBLK = SBLK                                                        2790
1823            HLBLK = LBLK                                                        2791
1824            HLPBUF = LPBUF                                                      2792

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  73
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1825    C     EXECUTE (QUEUE_STOPPER)                                               2793
1826          ASSIGN 54150 TO KKK048                                                2793
1827          GO TO 79828                                                               
1828    54150 CONTINUE                                                                  
1829          GO TO KKK026                                                          2794
1830    C                                                                               
1831    C                                                                               
1832    C.......................................................................        
1833    C     PROCEDURE (HOME_PLUS_LEDS_EXIT)                                       2795
1834    79826 CONTINUE                                                              2795
1835    CP    This routine homes the cursor, resets the LEDs (#3 off).                  
1836          IF (.NOT.(VT100))GO TO 54170                                          2797
1837              CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0q',1,1)                         2798
1838              IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                    2799
1839         1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                             
1840              IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')          2801
1841          GO TO 54160                                                           2802
1842    54170 CONTINUE                                                                  
1843              CALL LIB$SET_CURSOR(1,1)                                          2803
1844    54160 CONTINUE                                                              2804
1845          GO TO KKK046                                                          2805
1846    C                                                                               
1847    C                                                                               
1848    C.......................................................................        
1849    C     PROCEDURE (INPUT_SEVEN_BLOCKS)                                        2806
1850    79820 CONTINUE                                                              2806
1851    CP    This procedure inputs seven blocks of data                                
1852          IF (BLK .GE. (EBK - 6))GO TO 54190                                    2808
1853    C                                                                               
1854    C***   Not near the end of the file                                             
1855    C                                                                               
1856              SBLK = BLK                                                        2812
1857              CALL BLKSIN(BLK,NBUF,BUFFER)                                      2813
1858          IF (NBUF .NE. 0)GO TO 54210                                           2814
1859    C     EXECUTE (READ_ERROR)                                                  2815
1860          ASSIGN 54220 TO KKK060                                                2815
1861          GO TO 79840                                                               
1862    54220 CONTINUE                                                                  
1863    54210 CONTINUE                                                              2816
1864          GO TO 54180                                                           2817
1865    54190 CONTINUE                                                                  
1866    C                                                                               
1867    C***   Near the end of the file                                                 
1868    C                                                                               
1869              BLK = EBK - 6                                                     2821
1870          IF (BLK .LE. 0)GO TO 54240                                            2822
1871                SBLK = BLK                                                      2823
1872                CALL BLKSIN(BLK,NBUF,BUFFER)                                    2824
1873          IF (NBUF .NE. 0)GO TO 54260                                           2825
1874    C     EXECUTE (READ_ERROR)                                                  2826
1875          ASSIGN 54270 TO KKK060                                                2826
1876          GO TO 79840                                                               
1877    54270 CONTINUE                                                                  
1878    54260 CONTINUE                                                              2827
1879          GO TO 54230                                                           2828
1880    54240 CONTINUE                                                                  
1881    C                                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  74
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1882    C***   Do this if file size is < 7 blocks                                       
1883    C                                                                               
1884                BLK = 1                                                         2832
1885                SBLK = 1                                                        2833
1886                NBUF = 0                                                        2834
1887           I=BLK                                                                2835
1888          GO TO 54279                                                               
1889    54280  I= I+(1)                                                                 
1890          IF ( I.GT.EBK)GO TO 54281                                                 
1891    54279 CONTINUE                                                                  
1892                 CALL BLKIN(BLK,J,BUFFER(NBUF+1))                               2836
1893          IF (J .NE. 0)GO TO 54300                                              2837
1894    C     EXECUTE (READ_ERROR)                                                  2838
1895          ASSIGN 54310 TO KKK060                                                2838
1896          GO TO 79840                                                               
1897    54310 CONTINUE                                                                  
1898    54300 CONTINUE                                                              2839
1899                 NBUF = NBUF + J                                                2840
1900          GO TO 54280                                                           2841
1901    54281 CONTINUE                                                                  
1902    54230 CONTINUE                                                              2842
1903    54180 CONTINUE                                                              2843
1904          GO TO KKK040                                                          2844
1905    C                                                                               
1906    C                                                                               
1907    C.......................................................................        
1908    C     PROCEDURE (JUMP_LINES)                                                2845
1909    79808 CONTINUE                                                              2845
1910    CP    This procedure moves the current position NUMBER lines.                   
1911          IF ((NUMBER + LINEP) .LE. (NLINES - PAGLEN + 1))GO TO 54330           2847
1912    C                                                                               
1913    C***   Big jumps forward                                                        
1914    C                                                                               
1915              SECOND = .FALSE.                                                  2851
1916    54339 CONTINUE                                                              2852
1917          IF (BLK .LE. EBK)GO TO 54360                                          2853
1918                 LINEP = NLINES - PAGLEN + 1                                    2854
1919                 IF (LINEP .LT. 1) LINEP = 1                                    2855
1920                 JNUMB = NUMBER                                                 2856
1921          GO TO 54341                                                           2857
1922    54360 CONTINUE                                                              2858
1923               CALL BLKIN(BLK,I,BUFFER(NBUF+1))                                 2859
1924          IF (I .NE. 0)GO TO 54380                                              2860
1925    C     EXECUTE (READ_ERROR)                                                  2861
1926          ASSIGN 54390 TO KKK060                                                2861
1927          GO TO 79840                                                               
1928    54390 CONTINUE                                                                  
1929    54380 CONTINUE                                                              2862
1930               NBUF = NBUF + I                                                  2863
1931               PBUF = 1                                                         2864
1932               CALL LINCON(.FALSE.)                                             2865
1933          IF (.NOT.(STOPIT))GO TO 54410                                         2866
1934    C     EXECUTE (CANCEL_COMMAND)                                              2867
1935          ASSIGN 54420 TO KKK068                                                2867
1936          GO TO 79848                                                               
1937    54420 CONTINUE                                                                  
1938    54410 CONTINUE                                                              2868

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  75
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1939          IF ((LINEP + NUMBER) .GT. (NLINES - PAGLEN + 1))GO TO 54440           2869
1940                 LINEP = LINEP + NUMBER                                         2870
1941          GO TO 54341                                                           2871
1942    54440 CONTINUE                                                              2872
1943          IF ((NLINES - LINEP) .LT. (600 - 100))GO TO 54460                     2873
1944                 SECOND = .TRUE.                                                2874
1945                 NUMBER = NUMBER - NLINES + LINEP - 1                           2875
1946                 LINEP = NLINES                                                 2876
1947    54460 CONTINUE                                                              2877
1948          GO TO 54339                                                           2878
1949    54341 CONTINUE                                                                  
1950              IF (SECOND) NUMBER = 25                                           2879
1951          GO TO 54320                                                           2880
1952    54330 CONTINUE                                                                  
1953          IF ((NUMBER + LINEP) .GT. 0)GO TO 54480                               2881
1954    C                                                                               
1955    C***   Big jumps backward                                                       
1956    C                                                                               
1957                NUMBER = -(NUMBER + LINEP)                                      2885
1958                INUMBR = 1 - LINEP                                              2886
1959          IF (.NOT.(RFM .EQ. 1 .AND. RAT .NE. 2 .AND. RAT .NE. -2))GO TO 545    2887
1960         X00                                                                        
1961    C                                                                               
1962    C---   Fixed record length with no carriage-control                             
1963    C                                                                               
1964          IF (RAT .GE. 0)GO TO 54520                                            2891
1965    C===   No spanned                                                               
1966                    BLK = SBLK - NUMBER*IFSZ/RECBLK - 1                         2893
1967                    J = RECBLK/IFSZ - NUMBER + (SBLK-BLK-1)*RECBLK/IFSZ         2894
1968          GO TO 54510                                                           2895
1969    54520 CONTINUE                                                                  
1970    C===   Spanned                                                                  
1971                    I = 512*(CCLINE(1,1) - 1) + CCLINE(2,1) -                   2897
1972         1              IFSZ*NUMBER                                                 
1973                    J = LIB$EXTZV(0,8,I)                                        2899
1974                    IF (J .EQ. 0) J = 512                                       2900
1975                    BLK = I/512 + 1                                             2901
1976    54510 CONTINUE                                                              2902
1977          IF (.NOT.(STOPIT))GO TO 54540                                         2903
1978    C     EXECUTE (CANCEL_COMMAND)                                              2904
1979          ASSIGN 54550 TO KKK068                                                2904
1980          GO TO 79848                                                               
1981    54550 CONTINUE                                                                  
1982    54540 CONTINUE                                                              2905
1983          IF (BLK .GT. 0)GO TO 54570                                            2906
1984                    BLK = 1                                                     2907
1985                    J = 1                                                       2908
1986    54570 CONTINUE                                                              2909
1987    C===   Input lines                                                              
1988    C     EXECUTE (INPUT_SEVEN_BLOCKS)                                          2911
1989          ASSIGN 54580 TO KKK040                                                2911
1990          GO TO 79820                                                               
1991    54580 CONTINUE                                                                  
1992                  CALL LINCON(.TRUE.)                                           2912
1993                  LINEP = J                                                     2913
1994                  NUMBER = 25                                                   2914
1995          GO TO 54490                                                           2915

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  76
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

1996    54500 CONTINUE                                                                  
1997    C                                                                               
1998    C---   Variable length records and/or carriage-control                          
1999    C                                                                               
2000           I=1                                                                  2919
2001          GO TO 54589                                                               
2002    54590  I= I+(1)                                                                 
2003          IF ( I.GT.NLINES)GO TO 54591                                              
2004    54589 CONTINUE                                                                  
2005          IF (CCLINE(1,I) .NE. 0)GO TO 54591                                    2920
2006          GO TO 54590                                                           2921
2007    54591 CONTINUE                                                                  
2008                  BLK = CCLINE(1,I)                                             2922
2009                  PBUF = CCLINE(2,I)                                            2923
2010                  CALL BLKIN(BLK,NBUF,BUFFER)                                   2924
2011          IF (NBUF .NE. 0)GO TO 54610                                           2925
2012    C     EXECUTE (READ_ERROR)                                                  2926
2013          ASSIGN 54620 TO KKK060                                                2926
2014          GO TO 79840                                                               
2015    54620 CONTINUE                                                                  
2016    54610 CONTINUE                                                              2927
2017     1810 CONTINUE                                                              2928
2018                   SECOND = .TRUE.                                              2929
2019     1820 CONTINUE                                                              2930
2020    54639 CONTINUE                                                                  
2021          IF (NUMBER .GE. 0)GO TO 54660                                         2931
2022                      NUMBER = 25                                               2932
2023          GO TO 54641                                                           2933
2024    54660 CONTINUE                                                              2934
2025          IF (RFM .NE. 1)GO TO 54680                                            2935
2026    C                                                                               
2027    C===  Fixed length records (must have carriage-control)                         
2028    C                                                                               
2029                      PBUF = PBUF - IFSZ                                        2939
2030          IF (PBUF .GE. 1)GO TO 54700                                           2940
2031                        BLK = BLK - 2                                           2941
2032          IF (BLK .GT. 0)GO TO 54720                                            2942
2033    C     EXECUTE (HIT_BEGINNING)                                               2943
2034          ASSIGN 54730 TO KKK084                                                2943
2035          GO TO 79864                                                               
2036    54730 CONTINUE                                                                  
2037          IF (.NOT.(SECOND))GO TO 54750                                         2944
2038                            NUMBER = INUMBR                                     2945
2039          GO TO 54740                                                           2946
2040    54750 CONTINUE                                                                  
2041                            NUMBER = 25                                         2947
2042    54740 CONTINUE                                                              2948
2043          GO TO 54631                                                           2949
2044    54720 CONTINUE                                                              2950
2045                        CALL BLKIN(BLK,NBUF,BUFFER)                             2951
2046          IF (NBUF .NE. 0)GO TO 54770                                           2952
2047    C     EXECUTE (READ_ERROR)                                                  2953
2048          ASSIGN 54780 TO KKK060                                                2953
2049          GO TO 79840                                                               
2050    54780 CONTINUE                                                                  
2051    54770 CONTINUE                                                              2954
2052                        SECOND = .FALSE.                                        2955

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  77
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2053                        PBUF = PBUF + NBUF                                      2956
2054    54700 CONTINUE                                                              2957
2055          IF (BUFFER(PBUF) .NE. '1')GO TO 54800                                 2958
2056                        NUMBER = NUMBER - 3                                     2959
2057          GO TO 54790                                                           2960
2058    54800 CONTINUE                                                                  
2059          IF (BUFFER(PBUF) .NE. '0')GO TO 54820                                 2961
2060                          NUMBER = NUMBER - 2                                   2962
2061          GO TO 54810                                                           2963
2062    54820 CONTINUE                                                                  
2063                          NUMBER = NUMBER - 1                                   2964
2064    54810 CONTINUE                                                              2965
2065    54790 CONTINUE                                                              2966
2066          GO TO 54670                                                           2967
2067    54680 CONTINUE                                                                  
2068    C                                                                               
2069    C===   Variable length records                                                  
2070    C                                                                               
2071    54829 CONTINUE                                                              2971
2072           I=PBUF-1                                                             2972
2073          GO TO 54839                                                               
2074    54840  I= I+(-1)                                                                
2075          IF ( I.LT.2)GO TO 54841                                                   
2076    54839 CONTINUE                                                                  
2077          IF (I)GO TO 54860                                                     2973
2078          IF (BUFFER(I) .NE. 0)GO TO 54880                                      2974
2079                            J = LIB$EXTZV(0,8,BUFFER(I-1))                      2975
2080          IF (J .GT. LRL)GO TO 54900                                            2976
2081                              IF (J) J = J + 1                                  2977
2082          IF (BUFFER(I+J+2) .NE. 0)GO TO 54920                                  2978
2083          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 54940                    2979
2084          IF (BUFFER(I+FSZ+1) .NE. '1')GO TO 54960                              2980
2085                                    NUMBER = NUMBER - 3                         2981
2086          GO TO 54950                                                           2982
2087    54960 CONTINUE                                                                  
2088          IF (BUFFER(I+FSZ+1) .NE. '0')GO TO 54980                              2983
2089                                      NUMBER = NUMBER - 2                       2984
2090          GO TO 54970                                                           2985
2091    54980 CONTINUE                                                                  
2092                                      NUMBER = NUMBER - 1                       2986
2093    54970 CONTINUE                                                              2987
2094    54950 CONTINUE                                                              2988
2095          GO TO 54930                                                           2989
2096    54940 CONTINUE                                                                  
2097                                  NUMBER = NUMBER - 1                           2990
2098          IF (.NOT.(RAT .EQ. 3 .OR. RAT .EQ. -3))GO TO 55000                    2991
2099                                    IF (LIB$EXTZV(7,1,BUFFER(I+1)) .EQ. 0)      2992
2100         1                              NUMBER = NUMBER -                           
2101         2                              LIB$EXTZV(0,7,BUFFER(I+1))                  
2102                                    IF (LIB$EXTZV(7,1,BUFFER(I+2)) .EQ. 0)      2995
2103         1                              NUMBER = NUMBER -                           
2104         2                              LIB$EXTZV(0,7,BUFFER(I+2))                  
2105    55000 CONTINUE                                                              2998
2106    54930 CONTINUE                                                              2999
2107                                PBUF = I - 1                                    3000
2108          GO TO 54640                                                           3001
2109    54920 CONTINUE                                                              3002

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  78
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2110    54900 CONTINUE                                                              3003
2111    54880 CONTINUE                                                              3004
2112    54860 CONTINUE                                                              3005
2113          IF (.NOT.(STOPIT))GO TO 55020                                         3006
2114    C     EXECUTE (CANCEL_COMMAND)                                              3007
2115          ASSIGN 55030 TO KKK068                                                3007
2116          GO TO 79848                                                               
2117    55030 CONTINUE                                                                  
2118    55020 CONTINUE                                                              3008
2119          GO TO 54840                                                           3009
2120    54841 CONTINUE                                                                  
2121    C===  New block                                                                 
2122           I=1                                                                  3011
2123          GO TO 55039                                                               
2124    55040  I= I+(1)                                                                 
2125          IF ( I.GT.150)GO TO 55041                                                 
2126    55039 CONTINUE                                                                  
2127                        CAPBUF(I) = BUFFER(I)                                   3012
2128          GO TO 55040                                                           3013
2129    55041 CONTINUE                                                                  
2130                       BLK = BLK - 2                                            3014
2131          IF (BLK .GT. 0)GO TO 55060                                            3015
2132          IF (.NOT.(SECOND))GO TO 55080                                         3016
2133                           NUMBER = INUMBR                                      3017
2134          GO TO 55070                                                           3018
2135    55080 CONTINUE                                                                  
2136                           NUMBER = 25                                          3019
2137    55070 CONTINUE                                                              3020
2138    C     EXECUTE (HIT_BEGINNING)                                               3021
2139          ASSIGN 55090 TO KKK084                                                3021
2140          GO TO 79864                                                               
2141    55090 CONTINUE                                                                  
2142          GO TO 54631                                                           3022
2143    55060 CONTINUE                                                              3023
2144                       CALL BLKIN(BLK,PBUF,BUFFER)                              3024
2145          IF (PBUF .NE. 0)GO TO 55110                                           3025
2146    C     EXECUTE (READ_ERROR)                                                  3026
2147          ASSIGN 55120 TO KKK060                                                3026
2148          GO TO 79840                                                               
2149    55120 CONTINUE                                                                  
2150    55110 CONTINUE                                                              3027
2151                       SECOND = .FALSE.                                         3028
2152           I=1                                                                  3029
2153          GO TO 55129                                                               
2154    55130  I= I+(1)                                                                 
2155          IF ( I.GT.150)GO TO 55131                                                 
2156    55129 CONTINUE                                                                  
2157                        BUFFER(PBUF+I) = CAPBUF(I)                              3030
2158          GO TO 55130                                                           3031
2159    55131 CONTINUE                                                                  
2160          GO TO 54829                                                           3032
2161    54670 CONTINUE                                                              3033
2162    54640 GO TO 54639                                                           3034
2163    54641 CONTINUE                                                                  
2164                   BLK = BLK - 1                                                3035
2165                   J = PBUF                                                     3036
2166    C     EXECUTE (INPUT_SEVEN_BLOCKS)                                          3037

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  79
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2167          ASSIGN 55140 TO KKK040                                                3037
2168          GO TO 79820                                                               
2169    55140 CONTINUE                                                                  
2170                   CALL LINCON(.TRUE.)                                          3038
2171           I=1                                                                  3039
2172          GO TO 55149                                                               
2173    55150  I= I+(1)                                                                 
2174          IF ( I.GT.NLINES)GO TO 55151                                              
2175    55149 CONTINUE                                                                  
2176          IF (.NOT.(CCLINE(1,I) .EQ. SBLK .AND. CCLINE(2,I) .EQ. J))GO TO 55    3040
2177         X170                                                                       
2178                      LINEP = I                                                 3041
2179          GO TO 55151                                                           3042
2180    55170 CONTINUE                                                              3043
2181          GO TO 55150                                                           3044
2182    55151 CONTINUE                                                                  
2183    54631 CONTINUE                                                              3045
2184    54490 CONTINUE                                                              3046
2185          GO TO 54470                                                           3047
2186    54480 CONTINUE                                                                  
2187    C                                                                               
2188    C---   Jumps within the stored buffer                                           
2189    C                                                                               
2190                LINEP = LINEP + NUMBER                                          3051
2191    54470 CONTINUE                                                              3052
2192    54320 CONTINUE                                                              3053
2193    C     EXECUTE (CANCEL_STOPPER)                                              3054
2194          ASSIGN 55180 TO KKK032                                                3054
2195          GO TO 79812                                                               
2196    55180 CONTINUE                                                                  
2197          GO TO KKK028                                                          3055
2198    C                                                                               
2199    C                                                                               
2200    C.......................................................................        
2201    C     PROCEDURE (OUTPUT_RANGE)                                              3056
2202    79836 CONTINUE                                                              3056
2203    CP    This procedure performs the output for the print, list, and append        
2204    CP    commands.  Which is being used is determined by the value of PRINT        
2205    CP    (-1 = print, 0 = append, 1 = list).                                       
2206    C                                                                               
2207    C---   Open printer output file                                                 
2208    C                                                                               
2209            CALL PRTOPN(PRINT)                                                  3063
2210          IF (PRINT .NE. 47)GO TO 55200                                         3064
2211    C     EXECUTE (ERROR_EXIT)                                                  3065
2212          ASSIGN 55210 TO KKK024                                                3065
2213          GO TO 79804                                                               
2214    55210 CONTINUE                                                                  
2215    55200 CONTINUE                                                              3066
2216    C     EXECUTE (HOLD_CURRENT_SETUP)                                          3067
2217          ASSIGN 55220 TO KKK026                                                3067
2218          GO TO 79806                                                               
2219    55220 CONTINUE                                                                  
2220    C                                                                               
2221    C---   Point to right place                                                     
2222    C                                                                               
2223          IF (.NOT.(NUMFLG))GO TO 55240                                         3071

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  80
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2224              NUMBER = DIRECT*ANUMB                                             3072
2225              RFLAG = .FALSE.                                                   3073
2226          GO TO 55230                                                           3074
2227    55240 CONTINUE                                                                  
2228          IF (RANGE(1,2) .NE. 0)GO TO 55260                                     3075
2229                NUMBER = PAGLEN                                                 3076
2230                RFLAG = .FALSE.                                                 3077
2231          GO TO 55250                                                           3078
2232    55260 CONTINUE                                                                  
2233                RFLAG = .TRUE.                                                  3079
2234    55250 CONTINUE                                                              3080
2235    55230 CONTINUE                                                              3081
2236          IF (.NOT.(RFLAG))GO TO 55280                                          3082
2237          IF (.NOT.(RANGE(1,1) .LT. RANGE(1,2) .OR. (RANGE(1,1) .EQ.            3083
2238         X          RANGE(1,2) .AND. RANGE(2,1) .LE. RANGE(2,2))))GO TO 5530        
2239         X0                                                                         
2240                BLK = RANGE(1,1)                                                3085
2241                PBUF = RANGE(2,1)                                               3086
2242                IENDPB = RANGE(1,2)                                             3087
2243                IENDPP = RANGE(2,2)                                             3088
2244          GO TO 55290                                                           3089
2245    55300 CONTINUE                                                                  
2246                BLK = RANGE(1,2)                                                3090
2247                PBUF = RANGE(2,2)                                               3091
2248                IENDPB = RANGE(1,1)                                             3092
2249                IENDPP = RANGE(2,1)                                             3093
2250    55290 CONTINUE                                                              3094
2251              SBLK = BLK                                                        3095
2252              CALL BLKIN(BLK,NBUF,BUFFER)                                       3096
2253          IF (NBUF .NE. 0)GO TO 55320                                           3097
2254    C     EXECUTE (READ_ERROR)                                                  3098
2255          ASSIGN 55330 TO KKK060                                                3098
2256          GO TO 79840                                                               
2257    55330 CONTINUE                                                                  
2258    55320 CONTINUE                                                              3099
2259          GO TO 55270                                                           3100
2260    55280 CONTINUE                                                                  
2261          IF (NUMBER .GE. 0)GO TO 55350                                         3101
2262                INUMB = NUMBER                                                  3102
2263    C     EXECUTE (FIND_NON_CC_LINE)                                            3103
2264          ASSIGN 55360 TO KKK038                                                3103
2265          GO TO 79818                                                               
2266    55360 CONTINUE                                                                  
2267                IENDPB = CCLINE(1,I)                                            3104
2268                IENDPP = CCLINE(2,I)                                            3105
2269    C     EXECUTE (JUMP_LINES)                                                  3106
2270          ASSIGN 55370 TO KKK028                                                3106
2271          GO TO 79808                                                               
2272    55370 CONTINUE                                                                  
2273                NUMBER = -1000                                                  3107
2274    55350 CONTINUE                                                              3108
2275    C     EXECUTE (FIND_NON_CC_LINE)                                            3109
2276          ASSIGN 55380 TO KKK038                                                3109
2277          GO TO 79818                                                               
2278    55380 CONTINUE                                                                  
2279              BLK = CCLINE(1,I)                                                 3110
2280              PBUF = CCLINE(2,I)                                                3111

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  81
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2281              SBLK = BLK                                                        3112
2282              CALL BLKIN(BLK,NBUF,BUFFER)                                       3113
2283          IF (NBUF .NE. 0)GO TO 55400                                           3114
2284    C     EXECUTE (READ_ERROR)                                                  3115
2285          ASSIGN 55410 TO KKK060                                                3115
2286          GO TO 79840                                                               
2287    55410 CONTINUE                                                                  
2288    55400 CONTINUE                                                              3116
2289    55270 CONTINUE                                                              3117
2290            IBLK = SBLK                                                         3118
2291    C                                                                               
2292    C---   Print loop                                                               
2293    C                                                                               
2294    55419 CONTINUE                                                              3122
2295          IF (.NOT.(STOPIT))GO TO 55440                                         3123
2296               CALL PRTCLS(STOPIT)                                              3124
2297    C     EXECUTE (RESTORE_HELD_SETUP)                                          3125
2298          ASSIGN 55450 TO KKK054                                                3125
2299          GO TO 79834                                                               
2300    55450 CONTINUE                                                                  
2301    C     EXECUTE (FREE_FLAGS_EXIT)                                             3126
2302          ASSIGN 55460 TO KKK064                                                3126
2303          GO TO 79844                                                               
2304    55460 CONTINUE                                                                  
2305               RETURN                                                           3127
2306    55440 CONTINUE                                                              3128
2307          IF (RFM .NE. 1)GO TO 55480                                            3129
2308               I = FSZ                                                          3130
2309          GO TO 55470                                                           3131
2310    55480 CONTINUE                                                                  
2311               I = LIB$EXTZV(0,8,BUFFER(PBUF))                                  3132
2312    55470 CONTINUE                                                              3133
2313          IF (.NOT.(I))GO TO 55500                                              3134
2314               K = 1                                                            3135
2315          GO TO 55490                                                           3136
2316    55500 CONTINUE                                                                  
2317               K = 0                                                            3137
2318    55490 CONTINUE                                                              3138
2319          IF (.NOT.((PBUF + I + K - 1) .GT. NBUF .OR. (RFM .NE. 1 .AND.         3139
2320         X          (PBUF + K + I + 1) .GT. NBUF)))GO TO 55520                      
2321          IF (BLK .GT. EBK)GO TO 55421                                          3141
2322           J=PBUF                                                               3142
2323          GO TO 55529                                                               
2324    55530  J= J+(1)                                                                 
2325          IF ( J.GT.NBUF)GO TO 55531                                                
2326    55529 CONTINUE                                                                  
2327                BUFFER(J-PBUF+1) = BUFFER(J)                                    3143
2328          GO TO 55530                                                           3144
2329    55531 CONTINUE                                                                  
2330               IBLK = BLK                                                       3145
2331               CALL BLKIN(BLK,J,BUFFER(NBUF-PBUF+2))                            3146
2332          IF (J .NE. 0)GO TO 55550                                              3147
2333    C     EXECUTE (READ_ERROR)                                                  3148
2334          ASSIGN 55560 TO KKK060                                                3148
2335          GO TO 79840                                                               
2336    55560 CONTINUE                                                                  
2337    55550 CONTINUE                                                              3149

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  82
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2338          IF (.NOT.(PBUF .GT. NBUF .AND. RFM .NE. 1))GO TO 55580                3150
2339                 I = LIB$EXTZV(0,8,BUFFER(1))                                   3151
2340          IF (.NOT.(I))GO TO 55600                                              3152
2341                   K = 1                                                        3153
2342          GO TO 55590                                                           3154
2343    55600 CONTINUE                                                                  
2344                   K = 0                                                        3155
2345    55590 CONTINUE                                                              3156
2346    55580 CONTINUE                                                              3157
2347               INDSFT = PBUF - NBUF - 1                                         3158
2348               NBUF = NBUF - PBUF + J + 1                                       3159
2349               PBUF = 1                                                         3160
2350    55520 CONTINUE                                                              3161
2351             J = PBUF + INDSFT                                                  3162
2352          IF (RFM .EQ. 1)GO TO 55620                                            3163
2353               PBUF = PBUF + 2 + FSZ                                            3164
2354               I = I - FSZ                                                      3165
2355    55620 CONTINUE                                                              3166
2356          IF (RFLAG)GO TO 55640                                                 3167
2357          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 55660                    3168
2358          IF (BUFFER(PBUF) .NE. '0')GO TO 55680                                 3169
2359                   NUMBER = NUMBER - 1                                          3170
2360          GO TO 55670                                                           3171
2361    55680 CONTINUE                                                                  
2362                   IF (BUFFER(PBUF) .EQ. '1') NUMBER = NUMBER - 2               3172
2363    55670 CONTINUE                                                              3173
2364          GO TO 55650                                                           3174
2365    55660 CONTINUE                                                                  
2366          IF (.NOT.(RAT .EQ. 3 .OR. RAT .EQ. -3))GO TO 55700                    3175
2367                   IF (LIB$EXTZV(7,1,BUFFER(PBUF-2)) .EQ. 0)                    3176
2368         1             NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-2))              
2369                   IF (LIB$EXTZV(7,1,BUFFER(PBUF-1)) .EQ. 0)                    3178
2370         1             NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-1))              
2371    55700 CONTINUE                                                              3180
2372    55650 CONTINUE                                                              3181
2373    55640 CONTINUE                                                              3182
2374             CALL PRTOUT(I,BUFFER(PBUF))                                        3183
2375             IF (.NOT.RFLAG) NUMBER = NUMBER - 1                                3184
2376             PBUF = PBUF + I + K                                                3185
2377          IF ((.NOT.RFLAG .AND. NUMBER .LE. 0) .OR. (RFLAG .AND.                3186
2378         X    (IBLK .GT. IENDPB .OR. (IBLK .LE. IENDPB .AND.                        
2379         X    J .GE. (IENDPP + 512*(IENDPB - IBLK))))))GO TO 55421                  
2380          GO TO 55419                                                           3189
2381    55421 CONTINUE                                                                  
2382            CALL PRTCLS                                                         3190
2383    C     EXECUTE (RESTORE_HELD_SETUP)                                          3191
2384          ASSIGN 55710 TO KKK054                                                3191
2385          GO TO 79834                                                               
2386    55710 CONTINUE                                                                  
2387    C     EXECUTE (FREE_FLAGS_EXIT)                                             3192
2388          ASSIGN 55720 TO KKK064                                                3192
2389          GO TO 79844                                                               
2390    55720 CONTINUE                                                                  
2391          GO TO KKK056                                                          3193
2392    C                                                                               
2393    C                                                                               
2394    C.......................................................................        

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  83
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2395    C     PROCEDURE (QUEUE_STOPPER)                                             3194
2396    79828 CONTINUE                                                              3194
2397    CP    This procedure sets up an AST to allow the user to stop an                
2398    CP    operation.                                                                
2399            STOPIT = .FALSE.                                                    3197
2400            CALL LIB$GET_EF(IOFLAG)                                             3198
2401          IF (IOFLAG .NE. -1)GO TO 55740                                        3199
2402              CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//       3200
2403         1                        'flag.  OPERATION ABORTED.',COMLIN,20)            
2404    C     EXECUTE (ERROR_EXIT)                                                  3202
2405          ASSIGN 55750 TO KKK024                                                3202
2406          GO TO 79804                                                               
2407    55750 CONTINUE                                                                  
2408    55740 CONTINUE                                                              3203
2409            CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,          3204
2410         1               STOPSC,,INBUF,%VAL(1),,,,)                                 
2411          GO TO KKK048                                                          3206
2412    C                                                                               
2413    C                                                                               
2414    C.......................................................................        
2415    C     PROCEDURE (READ_ERROR)                                                3207
2416    79840 CONTINUE                                                              3207
2417    CP    This procedure terminates program execution with an error message.        
2418    CP    It is used when an input error occurs.                                    
2419            CALL RESTRM(INCHAN)                                                 3210
2420            CALL BLKCLS                                                         3211
2421            CLOSE (UNIT=9)                                                      3212
2422            CALL SYS$DASSGN(%VAL(INCHAN))                                       3213
2423            CALL LIB$PUT_OUTPUT(CRLF//'ERROR READING FILE')                     3214
2424            CALL EXIT                                                           3215
2425          GO TO KKK060                                                          3216
2426    C                                                                               
2427    C                                                                               
2428    C.......................................................................        
2429    C     PROCEDURE (REFRESH_EXIT)                                              3217
2430    79816 CONTINUE                                                              3217
2431    CP    This procedure refreshes the screen (puts up a new set of lines           
2432    CP    corresponding to the current line position), resets the LEDs (#3          
2433    CP    off).                                                                     
2434            CALL WORKNG(.FALSE.)                                                3221
2435          IF (NLINES .GE. PAGEND)GO TO 55770                                    3222
2436    55779 CONTINUE                                                              3223
2437          IF (BLK .LE. EBK)GO TO 55800                                          3224
2438                 PAGEND = NLINES                                                3225
2439          GO TO 55781                                                           3226
2440    55800 CONTINUE                                                              3227
2441                 CALL BLKIN(BLK,I,BUFFER(NBUF+1))                               3228
2442          IF (I .NE. 0)GO TO 55820                                              3229
2443    C     EXECUTE (READ_ERROR)                                                  3230
2444          ASSIGN 55830 TO KKK060                                                3230
2445          GO TO 79840                                                               
2446    55830 CONTINUE                                                                  
2447    55820 CONTINUE                                                              3231
2448                 NBUF = NBUF + I                                                3232
2449                 PBUF = 1                                                       3233
2450                 CALL LINCON(.FALSE.)                                           3234
2451          IF (NLINES .GE. PAGEND)GO TO 55781                                    3235

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  84
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2452          GO TO 55779                                                           3237
2453    55781 CONTINUE                                                                  
2454    55770 CONTINUE                                                              3238
2455            CALL LIB$ERASE_PAGE(1,1)                                            3239
2456           I=LINEP                                                              3240
2457          GO TO 55839                                                               
2458    55840  I= I+(1)                                                                 
2459          IF ( I.GT.PAGEND)GO TO 55841                                              
2460    55839 CONTINUE                                                                  
2461          IF (LENLMT .LE. 0)GO TO 55860                                         3241
2462          IF (LENLMT .LE. LINLEN(I))GO TO 55880                                 3242
2463                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                3243
2464          GO TO 55870                                                           3244
2465    55880 CONTINUE                                                                  
2466                 CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)                   3245
2467    55870 CONTINUE                                                              3246
2468          GO TO 55850                                                           3247
2469    55860 CONTINUE                                                                  
2470          IF (LINLEN(I) .GT. -LENLMT)GO TO 55900                                3248
2471                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)                3249
2472          GO TO 55890                                                           3250
2473    55900 CONTINUE                                                                  
2474                 CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//                 3251
2475         1                           LINES(I)(1-LENLMT:LINLEN(I))//CRLF)            
2476    55890 CONTINUE                                                              3253
2477    55850 CONTINUE                                                              3254
2478          GO TO 55840                                                           3255
2479    55841 CONTINUE                                                                  
2480    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          3256
2481          ASSIGN 55910 TO KKK062                                                3256
2482          GO TO 79842                                                               
2483    55910 CONTINUE                                                                  
2484    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         3257
2485          ASSIGN 55920 TO KKK046                                                3257
2486          GO TO 79826                                                               
2487    55920 CONTINUE                                                                  
2488          GO TO KKK036                                                          3258
2489    C                                                                               
2490    C                                                                               
2491    C.......................................................................        
2492    C     PROCEDURE (RESTORE_HELD_SETUP)                                        3259
2493    79834 CONTINUE                                                              3259
2494    CP    This routine is used in searches.  It restores the position and           
2495    CP    arrays that have previously been saved by HOLD_CURRENT_SETUP.             
2496            CALL WORKNG(.FALSE.)                                                3262
2497            NBUF = HNBUF                                                        3263
2498            PBUF = HPBUF                                                        3264
2499            NLINES = HLINES                                                     3265
2500            LINEP = HLINEP                                                      3266
2501           I=1                                                                  3267
2502          GO TO 55929                                                               
2503    55930  I= I+(1)                                                                 
2504          IF ( I.GT.NLINES)GO TO 55931                                              
2505    55929 CONTINUE                                                                  
2506             LINES(I) = HLIN(I)                                                 3268
2507             LINLEN(I) = HLINLN(I)                                              3269
2508             CCLINE(1,I) = HCCLIN(1,I)                                          3270

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  85
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2509             CCLINE(2,I) = HCCLIN(2,I)                                          3271
2510          GO TO 55930                                                           3272
2511    55931 CONTINUE                                                                  
2512          IF (NBUF .EQ. 0)GO TO 55950                                           3273
2513           I=1                                                                  3274
2514          GO TO 55959                                                               
2515    55960  I= I+(1)                                                                 
2516          IF ( I.GT.NBUF)GO TO 55961                                                
2517    55959 CONTINUE                                                                  
2518               BUFFER(I) = HBUFER(I)                                            3275
2519          GO TO 55960                                                           3276
2520    55961 CONTINUE                                                                  
2521    55950 CONTINUE                                                              3277
2522            BLK = HBLK                                                          3278
2523            SBLK = HSBLK                                                        3279
2524            LBLK = HLBLK                                                        3280
2525            LPBUF = HLPBUF                                                      3281
2526          GO TO KKK054                                                          3282
2527    C                                                                               
2528    C                                                                               
2529    C.......................................................................        
2530    C     PROCEDURE (SCROLL_BLANK_LINE_POST)                                    3283
2531    79858 CONTINUE                                                              3283
2532    CP    This routine is used in scrolling backwards in non-FIXfiles.  It prints   
2533    CP    a blank line then waits for one timer interval (which is set by the       
2534    CP    scrolling speed), and then checks for the stop signal.                    
2535    C     EXECUTE (SCROLL_DOWN)                                                 3287
2536          ASSIGN 55970 TO KKK070                                                3287
2537          GO TO 79850                                                               
2538    55970 CONTINUE                                                                  
2539    C     EXECUTE (WAIT_FOR_SCROLL_AST)                                         3288
2540          ASSIGN 55980 TO KKK072                                                3288
2541          GO TO 79852                                                               
2542    55980 CONTINUE                                                                  
2543          IF (.NOT.(STOPIT))GO TO 56000                                         3289
2544    C     EXECUTE (VAR_BACK_SCROLL_EXIT)                                        3290
2545          ASSIGN 56010 TO KKK082                                                3290
2546          GO TO 79862                                                               
2547    56010 CONTINUE                                                                  
2548    56000 CONTINUE                                                              3291
2549          GO TO KKK078                                                          3292
2550    C                                                                               
2551    C                                                                               
2552    C.......................................................................        
2553    C     PROCEDURE (SCROLL_BLANK_LINE_PRE)                                     3293
2554    79856 CONTINUE                                                              3293
2555    CP    This routine is used in scrolling backward in FIX files.  It waits        
2556    CP    one timer interval (set by scrolling speed), checks for the stop          
2557    CP    signal, then writes one blank line.                                       
2558    C     EXECUTE (WAIT_FOR_SCROLL)                                             3297
2559          ASSIGN 56020 TO KKK074                                                3297
2560          GO TO 79854                                                               
2561    56020 CONTINUE                                                                  
2562          IF (.NOT.(STOPIT))GO TO 56040                                         3298
2563    C     EXECUTE (BACK_SCROLL_EXIT)                                            3299
2564          ASSIGN 56050 TO KKK058                                                3299
2565          GO TO 79838                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  86
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2566    56050 CONTINUE                                                                  
2567    56040 CONTINUE                                                              3300
2568    C     EXECUTE (SCROLL_DOWN)                                                 3301
2569          ASSIGN 56060 TO KKK070                                                3301
2570          GO TO 79850                                                               
2571    56060 CONTINUE                                                                  
2572            CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,          3302
2573         1               STOPSC,,INBUF,%VAL(1),,,,)                                 
2574          GO TO KKK076                                                          3304
2575    C                                                                               
2576    C                                                                               
2577    C.......................................................................        
2578    C     PROCEDURE (SCROLL_BLANK_LINE_VAR_PRE)                                 3305
2579    79860 CONTINUE                                                              3305
2580    CP    This routine is used in scrolling backward in non-FIX files.  It          
2581    CP    waits for one timer interval (set by scrolling speed), checks for         
2582    CP    the stop signal, and then writes one blank line.                          
2583    C     EXECUTE (WAIT_FOR_SCROLL)                                             3309
2584          ASSIGN 56070 TO KKK074                                                3309
2585          GO TO 79854                                                               
2586    56070 CONTINUE                                                                  
2587          IF (.NOT.(STOPIT))GO TO 56090                                         3310
2588    C     EXECUTE (VAR_BACK_SCROLL_EXIT)                                        3311
2589          ASSIGN 56100 TO KKK082                                                3311
2590          GO TO 79862                                                               
2591    56100 CONTINUE                                                                  
2592    56090 CONTINUE                                                              3312
2593    C     EXECUTE (SCROLL_DOWN)                                                 3313
2594          ASSIGN 56110 TO KKK070                                                3313
2595          GO TO 79850                                                               
2596    56110 CONTINUE                                                                  
2597            CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,          3314
2598         1               STOPSC,,INBUF,%VAL(1),,,,)                                 
2599          GO TO KKK080                                                          3316
2600    C                                                                               
2601    C                                                                               
2602    C.......................................................................        
2603    C     PROCEDURE (SCROLL_DOWN)                                               3317
2604    79850 CONTINUE                                                              3317
2605    CP    This procedure scrolls the screen down one line and leaves the            
2606    CP    cursor at the upper left hand corner.                                     
2607            CALL SYS$CANCEL(%VAL(INCHAN))                                       3320
2608            CALL LIB$SET_CURSOR(1,1)                                            3321
2609            CALL LIB$DOWN_SCROLL()                                              3322
2610            CALL LIB$SET_CURSOR(1,1)                                            3323
2611          GO TO KKK070                                                          3324
2612    C                                                                               
2613    C                                                                               
2614    C.......................................................................        
2615    C     PROCEDURE (SCROLL_REFRESH_EXIT)                                       3325
2616    79814 CONTINUE                                                              3325
2617    CP    This procedure scrolls to the proper line, resets the LED's (#3           
2618    CP    off).                                                                     
2619            CALL WORKNG(.FALSE.)                                                3328
2620          IF (NUMBER .LE. 0)GO TO 56130                                         3329
2621    C                                                                               
2622    C***   Forward scrolling                                                        

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  87
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2623    C                                                                               
2624          IF (OLDEND .EQ. PAGEND)GO TO 56150                                    3333
2625    C                                                                               
2626    C---   Make sure there is something to do                                       
2627    C                                                                               
2628    C---   Get extra lines if necessary                                             
2629    C                                                                               
2630          IF (NLINES .GE. PAGEND)GO TO 56170                                    3339
2631    56179 CONTINUE                                                              3340
2632          IF (BLK .LE. EBK)GO TO 56200                                          3341
2633                     PAGEND = NLINES                                            3342
2634          GO TO 56181                                                           3343
2635    56200 CONTINUE                                                              3344
2636                     CALL BLKIN(BLK,I,BUFFER(NBUF+1))                           3345
2637          IF (I .NE. 0)GO TO 56220                                              3346
2638    C     EXECUTE (READ_ERROR)                                                  3347
2639          ASSIGN 56230 TO KKK060                                                3347
2640          GO TO 79840                                                               
2641    56230 CONTINUE                                                                  
2642    56220 CONTINUE                                                              3348
2643                     NBUF = NBUF + I                                            3349
2644                     PBUF = 1                                                   3350
2645                     CALL LINCON(.FALSE.)                                       3351
2646          IF (NLINES .GE. PAGEND)GO TO 56181                                    3352
2647          GO TO 56179                                                           3354
2648    56181 CONTINUE                                                                  
2649    56170 CONTINUE                                                              3355
2650    C                                                                               
2651    C---   Output new lines                                                         
2652    C                                                                               
2653           I=PAGLEN+1                                                           3359
2654          GO TO 56239                                                               
2655    56240  I= I+(1)                                                                 
2656          IF ( I.GT.COMLIN)GO TO 56241                                              
2657    56239 CONTINUE                                                                  
2658                 CALL LIB$ERASE_LINE(I,1)                                       3360
2659          GO TO 56240                                                           3361
2660    56241 CONTINUE                                                                  
2661                CALL LIB$SET_CURSOR(PAGLEN+1,1)                                 3362
2662           I=OLDEND+1                                                           3363
2663          GO TO 56249                                                               
2664    56250  I= I+(1)                                                                 
2665          IF ( I.GT.PAGEND)GO TO 56251                                              
2666    56249 CONTINUE                                                                  
2667          IF (LENLMT .LE. 0)GO TO 56270                                         3364
2668          IF (LINLEN(I) .LT. LENLMT)GO TO 56290                                 3365
2669                     CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)               3366
2670          GO TO 56280                                                           3367
2671    56290 CONTINUE                                                                  
2672                     CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)            3368
2673    56280 CONTINUE                                                              3369
2674          GO TO 56260                                                           3370
2675    56270 CONTINUE                                                                  
2676          IF (LINLEN(I) .GT. -LENLMT)GO TO 56310                                3371
2677                     CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)            3372
2678          GO TO 56300                                                           3373
2679    56310 CONTINUE                                                                  

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  88
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2680                     CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//             3374
2681         1                LINES(I)(1-LENLMT:LINLEN(I))//CRLF)                       
2682    56300 CONTINUE                                                              3376
2683    56260 CONTINUE                                                              3377
2684          GO TO 56250                                                           3378
2685    56251 CONTINUE                                                                  
2686    56150 CONTINUE                                                              3379
2687          GO TO 56120                                                           3380
2688    56130 CONTINUE                                                                  
2689          IF (NUMBER .GE. 0)GO TO 56330                                         3381
2690    C                                                                               
2691    C***   Backward scrolling                                                       
2692    C                                                                               
2693           I=LINEP-NUMBER-1                                                     3385
2694          GO TO 56339                                                               
2695    56340  I= I+(-1)                                                                
2696          IF ( I.LT.LINEP)GO TO 56341                                               
2697    56339 CONTINUE                                                                  
2698    C     EXECUTE (SCROLL_DOWN)                                                 3386
2699          ASSIGN 56350 TO KKK070                                                3386
2700          GO TO 79850                                                               
2701    56350 CONTINUE                                                                  
2702          IF (ABS(LENLMT) .LT. LINLEN(I))GO TO 56370                            3387
2703                   CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)))                    3388
2704          GO TO 56360                                                           3389
2705    56370 CONTINUE                                                                  
2706          IF (LENLMT .GE. 0)GO TO 56390                                         3390
2707    C                                                                               
2708    C---   This assumes that LINLEN<=2*LENLMT                                       
2709    C                                                                               
2710    C     EXECUTE (SCROLL_DOWN)                                                 3394
2711          ASSIGN 56400 TO KKK070                                                3394
2712          GO TO 79850                                                               
2713    56400 CONTINUE                                                                  
2714                     CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//             3395
2715         1                               LINES(I)(1-LENLMT:LINLEN(I)))              
2716          GO TO 56380                                                           3397
2717    56390 CONTINUE                                                                  
2718                     CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT))                     3398
2719    56380 CONTINUE                                                              3399
2720    56360 CONTINUE                                                              3400
2721          GO TO 56340                                                           3401
2722    56341 CONTINUE                                                                  
2723    56330 CONTINUE                                                              3402
2724              CALL LIB$SET_CURSOR(PAGLEN+1,1)                                   3403
2725    56120 CONTINUE                                                              3404
2726    C     EXECUTE (WRITE_BLOCK_NUMBER)                                          3405
2727          ASSIGN 56410 TO KKK062                                                3405
2728          GO TO 79842                                                               
2729    56410 CONTINUE                                                                  
2730    C     EXECUTE (HOME_PLUS_LEDS_EXIT)                                         3406
2731          ASSIGN 56420 TO KKK046                                                3406
2732          GO TO 79826                                                               
2733    56420 CONTINUE                                                                  
2734          GO TO KKK034                                                          3407
2735    C                                                                               
2736    C                                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  89
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2737    C.......................................................................        
2738    C     PROCEDURE (SEARCH_ERROR_EXIT)                                         3408
2739    79846 CONTINUE                                                              3408
2740    CP    This procedure stops execution of a search command with an error.         
2741    CP    while restoring the held setup and getting rid of the I/O request         
2742    CP    to the terminal                                                           
2743    C     EXECUTE (CANCEL_STOPPER)                                              3412
2744          ASSIGN 56430 TO KKK032                                                3412
2745          GO TO 79812                                                               
2746    56430 CONTINUE                                                                  
2747            IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                             3413
2748            JJ = 1                                                              3414
2749           I=1                                                                  3415
2750          GO TO 56439                                                               
2751    56440  I= I+(1)                                                                 
2752          IF ( I.GT.10)GO TO 56441                                                  
2753    56439 CONTINUE                                                                  
2754          IF (SBFLEN(I) .EQ. 0 .OR. JJ .GT. (IABS(LENLMT) - 58))GO TO 56441     3416
2755             CAPLIN(JJ:) = SRCHBF(I)(:SBFLEN(I))                                3417
2756             JJ = SBFLEN(I) + JJ + 2                                            3418
2757          GO TO 56440                                                           3419
2758    56441 CONTINUE                                                                  
2759            IF (JJ .GT. (IABS(LENLMT) - 58)) JJ = IABS(LENLMT) - 58             3420
2760            CALL LIB$PUT_SCREEN(CAPLIN(:JJ-2)//'  Not found',COMLIN,            3421
2761         1                      IABS(LENLMT)-JJ-34)                                 
2762            IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)                         3423
2763    C     EXECUTE (STOP_WITH_ERROR)                                             3424
2764          ASSIGN 56450 TO KKK088                                                3424
2765          GO TO 79868                                                               
2766    56450 CONTINUE                                                                  
2767          GO TO KKK066                                                          3425
2768    C                                                                               
2769    C                                                                               
2770    C.......................................................................        
2771    C     PROCEDURE (STOP_WITH_ERROR)                                           3426
2772    79868 CONTINUE                                                              3426
2773    CP    This procedure stops execution of a command with an error exit,           
2774    CP    while restoring the held setup and getting rid of the I/O request         
2775    CP    to the terminal                                                           
2776    C     EXECUTE (CANCEL_STOPPER)                                              3430
2777          ASSIGN 56460 TO KKK032                                                3430
2778          GO TO 79812                                                               
2779    56460 CONTINUE                                                                  
2780    C     EXECUTE (RESTORE_HELD_SETUP)                                          3431
2781          ASSIGN 56470 TO KKK054                                                3431
2782          GO TO 79834                                                               
2783    56470 CONTINUE                                                                  
2784    C     EXECUTE (ERROR_EXIT)                                                  3432
2785          ASSIGN 56480 TO KKK024                                                3432
2786          GO TO 79804                                                               
2787    56480 CONTINUE                                                                  
2788          GO TO KKK088                                                          3433
2789    C                                                                               
2790    C                                                                               
2791    C.......................................................................        
2792    C     PROCEDURE (VAR_BACK_SCROLL_EXIT)                                      3434
2793    79862 CONTINUE                                                              3434

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  90
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2794    CP    This routine exits from scrolling backwards in non-FIX files.  It         
2795    CP    sets the position to the correct place in the buffer, then converts       
2796    CP    the rest of the buffer, sets the current line position, resets the        
2797    CP    LEDs (#3 off) and returns.                                                
2798            NBUF = PBUF                                                         3439
2799            PBUF = I - 1                                                        3440
2800    C     EXECUTE (BACK_SCROLL_EXIT)                                            3441
2801          ASSIGN 56490 TO KKK058                                                3441
2802          GO TO 79838                                                               
2803    56490 CONTINUE                                                                  
2804          GO TO KKK082                                                          3442
2805    C                                                                               
2806    C                                                                               
2807    C.......................................................................        
2808    C     PROCEDURE (WAIT_FOR_SCROLL)                                           3443
2809    79854 CONTINUE                                                              3443
2810    CP    This procedure waits for the scrolling interval to pass.                  
2811            CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)                              3445
2812            CALL SYS$WAITFR(%VAL(TIMFLG))                                       3446
2813          GO TO KKK074                                                          3447
2814    C                                                                               
2815    C                                                                               
2816    C.......................................................................        
2817    C     PROCEDURE (WAIT_FOR_SCROLL_AST)                                       3448
2818    79852 CONTINUE                                                              3448
2819    CP    This procedure waits for the scrolling interval to pass after             
2820    CP    queueing the stop command AST.                                            
2821            CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,          3451
2822         1               STOPSC,,INBUF,%VAL(1),,,,)                                 
2823            CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)                              3453
2824            CALL SYS$WAITFR(%VAL(TIMFLG))                                       3454
2825          GO TO KKK072                                                          3455
2826    C                                                                               
2827    C                                                                               
2828    C.......................................................................        
2829    C     PROCEDURE (WORKING)                                                   3456
2830    79802 CONTINUE                                                              3456
2831    CP    This procedure turns on LED 1 and starts up the working message.          
2832          IF (.NOT.(VT100))GO TO 56510                                          3458
2833              CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;1q')                           3459
2834              IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')          3460
2835              IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)                    3461
2836         1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')                             
2837    56510 CONTINUE                                                              3463
2838            CALL WORKNG(.TRUE.)                                                 3464
2839          GO TO KKK022                                                          3465
2840    C                                                                               
2841    C                                                                               
2842    C.......................................................................        
2843    C     PROCEDURE (WRITE_BLOCK_NUMBER)                                        3466
2844    79842 CONTINUE                                                              3466
2845    CP    This procedure scrolls an extra line if needed (if dividing line          
2846    CP    (BOX) switch is chosen, and writes out the block number in the            
2847    CP    lower right corner.                                                       
2848            IF (PAGLEN .EQ. (COMLIN - 2)) CALL LIB$PUT_SCREEN(CRLF)             3470
2849            CALL LIB$ERASE_LINE(COMLIN,1)                                       3471
2850    C                                                                               

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  91
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

2851    C***   Output block number                                                      
2852    C                                                                               
2853            IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)                             3475
2854           I=LINEP                                                              3476
2855          GO TO 56519                                                               
2856    56520  I= I+(1)                                                                 
2857          IF ( I.GT.NLINES)GO TO 56521                                              
2858    56519 CONTINUE                                                                  
2859          IF (CCLINE(1,I) .NE. 0)GO TO 56521                                    3477
2860          GO TO 56520                                                           3478
2861    56521 CONTINUE                                                                  
2862            WRITE (UNIT=TEMPCH,FMT=2000)CCLINE(1,I)                             3479
2863    2000    FORMAT (I5)                                                         3480
2864            I = LIB$SKPC(' ',TEMPCH)                                            3481
2865            CALL LIB$PUT_SCREEN('Block '//TEMPCH(I:),COMLIN,                    3482
2866         1                      IABS(LENLMT)+I-11)                                  
2867            IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)                         3484
2868          GO TO KKK062                                                          3485
2869          END                                                                   3486




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                14591   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                 210   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                               90484   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 LNCN                                  9798   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 CHARS                                79510   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 STOPCM                                  18   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               194680


ENTRY POINTS

    Address  Type  Name          

  0-00000000       DOIT          


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  2-00015D28  R*4  ANUMB           2-00015CF7  L*1  BELL            4-00001366  I*4  BLK             2-00015CF8  L*1  BSP           
  2-00015C6C  CHAR CAPLIN         AP-00000004@ I*2  COMAND          3-00000042  I*2  COMLIN          5-0001368C  CHAR CRLF          
  3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK             2-00015CF6  L*1  ESC             2-00015CF5  L*1  FIRST         
  4-0000136A  I*4  FSZ             2-00015D0C  I*4  HBLK            2-00015D14  I*4  HLBLK           2-00015CFE  I*2  HLINEP        
  2-00015CFC  I*2  HLINES          2-00015D18  I*4  HLPBUF          2-00015D00  I*4  HNBUF           2-00015D04  I*4  HPBUF         
  2-00015D10  I*4  HSBLK           2-00015D5C  I*4  I               2-00015D60  I*4  IBLK            2-00015D30  I*4  ICOM          
  2-00015E00  I*4  IENDPB          2-00015E04  I*4  IENDPP          4-0000136E  I*4  IFSZ            2-00015D94  I*4  II            
  2-00015D68  I*4  III             2-00015D90  I*4  IIII            2-00015DE4  I*4  ILEN            6-00000001  L*1  INBUF         

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  92
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  3-00000000  I*4  INCHAN          2-00015E0C  I*4  INDSFT          2-00015E08  I*4  INUMB           2-00015DFC  I*4  INUMBR        
  6-00000002  I*4  IOFLAG          2-00015DC4  I*4  ISAVE           2-00015DB4  I*4  J               2-00015DA4  I*4  JJ            
  2-00015D84  I*4  JNUMB           2-00015DAC  I*4  K               2-00015D2C  I*4  KKK022          2-00015D3C  I*4  KKK024        
  2-00015D40  I*4  KKK026          2-00015D44  I*4  KKK028          2-00015D48  I*4  KKK030          2-00015D4C  I*4  KKK032        
  2-00015D50  I*4  KKK034          2-00015D54  I*4  KKK036          2-00015D58  I*4  KKK038          2-00015D64  I*4  KKK040        
  2-00015D6C  I*4  KKK042          2-00015D70  I*4  KKK044          2-00015D74  I*4  KKK046          2-00015D78  I*4  KKK048        
  2-00015D7C  I*4  KKK050          2-00015D80  I*4  KKK052          2-00015D88  I*4  KKK054          2-00015D8C  I*4  KKK056        
  2-00015DD0  I*4  KKK058          2-00015D98  I*4  KKK060          2-00015D9C  I*4  KKK062          2-00015DA0  I*4  KKK064        
  2-00015DA8  I*4  KKK066          2-00015DB0  I*4  KKK068          2-00015DBC  I*4  KKK070          2-00015DC0  I*4  KKK072        
  2-00015DCC  I*4  KKK074          2-00015DD8  I*4  KKK076          2-00015DE0  I*4  KKK078          2-00015DE8  I*4  KKK080        
  2-00015DF0  I*4  KKK082          2-00015DF4  I*4  KKK084          2-00015DF8  I*4  KKK086          2-00015E10  I*4  KKK088        
  2-00015DB8  I*4  L               4-0000263E  I*4  LBLK            2-00015DDC  I*4  LEN             3-0000003A  I*2  LENLMT        
  2-00015DC8  I*4  LENREC          4-000004B0  I*4  LINEP           4-00002642  I*4  LPBUF           3-00000036  I*4  LRL           
  2-00015DEC  I*4  M              AP-00000010@ L*1  MINFLG          4-00001362  I*4  NBUF            4-000004B4  I*4  NLINES        
  2-00015D38  I*4  NUMBER         AP-00000008@ L*1  NUMFLG          2-00015D1C  I*4  OLDEND          2-00015D24  R*4  OPNFIL        
  3-0000003C  I*4  PAGEND          3-00000040  I*2  PAGLEN          4-0000135E  I*4  PBUF            2-00015D08  I*4  PRINT         
  4-00001376  I*4  RAT             3-00000023  I*2  RECBLK          2-00015DD4  R*4  RECLEN          5-00013692  CHAR REGVID        
  5-0001368E  CHAR REVVID          2-00015CF9  L*1  RFLAG           4-00001372  I*4  RFM             2-00015D20  I*4  SAVCOM        
  2-00015D34  R*4  SAVNUM          3-00000008  L*1  SBFFLG          4-0000137A  I*4  SBLK            2-00015CFA  L*1  SECOND        
  6-00000000  L*1  STOPIT         AP-0000000C@ R*4  TANUMB          2-00015CF0  CHAR TEMPCH          3-00000004  I*4  TIME          
  6-0000000E  I*4  TIMFLG          3-00000035  L*1  VT100           3-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  4-000004B8  L*1  BUFFER               3750  (3750)
  2-00014DC4  L*1  CAPBUF               3750  (3750)
  4-0000137E  I*4  CCLINE               4800  (2, 600)
  2-00000000  I*4  DELTIM                  8  (2)
  2-00014D10  L*1  HBUFER                150  (150)
  2-00000010  I*4  HCCLIN               4800  (2, 600)
  2-000017B0  CHAR HLIN                79200  (600)
  2-00001300  I*2  HLINLN               1200  (600)
  2-000012D0  I*4  IDESCR                  8  (2)
  6-00000006  I*2  IOSB                    8  (4)
  5-00000000  CHAR LINES               79200  (600)
  4-00000000  I*2  LINLEN               1200  (600)
  2-00000008  I*4  PAUSTM                  8  (2)
  3-00000025  I*4  RANGE                  16  (2, 2)
  2-00015C6A  L*1  SAVFLG                  2  (2)
  3-0000000F  I*2  SBFLEN                 20  (10)
  5-00013560  CHAR SRCHBF                300  (10)
  2-000012D8  I*4  STRPOS                 40  (10)
  2-00014DA6  L*1  TEMP                   30  (30)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

      **      1550          **      1650          **      1750          **      1810          **      1820      1-00000099  2000'   
  0-0000001F  50020     0-0000001F  50030     0-0000004F  50040     0-0000002E  50050     0-0000004A  50070     0-000004B5  50080   
  0-000004E0  50081     0-00000052  50090     0-00000071  50110     0-00000071  50120     0-0000007C  50130     0-00000087  50140   
  0-00000092  50150     0-0000009D  50160     0-000000CA  50170     0-000000BF  50180     0-000000BD  50190     0-000000CA  50200   
  0-000000CD  50210     0-000000DD  50230     0-000000DD  50240     0-000000E8  50250     0-00000139  50260     0-000001A9  50280   

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  93
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

      **      50290     0-00000179  50291     0-000001A9  50310     0-000001B4  50320     0-000001BF  50330     0-000001C2  50340   
  0-000001D5  50360     0-000001D5  50370     0-000001E5  50380     0-000001E1  50390         **      50400     0-00000244  50410   
  0-00000221  50420     0-0000021F  50430     0-00000214  50440     0-00000212  50450     0-0000021F  50460     0-00000244  50470   
  0-00000239  50480     0-00000237  50490     0-00000244  50500     0-0000024E  50510     0-00000295  50520     0-0000028A  50530   
  0-000002A0  50540     0-000002A3  50550     0-000002F8  50570     0-000002F8  50580     0-00000303  50590     0-00000343  50600   
  0-00000337  50610     0-00000335  50620     0-00000343  50630     0-00000346  50640     0-00000356  50660     0-00000356  50670   
  0-0000037E  50680     0-00000381  50690     0-0000039A  50700     0-00000397  50710     0-000003A5  50720     0-000003B4  50730   
      **      50740     0-00000419  50741     0-00000412  50760     0-00000402  50780     0-00000424  50790     0-00000430  50800   
  0-0000043B  50810     0-0000043E  50820     0-0000044E  50830     0-00000451  50840     0-0000045F  50850     0-0000045B  50860   
  0-0000046B  50870     0-0000046D  50880     0-00000476  50890     0-00000481  50900     0-00000483  50910     0-00000495  50920   
  0-00000492  50930         **      50940     0-000004EB  50950     0-0000053E  50970     0-00000531  50990     0-00000531  51000   
  0-00000563  51009     0-00000550  51010     0-00000587  51011     0-00000592  51020     0-0000059E  51030     0-000005AA  51040   
  0-00000A49  51051     0-000006AE  51070     0-000005CE  51079     0-000005C2  51080     0-000006AE  51081     0-0000060C  51089   
  0-000005FE  51090     0-000006AB  51091     0-000006A8  51110     0-00000678  51120     0-000006A5  51130     0-0000069A  51140   
  0-00000698  51150     0-000006A5  51160     0-000006B9  51170     0-000006D0  51190     0-000006D0  51200     0-000006ED  51220   
  0-000006ED  51230     0-00000718  51250     0-00000718  51260     0-00000737  51270     0-0000072F  51280     0-0000073F  51289   
  0-0000075D  51299     0-0000074F  51300     0-000007FE  51301     0-00000786  51309     0-000007FB  51311     0-000007C8  51330   
  0-000007C8  51340     0-000007E0  51360     0-00000813  51369     0-00000808  51370     0-0000083C  51371     0-0000083A  51390   
  0-000009B6  51410     0-0000087B  51430     0-0000087B  51440     0-000008FB  51460     0-000008B3  51480     0-000008B3  51490   
  0-000008FB  51510     0-000008F3  51530     0-000008F3  51540     0-0000091D  51549     0-0000090F  51550     0-000009B6  51551   
  0-000009B3  51570     0-0000099A  51580     0-000009A5  51590     0-000009B0  51600     0-000009C8  51620     0-000009C8  51630   
  0-000009D7  51639     0-000009CE  51640     0-000009E6  51641     0-00000A03  51660     0-00000A03  51670     0-00000A12  51679   
  0-00000A09  51680     0-00000A2B  51681     0-00000A46  51700     0-00000A46  51710     0-00000C96  51730     0-00000A8A  51739   
  0-00000A78  51740     0-00000C96  51741     0-00000C5B  51750     0-00000BA7  51760     0-00000AC9  51769     0-00000AA8  51770   
  0-00000AD7  51771     0-00000AD5  51780     0-00000BA4  51790     0-00000B5B  51800     0-00000BB3  51810     0-00000C5B  51820   
  0-00000C12  51830     0-00000C67  51840     0-00000C93  51860     0-00000C7A  51870     0-00000C86  51880     0-00000C92  51890   
  0-00000CA9  51899     0-00000C9C  51900     0-00000CB9  51901     0-00000CF9  51910     0-00000CEC  51920     0-00000CEA  51940   
  0-00000CEA  51950     0-00000D27  51970     0-00000D27  51980     0-00000D53  51989     0-00001378  52000     0-00000F2C  52010   
  0-00000DB8  52020     0-00000D9F  52030     0-00000D9D  52040     0-00000D9A  52050     0-00000DB8  52060     0-00000DB5  52070   
  0-00000DBD  52079     0-00000F29  52081     0-00000DC9  52090     0-00000DDD  52110     0-00000DDD  52120     0-00000DF9  52130   
  0-00000E44  52150     0-00000E36  52159     0-00000E19  52160     0-00000E44  52161     0-00000E42  52170     0-00000F26  52180   
  0-00000EA1  52190     0-00000F26  52200     0-00000F09  52210     0-00000EFB  52220     0-00000F07  52230     0-00000F26  52250   
  0-00000F26  52260     0-00000F42  52269     0-00000F36  52270     0-00001378  52271     0-00001375  52290     0-00001375  52310   
  0-00000F9D  52330     0-00000F8C  52340     0-00000FB3  52350     0-00000FB0  52360     0-00001375  52380     0-00001375  52390   
  0-0000111C  52400     0-0000106B  52420     0-0000106B  52440     0-0000105D  52449     0-00001050  52450     0-0000106B  52451   
  0-00001069  52460     0-00001077  52470     0-00001119  52490     0-00001119  52510     0-0000110B  52519     0-000010FE  52520   
  0-00001119  52521     0-00001117  52530     0-00001128  52540     0-00001355  52550     0-0000127C  52560     0-00001212  52580   
  0-000011E6  52590     0-000011C0  52600     0-000011BE  52610     0-000011B2  52620     0-00001192  52629     0-00001173  52630   
  0-000011A0  52631     0-0000119E  52640     0-000011E6  52650     0-000011E1  52660     0-00001279  52670     0-0000125A  52680   
  0-0000124C  52690     0-00001258  52700     0-00001279  52720     0-00001279  52730     0-0000130E  52740     0-000012EC  52750   
  0-000012EA  52760     0-000012DE  52770     0-000012C2  52779     0-000012A1  52780     0-000012D0  52781     0-000012CE  52790   
  0-0000130E  52800     0-00001309  52810     0-00001361  52820     0-00001375  52840     0-00001375  52850     0-000013A5  52870   
  0-0000138D  52880     0-00001398  52890     0-000013A4  52900     0-000013B8  52909     0-000013AB  52910     0-000013C9  52911   
  0-000013E6  52930     0-000013E6  52940     0-000013F9  52949     0-000013EC  52950     0-00001412  52951     0-00001443  52960   
  0-0000144E  52970     0-0000147F  52980     0-00001548  53000     0-00001594  53011     0-00001560  53019     0-00001553  53020   
  0-00001570  53021     0-00001584  53029     0-0000157B  53030     0-00001594  53031     0-000019D6  53041     0-000016A3  53060   
  0-000015CA  53069     0-000015BA  53070     0-000016A3  53071     0-000015DF  53079     0-000015D1  53080     0-000016A0  53081   
  0-0000169D  53100     0-00001670  53110     0-0000169A  53120     0-0000168F  53130     0-0000168D  53140     0-0000169A  53150   
  0-000016AE  53160     0-000016CD  53170     0-000016C9  53180     0-000016D6  53189     0-000016EC  53210     0-000016EC  53220   
  0-00001775  53230     0-00001725  53240     0-00001723  53260     0-00001723  53270     0-00001740  53279     0-00001731  53280   
  0-00001775  53281     0-0000176C  53300     0-0000176C  53310     0-000017AA  53319     0-0000179F  53320     0-000017FA  53321   
  0-000017F8  53340     0-000017F8  53350     0-00001814  53359     0-00001809  53360     0-00001846  53361     0-00001844  53380   
  0-000019A0  53400     0-00001898  53410     0-0000188E  53420     0-000018A7  53430     0-000018DA  53450     0-000018C8  53459   
  0-000018BB  53460     0-000018DA  53461     0-000018F4  53469     0-000018E2  53470     0-000019A0  53471     0-00001989  53490   
  0-00001971  53500     0-0000197C  53510     0-00001987  53520     0-0000199D  53540     0-0000199D  53550     0-000019B6  53559   
  0-000019AB  53560     0-000019D3  53561     0-00001A0A  53570     0-00001A07  53580     0-00001A0A  53589     0-00001EB5  53591   
  0-00001A35  53599     0-00001A25  53600     0-00001D98  53601     0-00001D1A  53610     0-00001BCD  53620     0-00001A73  53629   

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  94
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  0-00001A61  53630     0-00001A7E  53631     0-00001BCA  53640     0-00001B5D  53650     0-00001B5B  53660     0-00001AD8  53670   
  0-00001BCA  53680     0-00001B98  53690     0-00001C07  53700     0-00001BFE  53710     0-00001D1A  53720     0-00001CC5  53730   
  0-00001CC3  53740     0-00001C4C  53750     0-00001D1A  53760     0-00001CF4  53770     0-00001D2F  53780     0-00001D95  53800   
  0-00001D4B  53810     0-00001D7C  53830     0-00001D88  53840     0-00001D94  53850     0-00001DFE  53870     0-00001DBC  53880   
  0-00001DE5  53900     0-00001DF1  53910     0-00001DFD  53920     0-00001E8F  53930     0-00001E3C  53940     0-00001E3A  53960   
  0-00001E3A  53970     0-00001E59  53979     0-00001E4A  53980     0-00001E8F  53981     0-00001E87  54000     0-00001E87  54010   
  0-00001ECB  54020     0-00001EDF  54030     0-00001F6C  54040     0-00001F56  54050     0-00001F2D  54059     0-00001F10  54060   
  0-00001F54  54061     0-00001FF2  54070     0-00001FDB  54080     0-00001FB2  54089     0-00001F94  54090     0-00001FD9  54091   
  0-00002010  54100     0-0000203F  54109     0-00002032  54110     0-00002088  54111     0-000020C4  54130     0-000020B3  54139   
  0-000020A6  54140     0-000020C4  54141     0-000020F9  54150     0-000021B1  54160     0-000021A8  54170     0-00002291  54180   
  0-000021F8  54190     0-000021F5  54210     0-000021F5  54220     0-00002291  54230     0-0000222F  54240     0-0000222D  54260   
  0-0000222D  54270     0-0000225A  54279     0-0000224D  54280     0-00002291  54281     0-00002286  54300     0-00002286  54310   
  0-00002812  54320     0-000023B4  54330     0-000022C1  54339     0-000023A8  54341     0-000022FB  54360     0-00002322  54380   
  0-00002322  54390     0-0000234E  54410     0-0000234E  54420     0-00002378  54440     0-000023A5  54460     0-00002812  54470   
  0-0000280A  54480     0-00002808  54490     0-000024CC  54500     0-0000247B  54510     0-0000243E  54520     0-00002494  54540   
  0-00002494  54550     0-000024A8  54570     0-000024B3  54580     0-000024DF  54589     0-000024D2  54590     0-000024EF  54591   
  0-00002526  54610     0-00002526  54620     0-00002808  54631     0-0000252A  54639     0-000027A4  54640     0-000027A7  54641   
  0-00002536  54660     0-000027A4  54670     0-000025D9  54680     0-000025A7  54700     0-0000257C  54720     0-00002568  54730   
  0-00002579  54740     0-00002575  54750     0-00002599  54770     0-00002599  54780     0-000025D2  54790     0-000025C1  54800   
  0-000025D2  54810     0-000025D0  54820     0-000025D9  54829     0-000025F0  54839     0-000025E4  54840     0-00002708  54841   
  0-000026F1  54860     0-000026F1  54880     0-000026F1  54900     0-000026F1  54920     0-000026E4  54930     0-0000267E  54940   
  0-0000267C  54950     0-0000266D  54960     0-0000267C  54970     0-0000267A  54980     0-000026E4  55000     0-00002705  55020   
  0-00002705  55030     0-0000271B  55039     0-0000270E  55040     0-0000272C  55041     0-00002755  55060     0-00002746  55070   
  0-00002742  55080     0-00002752  55090     0-00002772  55110     0-00002772  55120     0-00002788  55129     0-0000277B  55130   
  0-000027A1  55131     0-000027C1  55140     0-000027DD  55149     0-000027D0  55150     0-00002808  55151     0-00002806  55170   
  0-0000281D  55180     0-00002842  55200     0-00002842  55210     0-0000284D  55220     0-0000287D  55230     0-0000286A  55240   
  0-0000287D  55250     0-00002879  55260     0-0000297E  55270     0-000028F5  55280     0-000028D0  55290     0-000028B8  55300   
  0-000028F2  55320     0-000028F2  55330     0-00002935  55350     0-0000290B  55360     0-0000292F  55370     0-00002940  55380   
  0-0000297E  55400     0-0000297E  55410     0-00002986  55419     0-00002C38  55421     0-000029B0  55440     0-000029A3  55450   
  0-000029AF  55460     0-000029E0  55470     0-000029C6  55480     0-000029EF  55490     0-000029EB  55500     0-00002AF6  55520   
  0-00002A49  55529     0-00002A3A  55530     0-00002A65  55531     0-00002A9E  55550     0-00002A9E  55560     0-00002AD0  55580   
  0-00002AD0  55590     0-00002ACC  55600     0-00002B22  55620     0-00002BD8  55640     0-00002BD8  55650     0-00002B5E  55660   
  0-00002B5C  55670     0-00002B50  55680     0-00002BD8  55700     0-00002C4B  55710     0-00002C57  55720     0-00002C93  55740   
  0-00002C93  55750     0-00002DA6  55770     0-00002D3A  55779     0-00002DA6  55781     0-00002D54  55800     0-00002D7F  55820   
  0-00002D7F  55830     0-00002DC9  55839     0-00002DB9  55840     0-00002F48  55841     0-00002F45  55850     0-00002E73  55860   
  0-00002E70  55870     0-00002E2F  55880     0-00002F45  55890     0-00002EC3  55900     0-00002F54  55910     0-00002F5F  55920   
  0-00002FA5  55929     0-00002F98  55930     0-00002FEE  55931     0-0000301A  55950     0-00003009  55959     0-00002FFC  55960   
  0-0000301A  55961     0-00003052  55970     0-0000305E  55980     0-00003072  56000     0-00003072  56010     0-0000308A  56020   
  0-0000309E  56040     0-0000309E  56050     0-000030A9  56060     0-000030DC  56070     0-000030F0  56090     0-000030F0  56100   
  0-000030FB  56110     0-00003520  56120     0-000033CE  56130     0-000033CB  56150     0-000031F2  56170     0-00003186  56179   
  0-000031F2  56181     0-000031A0  56200     0-000031CB  56220     0-000031CB  56230     0-00003210  56239     0-00003200  56240   
  0-0000321B  56241     0-0000324C  56249     0-0000323C  56250     0-000033CB  56251     0-000033C8  56260     0-000032F6  56270   
  0-000032F3  56280     0-000032B1  56290     0-000033C8  56300     0-00003346  56310     0-00003507  56330     0-000033F6  56339   
  0-000033E6  56340     0-00003507  56341     0-00003402  56350     0-00003504  56360     0-00003447  56370     0-00003504  56380   
  0-000034DC  56390     0-0000345E  56400     0-0000352C  56410     0-00003537  56420     0-0000354D  56430     0-00003572  56439   
  0-00003569  56440     0-000035CD  56441     0-00003658  56450     0-0000366F  56460     0-0000367B  56470     0-00003686  56480   
  0-000036B2  56490     0-000037DB  56510     0-0000383A  56519     0-0000382D  56520     0-0000384A  56521     0-00003739  79802   
  0-00001475  79804     0-0000202C  79806     0-0000229C  79808     0-00001EEB  79810     0-0000144F  79812     0-0000315B  79814   
  0-00002D24  79816     0-00001549  79818     0-000021BC  79820     0-0000159F  79822     0-000005AB  79824     0-00002104  79826   
  0-00002C63  79828     0-000019E1  79830     0-00000A54  79832     0-00002F6A  79834     0-00002828  79836     0-000004F5  79838   
  0-00002CB9  79840     0-000037EF  79842     0-00001EC0  79844     0-00003542  79846     0-0000142E  79848     0-00003122  79850   
  0-000036EE  79852     0-000036BE  79854     0-0000307E  79856     0-00003046  79858     0-000030D0  79860     0-00003692  79862   
  0-00001FFE  79864     0-00001F77  79866     0-00003664  79868   

DOIT                           					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  95
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        BLKCLS                                  BLKIN                                   BLKSIN                          
        CONVUP                                  FOR$CLOSE                               FOR$EXIT                        
        LIB$DOWN_SCROLL                         LIB$ERASE_LINE                          LIB$ERASE_PAGE                  
   I*4  LIB$EXTZV                               LIB$FREE_EF                             LIB$GET_EF                      
   I*4  LIB$INDEX                               LIB$PUT_OUTPUT                          LIB$PUT_SCREEN                  
        LIB$SET_CURSOR                     I*4  LIB$SKPC                                LINCON                          
        PRTCLS                                  PRTOPN                                  PRTOUT                          
        REDOIT                                  RESTRM                                  STOPSC                          
        SYS$CANCEL                              SYS$DASSGN                              SYS$QIO                         
        SYS$QIOW                                SYS$SETIMR                              SYS$WAITFR                      
        WORKNG                          

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  96
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          LOGICAL FUNCTION GETDEF(LINE,ISYM)                                    3487
0002    C                                                                               
0003    CDM   This routine translates a line into a symbol definition                   
0004    CDM                                                                             
0005    CDM   Programmer - Jon Vavrus   3 SEP 1981                                      
0006    CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
0007    CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
0008    CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
0009    CDM   Revised    - Jon Vavrus  28 MAY 1983                                      
0010    CDM   Revised    - Jon Vavrus  17 AUG 1983                                      
0011    CM                                                                              
0012    CM         The routine is called with the line to be translated in the          
0013    CM    character variable LINE.  The number of the symbol definition is          
0014    CM    passed as ISYM.                                                           
0015    C                                                                               
0016    C***   CALLED ROUTINES                                                          
0017    C                                                                               
0018    CC    PRSCOM  Parses a command string                                           
0019    C                                                                               
0020    C***   COMMON AREAS                                                             
0021    C                                                                               
0022    CS    CHARS   Used to pass character variables; contains LINES a character      
0023    CS            array of the output lines, and SRCHBF the search buffer, and      
0024    CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
0025    CS            the VT100 control sequences to set/unset reverse video            
0026    C                                                                               
0027    CS    DOITNM  Contains information transferred from the main program:           
0028    CS                 INCHAN - input channel of the terminal                       
0029    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0030    CS                 SBFFLG - flag indicating whether there is a string           
0031    CS                          in the search buffer                                
0032    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0033    CS                 EBK    - EBK of input file                                   
0034    CS                 SBFLEN - length of string(s) in search buffer(s)             
0035    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0036    CS                 RANGE  - beginning and ending block numbers and pointers     
0037    CS                          of the print range                                  
0038    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0039    CS                 LRL    - length of the longest record in input file.         
0040    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0041    CS                 PAGEND - line number of last line output to screen           
0042    CS                 PAGLEN - number of lines per page                            
0043    CS                 COMLIN - line number for command input (bottom of screen)    
0044    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0045    C                                                                               
0046    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0047    CS            symbols SYMS and the definition search buffers DEFBUF             
0048    C                                                                               
0049    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0050    CS            symbol definitions DEFS, the number of such definitions           
0051    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0052    CS            numbers NUDMEF                                                    
0053    C                                                                               
0054    CS    PRSCHR  Contains the current symbol's search buffers (CURBUF)             
0055    C                                                                               
0056    CS    PRSNUM  Contains the current symbol's definitions (CUR), flags            
0057    CS            (CURFLG), and associated numbers (NUMCUR)                         

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  97
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    C                                                                               
0059          CHARACTER*(*) LINE                                                    3545
0060          CHARACTER*132 LINES(600)                                              3546
0061          CHARACTER*128 INLINE                                                  3547
0062          CHARACTER*30 DEFBUF(10,10,60),SRCHBF(10),HLDBUF(10),CURBUF(10,10)     3548
0063          CHARACTER*4 REVVID,REGVID                                             3549
0064          CHARACTER*2 CRLF                                                      3550
0065          CHARACTER*1 SYMS(60)                                                  3551
0066          REAL*4 NUMDEF(10,60),NUMCUR(10)                                       3552
0067          INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND                           3553
0068          INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,PAGLEN,      3554
0069         1          LENSAV,HLDLEN(10),CUR(11,10),COMLIN                             
0070          LOGICAL*1 SBFFLG,VT100,DEFFLG(3,10,60),HLDFLG,CURFLG(3,10),MINFLG,    3556
0071         1          NUMFLG,VT100A,RESULT                                            
0072                                                                                3558
0073          COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                         3559
0074          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     3560
0075         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0076          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                     3562
0077          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                        3563
0078          COMMON /PRSNUM/CUR,NUMCUR,CURFLG                                      3564
0079          COMMON /PRSCHR/CURBUF                                                 3565
0080                                                                                3566
0081          RESULT = .TRUE.                                                       3567
0082    C                                                                               
0083    C***   Store the current definition in case it is recursive                     
0084    C                                                                               
0085          DO 50010  JJ=1,10                                                     3571
0086           CUR(1,JJ) = DEFS(1,JJ,ISYM)                                          3572
0087          IF (CUR(1,JJ) .EQ. 0)GO TO 50011                                      3573
0088           NUMCUR(JJ) = NUMDEF(JJ,ISYM)                                         3574
0089           CURFLG(1,JJ) = DEFFLG(1,JJ,ISYM)                                     3575
0090           CURFLG(2,JJ) = DEFFLG(2,JJ,ISYM)                                     3576
0091           CURFLG(3,JJ) = DEFFLG(3,JJ,ISYM)                                     3577
0092          DO 50020  I=1,10                                                      3578
0093            CUR(1+I,JJ) = DEFS(1+I,JJ,ISYM)                                     3579
0094          IF (CUR(1+I,JJ) .EQ. 0)GO TO 50021                                    3580
0095            CURBUF(I,JJ) = DEFBUF(I,JJ,ISYM)                                    3581
0096    50020 CONTINUE                                                              3582
0097    50021 CONTINUE                                                                  
0098    50010 CONTINUE                                                              3583
0099    50011 CONTINUE                                                                  
0100          NCOM = 1                                                              3584
0101    C                                                                               
0102    C***   Save search stuff                                                        
0103    C                                                                               
0104          DO 50030  JJ=1,10                                                     3588
0105           HLDLEN(JJ) = SBFLEN(JJ)                                              3589
0106           HLDBUF(JJ) = SRCHBF(JJ)                                              3590
0107          IF (SBFLEN(JJ) .EQ. 0)GO TO 50031                                     3591
0108    50030 CONTINUE                                                              3592
0109    50031 CONTINUE                                                                  
0110          HLDFLG = SBFFLG                                                       3593
0111          SBFFLG = .FALSE.                                                      3594
0112          LENBUF = LEN(LINE)                                                    3595
0113    50039 CONTINUE                                                              3596
0114    C                                                                               

GETDEF                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  98
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115    C***   Parse out a command                                                      
0116    C                                                                               
0117           CALL PRSCOM(LINE,LENBUF,ICOM,NUMFLG,ANUMB,MINFLG,NCOM,ISYM)          3600
0118          IF (NCOM .GT. 10)GO TO 50041                                          3601
0119          IF (.NOT.(ICOM .EQ. 0 .AND. LENBUF .GT. 0))GO TO 50060                3602
0120             RESULT = .FALSE.                                                   3603
0121          GO TO 50041                                                           3604
0122    50060 CONTINUE                                                              3605
0123           DEFS(1,NCOM,ISYM) = ICOM                                             3606
0124          IF (ICOM .EQ. 0)GO TO 50041                                           3607
0125           DEFFLG(1,NCOM,ISYM) = NUMFLG                                         3608
0126           NUMDEF(NCOM,ISYM) = ANUMB                                            3609
0127           DEFFLG(2,NCOM,ISYM) = MINFLG                                         3610
0128    C                                                                               
0129    C***   Search stuff if command is ^                                             
0130    C                                                                               
0131          IF (DEFS(1,NCOM,ISYM) .NE. 3)GO TO 50080                              3614
0132          DO 50090  JJ=1,10                                                     3615
0133              DEFBUF(JJ,NCOM,ISYM) = SRCHBF(JJ)                                 3616
0134              DEFS(1+JJ,NCOM,ISYM) = SBFLEN(JJ)                                 3617
0135    50090 CONTINUE                                                              3618
0136             DEFFLG(3,NCOM,ISYM) = SBFFLG                                       3619
0137          GO TO 50070                                                           3620
0138    50080 CONTINUE                                                                  
0139             DEFFLG(3,NCOM,ISYM) = .FALSE.                                      3621
0140    50070 CONTINUE                                                              3622
0141           NCOM = NCOM + 1                                                      3623
0142          GO TO 50039                                                           3624
0143    50041 CONTINUE                                                                  
0144    C                                                                               
0145    C***   Restore search stuff                                                     
0146    C                                                                               
0147          DO 50100  JJ=1,10                                                     3628
0148           SBFLEN(JJ) = HLDLEN(JJ)                                              3629
0149           SRCHBF(JJ) = HLDBUF(JJ)                                              3630
0150    50100 CONTINUE                                                              3631
0151          SBFFLG = HLDFLG                                                       3632
0152          GETDEF = RESULT                                                       3633
0153          RETURN                                                                3634
0154          END                                                                   3635

GETDEF                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page  99
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  512   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  2 $LOCAL                                 400   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 CHARS                                79510   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  7 PRSNUM                                 290   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  8 PRSCHR                                3000   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               281375


ENTRY POINTS

    Address  Type  Name          

  0-00000000  L*4  GETDEF        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  2-0000015C  R*4  ANUMB           4-00000042  I*2  COMLIN          3-0001368C  CHAR CRLF            4-00000009  I*2  DIRECT        
  4-0000000B  I*4  EBK             2-00000140  L*1  HLDFLG          2-0000014C  I*4  I               2-00000158  I*4  ICOM          
  4-00000000  I*4  INCHAN          5-00000000  CHAR INLINE         AP-00000008@ I*4  ISYM            2-00000148  I*4  JJ            
  2-00000154  I*4  LENBUF          4-0000003A  I*2  LENLMT          6-00000000  I*2  LENSAV         AP-00000004@ CHAR LINE          
  4-00000036  I*4  LRL             2-00000141  L*1  MINFLG          2-00000150  I*4  NCOM            6-00003392  I*4  NDEFS         
  2-00000142  L*1  NUMFLG          4-0000003C  I*4  PAGEND          4-00000040  I*2  PAGLEN          4-00000023  I*2  RECBLK        
  3-00013692  CHAR REGVID          2-00000143  L*1  RESULT          3-0001368E  CHAR REVVID          4-00000008  L*1  SBFFLG        
  4-00000004  I*4  TIME            4-00000035  L*1  VT100           4-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  7-00000000  I*2  CUR                   220  (11, 10)
  8-00000000  CHAR CURBUF               3000  (10, 10)
  7-00000104  L*1  CURFLG                 30  (3, 10)
  5-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  6-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  6-00000002  I*2  DEFS                13200  (11, 10, 60)
  2-00000014  CHAR HLDBUF                300  (10)
  2-00000000  I*2  HLDLEN                 20  (10)
  3-00000000  CHAR LINES               79200  (600)
  7-000000DC  R*4  NUMCUR                 40  (10)
  6-00003A9E  R*4  NUMDEF               2400  (10, 60)
  4-00000025  I*4  RANGE                  16  (2, 2)
  4-0000000F  I*2  SBFLEN                 20  (10)
  3-00013560  CHAR SRCHBF                300  (10)
  5-00000080  CHAR SYMS                   60  (60)

GETDEF                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 100
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

      **      50010     0-000000C9  50011         **      50020     0-000000C3  50021         **      50030     0-000000FE  50031   
  0-00000111  50039     0-000001CE  50041     0-00000138  50060     0-000001C8  50070     0-000001C1  50080         **      50090   
      **      50100   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name          

        PRSCOM        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 101
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE LINCON(START)                                              3636
0002    CDM   This subroutine converts a buffer full of data into output lines in       
0003    CDM   the output arrays.                                                        
0004    CDM                                                                             
0005    CDM   Programmer - Jon Vavrus  12 NOV 1980                                      
0006    CDM   Revised    - Jon Vavrus  13 MAY 1981                                      
0007    CDM   Revised    - Jon Vavrus  30 JUL 1981 (change CCLINE usage)                
0008    CDM   Revised    - Jon Vavrus  26 AUG 1981                                      
0009    CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
0010    CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
0011    CDM   Revised    - Jon Vavrus  12 JAN 1983                                      
0012    CM                                                                              
0013    CM         The conversion is done one line per record with blank lines          
0014    CM    being inserted to take care of FORTRAN carriage-control (which is         
0015    CM    then stripped off the record)(+ carriage control is ignored), and         
0016    CM    printer form-feeds (other printer control sequences are ignored).         
0017    CM                                                                              
0018    CM         If START is set to .TRUE. in the call, then it is assumed that       
0019    CM    the buffer is completely new, and bears no relationship to the current    
0020    CM    contents of the output arrays, thus the current contents of the arrays    
0021    CM    are disregarded and written over.  If START is set to .FALSE. in the      
0022    CM    call, the buffer is assumed to be full of data which should immediately   
0023    CM    follows the information currently in the output arrays.  It is also       
0024    CM    assumed (if START is .FALSE.) that the buffer pointer (PBUF) is           
0025    CM    pointing at the correct byte.                                             
0026    C                                                                               
0027    C***   CALLED ROUTINES                                                          
0028    C                                                                               
0029    CC    INTASC  Converts a string of bytes into a character variable.             
0030    CC    SFTLIN  Shifts the lines in the output arrays to free up space for        
0031    CC            more lines to be converted.                                       
0032    C                                                                               
0033    C***   COMMON AREAS                                                             
0034    C                                                                               
0035    CS    CHARS   Contains the character array containing the actual output lines.  
0036    C                                                                               
0037    CS    DOITNM  Contains information transferred from the main program:           
0038    CS                 INCHAN - input channel of the terminal                       
0039    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0040    CS                 SBFFLG - flag indicating whether there is a string           
0041    CS                          in the search buffer                                
0042    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0043    CS                 EBK    - EBK of input file                                   
0044    CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
0045    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0046    CS                 RANGE  - beginning and ending block numbers and pointers     
0047    CS                          of the print range                                  
0048    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0049    CS                 LRL    - length of the longest record in input file.         
0050    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0051    CS                 PAGEND - line number of last line output to screen           
0052    CS                 PAGLEN - number of lines per page                            
0053    CS                 COMLIN - line number for command input (bottom of screen)    
0054    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0055    C                                                                               
0056    CS    LNCN    Contains output arrays, and file pointers and information:        
0057    CS                 LINLEN - array of output line lengths                        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 102
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    CS                 LINEP  - top of screen line (or last line output by          
0059    CS                          backward scroll)                                    
0060    CS                 NLINES - number of lines in arrays                           
0061    CS                 BUFFER - array of unconverted data                           
0062    CS                 PBUF   - current position in BUFFER                          
0063    CS                 NBUF   - number of bytes in BUFFER                           
0064    CS                 BLK    - next block in file                                  
0065    CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
0066    CS                 IFSZ   - word extended record length for FIX files           
0067    CS                 RFM    - files RFM                                           
0068    CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
0069    CS                 SBLK   - starting block of current batch of output lines     
0070    CS                 CCLINE - array containing pointer to where the line's        
0071    CS                          record starts in the file (CCLINE(1,x) = block      
0072    CS                          #, CCLINE(2,x) = byte number in block).  If         
0073    CS                          CCLINE(1,x) = 0 then it is a carriage control       
0074    CS                          line.                                               
0075    CS                 LBLK   - last block processed by LINCON                      
0076    CS                 LPBUF  - last PBUF value processed by LINCON                 
0077    C                                                                               
0078          CHARACTER*132 LINES(600)                                              3713
0079          INTEGER*4 RFM,RAT,FSZ,BLK,PBUF,PBSAVE,SBLK,CCLINE(2,600),             3714
0080         1          INCHAN,TIME,RANGE(2,2),EBK,PAGEND,BUFDSC(2)                     
0081          INTEGER*2 LINLEN(600),DIRECT,SBFLEN(10),RECBLK,PAGLEN,LENLMT,         3716
0082         1          COMLIN                                                          
0083          LOGICAL*1 BUFFER(3750),START,SBFFLG,VT100,VT100A                      3718
0084          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     3719
0085         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0086          COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,       3721
0087         1             RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                               
0088          COMMON /CHARS/LINES                                                   3723
0089    C                                                                               
0090    C***   Calculate start position if this is a new block                          
0091    C                                                                               
0092          IF (.NOT.(START))GO TO 50020                                          3727
0093            NLINES = 0                                                          3728
0094            LINEP = 1                                                           3729
0095            LPBUF = 0                                                           3730
0096            LBLK = SBLK                                                         3731
0097          IF (RAT .LE. 0)GO TO 50040                                            3732
0098          IF (RFM .NE. 1)GO TO 50060                                            3733
0099                PBUF = IFSZ*(512*(SBLK - 1)/IFSZ + 1)                           3734
0100                PBUF = LIB$EXTZV(0,9,PBUF) + 1                                  3735
0101                IF (PBUF .EQ. (IFSZ + 1)) PBUF = 1                              3736
0102          GO TO 50050                                                           3737
0103    50060 CONTINUE                                                                  
0104                PBUF = 1                                                        3738
0105    50069 CONTINUE                                                              3739
0106                 PBUF = PBUF + 1                                                3740
0107          IF (BUFFER(PBUF) .NE. 0)GO TO 50070                                   3741
0108                 I = PBUF + LIB$EXTZV(0,8,BUFFER(PBUF-1)) + 2                   3742
0109                 IF (BUFFER(PBUF-1)) I = I + 1                                  3743
0110          IF (BUFFER(I) .EQ. 0)GO TO 50071                                      3744
0111    50070 GO TO 50069                                                           3745
0112    50071 CONTINUE                                                                  
0113                PBUF = PBUF - 1                                                 3746
0114    50050 CONTINUE                                                              3747

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 103
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115          GO TO 50030                                                           3748
0116    50040 CONTINUE                                                                  
0117              PBUF = 1                                                          3749
0118    50030 CONTINUE                                                              3750
0119    50020 CONTINUE                                                              3751
0120    C                                                                               
0121    C***   Check for either FORTRAN or printer carriage control                     
0122    C                                                                               
0123    C***   FORTRAN                                                                  
0124    C                                                                               
0125       20 CONTINUE                                                              3757
0126    50079 CONTINUE                                                                  
0127    C     EXECUTE (NEW_LINE)                                                    3758
0128          ASSIGN 50090 TO KKK022                                                3758
0129          GO TO 79802                                                               
0130    50090 CONTINUE                                                                  
0131          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 50110                    3759
0132          IF (RFM .NE. 1)GO TO 50130                                            3760
0133               I = BUFFER(PBUF)                                                 3761
0134          GO TO 50120                                                           3762
0135    50130 CONTINUE                                                                  
0136          IF (BUFFER(PBUF) .NE. FSZ)GO TO 50150                                 3763
0137                 I = 0                                                          3764
0138          GO TO 50140                                                           3765
0139    50150 CONTINUE                                                                  
0140                 I = BUFFER(PBUF+FSZ+2)                                         3766
0141    50140 CONTINUE                                                              3767
0142    50120 CONTINUE                                                              3768
0143          IF (I .NE. '30'X)GO TO 50170                                          3769
0144    C                                                                               
0145    C***   30 octal is an ASCII 0                                                   
0146    C                                                                               
0147    C     EXECUTE (INSERT_BLANK_LINE)                                           3773
0148          ASSIGN 50180 TO KKK024                                                3773
0149          GO TO 79804                                                               
0150    50180 CONTINUE                                                                  
0151          GO TO 50160                                                           3774
0152    50170 CONTINUE                                                                  
0153          IF (I .NE. '31'X)GO TO 50200                                          3775
0154    C                                                                               
0155    C***   31 octal is an ASCII 1                                                   
0156    C                                                                               
0157    C     EXECUTE (INSERT_BLANK_LINE)                                           3779
0158          ASSIGN 50210 TO KKK024                                                3779
0159          GO TO 79804                                                               
0160    50210 CONTINUE                                                                  
0161    C     EXECUTE (INSERT_BLANK_LINE)                                           3780
0162          ASSIGN 50220 TO KKK024                                                3780
0163          GO TO 79804                                                               
0164    50220 CONTINUE                                                                  
0165    50200 CONTINUE                                                              3781
0166    50160 CONTINUE                                                              3782
0167          GO TO 50100                                                           3783
0168    50110 CONTINUE                                                                  
0169          IF (.NOT.(RAT .EQ. 3 .OR. RAT .EQ. -3))GO TO 50240                    3784
0170    C                                                                               
0171    C***   Printer pre-line line feeds                                              

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 104
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0172    C                                                                               
0173          IF (LIB$EXTZV(7,1,BUFFER(PBUF+2)) .NE. 0)GO TO 50260                  3788
0174                 I = LIB$EXTZV(0,7,BUFFER(PBUF+2)) - 1                          3789
0175          IF (I .EQ. 0)GO TO 50280                                              3790
0176          DO 50290  J=1,I                                                       3791
0177    C     EXECUTE (INSERT_BLANK_LINE)                                           3792
0178          ASSIGN 50300 TO KKK024                                                3792
0179          GO TO 79804                                                               
0180    50300 CONTINUE                                                                  
0181    50290 CONTINUE                                                              3793
0182    50280 CONTINUE                                                              3794
0183                 PBSAVE = PBUF + 3                                              3795
0184    50260 CONTINUE                                                              3796
0185    50240 CONTINUE                                                              3797
0186    50100 CONTINUE                                                              3798
0187    C                                                                               
0188    C***   Extract records into lines                                               
0189    C                                                                               
0190          IF (RFM .NE. 1)GO TO 50320                                            3802
0191    C                                                                               
0192    C***   Fixed length records                                                     
0193    C                                                                               
0194    C     EXECUTE (SET_CCLINE)                                                  3806
0195          ASSIGN 50330 TO KKK026                                                3806
0196          GO TO 79806                                                               
0197    50330 CONTINUE                                                                  
0198          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 50350                    3807
0199               LENGTH = FSZ - 1                                                 3808
0200               PBUF = PBUF + 1                                                  3809
0201          GO TO 50340                                                           3810
0202    50350 CONTINUE                                                                  
0203               LENGTH = FSZ                                                     3811
0204    50340 CONTINUE                                                              3812
0205             I = PBUF                                                           3813
0206    C     EXECUTE (CONVERT_TO_LINES)                                            3814
0207          ASSIGN 50360 TO KKK028                                                3814
0208          GO TO 79808                                                               
0209    50360 CONTINUE                                                                  
0210             PBUF = PBUF + LENGTH                                               3815
0211             IF (FSZ) PBUF = PBUF + 1                                           3816
0212          IF ((PBUF + IFSZ - 1) .LE. NBUF)GO TO 50380                           3817
0213    C     EXECUTE (STORE_REMAINDER)                                             3818
0214          ASSIGN 50390 TO KKK030                                                3818
0215          GO TO 79810                                                               
0216    50390 CONTINUE                                                                  
0217    50380 CONTINUE                                                              3819
0218          GO TO 50310                                                           3820
0219    50320 CONTINUE                                                                  
0220    C                                                                               
0221    C***   Variable length records                                                  
0222    C                                                                               
0223    C     EXECUTE (SET_CCLINE)                                                  3824
0224          ASSIGN 50400 TO KKK026                                                3824
0225          GO TO 79806                                                               
0226    50400 CONTINUE                                                                  
0227          IF (.NOT.(RAT .EQ. 2 .OR. RAT .EQ. -2))GO TO 50420                    3825
0228               LENGTH = LIB$EXTZV(0,8,BUFFER(PBUF)) - 1 - FSZ                   3826

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 105
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0229               I = PBUF + 3 + FSZ                                               3827
0230          GO TO 50410                                                           3828
0231    50420 CONTINUE                                                                  
0232               LENGTH = LIB$EXTZV(0,8,BUFFER(PBUF)) - FSZ                       3829
0233               I = PBUF + 2 + FSZ                                               3830
0234    50410 CONTINUE                                                              3831
0235          IF (LENGTH .LE. 0)GO TO 50440                                         3832
0236    C     EXECUTE (CONVERT_TO_LINES)                                            3833
0237          ASSIGN 50450 TO KKK028                                                3833
0238          GO TO 79808                                                               
0239    50450 CONTINUE                                                                  
0240          IF (.NOT.(BUFFER(PBUF)))GO TO 50470                                   3834
0241                 PBUF = I + LENGTH + 1                                          3835
0242          GO TO 50460                                                           3836
0243    50470 CONTINUE                                                                  
0244                 PBUF = I + LENGTH                                              3837
0245    50460 CONTINUE                                                              3838
0246          GO TO 50430                                                           3839
0247    50440 CONTINUE                                                                  
0248               IF (LENGTH .EQ. 0 .AND. (RAT .EQ. 2 .OR. RAT .EQ. -2))           3840
0249         1         PBUF = PBUF + 2                                                  
0250               PBUF = PBUF + 2 + FSZ                                            3842
0251               IF (FSZ) PBUF = PBUF + 1                                         3843
0252               LINLEN(NLINES) = 1                                               3844
0253               LINES(NLINES) = ' '                                              3845
0254    50430 CONTINUE                                                              3846
0255    C                                                                               
0256    C***   Printer post-line line feeds                                             
0257    C                                                                               
0258          IF (.NOT.(RAT .EQ. 3 .OR. RAT .EQ. -3))GO TO 50490                    3850
0259          IF (LIB$EXTZV(7,1,BUFFER(PBSAVE)) .NE. 0)GO TO 50510                  3851
0260                 I = LIB$EXTZV(0,7,BUFFER(PBSAVE)) - 1                          3852
0261          IF (I .LE. 0)GO TO 50530                                              3853
0262    C     EXECUTE (NEW_LINE)                                                    3854
0263          ASSIGN 50540 TO KKK022                                                3854
0264          GO TO 79802                                                               
0265    50540 CONTINUE                                                                  
0266          DO 50550  J=1,I                                                       3855
0267    C     EXECUTE (INSERT_BLANK_LINE)                                           3856
0268          ASSIGN 50560 TO KKK024                                                3856
0269          GO TO 79804                                                               
0270    50560 CONTINUE                                                                  
0271    50550 CONTINUE                                                              3857
0272                   NLINES = NLINES - 1                                          3858
0273    50530 CONTINUE                                                              3859
0274    50510 CONTINUE                                                              3860
0275    50490 CONTINUE                                                              3861
0276          IF ((LIB$EXTZV(0,8,BUFFER(PBUF)) + PBUF + 1) .LE. NBUF)GO TO 50580    3862
0277    C     EXECUTE (STORE_REMAINDER)                                             3863
0278          ASSIGN 50590 TO KKK030                                                3863
0279          GO TO 79810                                                               
0280    50590 CONTINUE                                                                  
0281    50580 CONTINUE                                                              3864
0282    50310 CONTINUE                                                              3865
0283          GO TO 50079                                                           3866
0284    C                                                                               
0285    C****************************************************************************** 

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 106
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0286    C***********************   HERE FOLLOW THE PROCEDURES   *********************** 
0287    C****************************************************************************** 
0288    C                                                                               
0289    C                                                                               
0290    C                                                                               
0291    C.......................................................................        
0292    C     PROCEDURE (CONVERT_TO_LINES)                                          3872
0293    79808 CONTINUE                                                              3872
0294    CP    This procedure converts the LENGTH bytes in BUFFER into lines in LINES    
0295    CP    (starting at NLINES).  It takes into account form feeds (generate 2       
0296    CP    blank lines) and line feeds.                                              
0297    C                                                                               
0298    C***   Construct descriptor                                                     
0299    C                                                                               
0300            BUFDSC(1) = LENGTH                                                  3879
0301            BUFDSC(2) = %LOC(BUFFER(I))                                         3880
0302            J = I                                                               3881
0303    C                                                                               
0304    C***   Split string                                                             
0305    C                                                                               
0306    50599 CONTINUE                                                              3885
0307             IFF = LIB$LOCC(CHAR(12),BUFDSC)                                    3886
0308             ILF = LIB$LOCC(CHAR(10),BUFDSC)                                    3887
0309          IF (.NOT.(ILF .EQ. 0 .AND. IFF .EQ. 0))GO TO 50620                    3888
0310               ILEN = BUFDSC(1)                                                 3889
0311               IICHAR = ILEN                                                    3890
0312          GO TO 50610                                                           3891
0313    50620 CONTINUE                                                                  
0314          IF (.NOT.((ILF .LT. IFF .AND. ILF .NE. 0) .OR. IFF .EQ. 0))GO TO 5    3892
0315         X0640                                                                      
0316    C                                                                               
0317    C===   Line feed first                                                          
0318    C                                                                               
0319                 ILEN = ILF - 1                                                 3896
0320                 IICHAR = ILF                                                   3897
0321    C                                                                               
0322    C---   Get rid of <CR>                                                          
0323    C                                                                               
0324                 IF (BUFFER(J+ILEN-1) .EQ. 13) ILEN = ILEN - 1                  3901
0325          GO TO 50630                                                           3902
0326    50640 CONTINUE                                                                  
0327    C                                                                               
0328    C===   FF first                                                                 
0329    C                                                                               
0330                 CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                          3906
0331                 CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                          3907
0332    C     EXECUTE (INSERT_BLANK_LINE)                                           3908
0333          ASSIGN 50650 TO KKK024                                                3908
0334          GO TO 79804                                                               
0335    50650 CONTINUE                                                                  
0336                 CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                          3909
0337                 CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                          3910
0338    C     EXECUTE (INSERT_BLANK_LINE)                                           3911
0339          ASSIGN 50660 TO KKK024                                                3911
0340          GO TO 79804                                                               
0341    50660 CONTINUE                                                                  
0342                 ILEN = IFF - 1                                                 3912

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 107
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0343                 IICHAR = IFF                                                   3913
0344    50630 CONTINUE                                                              3914
0345    50610 CONTINUE                                                              3915
0346             IF (ILEN .GT. 132) ILEN = 132                                      3916
0347             BUFDSC(1) = BUFDSC(1) - IICHAR                                     3917
0348             BUFDSC(2) = BUFDSC(2) + IICHAR                                     3918
0349          IF ((J + IICHAR + 1) .GE. (I + LENGTH))GO TO 50680                    3919
0350    C                                                                               
0351    C===   Not end of record                                                        
0352    C                                                                               
0353               CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                            3923
0354               CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                            3924
0355               CCLINE(1,NLINES) = 0                                             3925
0356    C     EXECUTE (NEW_LINE)                                                    3926
0357          ASSIGN 50690 TO KKK022                                                3926
0358          GO TO 79802                                                               
0359    50690 CONTINUE                                                                  
0360          IF (ILEN .NE. 0)GO TO 50710                                           3927
0361                 LINES(NLINES-1) = ' '                                          3928
0362                 LINLEN(NLINES-1) = 1                                           3929
0363          GO TO 50700                                                           3930
0364    50710 CONTINUE                                                                  
0365                 CALL INTASC(ILEN,BUFFER(J),LINES(NLINES-1))                    3931
0366                 LINLEN(NLINES-1) = ILEN                                        3932
0367    50700 CONTINUE                                                              3933
0368          GO TO 50670                                                           3934
0369    50680 CONTINUE                                                                  
0370    C                                                                               
0371    C===   End of record                                                            
0372    C                                                                               
0373          IF (ILEN .NE. 0)GO TO 50730                                           3938
0374                 LINES(NLINES) = ' '                                            3939
0375                 LINLEN(NLINES) = 1                                             3940
0376          GO TO 50720                                                           3941
0377    50730 CONTINUE                                                                  
0378                 CALL INTASC(ILEN,BUFFER(J),LINES(NLINES))                      3942
0379                 LINLEN(NLINES) = ILEN                                          3943
0380    50720 CONTINUE                                                              3944
0381          IF (.NOT.(ABS(RAT) .NE. 4 .AND. ILF .NE. 0 .AND. IFF .EQ. 0))GO TO    3945
0382         X 50750                                                                    
0383                 CCLINE(1,NLINES+1) = CCLINE(1,NLINES)                          3946
0384                 CCLINE(2,NLINES+1) = CCLINE(2,NLINES)                          3947
0385                 CCLINE(1,NLINES) = 0                                           3948
0386    C     EXECUTE (NEW_LINE)                                                    3949
0387          ASSIGN 50760 TO KKK022                                                3949
0388          GO TO 79802                                                               
0389    50760 CONTINUE                                                                  
0390                 LINES(NLINES) = ' '                                            3950
0391                 LINLEN(NLINES) = 1                                             3951
0392    50750 CONTINUE                                                              3952
0393    50670 CONTINUE                                                              3953
0394             J = J + IICHAR                                                     3954
0395          IF ((J + 1) .GE. (I + LENGTH))GO TO 50601                             3955
0396          GO TO 50599                                                           3956
0397    50601 CONTINUE                                                                  
0398          GO TO KKK028                                                          3957
0399    C                                                                               

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 108
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0400    C                                                                               
0401    C.......................................................................        
0402    C     PROCEDURE (INSERT_BLANK_LINE)                                         3958
0403    79804 CONTINUE                                                              3958
0404    CP    This procedure inserts a blank line of length one character into the      
0405    CP    proper arrays.                                                            
0406            LINLEN(NLINES) = 1                                                  3961
0407            LINES(NLINES) = ' '                                                 3962
0408            CCLINE(1,NLINES) = 0                                                3963
0409    C     EXECUTE (NEW_LINE)                                                    3964
0410          ASSIGN 50770 TO KKK022                                                3964
0411          GO TO 79802                                                               
0412    50770 CONTINUE                                                                  
0413          GO TO KKK024                                                          3965
0414    C                                                                               
0415    C                                                                               
0416    C.......................................................................        
0417    C     PROCEDURE (NEW_LINE)                                                  3966
0418    79802 CONTINUE                                                              3966
0419    CP    This procedure takes care of shifting the translated lines in the         
0420    CP    arrays to make more room.                                                 
0421            NLINES = NLINES + 1                                                 3969
0422          IF (NLINES .NE. 600)GO TO 50790                                       3970
0423          IF (.NOT.(START))GO TO 50810                                          3971
0424    C                                                                               
0425    C***   START = .TRUE., therefore we should throw away the rest of the blocks    
0426    C***   instead of trying to shift.                                              
0427    C                                                                               
0428           II=600                                                               3976
0429          GO TO 50819                                                               
0430    50820  II= II+(-1)                                                              
0431          IF ( II.LT.1)GO TO 50821                                                  
0432    50819 CONTINUE                                                                  
0433    C                                                                               
0434    C===   Find out which block we are in                                           
0435    C                                                                               
0436          IF (CCLINE(1,II) .EQ. 0)GO TO 50840                                   3980
0437                   IIBLK = CCLINE(1,II) - 1                                     3981
0438    C                                                                               
0439    C===   Move to previous block                                                   
0440    C                                                                               
0441           JJ=II                                                                3985
0442          GO TO 50849                                                               
0443    50850  JJ= JJ+(-1)                                                              
0444          IF ( JJ.LT.1)GO TO 50851                                                  
0445    50849 CONTINUE                                                                  
0446          IF (CCLINE(1,JJ) .NE. IIBLK)GO TO 50870                               3986
0447    C                                                                               
0448    C===   Throw away rest of blocks                                                
0449    C                                                                               
0450                      NLINES = JJ - 1                                           3990
0451                      NBUF = RECBLK*IIBLK                                       3991
0452                      PBUF = RECBLK*(IIBLK - 1) + CCLINE(2,JJ)                  3992
0453    C                                                                               
0454    C===   Done so return                                                           
0455    C                                                                               
0456    C     EXECUTE (STORE_REMAINDER)                                             3996

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 109
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0457          ASSIGN 50880 TO KKK030                                                3996
0458          GO TO 79810                                                               
0459    50880 CONTINUE                                                                  
0460    50870 CONTINUE                                                              3997
0461          GO TO 50850                                                           3998
0462    50851 CONTINUE                                                                  
0463    50840 CONTINUE                                                              3999
0464          GO TO 50820                                                           4000
0465    50821 CONTINUE                                                                  
0466          GO TO 50800                                                           4001
0467    50810 CONTINUE                                                                  
0468                CALL SFTLIN(LINES)                                              4002
0469    50800 CONTINUE                                                              4003
0470    50790 CONTINUE                                                              4004
0471          GO TO KKK022                                                          4005
0472    C                                                                               
0473    C                                                                               
0474    C.......................................................................        
0475    C     PROCEDURE (SET_CCLINE)                                                4006
0476    79806 CONTINUE                                                              4006
0477    CP    This procedure sets the block and pointer values in the array CCLINE.     
0478    C                                                                               
0479    C***   First set up proper block number and byte count                          
0480    C                                                                               
0481            J = PBUF + LPBUF                                                    4011
0482            CCLINE(1,NLINES) = LBLK + J/RECBLK                                  4012
0483    C                                                                               
0484    C***   Get byte offset                                                          
0485    C                                                                               
0486          IF (RECBLK .NE. 512)GO TO 50900                                       4016
0487              CCLINE(2,NLINES) = LIB$EXTZV(0,9,J)                               4017
0488          GO TO 50890                                                           4018
0489    50900 CONTINUE                                                                  
0490              CCLINE(2,NLINES) = J - RECBLK*(J/RECBLK)                          4019
0491    50890 CONTINUE                                                              4020
0492            IF (J .NE. 0 .AND. CCLINE(2,NLINES) .EQ. 0)                         4021
0493         1      CCLINE(1,NLINES) = CCLINE(1,NLINES) - 1                             
0494            IF (CCLINE(2,NLINES) .EQ. 0) CCLINE(2,NLINES) = RECBLK              4023
0495          GO TO KKK026                                                          4024
0496    C                                                                               
0497    C                                                                               
0498    C.......................................................................        
0499    C     PROCEDURE (STORE_REMAINDER)                                           4025
0500    79810 CONTINUE                                                              4025
0501    CP    This procedure moves the partial record at the end of BUFFER to           
0502    CP    the beginning of BUFFER and sets NBUF, and PBUF accordingly.              
0503           I=PBUF                                                               4028
0504          GO TO 50909                                                               
0505    50910  I= I+(1)                                                                 
0506          IF ( I.GT.NBUF)GO TO 50911                                                
0507    50909 CONTINUE                                                                  
0508             BUFFER(I-PBUF+1) = BUFFER(I)                                       4029
0509          GO TO 50910                                                           4030
0510    50911 CONTINUE                                                                  
0511            NBUF = NBUF - PBUF + 1                                              4031
0512            I = PBUF + LPBUF                                                    4032
0513          IF (RECBLK .NE. 512)GO TO 50930                                       4033

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 110
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0514              LPBUF = LIB$EXTZV(0,9,I)                                          4034
0515          GO TO 50920                                                           4035
0516    50930 CONTINUE                                                                  
0517              LPBUF = PBUF - RECBLK*(I/RECBLK)                                  4036
0518    50920 CONTINUE                                                              4037
0519            IF (LPBUF .EQ. 0) LPBUF = RECBLK                                    4038
0520            LPBUF = LPBUF - 1                                                   4039
0521            PBUF = 1                                                            4040
0522           I=NLINES                                                             4041
0523          GO TO 50939                                                               
0524    50940  I= I+(-1)                                                                
0525          IF ( I.LT.1)GO TO 50941                                                   
0526    50939 CONTINUE                                                                  
0527          IF (CCLINE(1,I) .EQ. 0)GO TO 50960                                    4042
0528               LBLK = CCLINE(1,I)                                               4043
0529               IF (LPBUF .EQ. 0) LBLK = LBLK + 1                                4044
0530          GO TO 50941                                                           4045
0531    50960 CONTINUE                                                              4046
0532          GO TO 50940                                                           4047
0533    50941 CONTINUE                                                                  
0534            RETURN                                                              4048
0535          END                                                                   4050




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                 2350   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                  24   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                 280   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 LNCN                                  9798   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 CHARS                                79200   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                91721


ENTRY POINTS

    Address  Type  Name          

  0-00000000       LINCON        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  4-00001366  I*4  BLK             3-00000042  I*2  COMLIN          3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK           
  4-0000136A  I*4  FSZ             2-0000000C  I*4  I               2-0000002C  I*4  IFF             4-0000136E  I*4  IFSZ          
  2-0000003C  I*4  II              2-00000040  I*4  IIBLK           2-00000038  I*4  IICHAR          2-00000034  I*4  ILEN          
  2-00000030  I*4  ILF             3-00000000  I*4  INCHAN          2-00000018  I*4  J               2-00000044  I*4  JJ            
  2-00000010  I*4  KKK022          2-00000014  I*4  KKK024          2-0000001C  I*4  KKK026          2-00000024  I*4  KKK028        
  2-00000028  I*4  KKK030          4-0000263E  I*4  LBLK            2-00000020  I*4  LENGTH          3-0000003A  I*2  LENLMT        

LINCON                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 111
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  4-000004B0  I*4  LINEP           4-00002642  I*4  LPBUF           3-00000036  I*4  LRL             4-00001362  I*4  NBUF          
  4-000004B4  I*4  NLINES          3-0000003C  I*4  PAGEND          3-00000040  I*2  PAGLEN          2-00000008  I*4  PBSAVE        
  4-0000135E  I*4  PBUF            4-00001376  I*4  RAT             3-00000023  I*2  RECBLK          4-00001372  I*4  RFM           
  3-00000008  L*1  SBFFLG          4-0000137A  I*4  SBLK           AP-00000004@ L*1  START           3-00000004  I*4  TIME          
  3-00000035  L*1  VT100           3-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  2-00000000  I*4  BUFDSC                  8  (2)
  4-000004B8  L*1  BUFFER               3750  (3750)
  4-0000137E  I*4  CCLINE               4800  (2, 600)
  5-00000000  CHAR LINES               79200  (600)
  4-00000000  I*2  LINLEN               1200  (600)
  3-00000025  I*4  RANGE                  16  (2, 2)
  3-0000000F  I*2  SBFLEN                 20  (10)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

      **      20        0-000000DC  50020     0-000000DC  50030     0-000000D5  50040     0-000000D3  50050     0-00000077  50060   
  0-0000007C  50069     0-000000CB  50070     0-000000CD  50071     0-000000DC  50079     0-000000E7  50090     0-000001E8  50100   
  0-0000016C  50110     0-0000013B  50120     0-00000115  50130     0-0000013B  50140     0-0000012C  50150     0-0000016A  50160   
  0-0000014E  50170     0-0000014C  50180     0-0000016A  50200     0-0000015F  50210     0-0000016A  50220     0-000001E8  50240   
  0-000001E8  50260     0-000001E0  50280         **      50290     0-000001D9  50300     0-0000042E  50310     0-0000026E  50320   
  0-000001FC  50330     0-00000228  50340     0-00000222  50350     0-00000239  50360     0-0000026B  50380     0-0000026B  50390   
  0-00000279  50400     0-000002E6  50410     0-000002BE  50420     0-0000037A  50430     0-00000322  50440     0-000002F6  50450   
  0-00000320  50460     0-00000316  50470     0-000003F9  50490     0-000003F9  50510     0-000003F9  50530     0-000003CF  50540   
      **      50550     0-000003EC  50560     0-0000042E  50580     0-0000042E  50590     0-00000447  50599     0-000006A8  50601   
  0-000004FF  50610     0-00000475  50620     0-000004FF  50630     0-000004A7  50640     0-000004CA  50650     0-000004F4  50660   
  0-00000690  50670     0-000005C4  50680     0-0000055E  50690     0-000005C1  50700     0-0000058D  50710     0-00000627  50720   
  0-000005F3  50730     0-00000690  50750     0-00000668  50760     0-000006ED  50770     0-000007A5  50790     0-000007A5  50800   
  0-0000079C  50810     0-00000727  50819     0-0000071E  50820     0-0000079A  50821     0-00000798  50840     0-0000074F  50849   
  0-00000746  50850     0-00000798  50851     0-00000796  50870     0-00000796  50880     0-0000081A  50890     0-000007FD  50900   
  0-00000870  50909     0-00000863  50910     0-0000088B  50911     0-000008DB  50920     0-000008C4  50930     0-00000904  50939   
  0-000008FB  50940     0-0000092D  50941     0-0000092B  50960     0-000006F8  79802     0-000006B3  79804     0-000007B0  79806   
  0-00000431  79808     0-00000859  79810   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name            Type  Name            Type  Name            Type  Name          

        INTASC           I*4  LIB$EXTZV        I*4  LIB$LOCC              SFTLIN        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 112
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE BRDCST(MESSAGE)                                            4051
0002    C                                                                               
0003    C***********************************************************************        
0004    C*****************************   BRDCST   ******************************        
0005    C***********************************************************************        
0006    C                                                                               
0007    CDM   This subroutine catches broadcast messages and stores them away in        
0008    CDM   common.                                                                   
0009    CDM                                                                             
0010    CDM   Programmer - Jon Vavrus   4 APR 1983                                      
0011    CM                                                                              
0012    CM         This routine is called as an AST whenever a broadcast message        
0013    CM    comes through to the terminal.  That message is then stored away          
0014    CM    in the common area BRDCM1.  A flag is set and a count is updated          
0015    CM    in BRDCM2.                                                                
0016    CM                                                                              
0017    CM         A message is also output on to the screen.                           
0018    C                                                                               
0019    C***   COMMON AREAS                                                             
0020    C                                                                               
0021    CS    BRDCM1  Contains character variables for broadcast handling.              
0022    CS              BRDNOT holds the notice to be displayed on the screen.          
0023    CS              BRDMSG which holds broadcast messages.                          
0024    C                                                                               
0025    CS    BRDCM2  Contains non-character information for broadcast handling.        
0026    CS              BRDLEN the length of strings in BRDMSG.                         
0027    CS              BRDCNT the count of strings in BRDMSG.                          
0028    CS              BRDFLG a flag telling if there are unread messages.             
0029    C                                                                               
0030    CS    DOITNM  Contains information transferred from the main program:           
0031    CS                 INCHAN - input channel of the terminal                       
0032    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0033    CS                 SBFFLG - flag indicating whether there is a string           
0034    CS                          in the search buffer                                
0035    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0036    CS                 EBK    - EBK of input file                                   
0037    CS                 SBFLEN - length of string(s) in search buffer(s)             
0038    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0039    CS                 RANGE  - starting and ending block numbers and pointers      
0040    CS                          of the print range.                                 
0041    CS                 VT100  - flag set .TRUE. if terminal is a VT100              
0042    CS                 LRL    - length of longest record in input file              
0043    CS                 LENLMT - maximum length of output (if <0 then WRAP set)      
0044    CS                 PAGEND - Line number of last line output to screen.          
0045    CS                 PAGLEN - number of lines per page                            
0046    CS                 COMLIN - line number for command input (bottom of screen)    
0047    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0048    C                                                                               
0049          CHARACTER*(*) MESSAGE                                                 4099
0050          CHARACTER*128 BRDMSG(20)                                              4100
0051          CHARACTER*22 BRDNOT                                                   4101
0052          INTEGER*4 TIME,EBK,RANGE(2,2),PAGEND                                  4102
0053          INTEGER*2 DIRECT,SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,              4103
0054         1          BRDCNT,BRDLEN(20)                                               
0055          LOGICAL*1 SBFFLG,VT100,VT100A,BRDFLG                                  4105
0056                                                                                4106
0057          COMMON /BRDCM1/BRDNOT,BRDMSG                                          4107

BRDCST                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 113
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058          COMMON /BRDCM2/BRDLEN,BRDCNT,BRDFLG                                   4108
0059          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4109
0060         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0061                                                                                4111
0062          BRDCNT = BRDCNT + 1                                                   4112
0063          IF (BRDCNT .GT. 20)GO TO 50020                                        4113
0064            BRDFLG = .TRUE.                                                     4114
0065            BRDMSG(BRDCNT) = MESSAGE                                            4115
0066            BRDLEN(BRDCNT) = LEN(MESSAGE)                                       4116
0067          GO TO 50010                                                           4117
0068    50020 CONTINUE                                                                  
0069          DO 50030  I=2,20                                                      4118
0070             BRDMSG(I-1) = BRDMSG(I)                                            4119
0071             BRDLEN(I-1) = BRDLEN(I)                                            4120
0072    50030 CONTINUE                                                              4121
0073            BRDMSG(20) = MESSAGE                                                4122
0074            BRDLEN(20) = LEN(MESSAGE)                                           4123
0075    50010 CONTINUE                                                              4124
0076          IF (.NOT.(VT100))GO TO 50050                                          4125
0077            CALL LIB$PUT_SCREEN(CHAR(27)//'7')                                  4126
0078            CALL LIB$PUT_SCREEN(BRDNOT,COMLIN,IABS(LENLMT)-28)                  4127
0079    50050 CONTINUE                                                              4128
0080          RETURN                                                                4129
0081          END                                                                   4130




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  182   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                   3   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                  52   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 BRDCM1                                2582   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 BRDCM2                                  43   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                 2931


ENTRY POINTS

    Address  Type  Name          

  0-00000000       BRDCST        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  4-00000028  I*2  BRDCNT          4-0000002A  L*1  BRDFLG          3-00000000  CHAR BRDNOT          5-00000042  I*2  COMLIN        
  5-00000009  I*2  DIRECT          5-0000000B  I*4  EBK             2-00000000  I*4  I               5-00000000  I*4  INCHAN        
  5-0000003A  I*2  LENLMT          5-00000036  I*4  LRL            AP-00000004@ CHAR MESSAGE         5-0000003C  I*4  PAGEND        
  5-00000040  I*2  PAGLEN          5-00000023  I*2  RECBLK          5-00000008  L*1  SBFFLG          5-00000004  I*4  TIME          

BRDCST                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 114
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  5-00000035  L*1  VT100           5-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  4-00000000  I*2  BRDLEN                 40  (20)
  3-00000016  CHAR BRDMSG               2560  (20)
  5-00000025  I*4  RANGE                  16  (2, 2)
  5-0000000F  I*2  SBFLEN                 20  (10)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label   

  0-00000086  50010     0-0000004B  50020         **      50030     0-000000B5  50050   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                            

        LIB$PUT_SCREEN                  

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 115
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE CONVUP(LENGTH,LOWER,UPPER)                                 4132
0003    C                                                                               
0004    C***********************************************************************        
0005    C*****************************   CONVUP   ******************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine converts a string from lower to upper case.               
0009    CDM   Both of the strings are passed in non-descriptor form.                    
0010    CDM                                                                             
0011    CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
0012    CM                                                                              
0013    CM         The routine takes a string of bytes starting at the location         
0014    CM    given for LOWER and converts any alphabetic characters in the first       
0015    CM    LENGTH bytes to upper-case, returning the converted string of bytes       
0016    CM    starting at the location given for UPPER.                                 
0017    C                                                                               
0018          INTEGER*2 LENGTH                                                      4148
0019          LOGICAL*1 LOWER(1),UPPER(1)                                           4149
0020                                                                                4150
0021          DO 50010  I=1,LENGTH                                                  4151
0022    C                                                                               
0023    C***   141 octal is lowercase a in ASCII, 172 octal is lowercase z in           
0024    C***   ASCII.  40 octal is the spacing between the upper and lowercase          
0025    C***   alphabets in ASCII.                                                      
0026    C                                                                               
0027          IF (.NOT.(LOWER(I) .GE. '141'O .AND. LOWER(I) .LE. '172'O))GO TO 5    4157
0028         X0030                                                                      
0029             UPPER(I) = LOWER(I) - '40'O                                        4158
0030          GO TO 50020                                                           4159
0031    50030 CONTINUE                                                                  
0032             UPPER(I) = LOWER(I)                                                4160
0033    50020 CONTINUE                                                              4161
0034    50010 CONTINUE                                                              4162
0035          RETURN                                                                4163
0036          END                                                                   4164

CONVUP                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 116
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                   86   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  2 $LOCAL                                  44   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG

    Total Space Allocated                  130


ENTRY POINTS

    Address  Type  Name          

  0-00000000       CONVUP        


VARIABLES

    Address  Type  Name              Address  Type  Name          

  2-00000000  I*4  I              AP-00000004@ I*2  LENGTH        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

 AP-00000008@ L*1  LOWER                   1  (1)
 AP-0000000C@ L*1  UPPER                   1  (1)


LABELS

    Address   Label       Address   Label       Address   Label   

      **      50010     0-0000004E  50020     0-00000049  50030   

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 117
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE EXITR                                                      4166
0003    C                                                                               
0004    C***********************************************************************        
0005    C*******************************   EXITR   *****************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine is invoked on image exit and cancels any                  
0009    CDM   AST, and closes the file and re-stores the terminal.                      
0010    CDM                                                                             
0011    CDM   Programmer - Jon Vavrus  13 JAN 1983                                      
0012    CM                                                                              
0013    CM    Should be set up by a call to SYS$DCLEXH(BLOCK) where block               
0014    CM    is a 4 longword array with this routines address as the second            
0015    CM    longword, 1 as the third longword, and the address of any                 
0016    CM    writable location (longword) as the fourth.                               
0017    C                                                                               
0018    C***   COMMON STORAGE                                                           
0019    C                                                                               
0020    CS    DOITNM  Contains information transferred from the main program:           
0021    CS                 INCHAN - input channel of the terminal                       
0022    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0023    CS                 SBFFLG - flag indicating whether there is a string           
0024    CS                          in the search buffer                                
0025    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0026    CS                 EBK    - EBK of input file                                   
0027    CS                 SBFLEN - length of string(s) in search buffer(s)             
0028    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0029    CS                 RANGE  - starting and ending block numbers and pointers      
0030    CS                          of the print range.                                 
0031    CS                 VT100  - flag set .TRUE. if terminal is a VT100              
0032    C                                                                               
0033    CS    STOPCM  Used to pass information back and forth to/from the stop          
0034    CS            scrolling AST.  STOPIT is a flag set .TRUE. if scrolling          
0035    CS            should be stopped, INBUF is the input character, IOFLAG and       
0036    CS            TIMFLG are event flags, and IOSB is the I/O IOSB.                 
0037    C                                                                               
0038          INTEGER*4 TIMFLG,TIME,EBK,RANGE(2,2)                                  4202
0039          INTEGER*2 IOSB(4),DIRECT,SBFLEN(10),RECBLK                            4203
0040          LOGICAL*1 STOPIT,INBUF,SBFFLG,VT100                                   4204
0041                                                                                4205
0042          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4206
0043         1               VT100                                                      
0044          COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                        4208
0045                                                                                4209
0046          IF (IOFLAG .LE. 0)GO TO 50020                                         4210
0047            CALL SYS$CANCEL(%VAL(INCHAN))                                       4211
0048            CALL LIB$FREE_EF(IOFLAG)                                            4212
0049    50020 CONTINUE                                                              4213
0050          CALL WORKNG(.FALSE.)                                                  4214
0051          CALL RESTRM(INCHAN)                                                   4215
0052          CALL BLKCLS                                                           4216
0053          IF (VT100) CALL LIB$PUT_SCREEN(CHAR(27)//'[0q')                       4217
0054          CALL SYS$DASSGN(%VAL(INCHAN))                                         4218
0055          RETURN                                                                4219
0056          END                                                                   4220

EXITR                          					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 118
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                   95   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                   9   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                  48   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  54   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 STOPCM                                  18   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                  224


ENTRY POINTS

    Address  Type  Name          

  0-00000000       EXITR         


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK             4-00000001  L*1  INBUF           3-00000000  I*4  INCHAN        
  4-00000002  I*4  IOFLAG          3-00000023  I*2  RECBLK          3-00000008  L*1  SBFFLG          4-00000000  L*1  STOPIT        
  3-00000004  I*4  TIME            4-0000000E  I*4  TIMFLG          3-00000035  L*1  VT100         


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  4-00000006  I*2  IOSB                    8  (4)
  3-00000025  I*4  RANGE                  16  (2, 2)
  3-0000000F  I*2  SBFLEN                 20  (10)


LABELS

    Address   Label   

  0-00000028  50020   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        BLKCLS                                  LIB$FREE_EF                             LIB$PUT_SCREEN                  
        RESTRM                                  SYS$CANCEL                              SYS$DASSGN                      
        WORKNG                          

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 119
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE INTASC(LENGTH,DATA,STRING)                                 4222
0003    C                                                                               
0004    C***********************************************************************        
0005    C******************************   INTASC   *****************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine converts a string of ascii coded bytes to a character     
0009    CDM   variable                                                                  
0010    CDM                                                                             
0011    CDM   Programmer - Jon Vavrus    JUL 1980                                       
0012    CM                                                                              
0013    CM         The subroutine is called with LENGTH (the number of bytes to be      
0014    CM    converted), DATA (the starting location of the data), and STRING (a       
0015    CM    character variable to recieve the translation).  After translation the    
0016    CM    LENGTH+1 character of STRING is set to a blank.                           
0017    C                                                                               
0018          CHARACTER*(*) STRING                                                  4238
0019          INTEGER*2 LENGTH                                                      4239
0020          LOGICAL*1 DATA(200)                                                   4240
0021                                                                                4241
0022          DECODE (LENGTH,100,DATA)STRING                                        4242
0023    100   FORMAT (A<LENGTH>)                                                    4243
0024          STRING(LENGTH+1:LENGTH+1) = ' '                                       4244
0025          RETURN                                                                4245
0026          END                                                                   4246




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  107   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                   7   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                  32   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG

    Total Space Allocated                  146


ENTRY POINTS

    Address  Type  Name          

  0-00000000       INTASC        


VARIABLES

    Address  Type  Name              Address  Type  Name          

  2-00000000@ I*2  LENGTH         AP-0000000C@ CHAR STRING        

INTASC                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 120
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

ARRAYS

    Address  Type  Name                Bytes  Dimensions

 AP-00000008@ L*1  DATA                  200  (200)


LABELS

    Address   Label   

  1-00000000  100'    

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 121
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE REDOIT(COMAND,NUMFLG,TANUMB,MINFLG)                        4248
0003    C                                                                               
0004    C***********************************************************************        
0005    C*****************************   REDOIT   ******************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This routine calls DOIT                                                   
0009    CDM                                                                             
0010    CDM   Programmer - Jon Vavrus  26 AUG 1981                                      
0011    CM                                                                              
0012    CM         The routine simply calls DOIT with the same argument list.           
0013    CM    This allows DOIT to call itself.                                          
0014    C                                                                               
0015    C***   CALLED ROUTINES                                                          
0016    C                                                                               
0017    C     DOIT    Executes commands                                                 
0018    C                                                                               
0019          INTEGER*4 COMAND                                                      4265
0020          LOGICAL*1 MINFLG,NUMFLG                                               4266
0021                                                                                4267
0022    C      CALL DOIT(COMAND,NUMFLG,TANUMB,MINFLG)                                   
0023          RETURN                                                                4269
0024          END                                                                   4270




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                    3   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG

    Total Space Allocated                    3


ENTRY POINTS

    Address  Type  Name          

  0-00000000       REDOIT        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

 AP-00000004@ I*4  COMAND         AP-00000010@ L*1  MINFLG         AP-00000008@ L*1  NUMFLG         AP-0000000C@ R*4  TANUMB        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 122
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE SFTLIN(LINES)                                              4272
0003    C                                                                               
0004    C***********************************************************************        
0005    C*****************************   SFTLIN   ******************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine shifts the output lines stored in the line storage        
0009    CDM   arrays in order to make room at the end of the arrays for more lines.     
0010    CDM                                                                             
0011    CDM    Programmer - Jon Vavrus  13 NOV 1980                                     
0012    CDM    Revised    - Jon Vavrus  12 MAY 1981                                     
0013    CDM    Revised    - Jon Vavrus  29 JUL 1981 (change CCLINE usage)               
0014    CDM    Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                     
0015    CM                                                                              
0016    CM         The routine requires LINES (the character array of actual            
0017    CM    output lines) to be passed as an argument, all the other arrays are       
0018    CM    passed through common area LNCN.  The normal shift is to make room        
0019    CM    for 100 more lines at the end, however, if there are less then 500        
0020    CM    lines already then the shift frees up 599 of the 600 lines.  When         
0021    CM    the shift occurs lines shifted off the front of the arrays are lost.      
0022    C                                                                               
0023    C***   COMMON AREAS                                                             
0024    C                                                                               
0025    CS    LNCN    Contains output arrays, and file pointers and information:        
0026    CS                 LINLEN - array of output line lengths                        
0027    CS                 LINEP  - top of screen line (or last line output by          
0028    CS                          backward scroll)                                    
0029    CS                 NLINES - number of lines in arrays                           
0030    CS                 BUFFER - array of unconverted data                           
0031    CS                 PBUF   - current position in BUFFER                          
0032    CS                 NBUF   - number of bytes in BUFFER                           
0033    CS                 BLK    - next block in file                                  
0034    CS                 FSZ    - record length for FIX files, or FSZ for VFC files   
0035    CS                 IFSZ   - word extended record length for FIX files           
0036    CS                 RFM    - files RFM                                           
0037    CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)      
0038    CS                 SBLK   - starting block of current batch of output lines     
0039    CS                 CCLINE - array containing pointer to where the line's        
0040    CS                          record starts in the file (CCLINE(1,x) = block      
0041    CS                          #, CCLINE(2,x) = byte number in block).  If         
0042    CS                          CCLINE(1,x) = 0 then it is a carriage control       
0043    CS                          line.                                               
0044    CS                 LBLK   - last block processed by LINCON                      
0045    CS                 LPBUF  - last value of PBUF processed by LINCON              
0046    C                                                                               
0047          CHARACTER*132 LINES(600)                                              4317
0048          INTEGER*4 RFM,RAT,FSZ,PBUF,BLK,SBLK,CCLINE(2,600)                     4318
0049          INTEGER*2 LINLEN(600)                                                 4319
0050          LOGICAL*1 BUFFER(3750)                                                4320
0051                                                                                4321
0052          COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,       4322
0053         1             RFM,RAT,SBLK,CCLINE,LBLK,LPBUF                               
0054                                                                                4324
0055          IF (LINEP .LE. 500)GO TO 50020                                        4325
0056            J = 500                                                             4326
0057          GO TO 50010                                                           4327

SFTLIN                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 123
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    50020 CONTINUE                                                                  
0059            J = LINEP - 1                                                       4328
0060    50010 CONTINUE                                                              4329
0061          DO 50030  I=J,600                                                     4330
0062           LINLEN(I-J+1) = LINLEN(I)                                            4331
0063           LINES(I-J+1) = LINES(I)                                              4332
0064           CCLINE(1,I-J+1) = CCLINE(1,I)                                        4333
0065           CCLINE(2,I-J+1) = CCLINE(2,I)                                        4334
0066    50030 CONTINUE                                                              4335
0067          DO 50040  I=1,J-1                                                     4336
0068          IF (CCLINE(1,I) .EQ. 0)GO TO 50060                                    4337
0069             SBLK = CCLINE(1,I)                                                 4338
0070          GO TO 50041                                                           4339
0071    50060 CONTINUE                                                              4340
0072    50040 CONTINUE                                                              4341
0073    50041 CONTINUE                                                                  
0074          LINEP = LINEP - J + 1                                                 4342
0075          NLINES = 600 - J + 1                                                  4343
0076          RETURN                                                                4344
0077          END                                                                   4345




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  221   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  2 $LOCAL                                  40   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 LNCN                                  9798   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                10059


ENTRY POINTS

    Address  Type  Name          

  0-00000000       SFTLIN        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  3-00001366  I*4  BLK             3-0000136A  I*4  FSZ             2-00000004  I*4  I               3-0000136E  I*4  IFSZ          
  2-00000000  I*4  J               3-0000263E  I*4  LBLK            3-000004B0  I*4  LINEP           3-00002642  I*4  LPBUF         
  3-00001362  I*4  NBUF            3-000004B4  I*4  NLINES          3-0000135E  I*4  PBUF            3-00001376  I*4  RAT           
  3-00001372  I*4  RFM             3-0000137A  I*4  SBLK          

SFTLIN                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 124
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

ARRAYS

    Address  Type  Name                Bytes  Dimensions

  3-000004B8  L*1  BUFFER               3750  (3750)
  3-0000137E  I*4  CCLINE               4800  (2, 600)
 AP-00000004@ CHAR LINES               79200  (600)
  3-00000000  I*2  LINLEN               1200  (600)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  0-00000039  50010     0-00000033  50020         **      50030         **      50040     0-000000BC  50041     0-000000B7  50060   

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 125
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE STOPSC                                                     4347
0003    C                                                                               
0004    C***********************************************************************        
0005    C*****************************   STOPSC   ******************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine is the AST used to stop the scrolling function.           
0009    CDM                                                                             
0010    CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
0011    CDM   Revised    - Jon Vavrus  12 MAY 1981                                      
0012    CDM   Revised    - Jon Vavrus  26 AUG 1981                                      
0013    CDM   Revised    - Jon Vavrus   6 NOV 1981                                      
0014    CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
0015    CM                                                                              
0016    CM         The routine is executed whenever anything is typed while a           
0017    CM    scroll is in progress.  If the character typed is "(" or a symbol         
0018    CM    defined as "(", all timer requests are cancelled, the timer event         
0019    CM    flag is set, and STOPIT is set to .TRUE..  If the character typed         
0020    CM    is not one of the above, then the I/O is requeued with STPSC2 as          
0021    CM    its AST (STPSC2 just calls this routine), and the character is in-        
0022    CM    serted into the input buffer.                                             
0023    C                                                                               
0024    C***   CALLED ROUTINES                                                          
0025    C                                                                               
0026    CC    STPSC2  Routine which simply calls this one.                              
0027    C                                                                               
0028    C***   COMMON AREAS                                                             
0029    C                                                                               
0030    C                                                                               
0031    CS    STOPCM  Used to pass information back and forth to/from the main          
0032    CS            process.  STOPIT is a flag set .TRUE. if scrolling should         
0033    CS            be stopped, INBUF is the input character, IOFLAG and TIMFLG       
0034    CS            are event flags, and IOSB is the I/O IOSB.                        
0035    C                                                                               
0036    CS    DOITNM  Contains information transferred from the main program:           
0037    CS                 INCHAN - input channel of the terminal                       
0038    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0039    CS                 SBFFLG - flag indicating whether there is a string           
0040    CS                          in the search buffer                                
0041    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0042    CS                 EBK    - EBK of input file                                   
0043    CS                 SBFLEN - length of string(s) in search buffer(s)             
0044    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0045    CS                 RANGE  - starting and ending block numbers and pointers      
0046    CS                          of the print range.                                 
0047    CS                 VT100  - flag set .TRUE. if terminal is a VT100              
0048    CS                 LRL    - length of longest record in input file              
0049    CS                 LENLMT - maximum length of output (if <0 then WRAP set)      
0050    CS                 PAGEND - Line number of last line output to screen.          
0051    CS                 PAGLEN - number of lines per page                            
0052    CS                 COMLIN - line number for command input (bottom of screen)    
0053    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0054    C                                                                               
0055    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0056    CS            symbols SYMS and the definition search buffers DEFBUF             
0057    C                                                                               

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 126
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0059    CS            symbol definitions DEFS, the number of such definitions           
0060    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0061    CS            numbers NUMDEF                                                    
0062    C                                                                               
0063    C***   INPUT VARIABLES                                                          
0064    C                                                                               
0065    CI    INBUF   One byte buffer used for the QIO input request.                   
0066    C                                                                               
0067    C***   INPUT UNIT                                                               
0068    C                                                                               
0069    CR    INCHAN  Channel number of the terminal.                                   
0070    C                                                                               
0071          EXTERNAL STPSC2                                                       4416
0072          CHARACTER*128 INLINE                                                  4417
0073          CHARACTER*30 DEFBUF(10,10,60)                                         4418
0074          CHARACTER*1 SYMS(60)                                                  4419
0075          REAL*4 NUMDEF(10,60)                                                  4420
0076          INTEGER*4 TIMFLG,TIME,EBK,RANGE(2,2),PAGEND                           4421
0077          INTEGER*2 IOSB(4),DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,     4422
0078         1          LENSAV,PAGLEN,COMLIN                                            
0079          LOGICAL*1 INBUF,STOPIT,ERROUT(5),SBFFLG,VT100,DEFFLG(3,10,60),        4424
0080         1          VT100A                                                          
0081                                                                                4426
0082          COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG                        4427
0083          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4428
0084         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0085          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                     4430
0086          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                        4431
0087                                                                                4432
0088          DATA ERROUT/7,27,'[','3','q'/                                         4433
0089          IF (.NOT.(IOSB(1) .NE. '830'X .AND. IOSB(1) .NE. '2C'X))GO TO 5002    4434
0090         X0                                                                         
0091    C                                                                               
0092    C***   Is the character a (                                                     
0093    C                                                                               
0094          IF (INBUF .NE. '(')GO TO 50040                                        4438
0095              CALL SYS$CANTIM(,)                                                4439
0096              STOPIT = .TRUE.                                                   4440
0097              CALL SYS$SETEF(%VAL(TIMFLG))                                      4441
0098          GO TO 50030                                                           4442
0099    50040 CONTINUE                                                                  
0100    C                                                                               
0101    C***   Is the character a symbol defined as (                                   
0102    C                                                                               
0103          DO 50050  I=1,NDEFS                                                   4446
0104          IF (.NOT.(ICHAR(SYMS(I)) .EQ. INBUF .AND. DEFS(1,1,I) .EQ. 6))GO T    4447
0105         XO 50070                                                                   
0106                 CALL SYS$CANTIM(,)                                             4448
0107                 STOPIT = .TRUE.                                                4449
0108                 CALL SYS$SETEF(%VAL(TIMFLG))                                   4450
0109                 RETURN                                                         4451
0110    50070 CONTINUE                                                              4452
0111    50050 CONTINUE                                                              4453
0112    C                                                                               
0113    C***   If character is not a control character add it to INLINE (input          
0114    C***   buffer)                                                                  

STOPSC                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 127
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115    C                                                                               
0116          IF (.NOT.(INBUF .GE. 32 .AND. INBUF .LE. 126))GO TO 50090             4458
0117                LENSAV = LENSAV + 1                                             4459
0118                INLINE(LENSAV:LENSAV) = CHAR(INBUF)                             4460
0119          GO TO 50080                                                           4461
0120    50090 CONTINUE                                                                  
0121    C                                                                               
0122    C***   If it is a <DEL> then remove the last character                          
0123    C                                                                               
0124          IF (.NOT.(INBUF .EQ. 127 .AND. LENSAV .GE. 1))GO TO 50110             4465
0125                  LENSAV = LENSAV - 1                                           4466
0126          GO TO 50100                                                           4467
0127    50110 CONTINUE                                                                  
0128    C                                                                               
0129    C***   If it is a ^X or ^U then delete entire buffer                            
0130    C                                                                               
0131          IF (.NOT.(INBUF .EQ. 24 .OR. INBUF .EQ. 21))GO TO 50130               4471
0132                    LENSAV = 0                                                  4472
0133    50130 CONTINUE                                                              4473
0134    50100 CONTINUE                                                              4474
0135    50080 CONTINUE                                                              4475
0136    C                                                                               
0137    C***   Requeue request                                                          
0138    C                                                                               
0139              CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,        4479
0140         1                 STPSC2,,INBUF,%VAL(1),,,,)                               
0141    50030 CONTINUE                                                              4481
0142    50020 CONTINUE                                                              4482
0143          RETURN                                                                4483
0144          END                                                                   4484

STOPSC                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 128
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  252   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  2 $LOCAL                                  84   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 STOPCM                                  18   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               198017


ENTRY POINTS

    Address  Type  Name          

  0-00000000       STOPSC        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  4-00000042  I*2  COMLIN          4-00000009  I*2  DIRECT          4-0000000B  I*4  EBK             2-00000008  I*4  I             
  3-00000001  L*1  INBUF           4-00000000  I*4  INCHAN          5-00000000  CHAR INLINE          3-00000002  I*4  IOFLAG        
  4-0000003A  I*2  LENLMT          6-00000000  I*2  LENSAV          4-00000036  I*4  LRL             6-00003392  I*4  NDEFS         
  4-0000003C  I*4  PAGEND          4-00000040  I*2  PAGLEN          4-00000023  I*2  RECBLK          4-00000008  L*1  SBFFLG        
  3-00000000  L*1  STOPIT          4-00000004  I*4  TIME            3-0000000E  I*4  TIMFLG          4-00000035  L*1  VT100         
  4-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  5-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  6-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  6-00000002  I*2  DEFS                13200  (11, 10, 60)
  2-00000000  L*1  ERROUT                  5  (5)
  3-00000006  I*2  IOSB                    8  (4)
  6-00003A9E  R*4  NUMDEF               2400  (10, 60)
  4-00000025  I*4  RANGE                  16  (2, 2)
  4-0000000F  I*2  SBFLEN                 20  (10)
  5-00000080  CHAR SYMS                   60  (60)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  0-000000FB  50020     0-000000FB  50030     0-00000045  50040         **      50050     0-00000096  50070     0-000000E6  50080   
  0-000000C8  50090     0-000000E6  50100     0-000000D8  50110     0-000000E6  50130   

STOPSC                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 129
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name            Type  Name            Type  Name            Type  Name          

        STPSC2                SYS$CANTIM            SYS$QIO               SYS$SETEF     

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 130
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE STPSC2                                                     4486
0003    C                                                                               
0004    C***********************************************************************        
0005    C*****************************   STPSC2   ******************************        
0006    C***********************************************************************        
0007    C                                                                               
0008    CDM   This subroutine is the AST for the I/O request from STOPSC, if            
0009    CDM   invoked it will call STOPSC and exit.                                     
0010    CDM                                                                             
0011    CDM   Programmer - Jon Vavrus  13 NOV 1980                                      
0012    C                                                                               
0013    C***   CALLED ROUTINES                                                          
0014    C                                                                               
0015    C     STOPSC   Actual AST routine.                                              
0016    C                                                                               
0017    C      CALL STOPSC                                                              
0018          RETURN                                                                4502
0019          END                                                                   4503




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                    3   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG

    Total Space Allocated                    3


ENTRY POINTS

    Address  Type  Name          

  0-00000000       STPSC2        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 131
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE TMAST2                                                     4505
0003    C                                                                               
0004    C****************************************************************************** 
0005    C*********************************   TMAST2   ********************************* 
0006    C****************************************************************************** 
0007    C                                                                               
0008    C                                                                               
0009    CDM   This routine is simply a means for TIMAST to refer to itself.  All it     
0010    CDM   does is call TIMAST.                                                      
0011    CDM                                                                             
0012    CDM   Programmer  Jon Vavrus -  3 SEP 1982                                      
0013    CDM   Revised     Jon Vavrus - 21 SEP 1983 (changed name with TIMAST)           
0014    C                                                                               
0015    C***   CALLED ROUTINES                                                          
0016    C                                                                               
0017    C     TIMAST    - Routine to actually output the next message.                  
0018    C                                                                               
0019    C      CALL TIMAST                                                              
0020          RETURN                                                                4523
0021          END                                                                   4524




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                    3   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG

    Total Space Allocated                    3


ENTRY POINTS

    Address  Type  Name          

  0-00000000       TMAST2        

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 132
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE TIMAST                                                     4526
0003    C                                                                               
0004    C****************************************************************************** 
0005    C*********************************   TIMAST   ********************************* 
0006    C****************************************************************************** 
0007    C                                                                               
0008    CDM   This routine outputs the proper "WORKING" message at the bottom of the    
0009    CDM   screen and requeues itself as a timer AST (through TMAST2).               
0010    CDM                                                                             
0011    CDM   Programmer  Jon Vavrus -  8 SEP 1982                                      
0012    CDM   Revised     Jon Vavrus - 21 SEP 1983 (changed name with TMAST2)           
0013    C                                                                               
0014    C***   CALLED ROUTINES                                                          
0015    C                                                                               
0016    CC    TMAST2   - Routine which calls this one.                                  
0017    C                                                                               
0018    C***   COMMON AREAS                                                             
0019    C                                                                               
0020    CS    DOITNM  Contains information transferred from the main program:           
0021    CS                 INCHAN - input channel of the terminal                       
0022    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0023    CS                 SBFFLG - flag indicating whether there is a string           
0024    CS                          in the search buffer                                
0025    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0026    CS                 EBK    - EBK of input file                                   
0027    CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
0028    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0029    CS                 RANGE  - beginning and ending block numbers and pointers     
0030    CS                          of the print range                                  
0031    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0032    CS                 LRL    - length of the longest record in input file.         
0033    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0034    CS                 PAGEND - line number of last line output to screen           
0035    CS                 PAGLEN - number of lines per page                            
0036    CS                 COMLIN - line number for command input (bottom of screen)    
0037    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0038    C                                                                               
0039    CS    TASTNM  Used to pass the ROW and COLUMN for the message, the flag         
0040    CS            ONEFLG, the timer delta time DELTA, and the timer event flag      
0041    CS            TIMREF.                                                           
0042    C                                                                               
0043          EXTERNAL TMAST2                                                       4567
0044          INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,TIMREF,DELTA(2)           4568
0045          INTEGER*2 SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,DIRECT,ROW,COLUMN    4569
0046          LOGICAL*1 SBFFLG,VT100,VT100A,START,ONEFLG                            4570
0047                                                                                4571
0048          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4572
0049         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0050          COMMON /TASTNM/ROW,COLUMN,ONEFLG,DELTA,TIMREF                         4574
0051                                                                                4575
0052          IF (.NOT.(ONEFLG))GO TO 50020                                         4576
0053          IF (.NOT.(VT100A))GO TO 50040                                         4577
0054              CALL LIB$PUT_SCREEN(CHAR(27)//'[7mWORKING'//CHAR(27)//'[0m',      4578
0055         1                        ROW,COLUMN)                                       
0056          GO TO 50030                                                           4580
0057    50040 CONTINUE                                                                  

TIMAST                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 133
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058              CALL LIB$PUT_SCREEN('WORKING',ROW,COLUMN)                         4581
0059    50030 CONTINUE                                                              4582
0060            ONEFLG = .FALSE.                                                    4583
0061          GO TO 50010                                                           4584
0062    50020 CONTINUE                                                                  
0063          IF (.NOT.(VT100A))GO TO 50060                                         4585
0064              CALL LIB$PUT_SCREEN(CHAR(27)//'[1mWORKING'//CHAR(27)//'[0m',      4586
0065         1                        ROW,COLUMN)                                       
0066          GO TO 50050                                                           4588
0067    50060 CONTINUE                                                                  
0068              CALL LIB$PUT_SCREEN('working',ROW,COLUMN)                         4589
0069    50050 CONTINUE                                                              4590
0070            ONEFLG = .TRUE.                                                     4591
0071    50010 CONTINUE                                                              4592
0072    C                                                                               
0073    C***   Queue AST                                                                
0074    C                                                                               
0075          CALL SYS$SETIMR(%VAL(TIMREF),DELTA,TMAST2,%VAL(1))                    4596
0076          RETURN                                                                4597
0077          END                                                                   4598




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  101   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                  48   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                 120   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 TASTNM                                  17   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                  355


ENTRY POINTS

    Address  Type  Name          

  0-00000000       TIMAST        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  4-00000002  I*2  COLUMN          3-00000042  I*2  COMLIN          3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK           
  3-00000000  I*4  INCHAN          3-0000003A  I*2  LENLMT          3-00000036  I*4  LRL             4-00000004  L*1  ONEFLG        
  3-0000003C  I*4  PAGEND          3-00000040  I*2  PAGLEN          3-00000023  I*2  RECBLK          4-00000000  I*2  ROW           
  3-00000008  L*1  SBFFLG          2-00000000  L*1  START           3-00000004  I*4  TIME            4-0000000D  I*4  TIMREF        
  3-00000035  L*1  VT100           3-00000044  L*1  VT100A        

TIMAST                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 134
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

ARRAYS

    Address  Type  Name                Bytes  Dimensions

  4-00000005  I*4  DELTA                   8  (2)
  3-00000025  I*4  RANGE                  16  (2, 2)
  3-0000000F  I*2  SBFLEN                 20  (10)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  0-00000054  50010     0-00000033  50020     0-0000002B  50030     0-00000023  50040     0-0000004D  50050     0-00000045  50060   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        LIB$PUT_SCREEN                          SYS$SETIMR                              TMAST2                          

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 135
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001                                                                                   
0002          SUBROUTINE WORKNG(START)                                              4600
0003    C                                                                               
0004    C****************************************************************************** 
0005    C*********************************   WORKNG   ********************************* 
0006    C****************************************************************************** 
0007    C                                                                               
0008    CDM   This subroutine puts out the flashing "WORKING" message.                  
0009    CDM                                                                             
0010    CDM   Programmer  Jon Vavrus -  8 SEP 1982                                      
0011    CM                                                                              
0012    CM    The message is displayed at screen position COMLIN(from DOITNM),          
0013    CM    IABS(LENLMT)-19(DOITNM also) if START (logical) is .TRUE., and is         
0014    CM    stopped if START is .FALSE..  The changing of the display is done         
0015    CM    through the use of a system timer AST.                                    
0016    C                                                                               
0017    C***   COMMON AREAS                                                             
0018    C                                                                               
0019    CS    DOITNM  Contains information transferred from the main program:           
0020    CS                 INCHAN - input channel of the terminal                       
0021    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0022    CS                 SBFFLG - flag indicating whether there is a string           
0023    CS                          in the search buffer                                
0024    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0025    CS                 EBK    - EBK of input file                                   
0026    CS                 SBFLEN - length(s) of string(s) in search buffer(s)          
0027    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0028    CS                 RANGE  - beginning and ending block numbers and pointers     
0029    CS                          of the print range                                  
0030    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0031    CS                 LRL    - length of the longest record in input file.         
0032    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0033    CS                 PAGEND - line number of last line output to screen           
0034    CS                 PAGLEN - number of lines per page                            
0035    CS                 COMLIN - line number for command input (bottom of screen)    
0036    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0037    C                                                                               
0038    CS    TASTNM  Used to pass the ROW and COLUMN for the message, the flag         
0039    CS            ONEFLG, the timer delta time DELTA, and the timer event flag      
0040    CS            TIMREF.                                                           
0041    C                                                                               
0042    C***   CALLED ROUTINES                                                          
0043    C                                                                               
0044    CC    TIMAST  Timer AST.                                                        
0045    C                                                                               
0046          EXTERNAL TIMAST                                                       4644
0047          INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND,TIMREF,DELTA(2)           4645
0048          INTEGER*2 SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMLIN,DIRECT,ROW,COLUMN    4646
0049          LOGICAL*1 SBFFLG,VT100,VT100A,START,ONEFLG                            4647
0050                                                                                4648
0051          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4649
0052         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0053          COMMON /TASTNM/ROW,COLUMN,ONEFLG,DELTA,TIMREF                         4651
0054                                                                                4652
0055          DATA DELTA/-20000000,-1/                                              4653
0056                                                                                4654
0057          IF (.NOT.(START))GO TO 50020                                          4655

WORKNG                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 136
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    C                                                                               
0059    C***   Set up to start                                                          
0060    C                                                                               
0061            ONEFLG = .FALSE.                                                    4659
0062            CALL LIB$GET_EF(TIMREF)                                             4660
0063            ROW = COMLIN                                                        4661
0064            COLUMN = IABS(LENLMT) - 19                                          4662
0065    C                                                                               
0066    C***   Output message                                                           
0067    C                                                                               
0068          IF (.NOT.(VT100A))GO TO 50040                                         4666
0069              CALL LIB$PUT_SCREEN(CHAR(27)//'[7mWORKING'//CHAR(27)//'[0m',      4667
0070         1                        ROW,COLUMN)                                       
0071          GO TO 50030                                                           4669
0072    50040 CONTINUE                                                                  
0073              CALL LIB$PUT_SCREEN('WORKING',ROW,COLUMN)                         4670
0074    50030 CONTINUE                                                              4671
0075    C                                                                               
0076    C***   Queue AST                                                                
0077    C                                                                               
0078            CALL SYS$SETIMR(%VAL(TIMREF),DELTA,TIMAST,%VAL(1))                  4675
0079          GO TO 50010                                                           4676
0080    50020 CONTINUE                                                                  
0081          IF (TIMREF .LE. 0)GO TO 50060                                         4677
0082    C                                                                               
0083    C***   Make sure not invoked at wrong time by EXITR                             
0084    C                                                                               
0085    C***   Done working, cancel timer requests and clear message                    
0086    C                                                                               
0087              CALL SYS$CANTIM(%VAL(1),)                                         4683
0088              CALL LIB$PUT_SCREEN('       ',ROW,COLUMN)                         4684
0089              CALL LIB$SET_CURSOR(1,1)                                          4685
0090              CALL LIB$FREE_EF(TIMREF)                                          4686
0091    50060 CONTINUE                                                              4687
0092    50010 CONTINUE                                                              4688
0093          RETURN                                                                4689
0094          END                                                                   4690

WORKNG                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 137
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                  133   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                  36   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                 124   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 TASTNM                                  17   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated                  379


ENTRY POINTS

    Address  Type  Name          

  0-00000000       WORKNG        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

  4-00000002  I*2  COLUMN          3-00000042  I*2  COMLIN          3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK           
  3-00000000  I*4  INCHAN          3-0000003A  I*2  LENLMT          3-00000036  I*4  LRL             4-00000004  L*1  ONEFLG        
  3-0000003C  I*4  PAGEND          3-00000040  I*2  PAGLEN          3-00000023  I*2  RECBLK          4-00000000  I*2  ROW           
  3-00000008  L*1  SBFFLG         AP-00000004@ L*1  START           3-00000004  I*4  TIME            4-0000000D  I*4  TIMREF        
  3-00000035  L*1  VT100           3-00000044  L*1  VT100A        


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  4-00000005  I*4  DELTA                   8  (2)
  3-00000025  I*4  RANGE                  16  (2, 2)
  3-0000000F  I*2  SBFLEN                 20  (10)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

  0-00000084  50010     0-00000060  50020     0-00000051  50030     0-00000049  50040     0-00000084  50060   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        LIB$FREE_EF                             LIB$GET_EF                              LIB$PUT_SCREEN                  
        LIB$SET_CURSOR                          SYS$CANTIM                              SYS$SETIMR                      
        TIMAST                          

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 138
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0001          SUBROUTINE PRSCOM(LINE,LENLIN,ICOM,NUMFLG,ANUMB,MINFLG,NDEF,NSYM)     4691
0002    CDM   This routine parses a command line.                                       
0003    CDM                                                                             
0004    CDM   Programmer - Jon Vavrus  26 AUG 1981                                      
0005    CDM   Revised    - Jon Vavrus   3 SEP 1981                                      
0006    CDM   Revised    - Jon Vavrus  23 SEP 1981                                      
0007    CDM   Revised    - Jon Vavrus  30 DEC 1981 (put LED #1 turn-on in DOIT)         
0008    CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)         
0009    CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)                      
0010    CDM   Revised    - Jon Vavrus   9 SEP 1982                                      
0011    CDM   Revised    - Jon Vavrus  30 NOV 1982                                      
0012    CDM   Revised    - Jon Vavrus  28 MAY 1983 (Allow real scroll speeds)           
0013    CDM   Revised    - Jon Vavrus   7 SEP 1983                                      
0014    CDM   Revised    - Jon Vavrus  21 SEP 1983                                      
0015    CM                                                                              
0016    CM         The routine parses a command line.  It is passed the command line    
0017    CM    in LINE its length in LENLIN.  The command number is returned in          
0018    CM    ICOM, if it is "minussed" the flag MINFLG is set, if there is a number    
0019    CM    preceding it the number is stored in ANUMB and the flag NUMFLG is         
0020    CM    set.  If ICOM = 0 then no command was found/legal (error "beep" +         
0021    CM    LED 3 are taken care of).  If a defined symbol is found its commands      
0022    CM    are executed and ICOM = -1.  After execution the procedure sets LINE      
0023    CM    and LENLIN to the after parse values.  Note:  If a definition symbol      
0024    CM    encountered, it's internal commands will be executed should NDEF or       
0025    CM    NSYM be zero, otherwise its definition will be inserted into the          
0026    CM    definition arrays  beginning at command NDEF of definition NSYM.          
0027    C                                                                               
0028    C***   CALLED ROUTINES                                                          
0029    C                                                                               
0030    CC    DOIT    Executes commands                                                 
0031    C                                                                               
0032    C***   COMMON AREAS                                                             
0033    C                                                                               
0034    CS    CHARS   Used to pass character variables; contains LINES a character      
0035    CS            array of the output lines, and SRCHBF the search buffer, and      
0036    CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are       
0037    CS            the VT100 control sequences to set/unset reverse video            
0038    C                                                                               
0039    CS    DOITNM  Contains information transferred from the main program:           
0040    CS                 INCHAN - input channel of the terminal                       
0041    CS                 TIME   - scrolling speed in -10000000*seconds/line           
0042    CS                 SBFFLG - flag indicating whether there is a string           
0043    CS                          in the search buffer                                
0044    CS                 DIRECT - flag for reverse (-1 for reverse, else 1)           
0045    CS                 EBK    - EBK of input file                                   
0046    CS                 SBFLEN - length of string(s) in search buffer(s)             
0047    CS                 RECBLK - number of bytes used per block in FIX-BLK files     
0048    CS                 RANGE  - beginning and ending block numbers and pointers     
0049    CS                          of the print range                                  
0050    CS                 VT100  - flag set .TRUE. if terminal is VT100.               
0051    CS                 LRL    - length of the longest record in input file.         
0052    CS                 LENLMT - maximum output length (if <0 then WRAP set)         
0053    CS                 PAGEND - line number of last line output to screen           
0054    CS                 PAGLEN - number of lines per page                            
0055    CS                 COMLIN - line number for command input (bottom of screen)    
0056    CS                 VT100A - flag set .TRUE. if VT100 has advanced video option  
0057    C                                                                               

                               					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 139
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0058    CS    INPUTC  Contains the input character buffer INLINE and the defined        
0059    CS            symbols SYMS and the definition search buffers DEFBUF             
0060    C                                                                               
0061    CS    INPUTN  Contains the input character buffer length LENSAV, and the        
0062    CS            symbol definitions DEFS, the number of such definitions           
0063    CS            (NDEFS), the definition flags DEFFLG, and the definition          
0064    CS            numbers NUMDEF                                                    
0065    C                                                                               
0066    CS    PRSCHR  Contains the current symbol's search buffers (CURBUF)             
0067    C                                                                               
0068    CS    PRSNUM  Contains the current symbol's definitions (CUR), flags            
0069    CS            (CURFLG), and associated numbers (NUMCUR)                         
0070    C                                                                               
0071    C***   OUTPUT UNITS                                                             
0072    C                                                                               
0073    CW    9       Output to terminal.  Carriage-control LIST if file is either      
0074    CW            CR, FTN, or PRN; otherwise no carriage-control.                   
0075    C                                                                               
0076          CHARACTER*(*) LINE                                                    4766
0077          CHARACTER*132 LINES(600)                                              4767
0078          CHARACTER*128 INLINE                                                  4768
0079          CHARACTER*30 SRCHBF(10),DEFBUF(10,10,60),CURBUF(10,10)                4769
0080          CHARACTER*11 SWIT                                                     4770
0081          CHARACTER*8 NARROW                                                    4771
0082          CHARACTER*4 REVVID,REGVID,WRAP                                        4772
0083          CHARACTER*3 BOX                                                       4773
0084          CHARACTER*2 CRLF                                                      4774
0085          CHARACTER*1 SYMS(60),COMAND(13),QUOTE                                 4775
0086          REAL*4 NUMDEF(10,60),NUMCUR(10)                                       4776
0087          INTEGER*4 INCHAN,TIME,EBK,RANGE(2,2),PAGEND                           4777
0088          INTEGER*2 DIRECT,SBFLEN(10),RECBLK,DEFS(11,10,60),LENLMT,LENSAV,      4778
0089         1          PAGLEN,CUR(11,10),COMLIN                                        
0090          LOGICAL*1 SBFFLG,NUMFLG,MINFLG,ESC,VT100,BELL,DEFFLG(3,10,60),        4780
0091         1          CURFLG(3,10),VT100A                                             
0092                                                                                4782
0093          COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,     4783
0094         1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A               
0095          COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID                         4785
0096          COMMON /INPUTC/INLINE,SYMS,DEFBUF                                     4786
0097          COMMON /INPUTN/LENSAV,DEFS,NDEFS,DEFFLG,NUMDEF                        4787
0098          COMMON /PRSNUM/CUR,NUMCUR,CURFLG                                      4788
0099          COMMON /PRSCHR/CURBUF                                                 4789
0100                                                                                4790
0101          DATA NUMCOM,COMAND/13,'$','%','^','!','#','(',')','*',' ','&','@',    4791
0102         1                   '+','<'/                                               
0103          DATA BELL,ESC/7,27/                                                   4793
0104    C                                                                               
0105    C***   Setup things                                                             
0106    C                                                                               
0107          NSRCH = 0                                                             4797
0108          IF (.NOT.(SBFFLG))GO TO 50020                                         4798
0109          DO 50030  I=1,10                                                      4799
0110          IF (SBFLEN(I) .EQ. 0)GO TO 50031                                      4800
0111             NSRCH = NSRCH + 1                                                  4801
0112    50030 CONTINUE                                                              4802
0113    50031 CONTINUE                                                                  
0114    50020 CONTINUE                                                              4803

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 140
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0115          NUMFLG = .FALSE.                                                      4804
0116          MINFLG = .FALSE.                                                      4805
0117                                                                                4806
0118      100 CONTINUE                                                              4807
0119    50039 CONTINUE                                                                  
0120    C                                                                               
0121    C***   Trim leading blanks                                                      
0122    C                                                                               
0123          IF (LENLIN .LE. 0)GO TO 50060                                         4811
0124             K = LIB$SKPC(' ',LINE(:LENLIN))                                    4812
0125          IF (K .NE. 0)GO TO 50080                                              4813
0126               LENLIN = 0                                                       4814
0127          GO TO 50070                                                           4815
0128    50080 CONTINUE                                                                  
0129               LINE = LINE(K:LENLIN)                                            4816
0130               LENLIN = LENLIN - K + 1                                          4817
0131    50070 CONTINUE                                                              4818
0132    50060 CONTINUE                                                              4819
0133          IF (LENLIN .NE. 0)GO TO 50100                                         4820
0134    C     EXECUTE (NO_COMMAND)                                                  4821
0135          ASSIGN 50110 TO KKK022                                                4821
0136          GO TO 79802                                                               
0137    50110 CONTINUE                                                                  
0138    50100 CONTINUE                                                              4822
0139    C                                                                               
0140    C***   Check for " or '                                                         
0141    C                                                                               
0142          IF (LINE(1:1) .NE. '"')GO TO 50130                                    4826
0143          IF (LENLIN .NE. 1)GO TO 50150                                         4827
0144    C     EXECUTE (INVALID_COMMAND)                                             4828
0145          ASSIGN 50160 TO KKK024                                                4828
0146          GO TO 79804                                                               
0147    50160 CONTINUE                                                                  
0148    50150 CONTINUE                                                              4829
0149             K = 1                                                              4830
0150    50169 CONTINUE                                                              4831
0151              J = INDEX(LINE(K+1:LENLIN),'"') + K                               4832
0152          IF (K .NE. J)GO TO 50190                                              4833
0153    C     EXECUTE (INVALID_COMMAND)                                             4834
0154          ASSIGN 50200 TO KKK024                                                4834
0155          GO TO 79804                                                               
0156    50200 CONTINUE                                                                  
0157    50190 CONTINUE                                                              4835
0158          IF (LINE(J+1:J+1) .EQ. '"')GO TO 50220                                4836
0159                NSRCH = 1                                                       4837
0160    C     EXECUTE (INSERT_SEARCH_STRING)                                        4838
0161          ASSIGN 50230 TO KKK026                                                4838
0162          GO TO 79806                                                               
0163    50230 CONTINUE                                                                  
0164          GO TO 50171                                                           4839
0165    50220 CONTINUE                                                              4840
0166            K = J + 1                                                           4841
0167          GO TO 50169                                                           4842
0168    50171 CONTINUE                                                                  
0169          GO TO 50120                                                           4843
0170    50130 IF (LINE(1:1) .NE. '''')GO TO 50240                                       
0171          IF (LENLIN .NE. 1)GO TO 50260                                         4844

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 141
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0172    C     EXECUTE (INVALID_COMMAND)                                             4845
0173          ASSIGN 50270 TO KKK024                                                4845
0174          GO TO 79804                                                               
0175    50270 CONTINUE                                                                  
0176    50260 CONTINUE                                                              4846
0177             K = 1                                                              4847
0178    50279 CONTINUE                                                              4848
0179              J = INDEX(LINE(K+1:LENLIN),'''') + K                              4849
0180          IF (K .NE. J)GO TO 50300                                              4850
0181    C     EXECUTE (INVALID_COMMAND)                                             4851
0182          ASSIGN 50310 TO KKK024                                                4851
0183          GO TO 79804                                                               
0184    50310 CONTINUE                                                                  
0185    50300 CONTINUE                                                              4852
0186          IF (LINE(J+1:J+1) .EQ. '''')GO TO 50330                               4853
0187                NSRCH = NSRCH + 1                                               4854
0188    C     EXECUTE (INSERT_SEARCH_STRING)                                        4855
0189          ASSIGN 50340 TO KKK026                                                4855
0190          GO TO 79806                                                               
0191    50340 CONTINUE                                                                  
0192          GO TO 50281                                                           4856
0193    50330 CONTINUE                                                              4857
0194            K = J + 1                                                           4858
0195          GO TO 50279                                                           4859
0196    50281 CONTINUE                                                                  
0197    C                                                                               
0198    C***   Check for minus sign                                                     
0199    C                                                                               
0200          GO TO 50120                                                           4863
0201    50240 IF (LINE(1:1) .NE. '-')GO TO 50350                                        
0202          IF (LENLIN .NE. 1)GO TO 50370                                         4864
0203    C     EXECUTE (NO_COMMAND)                                                  4865
0204          ASSIGN 50380 TO KKK022                                                4865
0205          GO TO 79802                                                               
0206    50380 CONTINUE                                                                  
0207    50370 CONTINUE                                                              4866
0208             I = LIB$SKPC(' ',LINE(2:LENLIN)) + 1                               4867
0209          IF (I .NE. 1)GO TO 50400                                              4868
0210    C     EXECUTE (NO_COMMAND)                                                  4869
0211          ASSIGN 50410 TO KKK022                                                4869
0212          GO TO 79802                                                               
0213    50410 CONTINUE                                                                  
0214    50400 CONTINUE                                                              4870
0215    C                                                                               
0216    C---   Check for --&                                                            
0217    C                                                                               
0218          IF (LINE(I:I) .NE. '-')GO TO 50430                                    4874
0219          IF (LENLIN .NE. I)GO TO 50450                                         4875
0220    C     EXECUTE (NO_COMMAND)                                                  4876
0221          ASSIGN 50460 TO KKK022                                                4876
0222          GO TO 79802                                                               
0223    50460 CONTINUE                                                                  
0224    50450 CONTINUE                                                              4877
0225               J = LIB$SKPC(' ',LINE(I+1:LENLIN)) + I                           4878
0226          IF (I .NE. J)GO TO 50480                                              4879
0227    C     EXECUTE (NO_COMMAND)                                                  4880
0228          ASSIGN 50490 TO KKK022                                                4880

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 142
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0229          GO TO 79802                                                               
0230    50490 CONTINUE                                                                  
0231    50480 CONTINUE                                                              4881
0232          IF (LINE(J:J) .NE. '&')GO TO 50510                                    4882
0233                 ICOM = 9                                                       4883
0234                 LINE = LINE(J+1:LENLIN)                                        4884
0235                 LENLIN = LENLIN - J                                            4885
0236                 RETURN                                                         4886
0237    50510 CONTINUE                                                              4887
0238                 MINFLG = .NOT.MINFLG                                           4888
0239                 LINE = LINE(I:LENLIN)                                          4889
0240                 LENLIN = LENLIN - I + 1                                        4890
0241    C                                                                               
0242    C---   Check for number                                                         
0243    C                                                                               
0244          GO TO 50420                                                           4895
0245    50430 IF (.NOT.(ICHAR(LINE(I:I)) .GE. ICHAR('0') .AND.                          
0246         X          ICHAR(LINE(I:I)) .LE. ICHAR('9')))GO TO 50520                   
0247    C     EXECUTE (GET_NUMBER)                                                  4897
0248          ASSIGN 50530 TO KKK028                                                4897
0249          GO TO 79808                                                               
0250    50530 CONTINUE                                                                  
0251          GO TO 50420                                                           4898
0252    50520 CONTINUE                                                                  
0253    C                                                                               
0254    C---   Otherwise it is minus flag                                               
0255    C                                                                               
0256               MINFLG = .NOT.MINFLG                                             4902
0257               LINE = LINE(I:LENLIN)                                            4903
0258               LENLIN = LENLIN - I + 1                                          4904
0259    50420 CONTINUE                                                              4905
0260    C                                                                               
0261    C***   Check for number                                                         
0262    C                                                                               
0263          GO TO 50120                                                           4909
0264    50350 IF (.NOT.(ICHAR(LINE(1:1)) .GE. ICHAR('0') .AND.                          
0265         X          ICHAR(LINE(1:1)) .LE. ICHAR('9')))GO TO 50540                   
0266    C     EXECUTE (GET_NUMBER)                                                  4911
0267          ASSIGN 50550 TO KKK028                                                4911
0268          GO TO 79808                                                               
0269    50550 CONTINUE                                                                  
0270          GO TO 50120                                                           4912
0271    50540 IF (LINE(1:1) .NE. '+')GO TO 50560                                        
0272          IF (LENLIN .NE. 1)GO TO 50580                                         4913
0273               ICOM = 12                                                        4914
0274               LENLIN = 0                                                       4915
0275               RETURN                                                           4916
0276    50580 CONTINUE                                                              4917
0277             I = LIB$SKPC(' ',LINE(2:LENLIN)) + 1                               4918
0278          IF (I .NE. 1)GO TO 50600                                              4919
0279               ICOM = 12                                                        4920
0280               LENLIN = 0                                                       4921
0281               RETURN                                                           4922
0282    50600 CONTINUE                                                              4923
0283          IF (.NOT.(ICHAR(LINE(I:I)) .LE. ICHAR('9') .AND.                      4924
0284         X          ICHAR(LINE(I:I)) .GE. ICHAR('0')))GO TO 50620                   
0285    C     EXECUTE (GET_NUMBER)                                                  4926

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 143
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0286          ASSIGN 50630 TO KKK028                                                4926
0287          GO TO 79808                                                               
0288    50630 CONTINUE                                                                  
0289          GO TO 50610                                                           4927
0290    50620 CONTINUE                                                                  
0291               LINE = LINE(I:LENLIN)                                            4928
0292               LENLIN = LENLIN - I + 1                                          4929
0293               ICOM = 12                                                        4930
0294               RETURN                                                           4931
0295    50610 CONTINUE                                                              4932
0296          GO TO 50120                                                           4933
0297    50560 CONTINUE                                                                  
0298    C                                                                               
0299    C***   Otherwise it must be a command                                           
0300    C                                                                               
0301          DO 50640  ICOM=1,NUMCOM                                               4937
0302          IF (LINE(1:1) .NE. COMAND(ICOM))GO TO 50660                           4938
0303                LINE = LINE(2:)                                                 4939
0304                LENLIN = LENLIN - 1                                             4940
0305                RETURN                                                          4941
0306    50660 CONTINUE                                                              4942
0307    50640 CONTINUE                                                              4943
0308    C                                                                               
0309    C***   Not a command symbol, check for definition                               
0310    C                                                                               
0311          DO 50670  J=1,NDEFS                                                   4947
0312          IF (SYMS(J) .NE. LINE(1:1))GO TO 50690                                4948
0313          IF (.NOT.(NUMFLG))GO TO 50710                                         4949
0314                  NUMBER = ANUMB                                                4950
0315          GO TO 50700                                                           4951
0316    50710 CONTINUE                                                                  
0317                  NUMBER = 1                                                    4952
0318    50700 CONTINUE                                                              4953
0319                LINE = LINE(2:LENLIN)                                           4954
0320                LENLIN = LENLIN - 1                                             4955
0321          IF (.NOT.(NDEF .EQ. 0 .OR. NSYM .EQ. 0))GO TO 50730                   4956
0322    C                                                                               
0323    C---   Executable definition                                                    
0324    C                                                                               
0325          DO 50740  L=1,NUMBER                                                  4960
0326          DO 50750  K=1,10                                                      4961
0327          IF (DEFS(1,K,J) .EQ. 0)GO TO 50751                                    4962
0328          IF (.NOT.(DEFFLG(3,K,J)))GO TO 50770                                  4963
0329          DO 50780  JJ=1,10                                                     4964
0330                       SRCHBF(JJ) = DEFBUF(JJ,K,J)                              4965
0331                       SBFLEN(JJ) = DEFS(1+JJ,K,J)                              4966
0332          IF (SBFLEN(JJ) .EQ. 0)GO TO 50781                                     4967
0333    50780 CONTINUE                                                              4968
0334    50781 CONTINUE                                                                  
0335                      SBFFLG = .TRUE.                                           4969
0336    50770 CONTINUE                                                              4970
0337                    CALL DOIT(DEFS(1,K,J),DEFFLG(1,K,J),NUMDEF(K,J),            4971
0338         1                    DEFFLG(2,K,J))                                        
0339    50750 CONTINUE                                                              4973
0340    50751 CONTINUE                                                                  
0341    50740 CONTINUE                                                              4974
0342                  ICOM = -1                                                     4975

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 144
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0343                  RETURN                                                        4976
0344    50730 CONTINUE                                                              4977
0345    C                                                                               
0346    C---   Definition insertion                                                     
0347    C                                                                               
0348          DO 50790  L=1,NUMBER                                                  4981
0349          IF (J .NE. NSYM)GO TO 50810                                           4982
0350    C                                                                               
0351    C===   If symbol is the one being defined then use current stuff                
0352    C                                                                               
0353          DO 50820  JJ=1,10                                                     4986
0354          IF (NDEF .LE. 10)GO TO 50840                                          4987
0355                        ICOM = 0                                                4988
0356                        RETURN                                                  4989
0357    50840 CONTINUE                                                              4990
0358                      DEFS(1,NDEF,NSYM) = CUR(1,JJ)                             4991
0359          IF (CUR(1,JJ) .EQ. 0)GO TO 50821                                      4992
0360                      NUMDEF(NDEF,NSYM) = NUMCUR(JJ)                            4993
0361                      DEFFLG(1,NDEF,NSYM) = CURFLG(1,JJ)                        4994
0362                      DEFFLG(2,NDEF,NSYM) = CURFLG(2,JJ)                        4995
0363                      DEFFLG(3,NDEF,NSYM) = CURFLG(3,JJ)                        4996
0364          DO 50850  K=1,10                                                      4997
0365                       DEFS(1+K,NDEF,NSYM) = CUR(1+K,JJ)                        4998
0366          IF (CUR(1+K,JJ) .EQ. 0)GO TO 50851                                    4999
0367                       DEFBUF(K,NDEF,NSYM) = CURBUF(K,JJ)                       5000
0368    50850 CONTINUE                                                              5001
0369    50851 CONTINUE                                                                  
0370                      NDEF = NDEF + 1                                           5002
0371    50820 CONTINUE                                                              5003
0372    50821 CONTINUE                                                                  
0373          GO TO 50800                                                           5004
0374    50810 CONTINUE                                                                  
0375          DO 50860  K=1,10                                                      5005
0376          IF (NDEF .LE. 10)GO TO 50880                                          5006
0377                        ICOM = 0                                                5007
0378                        RETURN                                                  5008
0379    50880 CONTINUE                                                              5009
0380          IF (DEFS(1,K,J) .EQ. 0)GO TO 50861                                    5010
0381                      DEFFLG(1,NDEF,NSYM) = DEFFLG(1,K,J)                       5011
0382                      DEFFLG(2,NDEF,NSYM) = DEFFLG(2,K,J)                       5012
0383                      DEFFLG(3,NDEF,NSYM) = DEFFLG(3,K,J)                       5013
0384          DO 50890  JJ=1,10                                                     5014
0385                       DEFBUF(JJ,NDEF,NSYM) = DEFBUF(JJ,K,J)                    5015
0386                       DEFS(1+JJ,NDEF,NSYM) = DEFS(1+JJ,K,J)                    5016
0387          IF (DEFS(1+JJ,NDEF,NSYM) .EQ. 0)GO TO 50891                           5017
0388    50890 CONTINUE                                                              5018
0389    50891 CONTINUE                                                                  
0390                      NUMDEF(NDEF,NSYM) = NUMDEF(K,J)                           5019
0391                      DEFS(1,NDEF,NSYM) = DEFS(1,K,J)                           5020
0392                      NDEF = NDEF + 1                                           5021
0393    50860 CONTINUE                                                              5022
0394    50861 CONTINUE                                                                  
0395    50800 CONTINUE                                                              5023
0396    50790 CONTINUE                                                              5024
0397          GO TO 50040                                                           5025
0398    50690 CONTINUE                                                              5027
0399    50670 CONTINUE                                                              5028

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 145
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0400    C                                                                               
0401    C***   If it gets here it didn't match anything                                 
0402    C                                                                               
0403    C     EXECUTE (INVALID_COMMAND)                                             5032
0404          ASSIGN 50900 TO KKK024                                                5032
0405          GO TO 79804                                                               
0406    50900 CONTINUE                                                                  
0407    50120 CONTINUE                                                              5033
0408    50040 GO TO 50039                                                           5034
0409    C                                                                               
0410    C************************************************************************       
0411    C********************   HERE FOLLOW THE PROCEDURES   ********************       
0412    C************************************************************************       
0413    C                                                                               
0414    C                                                                               
0415    C                                                                               
0416    C.......................................................................        
0417    C     PROCEDURE (GET_NUMBER)                                                5040
0418    79808 CONTINUE                                                              5040
0419    CP    This procedure converts the number which starts the line into a           
0420    CP    real (floating point) number in ANUMB.                                    
0421          IF (LENLIN .NE. 1)GO TO 50920                                         5043
0422    C     EXECUTE (NO_COMMAND)                                                  5044
0423          ASSIGN 50930 TO KKK022                                                5044
0424          GO TO 79802                                                               
0425    50930 CONTINUE                                                                  
0426          GO TO 50910                                                           5045
0427    50920 CONTINUE                                                                  
0428           I=2                                                                  5046
0429          GO TO 50939                                                               
0430    50940  I= I+(1)                                                                 
0431          IF ( I.GT.LENLIN)GO TO 50941                                              
0432    50939 CONTINUE                                                                  
0433          IF (.NOT.(LINE(I:I) .EQ. ' ' .OR. (ICHAR(LINE(I:I))              .    5047
0434         XGE. ICHAR('0') .AND. ICHAR(LINE(I:I)) .LE. ICHAR('9'))           .        
0435         XOR. LINE(I:I) .EQ. '.'))GO TO 50941                                       
0436          GO TO 50940                                                           5050
0437    50941 CONTINUE                                                                  
0438              READ (UNIT=LINE(:I-1),FMT=200,IOSTAT=J) ANUMB                     5051
0439    200       FORMAT (F<I-1>.0)                                                 5052
0440          IF (J .NE. 0)GO TO 50960                                              5053
0441                LINE = LINE(I:LENLIN)                                           5054
0442                LENLIN = LENLIN - I + 1                                         5055
0443                NUMFLG = .TRUE.                                                 5056
0444          GO TO 50950                                                           5057
0445    50960 CONTINUE                                                                  
0446    C     EXECUTE (INVALID_COMMAND)                                             5058
0447          ASSIGN 50970 TO KKK024                                                5058
0448          GO TO 79804                                                               
0449    50970 CONTINUE                                                                  
0450    50950 CONTINUE                                                              5059
0451    50910 CONTINUE                                                              5060
0452          GO TO KKK028                                                          5061
0453    C                                                                               
0454    C                                                                               
0455    C.......................................................................        
0456    C     PROCEDURE (INSERT_SEARCH_STRING)                                      5062

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 146
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0457    79806 CONTINUE                                                              5062
0458    CP    This procedure inserts a search string (LINE(2:J-1)) in the search        
0459    CP    buffers as string NSRCH.                                                  
0460    C                                                                               
0461    C***   Only ten strings                                                         
0462    C                                                                               
0463          IF (NSRCH .LE. 10)GO TO 50990                                         5068
0464           I=1                                                                  5069
0465          GO TO 50999                                                               
0466    51000  I= I+(1)                                                                 
0467          IF ( I.GT.9)GO TO 51001                                                   
0468    50999 CONTINUE                                                                  
0469               SRCHBF(I) = SRCHBF(I+1)                                          5070
0470               SBFLEN(I) = SBFLEN(I+1)                                          5071
0471          GO TO 51000                                                           5072
0472    51001 CONTINUE                                                                  
0473              NSRCH = 10                                                        5073
0474    50990 CONTINUE                                                              5074
0475            SRCHBF(NSRCH) = LINE(2:J-1)                                         5075
0476            SBFLEN(NSRCH) = J - 2                                               5076
0477            LENLIN = LENLIN - J                                                 5077
0478            QUOTE = LINE(1:1)                                                   5078
0479            IF (LENLIN .GT. 0) LINE = LINE(J+1:)                                5079
0480    C                                                                               
0481    C***   Get rid of double quotes                                                 
0482    C                                                                               
0483            J = 1                                                               5083
0484    51009 CONTINUE                                                              5084
0485             I = INDEX(SRCHBF(NSRCH)(J:SBFLEN(NSRCH)),QUOTE) + J - 1            5085
0486          IF (I .EQ. (J - 1))GO TO 51011                                        5086
0487             SRCHBF(NSRCH) = SRCHBF(NSRCH)(:I)//SRCHBF(NSRCH)(I+2:)             5087
0488             SBFLEN(NSRCH) = SBFLEN(NSRCH) - 1                                  5088
0489             J = I + 1                                                          5089
0490          GO TO 51009                                                           5090
0491    51011 CONTINUE                                                                  
0492            SBFLEN(NSRCH+1) = 0                                                 5091
0493            SBFFLG = .TRUE.                                                     5092
0494          GO TO KKK026                                                          5093
0495    C                                                                               
0496    C                                                                               
0497    C.......................................................................        
0498    C     PROCEDURE (INVALID_COMMAND)                                           5094
0499    79804 CONTINUE                                                              5094
0500    CP    This procedure takes care of invalid command syntax.                      
0501            CALL LIB$PUT_SCREEN(CHAR(BELL))                                     5096
0502          IF (.NOT.(VT100))GO TO 51030                                          5097
0503              CALL LIB$PUT_SCREEN(CHAR(ESC)//'[3q')                             5098
0504    51030 CONTINUE                                                              5099
0505            ICOM = 0                                                            5100
0506            RETURN                                                              5101
0507    C                                                                               
0508    C                                                                               
0509    C.......................................................................        
0510    C     PROCEDURE (NO_COMMAND)                                                5103
0511    79802 CONTINUE                                                              5103
0512    CP    This procedure handles a "empty" line.                                    
0513            ICOM = 0                                                            5105

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 147
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

0514            LENLIN = 0                                                          5106
0515            RETURN                                                              5107
0516          END                                                                   5109




PROGRAM SECTIONS

    Name				 Bytes   Attributes

  0 $CODE                                 2468   PIC CON REL LCL   SHR   EXE   RD NOWRT LONG
  1 $PDATA                                  17   PIC CON REL LCL   SHR NOEXE   RD NOWRT LONG
  2 $LOCAL                                 272   PIC CON REL LCL NOSHR NOEXE   RD   WRT LONG
  3 DOITNM                                  69   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  4 CHARS                                79510   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  5 INPUTC                              180188   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  6 INPUTN                               17406   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  7 PRSNUM                                 290   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG
  8 PRSCHR                                3000   PIC OVR REL GBL   SHR NOEXE   RD   WRT LONG

    Total Space Allocated               283220


ENTRY POINTS

    Address  Type  Name          

  0-00000000       PRSCOM        


VARIABLES

    Address  Type  Name              Address  Type  Name              Address  Type  Name              Address  Type  Name          

 AP-00000014@ R*4  ANUMB           2-00000029  L*1  BELL            2-00000024  CHAR BOX             3-00000042  I*2  COMLIN        
  4-0001368C  CHAR CRLF            3-00000009  I*2  DIRECT          3-0000000B  I*4  EBK             2-00000028  L*1  ESC           
  2-00000034  I*4  I              AP-0000000C@ I*4  ICOM            3-00000000  I*4  INCHAN          5-00000000  CHAR INLINE        
  2-00000044  I*4  J               2-00000058  I*4  JJ              2-00000038  I*4  K               2-0000003C  I*4  KKK022        
  2-00000040  I*4  KKK024          2-00000048  I*4  KKK026          2-0000004C  I*4  KKK028          2-00000054  I*4  L             
 AP-00000008@ I*4  LENLIN          3-0000003A  I*2  LENLMT          6-00000000  I*2  LENSAV         AP-00000004@ CHAR LINE          
  3-00000036  I*4  LRL            AP-00000018@ L*1  MINFLG          2-00000018  CHAR NARROW         AP-0000001C@ I*4  NDEF          
  6-00003392  I*4  NDEFS           2-00000030  I*4  NSRCH          AP-00000020@ I*4  NSYM            2-00000050  I*4  NUMBER        
  2-0000002C  I*4  NUMCOM         AP-00000010@ L*1  NUMFLG          3-0000003C  I*4  PAGEND          3-00000040  I*2  PAGLEN        
  2-00000027  CHAR QUOTE           3-00000023  I*2  RECBLK          4-00013692  CHAR REGVID          4-0001368E  CHAR REVVID        
  3-00000008  L*1  SBFFLG          2-0000000D  CHAR SWIT            3-00000004  I*4  TIME            3-00000035  L*1  VT100         
  3-00000044  L*1  VT100A          2-00000020  CHAR WRAP          


ARRAYS

    Address  Type  Name                Bytes  Dimensions

  2-00000000  CHAR COMAND                 13  (13)
  7-00000000  I*2  CUR                   220  (11, 10)
  8-00000000  CHAR CURBUF               3000  (10, 10)
  7-00000104  L*1  CURFLG                 30  (3, 10)

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 148
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

  5-000000BC  CHAR DEFBUF             180000  (10, 10, 60)
  6-00003396  L*1  DEFFLG               1800  (3, 10, 60)
  6-00000002  I*2  DEFS                13200  (11, 10, 60)
  4-00000000  CHAR LINES               79200  (600)
  7-000000DC  R*4  NUMCUR                 40  (10)
  6-00003A9E  R*4  NUMDEF               2400  (10, 60)
  3-00000025  I*4  RANGE                  16  (2, 2)
  3-0000000F  I*2  SBFLEN                 20  (10)
  4-00013560  CHAR SRCHBF                300  (10)
  5-00000080  CHAR SYMS                   60  (60)


LABELS

    Address   Label       Address   Label       Address   Label       Address   Label       Address   Label       Address   Label   

      **      100       1-00000006  200'      0-00000039  50020         **      50030     0-00000039  50031     0-0000003F  50039   
  0-00000712  50040     0-00000081  50060     0-0000007D  50070     0-00000060  50080     0-00000091  50100     0-00000091  50110   
  0-00000712  50120     0-00000104  50130     0-000000A8  50150     0-000000A8  50160     0-000000AC  50169     0-00000101  50171   
  0-000000DD  50190     0-000000DD  50200     0-000000F9  50220     0-000000F7  50230     0-00000176  50240     0-0000011B  50260   
  0-0000011B  50270     0-0000011F  50279     0-00000173  50281     0-00000150  50300     0-00000150  50310     0-0000016B  50330   
  0-00000169  50340     0-000002E4  50350     0-00000190  50370     0-00000190  50380     0-000001C1  50400     0-000001C1  50410   
  0-000002E1  50420     0-00000283  50430     0-000001F2  50450     0-000001F2  50460     0-00000227  50480     0-00000227  50490   
  0-0000025D  50510     0-000002BD  50520     0-000002BB  50530     0-00000300  50540     0-000002FD  50550     0-000003A6  50560   
  0-00000317  50580     0-00000345  50600     0-000003A3  50610     0-0000037F  50620     0-0000037D  50630         **      50640   
  0-000003D6  50660         **      50670     0-000006FE  50690     0-00000415  50700     0-00000411  50710     0-00000516  50730   
      **      50740         **      50750     0-00000508  50751     0-000004BE  50770         **      50780     0-000004B7  50781   
      **      50790     0-000006F3  50800     0-00000606  50810         **      50820     0-00000603  50821     0-00000543  50840   
      **      50850     0-000005F9  50851         **      50860     0-000006F3  50861     0-00000614  50880         **      50890   
  0-000006B5  50891     0-00000712  50900     0-000007F6  50910     0-00000729  50920     0-00000726  50930     0-00000739  50939   
  0-0000072F  50940     0-0000078B  50941     0-000007F6  50950     0-000007EB  50960     0-000007F6  50970     0-00000840  50990   
  0-00000816  50999     0-0000080D  51000     0-0000083C  51001     0-00000897  51009     0-00000925  51011     0-0000098E  51030   
  0-00000992  79802     0-00000942  79804     0-00000801  79806     0-00000715  79808   


FUNCTIONS AND SUBROUTINES REFERENCED

  Type  Name                              Type  Name                              Type  Name                            

        DOIT                               I*4  LIB$INDEX                               LIB$PUT_SCREEN                  
   I*4  LIB$SKPC                        


COMMAND QUALIFIERS

  FORTRAN /LIS=LOOK.FLS/NOOBJ LOOK

  /CHECK=(NOBOUNDS,OVERFLOW,NOUNDERFLOW)
  /DEBUG=(NOSYMBOLS,TRACEBACK)
  /STANDARD=(NOSYNTAX,NOSOURCE_FORM)
  /SHOW=(NOPREPROCESSOR,NOINCLUDE,MAP)
  /F77  /NOG_FLOATING  /I4  /OPTIMIZE  /WARNINGS  /NOD_LINES  /NOCROSS_REFERENCE  /NOMACHINE_CODE  /CONTINUATIONS=19

PRSCOM                         					30-Sep-1983 08:38:38	VAX-11 FORTRAN V3.3-45              Page 149
								30-Sep-1983 08:30:12	JPLSCR:[JLV.LOOK]LOOK.FOR;1                 

COMPILATION STATISTICS

  Run Time:           107.30 seconds
  Elapsed Time:       458.87 seconds
  Page Faults:        3853
  Dynamic Memory:     656 pages
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   1
Table of contents
                                                                                                                                     
    (1)        2        BLKIN - BLOCK INPUT ROUTINE
    (1)       73        BLKOPN - OPENS A FILE FOR BLOCK INPUT
    (1)      167        BLKSIN - INPUTS 7 BLOCKS OF DATA
    (1)      219        BLKCLS - CLOSES OPEN FILE
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   2
                                                                         26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
                                     0000     1 	.TITLE	BLKIN - THESE ROUTINES ARE FOR BLOCK IO
                                     0000     2 	.SUBTITLE	BLKIN - BLOCK INPUT ROUTINE
                                     0000     3
                                     0000     4 ;DM   This module contains routines for block I/O
                                     0000     5 ;DM        BLKOPN opens a file for block input
                                     0000     6 ;DM        BLKSIN inputs 7 blocks of data
                                     0000     7 ;DM        BLKIN  inputs one block of data
                                     0000     8 ;DM        BLKCLS closes the file
                                     0000     9 ;DM
                                     0000    10 ;DM   Programmer - Jon Vavrus  28 OCT 1980
                                     0000    11 ;DM   Revised    - Jon Vavrus  12 MAY 1981
                                     0000    12 ;DM   Revised    - Jon Vavrus  27 JUL 1981
                                     0000    13 ;DM   Revised    - Jon Vavrus  29 JUL 1981
                                     0000    14 ;DM   Revised    - Jon Vavrus  26 AUG 1981
                                     0000    15 ;DM
                                     0000    16 ;DM   BLKIN inputs the a single block of data from the file opened by
                                     0000    17 ;DM   BLKOPN.
                                     0000    18 ;M
                                     0000    19 ;M         The routine BLKIN inputs the Nth block of the file.  N is the
                                     0000    20 ;M    first argument in the call list, the second argument receives the
                                     0000    21 ;M    actual number of bytes input, and the third argument is the
                                     0000    22 ;M    address of the buffer to receive the input.
                                     0000    23 ;
                                     0000    24 ;	ENTRY POINTS
                                     0000    25 ;
                                     0000    26 ;E    BLKOPN  Opens a file for block input.
                                     0000    27 ;E    BLKSIN  Inputs seven blocks of data.
                                     0000    28 ;E    BLKIN   Inputs one block of data.
                                     0000    29 ;E    BLKCLS  Closes the file opened by BLKOPN.
                                     0000    30 ;
                                     0000    31 ;	COMMON AREAS USED
                                     0000    32 ;
                                     0000    33 ;S      Contains the number of bytes per block (in case of NOSPAN)
                                     0000    34
                                 00000000    35 		.PSECT	DOITNM,PIC,USR,OVR,REL,GBL,SHR,NOEXE,RD,WRT,LONG
                                     0000    36
                           00000023  0000    37 		.BLKB	35
                           00000025  0023    38 RECBLK:		.BLKW	1
                                     0025    39
                                 00000000    40 		.PSECT	BLKDAT,LONG
                                     0000    41
                                     0000    42 BLKFABIN:	$FAB	FAC=<BIO,GET>,FOP=RCK,XAB=BLKXAB
                                     0050    43 BLKRABIN:	$RAB	FAB=BLKFABIN,ROP=BIO,USZ=512
                                     0094    44 BLKXAB:		$XABFHC	NXT=0
                           00000000  00C0    45 EBK:		.LONG
                               0000  00C4    46 EBK_BYTES:	.WORD
                                     00C6    47
                                     00C6    48 ;
                                     00C6    49 ;	BLKIN
                                     00C6    50 ;
                                 00000000    51 	.PSECT		BLKIN,NOWRT
                               0000  0000    52 	.ENTRY		BLKIN,^M<>
           00000088'EF   04 BC   D0  0002    53 	MOVL		@4(AP),<BLKRABIN+RAB$L_BKT>	; get block number
           00000074'EF   0C AC   D0  000A    54 	MOVL		12(AP),<BLKRABIN+RAB$L_UBF>	; get buffer address
     000000C0'EF   00000088'EF   D1  0012    55 	CMPL		<BLKRABIN+RAB$L_BKT>,EBK	; last block?
                            0D   12  001D    56 	BNEQ		190$
     00000070'EF   000000C4'EF   B0  001F    57 	MOVW		EBK_BYTES,<BLKRABIN+RAB$W_USZ>	; set transfer size
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   3
                                BLKIN - BLOCK INPUT ROUTINE              26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
                            0B   11  002A    58 	BRB		195$
     00000070'EF   00000023'EF   B0  002C    59 190$:	MOVW		RECBLK,<BLKRABIN+RAB$W_USZ>	; set transfer size
                                     0037    60 195$:	$READ		RAB=BLKRABIN			; read a block
              00000000'8F   50   D1  0044    61 	CMPL		R0,#RMS$_NORMAL			; error ?
                            04   13  004B    62 	BEQL		200$
                         08 BC   D4  004D    63 	CLRL		@8(AP)				; if so clear arg. 2
                                 04  0050    64 	RET
           08 BC   00000072'EF   3C  0051    65 200$:	MOVZWL		<BLKRABIN+RAB$W_RSZ>,@8(AP)	; move number of bytes
                                     0059    66 							; to argument 2
           00000023'EF   08 BC   B1  0059    67 	CMPW		@8(AP),RECBLK			; test for >RECBLK
                            08   15  0061    68 	BLEQ		210$
           08 BC   00000023'EF   3C  0063    69 	MOVZWL		RECBLK,@8(AP)
                    04 BC   01   C0  006B    70 210$:	ADDL2		#1,@4(AP)			; increment block #
                                 04  006F    71 	RET
                                     0070    72
                                     0070    73 	.SUBTITLE	BLKOPN - OPENS A FILE FOR BLOCK INPUT
                                     0070    74 ;
                                     0070    75 ;	BLKOPN
                                     0070    76 ;
                                     0070    77 ;DM
                                     0070    78 ;DM   BLKOPN opens a file for block input.
                                     0070    79 ;M
                                     0070    80 ;M         The routine BLKOPN takes a seven element argument list:
                                     0070    81 ;M              The first contains the name of the file to be opened;
                                     0070    82 ;M              The second receives a completion code (1 is success);
                                     0070    83 ;M              The third receives the files RFM;
                                     0070    84 ;M              The fourth receives a value for the files RAT:
                                     0070    85 ;M                   1 = CR
                                     0070    86 ;M                   2 = FTN
                                     0070    87 ;M                   3 = PRN
                                     0070    88 ;M                   4 = none
                                     0070    89 ;M                   <0 indicates BLK is set;
                                     0070    90 ;M              The fifth receives the files FSZ for VFC files, or the
                                     0070    91 ;M                   files MRS for FIX files;
                                     0070    92 ;M              The sixth receives the files EBK;
                                     0070    93 ;M              And the seventh recieves the longest record's length.
                                     0070    94 ;M
                                     0070    95 ;M    If the file is not of sequential organization an RMS$_ORG error
                                     0070    96 ;M    code is returned.  If the records are either of unknown format or
                                     0070    97 ;M    of maximum record length greater than 132+FSZ an RMS$_RFM error
                                     0070    98 ;M    code is returned.
                                     0070    99
                                 00000000   100 	.PSECT		BLKOPN,NOWRT
                               0000  0000   101 	.ENTRY		BLKOPN,^M<>
                                     0002   102
                    50   04 AC   D0  0002   103 	MOVL		4(AP),R0			; get filename
              00000034'EF   60   90  0006   104 	MOVB		(R0),<BLKFABIN+FAB$B_FNS>
           0000002C'EF   04 A0   D0  000D   105 	MOVL		4(R0),<BLKFABIN+FAB$L_FNA>
                                     0015   106 	$OPEN		FAB=BLKFABIN			; open file
              00000000'8F   50   D1  0022   107 	CMPL		R0,#RMS$_NORMAL			; error ?
                            05   13  0029   108 	BEQL		OPENED
                    08 BC   50   D0  002B   109 	MOVL		R0,@8(AP)
                                 04  002F   110 	RET
                                     0030   111
              00   0000001F'EF   91  0030   112 OPENED:	CMPB		<BLKFABIN+FAB$B_RFM>,#FAB$C_UDF	; file UDF ?
                            16   12  0037   113 	BNEQ		TESTEM
           08 BC   00000000'8F   D0  0039   114 OUT:	MOVL		#RMS$_RFM,@8(AP)
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   4
                                BLKOPN - OPENS A FILE FOR BLOCK INPUT    26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
                                     0041   115 	$CLOSE		FAB=BLKFABIN
                                 04  004E   116 	RET
                                     004F   117
              00   0000001D'EF   91  004F   118 TESTEM:	CMPB		<BLKFABIN+FAB$B_ORG>,#FAB$C_SEQ	; Sequential org. ?
                            16   13  0056   119 	BEQL		CNCTEM
           08 BC   00000000'8F   D0  0058   120 	MOVL		#RMS$_ORG,@8(AP)
                                     0060   121 	$CLOSE		FAB=BLKFABIN
                                 04  006D   122 	RET
                                     006E   123
                                     006E   124 CNCTEM:	$CONNECT	RAB=BLKRABIN			; connect record stream
              00000000'8F   50   D1  007B   125 	CMPL		R0,#RMS$_NORMAL			; error ?
                            12   13  0082   126 	BEQL		CNCTED
                    08 BC   50   D0  0084   127 	MOVL		R0,@8(AP)
                                     0088   128 	$CLOSE		FAB=BLKFABIN
                                 04  0095   129 	RET
                                     0096   130
                    08 BC   01   D0  0096   131 CNCTED:	MOVL		#1,@8(AP)			; completion code of 1
           18 BC   000000A4'EF   D0  009A   132 	MOVL		<BLKXAB+XAB$L_EBK>,@24(AP)	; get EBK
     000000C0'EF   000000A4'EF   D0  00A2   133 	MOVL		<BLKXAB+XAB$L_EBK>,EBK
                                     00AD   134 						; store # of bytes in EBK
     000000C4'EF   000000A8'EF   B0  00AD   135 	MOVW		<BLKXAB+XAB$W_FFB>,EBK_BYTES
                   000000A8'EF   B5  00B8   136 	TSTW		<BLKXAB+XAB$W_FFB>
                            12   12  00BE   137 	BNEQ		2$
         000000C4'EF   0200 8F   B0  00C0   138 	MOVW		#512,EBK_BYTES
                   000000C4'EF   D7  00C9   139 	DECL		EBK_BYTES
                         18 BC   D7  00CF   140 	DECL		@24(AP)
           0C BC   0000001F'EF   9A  00D2   141 2$:	MOVZBL		<BLKFABIN+FAB$B_RFM>,@12(AP)	; get RFM
           1C BC   0000009E'EF   3C  00DA   142 	MOVZWL		<BLKXAB+XAB$W_LRL>,@28(AP)	; get LRL
           49 0000001E'EF   01   E0  00E2   143 	BBS		#FAB$V_CR,<BLKFABIN+FAB$B_RAT>,10$ ; get RAT
           47 0000001E'EF   00   E0  00EA   144 	BBS		#FAB$V_FTN,<BLKFABIN+FAB$B_RAT>,20$
           45 0000001E'EF   02   E0  00F2   145 	BBS		#FAB$V_PRN,<BLKFABIN+FAB$B_RAT>,30$
                    10 BC   04   D0  00FA   146 	MOVL		#4,@16(AP)
           05 0000001E'EF   03   E1  00FE   147 5$:	BBC		#FAB$V_BLK,<BLKFABIN+FAB$B_RAT>,7$
                 10 BC   10 BC   CE  0106   148 	MNEGL		@16(AP),@16(AP)
              03   0000001F'EF   91  010B   149 7$:	CMPB		<BLKFABIN+FAB$B_RFM>,#FAB$C_VFC
                            09   12  0112   150 	BNEQ		8$
           14 BC   0000003F'EF   9A  0114   151 	MOVZBL		<BLKFABIN+FAB$B_FSZ>,@20(AP)	; get FSZ
                                 04  011C   152 	RET
                                     011D   153
              01   0000001F'EF   91  011D   154 8$:	CMPB		<BLKFABIN+FAB$B_RFM>,#FAB$C_FIX
                            09   12  0124   155 	BNEQ		9$
           14 BC   00000036'EF   3C  0126   156 	MOVZWL		<BLKFABIN+FAB$W_MRS>,@20(AP)	; get MRS
                                 04  012E   157 	RET
                         14 BC   D4  012F   158 9$:	CLRL		@20(AP)				; if VAR clear FSZ arg.
                                 04  0132   159 	RET
                    10 BC   01   D0  0133   160 10$:	MOVL		#1,@16(AP)
                            C5   11  0137   161 	BRB		5$
                    10 BC   02   D0  0139   162 20$:	MOVL		#2,@16(AP)
                            BF   11  013D   163 	BRB		5$
                    10 BC   03   D0  013F   164 30$:	MOVL		#3,@16(AP)
                            B9   11  0143   165 	BRB		5$
                                     0145   166
                                     0145   167 	.SUBTITLE	BLKSIN - INPUTS 7 BLOCKS OF DATA
                                     0145   168 ;
                                     0145   169 ;	BLKSIN
                                     0145   170 ;
                                     0145   171 ;DM
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   5
                                BLKSIN - INPUTS 7 BLOCKS OF DATA         26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
                                     0145   172 ;DM   BLKSIN is used to input 7 blocks of data in a manner similiar to
                                     0145   173 ;DM   BLKIN.
                                     0145   174 ;M
                                     0145   175 ;M         The routine BLKSIN starts input from the Nth block of the file.
                                     0145   176 ;M    N is given as the first argument in the call list, the second argument
                                     0145   177 ;M    receives the actual number of bytes input, and the third argument
                                     0145   178 ;M    is the address used as the start of the input buffer.
                                     0145   179
                                 00000000   180 	.PSECT		BLKSIN,NOWRT
                               0300  0000   181 	.ENTRY		BLKSIN,^M<R8,R9>
                                     0002   182
           00000088'EF   04 BC   D0  0002   183 	MOVL		@4(AP),<BLKRABIN+RAB$L_BKT>	; get block number
           00000074'EF   0C AC   D0  000A   184 	MOVL		12(AP),<BLKRABIN+RAB$L_UBF>	; get buffer address
                         08 BC   D4  0012   185 	CLRL		@8(AP)
                            58   D4  0015   186 	CLRL		R8
     00000070'EF   00000023'EF   B0  0017   187 	MOVW		RECBLK,<BLKRABIN+RAB$W_USZ>	; set transfer size
                                     0022   188 READMO:	$READ		RAB=BLKRABIN			; read a block
              00000000'8F   50   D1  002F   189 	CMPL		R0,#RMS$_NORMAL			; error ?
                            04   13  0036   190 	BEQL		READIT
                         08 BC   D4  0038   191 	CLRL		@8(AP)				; if so clear argument 2
                                 04  003B   192 	RET
                                     003C   193
     00000023'EF   00000072'EF   B1  003C   194 READIT:	CMPW		<BLKRABIN+RAB$W_RSZ>,RECBLK	; test for >RECBLK
                            0A   15  0047   195 	BLEQ		100$
           08 BC   00000023'EF   A0  0049   196 	ADDW2		RECBLK,@8(AP)			; add bytes read
                            08   11  0051   197 	BRB		105$
           08 BC   00000072'EF   A0  0053   198 100$:	ADDW2		<BLKRABIN+RAB$W_RSZ>,@8(AP)	; add bytes read
                    04 BC   01   C0  005B   199 105$:	ADDL2		#1,@4(AP)			; increment block #
     00000023'EF   00000072'EF   B1  005F   200 	CMPW		<BLKRABIN+RAB$W_RSZ>,RECBLK	; if less than 512
                            01   13  006A   201 	BEQL		110$				; exit
                                 04  006C   202 	RET
                                     006D   203
              59   00000023'EF   3C  006D   204 110$:	MOVZWL		RECBLK,R9
              00000074'EF   59   C0  0074   205 	ADDL2		R9,<BLKRABIN+RAB$L_UBF>		; move buffer pointer
                   00000088'EF   D4  007B   206 	CLRL		<BLKRABIN+RAB$L_BKT>		; set for next block
                    9D 58   06   F2  0081   207 	AOBLSS		#6,R8,READMO			; check if 6 blocks
                                     0085   208 							; have been read
                         01 58   E9  0085   209 	BLBC		R8,120$				; if only 6 read, read
                                     0088   210 							; the last one
                                 04  0088   211 	RET						; otherwise return
                                     0089   212
                   00000060'EF   D6  0089   213 120$:	INCL		<BLKRABIN+RAB$W_RFA>		; test if last block in
     000000C0'EF   00000060'EF   D1  008F   214 	CMPL		<BLKRABIN+RAB$W_RFA>,EBK	; file
                            86   12  009A   215 	BNEQ		READMO
     00000070'EF   000000C4'EF   B0  009C   216 	MOVW		EBK_BYTES,<BLKRABIN+RAB$W_USZ>	; if so set transfer size
                          FF78   31  00A7   217 	BRW		READMO
                                     00AA   218
                                     00AA   219 	.SUBTITLE	BLKCLS - CLOSES OPEN FILE
                                     00AA   220 ;
                                     00AA   221 ;	BLKCLS
                                     00AA   222 ;
                                     00AA   223 ;DM
                                     00AA   224 ;DM   BLKCLS closes the input file.
                                     00AA   225 ;M
                                     00AA   226 ;M         The routine BLKCLS needs no argument list and simply closes the
                                     00AA   227 ;M    file which BLKOPN has previously opened.
                                     00AA   228
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   6
                                BLKCLS - CLOSES OPEN FILE                26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
                                 00000000   229 	.PSECT		BLKCLS,NOWRT
                               0000  0000   230 	.ENTRY		BLKCLS,^M<>
                                     0002   231
                                     0002   232 	$DISCONNECT	RAB=BLKRABIN
                                     000F   233 	$CLOSE		FAB=BLKFABIN
                                 04  001C   234 	RET
                                     001D   235
                                     001D   236 	.END
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   7
Symbol table                                                             26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
$$.TAB         = 00000094 R     03      FAB$L_XAB        00000024               FAB$V_CBT      = 00000015
$$.TABEND      = 000000C0 R     03      FAB$M_BIO      = 00000020               FAB$V_CIF      = 00000019
$$.TMP         = 00000800               FAB$M_BLK      = 00000008               FAB$V_CR       = 00000001
$$.TMP1        = 00000001               FAB$M_BRO      = 00000040               FAB$V_CTG      = 00000014
$$.TMP2        = 000000AF               FAB$M_CBT      = 00200000               FAB$V_DEL      = 00000002
BLKCLS           00000000 RG    08      FAB$M_CIF      = 02000000               FAB$V_DFW      = 00000005
BLKFABIN         00000000 R     03      FAB$M_CR       = 00000002               FAB$V_DLT      = 0000000F
BLKIN            00000000 RG    05      FAB$M_CTG      = 00100000               FAB$V_DMO      = 0000000C
BLKOPN           00000000 RG    06      FAB$M_DEL      = 00000004               FAB$V_ESC      = 0000001B
BLKRABIN         00000050 R     03      FAB$M_DFW      = 00000020               FAB$V_EXE      = 00000007
BLKSIN           00000000 RG    07      FAB$M_DLT      = 00008000               FAB$V_FTN      = 00000000
BLKXAB           00000094 R     03      FAB$M_DMO      = 00001000               FAB$V_GET      = 00000001
CNCTED           00000096 R     06      FAB$M_ESC      = 08000000               FAB$V_INP      = 00000013
CNCTEM           0000006E R     06      FAB$M_EXE      = 00000080               FAB$V_JNL      = 00000016
EBK              000000C0 R     03      FAB$M_FTN      = 00000001               FAB$V_KFO      = 0000001E
EBK_BYTES        000000C4 R     03      FAB$M_GET      = 00000002               FAB$V_MSE      = 00000004
FAB$B_BID        00000000               FAB$M_INP      = 00080000               FAB$V_MXV      = 00000001
FAB$B_BKS        0000003E               FAB$M_JNL      = 00400000               FAB$V_NAM      = 00000018
FAB$B_BLN        00000001               FAB$M_KFO      = 40000000               FAB$V_NEF      = 0000000A
FAB$B_DNS        00000035               FAB$M_MSE      = 00000010               FAB$V_NFS      = 00000010
FAB$B_DSBMSK     0000004A               FAB$M_MXV      = 00000002               FAB$V_NIL      = 00000005
FAB$B_FAC        00000016               FAB$M_NAM      = 01000000               FAB$V_OFP      = 0000001D
FAB$B_FNS        00000034               FAB$M_NEF      = 00000400               FAB$V_ORG      = 00000004
FAB$B_FSZ        0000003F               FAB$M_NFS      = 00010000               FAB$V_POS      = 00000008
FAB$B_ORG        0000001D               FAB$M_NIL      = 00000020               FAB$V_PPF      = 00000012
FAB$B_RAT        0000001E               FAB$M_OFP      = 20000000               FAB$V_PPF_IND  = 0000000E
FAB$B_RFM        0000001F               FAB$M_POS      = 00000100               FAB$V_PPF_RAT  = 00000006
FAB$B_RTV        0000001C               FAB$M_PPF      = 00040000               FAB$V_PRN      = 00000002
FAB$B_SHR        00000017               FAB$M_PPF_IND  = 00004000               FAB$V_PUT      = 00000000
FAB$C_BID      = 00000003               FAB$M_PPF_RAT  = 00003FC0               FAB$V_RCK      = 00000017
FAB$C_BLN        00000050               FAB$M_PRN      = 00000004               FAB$V_RWC      = 0000000B
FAB$C_FIX      = 00000001               FAB$M_PUT      = 00000001               FAB$V_RWO      = 00000007
FAB$C_HSH      = 00000030               FAB$M_RCK      = 00800000               FAB$V_SCF      = 0000000E
FAB$C_IDX      = 00000020               FAB$M_RWC      = 00000800               FAB$V_SHRDEL   = 00000002
FAB$C_MAXRFM   = 00000006               FAB$M_RWO      = 00000080               FAB$V_SHRGET   = 00000001
FAB$C_REL      = 00000010               FAB$M_SCF      = 00004000               FAB$V_SHRPUT   = 00000000
FAB$C_RFM_DFLT = 00000002               FAB$M_SHRDEL   = 00000004               FAB$V_SHRUPD   = 00000003
FAB$C_SEQ      = 00000000               FAB$M_SHRGET   = 00000002               FAB$V_SPL      = 0000000D
FAB$C_STM      = 00000004               FAB$M_SHRPUT   = 00000001               FAB$V_SQO      = 00000006
FAB$C_STMCR    = 00000006               FAB$M_SHRUPD   = 00000008               FAB$V_SUP      = 00000002
FAB$C_STMLF    = 00000005               FAB$M_SPL      = 00002000               FAB$V_TEF      = 0000001C
FAB$C_UDF      = 00000000               FAB$M_SQO      = 00000040               FAB$V_TMD      = 00000004
FAB$C_VAR      = 00000002               FAB$M_SUP      = 00000004               FAB$V_TMP      = 00000003
FAB$C_VFC      = 00000003               FAB$M_TEF      = 10000000               FAB$V_TRN      = 00000004
FAB$K_BLN        00000050               FAB$M_TMD      = 00000010               FAB$V_UFM      = 0000001A
FAB$L_ALQ        00000010               FAB$M_TMP      = 00000008               FAB$V_UFO      = 00000011
FAB$L_CTX        00000018               FAB$M_TRN      = 00000010               FAB$V_UPD      = 00000003
FAB$L_DEV        00000040               FAB$M_UFM      = 04000000               FAB$V_UPI      = 00000006
FAB$L_DNA        00000030               FAB$M_UFO      = 00020000               FAB$V_WCK      = 00000009
FAB$L_FNA        0000002C               FAB$M_UPD      = 00000008               FAB$W_BLS        0000003C
FAB$L_FOP        00000004               FAB$M_UPI      = 00000040               FAB$W_DEQ        00000014
FAB$L_JNL        00000020               FAB$M_WCK      = 00000200               FAB$W_GBC        00000048
FAB$L_MRN        00000038               FAB$S_ORG      = 00000004               FAB$W_IFI        00000002
FAB$L_NAM        00000028               FAB$S_PPF_RAT  = 00000008               FAB$W_MRS        00000036
FAB$L_SDC        00000044               FAB$V_BIO      = 00000005               OPENED           00000030 R     06
FAB$L_STS        00000008               FAB$V_BLK      = 00000003               OUT              00000039 R     06
FAB$L_STV        0000000C               FAB$V_BRO      = 00000006               RAB$B_BID        00000000
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   8
Symbol table                                                             26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     
RAB$B_BLN        00000001               RAB$M_TPT      = 00000002               XAB$B_ATR        00000009
RAB$B_KRF        00000035               RAB$M_UIF      = 00000010               XAB$B_BKZ        00000016
RAB$B_KSZ        00000034               RAB$M_ULK      = 00040000               XAB$B_BLN        00000001
RAB$B_MBC        00000037               RAB$M_WAT      = 00020000               XAB$B_COD        00000000
RAB$B_MBF        00000036               RAB$M_WBH      = 00000400               XAB$B_HSZ        00000017
RAB$B_PSZ        00000034               RAB$S_PPF_RAT  = 00000008               XAB$B_RFO        00000008
RAB$B_RAC        0000001E               RAB$S_RFA      = 00000006               XAB$C_FHC      = 0000001D
RAB$B_ROP1       00000005               RAB$V_ASY      = 00000000               XAB$C_FHCLEN     0000002C
RAB$B_ROP2       00000006               RAB$V_BIO      = 0000000B               XAB$K_FHCLEN     0000002C
RAB$B_ROP3       00000007               RAB$V_CCO      = 0000001F               XAB$L_EBK        00000010
RAB$B_TMO        0000001F               RAB$V_CVT      = 0000001A               XAB$L_HBK        0000000C
RAB$C_BID      = 00000001               RAB$V_EOF      = 00000008               XAB$L_NXT        00000004
RAB$C_BLN        00000044               RAB$V_FDL      = 00000006               XAB$L_RDT0       0000000C
RAB$C_KEY      = 00000001               RAB$V_HSH      = 00000007               XAB$L_RDT4       00000010
RAB$C_RFA      = 00000002               RAB$V_KGE      = 00000015               XAB$L_SBN        00000028
RAB$C_SEQ      = 00000000               RAB$V_KGT      = 00000016               XAB$Q_RDT        0000000C
RAB$C_STM      = 00000003               RAB$V_LIM      = 0000000E               XAB$S_RDT      = 00000008
RAB$K_BLN        00000044               RAB$V_LOA      = 0000000D               XAB$W_DXQ        0000001A
RAB$L_BKT        00000038               RAB$V_LOC      = 00000010               XAB$W_EBK0       00000010
RAB$L_CTX        00000018               RAB$V_MAS      = 00000005               XAB$W_EBK2       00000012
RAB$L_DCT        00000038               RAB$V_NLK      = 00000014               XAB$W_FFB        00000014
RAB$L_FAB        0000003C               RAB$V_NXR      = 00000017               XAB$W_GBC        0000001C
RAB$L_KBF        00000030               RAB$V_PMT      = 0000001E               XAB$W_HBK0       0000000C
RAB$L_PBF        00000030               RAB$V_PPF_IND  = 0000000E               XAB$W_HBK2       0000000E
RAB$L_RBF        00000028               RAB$V_PPF_RAT  = 00000006               XAB$W_LRL        0000000A
RAB$L_RFA0       00000010               RAB$V_PTA      = 0000001D               XAB$W_MRZ        00000018
RAB$L_RHB        0000002C               RAB$V_RAH      = 00000009               XAB$W_RVN        00000008
RAB$L_ROP        00000004               RAB$V_REA      = 00000002               XAB$W_VERLIMIT   00000026
RAB$L_STS        00000008               RAB$V_RLK      = 00000013
RAB$L_STV        0000000C               RAB$V_RNE      = 00000018
RAB$L_UBF        00000024               RAB$V_RNF      = 0000001B
RAB$M_ASY      = 00000001               RAB$V_RRL      = 00000003
RAB$M_BIO      = 00000800               RAB$V_TMO      = 00000019
RAB$M_CCO      = 80000000               RAB$V_TPT      = 00000001
RAB$M_CVT      = 04000000               RAB$V_UIF      = 00000004
RAB$M_EOF      = 00000100               RAB$V_ULK      = 00000012
RAB$M_FDL      = 00000040               RAB$V_WAT      = 00000011
RAB$M_HSH      = 00000080               RAB$V_WBH      = 0000000A
RAB$M_KGE      = 00200000               RAB$W_ISI        00000002
RAB$M_KGT      = 00400000               RAB$W_RFA        00000010
RAB$M_LIM      = 00004000               RAB$W_RFA4       00000014
RAB$M_LOA      = 00002000               RAB$W_RSZ        00000022
RAB$M_LOC      = 00010000               RAB$W_STV0       0000000C
RAB$M_MAS      = 00000020               RAB$W_STV2       0000000E
RAB$M_NLK      = 00100000               RAB$W_USZ        00000020
RAB$M_NXR      = 00800000               READIT           0000003C R     07
RAB$M_PMT      = 40000000               READMO           00000022 R     07
RAB$M_PPF_IND  = 00004000               RECBLK           00000023 R     02
RAB$M_PPF_RAT  = 00003FC0               RMS$_NORMAL      ********   X   05
RAB$M_PTA      = 20000000               RMS$_ORG         ********   X   06
RAB$M_RAH      = 00000200               RMS$_RFM         ********   X   06
RAB$M_REA      = 00000004               SYS$CLOSE        ********  GX   06
RAB$M_RLK      = 00080000               SYS$CONNECT      ********  GX   06
RAB$M_RNE      = 01000000               SYS$DISCONNECT   ********  GX   08
RAB$M_RNF      = 08000000               SYS$OPEN         ********  GX   06
RAB$M_RRL      = 00000008               SYS$READ         ********  GX   05
RAB$M_TMO      = 02000000               TESTEM           0000004F R     06
BLKIN                           - THESE ROUTINES ARE FOR BLOCK IO        29-SEP-1983 15:34:44  VAX-11 Macro V03-00         Page   9
Psect synopsis                                                           26-SEP-1983 18:10:26  JPLSCR:[JLV.LOOK]BLKIN.MAR;7      (1)
                                                                                                                                     

                                                +----------------+
                                                ! Psect synopsi
PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          -
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE
. BLANK .                       00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
DOITNM                          00000025  (   37.)  02 (  2.)    PIC   USR   OVR   REL   GBL   SHR NOEXE   RD    WRT NOVEC LONG
BLKDAT                          000000C6  (  198.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC LONG
$ABS$                           00000050  (   80.)  04 (  4.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
BLKIN                           00000070  (  112.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE
BLKOPN                          00000145  (  325.)  06 (  6.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE
BLKSIN                          000000AA  (  170.)  07 (  7.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE
BLKCLS                          0000001D  (   29.)  08 (  8.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE

                                             +------------------------+
                                             ! Performance
Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------
Initialization                   27     00:00:00.05    00:00:00.64
Command processing               25     00:00:00.16    00:00:00.96
Pass 1                          223     00:00:06.29    00:02:09.11
Symbol table sort                 0     00:00:00.34    00:00:01.28
Pass 2                           93     00:00:01.12    00:00:34.65
Symbol table output              29     00:00:00.18    00:00:04.85
Psect synopsis output             4     00:00:00.06    00:00:00.10
Cross-reference output            0     00:00:00.00    00:00:00.00
Assembler run totals            403     00:00:08.22    00:02:51.81
                                                                                                                                     
The working set limit was 415 pages.
23781 bytes (47 pages) of virtual memory were used to buffer the intermediate code.
There were 20 pages of symbol table space allocated to hold 313 non-local and 16 local symbols.
236 source lines were read in Pass 1, producing 0 object records in Pass 2.
29 pages of virtual memory were used to define 23 macros.

                                            +--------------------------+
                                            ! Macro libra
Macro library name                           Macros defined      
------------------                           --------------
SYS$SYSROOT:[SYSLIB]STARLET.MLB;1                      20
                                                                                                                                     
614 GETS were required to define 20 macros.
                                                                                                                                     
There were no errors, warnings or information messages.
                                                                                                                                     
/NOOBJECT/LIST=LOOK.MLS BLKIN.MAR
GETOWN                          - FORTRAN USEROPEN PROCEDURE             29-SEP-1983 15:37:52  VAX-11 Macro V03-00         Page  10
Table of contents
                                                                                                                                     
    (1)        2        GETOWN - FORTRAN USEROPEN PROCEDURE
GETOWN                          - FORTRAN USEROPEN PROCEDURE             29-SEP-1983 15:37:52  VAX-11 Macro V03-00         Page  11
                                                                         26-SEP-1983 18:11:01  JPLSCR:[JLV.LOOK]GETOWN.MAR;13    (1)
                                                                                                                                     
                                     0000     1 	.TITLE	GETOWN - FORTRAN USEROPEN PROCEDURE
                                     0000     2 	.SUBTITLE	GETOWN - FORTRAN USEROPEN PROCEDURE
                                     0000     3
                                     0000     4 ;DM   This routine is used to get a file ownership.
                                     0000     5 ;DM
                                     0000     6 ;DM   Programmer - Jon Vavrus  28 OCT 1980
                                     0000     7 ;M
                                     0000     8 ;M         This routine is invoked as the USEROPEN qualifier in a FORTRAN
                                     0000     9 ;M    OPEN statement.  When invoked it will return the file owner's group
                                     0000    10 ;M    number as the first word of the common area OWNER, and the file
                                     0000    11 ;M    owner's member number as the second word.
                                     0000    12 ;
                                     0000    13 ;	COMMON AREAS
                                     0000    14 ;
                                     0000    15 ;S    OWNER  Used to return the owner UIC to the main program.
                                     0000    16
                                 00000000    17 	.PSECT		OWNER,PIC,USR,OVR,REL,GBL,SHR,NOEXE,RD,WRT,LONG
                                     0000    18
                           00000002  0000    19 GROUP:		.BLKW	1
                           00000004  0002    20 MEMBER:		.BLKW	1
                                     0004    21
                                 00000000    22 	.PSECT		GETDAT,NOEXE,LONG
                                     0000    23
                                     0000    24 PROXAB:		$XABPRO	NXT=0
                                     0010    25
                                 00000000    26 	.PSECT		GETOWN,NOWRT
                               0004  0000    27 	.ENTRY		GETOWN,^M<R2>
                                     0002    28
                    52   04 AC   D0  0002    29 	MOVL		4(AP),R2		; get address of FAB
                  52   0000'C2   D0  0006    30 	MOVL		FAB$L_XAB(R2),R2	; get address of XABFHC
           04 A2   00000000'EF   DE  000B    31 	MOVAL		PROXAB,XAB$L_NXT(R2)	; add XABPRO to chain
                                     0013    32 	$OPEN		FAB=@4(AP)		; actually open file
              00000000'8F   50   D1  001D    33 	CMPL		R0,#RMS$_NORMAL
                            01   13  0024    34 	BEQL		10$
                                 04  0026    35 	RET
                                     0027    36
                                     0027    37 10$:	$CONNECT	RAB=@8(AP)
              00000000'8F   50   D1  0031    38 	CMPL		R0,#RMS$_NORMAL
                            01   13  0038    39 	BEQL		20$
                                 04  003A    40 	RET
                                     003B    41
     00000000'EF   0000000E'EF   B0  003B    42 20$:	MOVW		<PROXAB+XAB$W_GRP>,GROUP ; get UIC
     00000002'EF   0000000C'EF   B0  0046    43 	MOVW		<PROXAB+XAB$W_MBM>,MEMBER
                                 04  0051    44 	RET
                                     0052    45
                                     0052    46 	.END
GETOWN                          - FORTRAN USEROPEN PROCEDURE             29-SEP-1983 15:37:52  VAX-11 Macro V03-00         Page  12
Symbol table                                                             26-SEP-1983 18:11:01  JPLSCR:[JLV.LOOK]GETOWN.MAR;13    (1)
                                                                                                                                     
$$.TAB         = 00000000 R     03
$$.TABEND      = 00000010 R     03
$$.TMP         = FFFFFFFF
$$.TMP1        = 00000001
$$.TMP2        = 000000BC
FAB$L_XAB        ********   X   05
GETOWN           00000000 RG    05
GROUP            00000000 R     02
MEMBER           00000002 R     02
PROXAB           00000000 R     03
RMS$_NORMAL      ********   X   05
SYS$CONNECT      ********  GX   05
SYS$OPEN         ********  GX   05
XAB$B_BKZ        00000016
XAB$B_BLN        00000001
XAB$B_COD        00000000
XAB$B_MTACC      0000000A
XAB$C_PRO      = 00000013
XAB$C_PROLEN     00000010
XAB$K_PROLEN     00000010
XAB$L_NXT        00000004
XAB$L_RDT0       0000000C
XAB$L_RDT4       00000010
XAB$L_UIC        0000000C
XAB$M_NODEL    = 00000008
XAB$M_NOEXE    = 00000004
XAB$M_NOREAD   = 00000001
XAB$M_NOWRITE  = 00000002
XAB$Q_RDT        0000000C
XAB$S_GRP      = 00000004
XAB$S_OWN      = 00000004
XAB$S_RDT      = 00000008
XAB$S_SYS      = 00000004
XAB$S_WLD      = 00000004
XAB$V_GRP      = 00000008
XAB$V_NODEL    = 00000003
XAB$V_NOEXE    = 00000002
XAB$V_NOREAD   = 00000000
XAB$V_NOWRITE  = 00000001
XAB$V_OWN      = 00000004
XAB$V_SYS      = 00000000
XAB$V_WLD      = 0000000C
XAB$W_GRP        0000000E
XAB$W_MBM        0000000C
XAB$W_PRO        00000008
XAB$W_RVN        00000008

                                                +----------------+
                                                ! Psect synopsi
PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          -
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE
. BLANK .                       00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
OWNER                           00000004  (    4.)  02 (  2.)    PIC   USR   OVR   REL   GBL   SHR NOEXE   RD    WRT NOVEC LONG
GETDAT                          00000010  (   16.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG
GETOWN                          - FORTRAN USEROPEN PROCEDURE             29-SEP-1983 15:37:52  VAX-11 Macro V03-00         Page  13
Psect synopsis                                                           26-SEP-1983 18:11:01  JPLSCR:[JLV.LOOK]GETOWN.MAR;13    (1)
                                                                                                                                     
$ABS$                           00000017  (   23.)  04 (  4.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
GETOWN                          00000052  (   82.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE

                                             +------------------------+
                                             ! Performance
Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------
Initialization                   29     00:00:00.05    00:00:01.75
Command processing               23     00:00:00.17    00:00:10.86
Pass 1                          125     00:00:01.98    00:01:04.87
Symbol table sort                 0     00:00:00.02    00:00:00.21
Pass 2                           32     00:00:00.24    00:00:09.02
Symbol table output               4     00:00:00.04    00:00:00.23
Psect synopsis output             4     00:00:00.04    00:00:00.04
Cross-reference output            0     00:00:00.00    00:00:00.00
Assembler run totals            221     00:00:02.57    00:01:30.49
                                                                                                                                     
The working set limit was 450 pages.
4842 bytes (10 pages) of virtual memory were used to buffer the intermediate code.
There were 10 pages of symbol table space allocated to hold 46 non-local and 2 local symbols.
46 source lines were read in Pass 1, producing 0 object records in Pass 2.
18 pages of virtual memory were used to define 15 macros.

                                            +--------------------------+
                                            ! Macro libra
Macro library name                           Macros defined      
------------------                           --------------
SYS$SYSROOT:[SYSLIB]STARLET.MLB;1                      12
                                                                                                                                     
239 GETS were required to define 12 macros.
                                                                                                                                     
There were no errors, warnings or information messages.
                                                                                                                                     
/NOOBJECT/LIST GETOWN.MAR
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  14
Table of contents
                                                                                                                                     
    (1)        2        PRTOUT - PRINTER OUTPUT ROUTINE
    (1)       74        PRTOPN - OPENS THE OUTPUT FILE
    (1)      155        PRTCLS - CLOSES THE OUTPUT FILE
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  15
                                                                         26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
                                     0000     1 		.TITLE	PRTOUT - OUTPUT ROUTINES FOR PRINTER OUTPUT
                                     0000     2 	.SUBTITLE	PRTOUT - PRINTER OUTPUT ROUTINE
                                     0000     3
                                     0000     4 ;DM   This module consists of routines to write out files for the & command
                                     0000     5 ;DM        PRTOPN - Opens the output file.
                                     0000     6 ;DM        PRTOUT - Outputs a record.
                                     0000     7 ;DM        PRTCLS - Closes the file.
                                     0000     8 ;DM
                                     0000     9 ;DM   Programmer - Jon Vavrus  12 NOV 1980
                                     0000    10 ;DM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
                                     0000    11 ;DM
                                     0000    12 ;DM   PRTOUT outputs a record.
                                     0000    13 ;M
                                     0000    14 ;M         The routine PRTOUT prints one record to the file opened in
                                     0000    15 ;M    PRTOPN.  It is called with two values, the first is an longword
                                     0000    16 ;M    containing the number of bytes to be transfered, and the second is
                                     0000    17 ;M    the address of the start of the data.
                                     0000    18 ;
                                     0000    19 ;	ENTRY POINTS
                                     0000    20 ;
                                     0000    21 ;E    BLKCLS  Closes the output file.
                                     0000    22 ;E    BLKOPN  Opens the file for output.
                                     0000    23 ;E    BLKOUT  Outputs one record to the file.
                                     0000    24 ;
                                     0000    25 ;	OUTPUT FILES
                                     0000    26 ;
                                     0000    27 ;W    PRTFAB  The file LOOKPRINT.LIS or LOOKTEMP.LIS .
                                     0000    28 ;
                                     0000    29 ;	COMMON AREAS
                                     0000    30 ;
                                     0000    31 ;S    LNCN    Used to transfer the FSZ, RFM, and RAT of the file.
                                     0000    32
                                 00000000    33 		.PSECT	LNCN,PIC,USR,OVR,REL,GBL,SHR,NOEXE,RD,WRT,LONG
                           0000136A  0000    34 		.BLKB	4970				; COMMON LNCN
                           00001372  136A    35 FSZ:		.BLKL	2
                           00001376  1372    36 RFM:		.BLKL	1
                           0000137A  1376    37 RAT:		.BLKL	1
                                     137A    38
                                 00000000    39 		.PSECT	PRTDAT,LONG
                                     0000    40 PRTFAB:		$FAB	FAC=PUT,FOP=<CBT,MXV,SQO>,NAM=PRTNAM,ORG=SEQ
                                     0050    41 PRTNAM:		$NAM	ESA=ESA,ESS=255,RSA=RSA,RSS=255
                                     00B0    42 PRTRAB:		$RAB	FAB=PRTFAB,MBC=1,MBF=2,RAC=SEQ,ROP=WBH
                           000001F3  00F4    43 ESA:		.BLKB	255
                           000002F2  01F3    44 RSA:		.BLKB	255
                           000002F8  02F2    45 RFA:		.BLKW	3			; storage for first RFA
                                 00  02F8    46 FILE_OPEN:	.BYTE				; flag for previous file
                                 00  02F9    47 APPEND:		.BYTE				; flag for append
                                 00  02FA    48 PRINT:		.BYTE				; flag for printing
53 49 4C 2E 50 4D 45 54 4B 4F 4F 4C  02FB    49 LOOKTEMP_LIS:	.ASCII	/LOOKTEMP.LIS/
49 4C 2E 54 4E 49 52 50 4B 4F 4F 4C  0307    50 LOOKPRINT_LIS:	.ASCII	/LOOKPRINT.LIS/
                                 53  0313
                                     0314    51
                                     0314    52 ;
                                     0314    53 ;	PRTOUT
                                     0314    54 ;
                                 00000000    55 	.PSECT		PRTOUT,NOWRT
                               003C  0000    56 	.ENTRY		PRTOUT,^M<R2,R3,R4,R5>
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  16
                                PRTOUT - PRINTER OUTPUT ROUTINE          26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
                                     0002    57
              0000001F'EF   03   91  0002    58 	CMPB		#FAB$C_VFC,<PRTFAB+FAB$B_RFM>	; VFC ?
                            24   12  0009    59 	BNEQ		10$
           000000DC'EF   08 AC   D0  000B    60 	MOVL		8(AP),<PRTRAB+RAB$L_RHB>	; if so: set header
           0000136A'EF   08 AC   C1  0013    61 	ADDL3		8(AP),FSZ,<PRTRAB+RAB$L_RBF>	; set buffer
                   000000D8'EF       001B
           04 BC   0000136A'EF   A3  0020    62 	SUBW3		FSZ,@4(AP),<PRTRAB+RAB$W_RSZ>
                   000000D2'EF       0028
                            10   11  002D    63 	BRB		20$
           000000D8'EF   08 AC   D0  002F    64 10$:	MOVL		8(AP),<PRTRAB+RAB$L_RBF>	; set buffer
           000000D2'EF   04 BC   B0  0037    65 	MOVW		@4(AP),<PRTRAB+RAB$W_RSZ>
                                     003F    66 20$:	$PUT		RAB=PRTRAB			; output record
              000002F2'EF   00   D1  004C    67 	CMPL		#0,RFA				; first output ?
                            15   12  0053    68 	BNEQ		30$
              000002F6'EF   00   B1  0055    69 	CMPW		#0,<RFA+4>
                            0C   12  005C    70 	BNEQ		30$
000002F2'EF   000000C0'EF   06   28  005E    71 	MOVC3		#6,<PRTRAB+RAB$W_RFA>,RFA	; if so: save RFA
                                 04  006A    72 30$:	RET
                                     006B    73
                                     006B    74 	.SUBTITLE	PRTOPN - OPENS THE OUTPUT FILE
                                     006B    75 ;
                                     006B    76 ;	PRTOPN
                                     006B    77 ;
                                     006B    78 ;DM
                                     006B    79 ;DM   PRTOPN opens or creates the output file.  If it is supposed to be
                                     006B    80 ;DM   queued for printing the correct characteristics will be assigned to
                                     006B    81 ;DM   it.
                                     006B    82 ;M
                                     006B    83 ;M         The routine PRTOPN requires one argument an integer*4 variable
                                     006B    84 ;M    with the value -1 for printer output, 0 for output appended to file
                                     006B    85 ;M    LOOKPRINT.LIS in the default directory (a new file is created if
                                     006B    86 ;M    no previous call to PRTOPN was made, or the previous call was made
                                     006B    87 ;M    with a value of 1), and 1 for output to a new file named LOOKPRINT.LIS
                                     006B    88 ;M    in the default directory.  If the open was unsuccessful the value
                                     006B    89 ;M    47 is returned.
                                     006B    90
                                 00000000    91 	.PSECT		PRTOPN,NOWRT
                               0080  0000    92 	.ENTRY		PRTOPN,^M<R7>
                                     0002    93
     00000004'EF   00002000 8F   CA  0002    94 	BICL2		#FAB$M_SPL,<PRTFAB+FAB$L_FOP>	; clear print bit
                 26 04 BC   01   E1  000D    95 	BBC		#1,@4(AP),10$			; check for print
     0000002C'EF   000002FB'EF   DE  0012    96 	MOVAL		LOOKTEMP_LIS,<PRTFAB+FAB$L_FNA>	; if so: move name
              00000034'EF   0C   90  001D    97 	MOVB		#12,<PRTFAB+FAB$B_FNS>
     00000004'EF   00008000 8F   C8  0024    98 	BISL2		#FAB$M_DLT,<PRTFAB+FAB$L_FOP>	; set delete bit
              000002FA'EF   01   90  002F    99 	MOVB		#1,PRINT			; set print flag
                            3B   11  0036   100 	BRB		20$
     0000002C'EF   00000307'EF   DE  0038   101 10$:	MOVAL		LOOKPRINT_LIS,<PRTFAB+FAB$L_FNA> ; move name
              00000034'EF   0D   90  0043   102 	MOVB		#13,<PRTFAB+FAB$B_FNS>
     00000004'EF   00008000 8F   CA  004A   103 	BICL2		#FAB$M_DLT,<PRTFAB+FAB$L_FOP>	; clear delete bit
                   000002FA'EF   94  0055   104 	CLRB		PRINT				; clear print flag
                      14 04 BC   E8  005B   105 	BLBS		@4(AP),20$			; check for new file
              000002F9'EF   01   88  005F   106 	BISB2		#1,APPEND			; if not: set app. flg.
     000000B4'EF   00000100 8F   C8  0066   107 	BISL2		#RAB$M_EOF,<PRTRAB+RAB$L_ROP>	; set EOF bit
                            11   11  0071   108 	BRB		30$
                   000002F9'EF   94  0073   109 20$:	CLRB		APPEND				; clear append flag
     000000B4'EF   00000100 8F   CA  0079   110 	BICL2		#RAB$M_EOF,<PRTRAB+RAB$L_ROP>	; clear EOF bit
     0000001F'EF   00001372'EF   90  0084   111 30$:	MOVB		RFM,<PRTFAB+FAB$B_RFM>		; set record format
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  17
                                PRTOPN - OPENS THE OUTPUT FILE           26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
              00001372'EF   01   91  008F   112 	CMPB		#FAB$C_FIX,RFM			; FIX file ?
                            0D   12  0096   113 	BNEQ		33$
     00000036'EF   0000136A'EF   B0  0098   114 	MOVW		FSZ,<PRTFAB+FAB$W_MRS>		; if so: set MRS
                            06   11  00A3   115 	BRB		35$
                   00000036'EF   B4  00A5   116 33$:	CLRW		<PRTFAB+FAB$W_MRS>		; clear MRS
           09 00001376'EF   07   E0  00AB   117 35$:	BBS		#7,RAT,40$			; figure out RAT
              57   00001376'EF   90  00B3   118 	MOVB		RAT,R7
                            07   11  00BA   119 	BRB		50$
              57   00001376'EF   8E  00BC   120 40$:	MNEGB		RAT,R7
                       57   01   91  00C3   121 50$:	CMPB		#1,R7
                            09   12  00C6   122 	BNEQ		60$
              0000001E'EF   02   90  00C8   123 	MOVB		#FAB$M_CR,<PRTFAB+FAB$B_RAT>	; set CR
                            15   11  00CF   124 	BRB		80$
                       57   02   91  00D1   125 60$:	CMPB		#2,R7
                            09   12  00D4   126 	BNEQ		70$
              0000001E'EF   01   90  00D6   127 	MOVB		#FAB$M_FTN,<PRTFAB+FAB$B_RAT>	; set FTN
                            07   11  00DD   128 	BRB		80$
              0000001E'EF   04   90  00DF   129 70$:	MOVB		#FAB$M_PRN,<PRTFAB+FAB$B_RAT>	; set PRN
              0000001F'EF   03   91  00E6   130 80$:	CMPB		#FAB$C_VFC,<PRTFAB+FAB$B_RFM>	; VFC ?
                            0D   12  00ED   131 	BNEQ		81$
     0000003F'EF   0000136A'EF   90  00EF   132 	MOVB		FSZ,<PRTFAB+FAB$B_FSZ>		; if so: set FSZ
                            06   11  00FA   133 	BRB		82$
                   0000003F'EF   94  00FC   134 81$:	CLRB		<PRTFAB+FAB$B_FSZ>		; clear FSZ
                      21 04 BC   E8  0102   135 82$:	BLBS		@4(AP),83$			; new file ?
                1A 000002F8'EF   E9  0106   136 	BLBC		FILE_OPEN,83$			; if not: prev. file ?
     00000004'EF   01000000 8F   C8  010D   137 	BISL2		#FAB$M_NAM,<PRTFAB+FAB$L_FOP>	; if so: use NAM
                                     0118   138 	$OPEN		FAB=PRTFAB			; open
                            18   11  0125   139 	BRB		84$
     00000004'EF   01000000 8F   CA  0127   140 83$:	BICL2		#FAB$M_NAM,<PRTFAB+FAB$L_FOP>	; don't use NAM
                                     0132   141 	$CREATE		FAB=PRTFAB			; create
              50   00000000'8F   D1  013F   142 84$:	CMPL		#RMS$_NORMAL,R0			; OK ?
                            3D   12  0146   143 	BNEQ		90$
                                     0148   144 	$CONNECT	RAB=PRTRAB			; if so: connect RAB
              50   00000000'8F   D1  0155   145 	CMPL		#RMS$_NORMAL,R0			; OK ?
                            0D   12  015C   146 	BNEQ		85$
                   000002F2'EF   D4  015E   147 	CLRL		RFA				; if so: clear RFA stor.
                   000002F6'EF   B4  0164   148 	CLRW		<RFA+4>
                                 04  016A   149 	RET
                                     016B   150 85$:	$CLOSE		FAB=PRTFAB			; not OK: clean up
                                     0178   151 	$REMOVE		FAB=PRTFAB
                    04 BC   2F   D0  0185   152 90$:	MOVL		#47,@4(AP)
                                 04  0189   153 	RET
                                     018A   154
                                     018A   155 	.SUBTITLE	PRTCLS - CLOSES THE OUTPUT FILE
                                     018A   156 ;
                                     018A   157 ;	PRTCLS
                                     018A   158 ;
                                     018A   159 ;DM
                                     018A   160 ;DM   PRTCLS Closes the file previously opened by PRTOPN.
                                     018A   161 ;M
                                     018A   162 ;M         The routine PRTCLS closes the file opened by PRTPN.  If an
                                     018A   163 ;M    argument list is present the file is deleted (for appended files
                                     018A   164 ;M    the new records are stripped off), otherwise the file is closed and
                                     018A   165 ;M    queued for printing if necessary.
                                     018A   166
                                 00000000   167 	.PSECT		PRTCLS,NOWRT
                               003C  0000   168 	.ENTRY		PRTCLS,^M<R2,R3,R4,R5>
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  18
                                PRTCLS - CLOSES THE OUTPUT FILE          26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
                                     0002   169
                                     0002   170 	$DISCONNECT	RAB=PRTRAB			; disconnect RAB
                       6C   00   D1  000F   171 	CMPL		#0,(AP)				; argument list ?
                            7E   13  0012   172 	BEQL		10$
                5C 000002F9'EF   E9  0014   173 	BLBC		APPEND,3$			; if not: append ?
              000000CE'EF   02   90  001B   174 	MOVB		#RAB$C_RFA,<PRTRAB+RAB$B_RAC>	; if so: set RAC to RFA
                                     0022   175 	$CONNECT	RAB=PRTRAB			; reconnect RAB
000000C0'EF   000002F2'EF   06   28  002F   176 	MOVC3		#6,RFA,<PRTRAB+RAB$W_RFA>	; set RFA
                                     003B   177 	$FIND		RAB=PRTRAB			; find and truncate
                                     0048   178 	$TRUNCATE	RAB=PRTRAB
                                     0055   179 	$DISCONNECT	RAB=PRTRAB			; disconnect RAB
              000000CE'EF   00   90  0062   180 	MOVB		#RAB$C_SEQ,<PRTRAB+RAB$B_RAC>	; reset RAC to SEQ
                                     0069   181 	$CLOSE		FAB=PRTFAB			; close file
                                 04  0076   182 	RET
                                     0077   183
                                     0077   184 3$:	$CLOSE		FAB=PRTFAB			; close file
                                     0084   185 	$REMOVE		FAB=PRTFAB			; delete file
                                 04  0091   186 	RET
                                     0092   187
                0B 000002FA'EF   E9  0092   188 10$:	BLBC		PRINT,20$			; print file ?
     00000004'EF   00002000 8F   C8  0099   189 	BISL2		#FAB$M_SPL,<PRTFAB+FAB$L_FOP>	; if so:set SPL bit
                                     00A4   190 20$:	$CLOSE		FAB=PRTFAB			; close file
                08 000002FA'EF   E8  00B1   191 	BLBS		PRINT,30$			; print file ?
              000002F8'EF   01   90  00B8   192 	MOVB		#1,FILE_OPEN			; if not: set prev. flag
                                 04  00BF   193 	RET
                   000002F8'EF   94  00C0   194 30$:	CLRB		FILE_OPEN			; clear prev. flag
                                 04  00C6   195 	RET
                                     00C7   196
                                     00C7   197 	.END
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  19
Symbol table                                                             26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
$$.TAB         = 000000B0 R     03      FAB$M_DFW      = 00000020               FAB$V_EXE      = 00000007
$$.TABEND      = 000000F4 R     03      FAB$M_DLT      = 00008000               FAB$V_FTN      = 00000000
$$.TMP         = 00000400               FAB$M_DMO      = 00001000               FAB$V_GET      = 00000001
$$.TMP1        = 00000001               FAB$M_ESC      = 08000000               FAB$V_INP      = 00000013
$$.TMP2        = 000000CF               FAB$M_EXE      = 00000080               FAB$V_JNL      = 00000016
APPEND           000002F9 R     03      FAB$M_FTN      = 00000001               FAB$V_KFO      = 0000001E
ESA              000000F4 R     03      FAB$M_GET      = 00000002               FAB$V_MSE      = 00000004
FAB$B_BID        00000000               FAB$M_INP      = 00080000               FAB$V_MXV      = 00000001
FAB$B_BKS        0000003E               FAB$M_JNL      = 00400000               FAB$V_NAM      = 00000018
FAB$B_BLN        00000001               FAB$M_KFO      = 40000000               FAB$V_NEF      = 0000000A
FAB$B_DNS        00000035               FAB$M_MSE      = 00000010               FAB$V_NFS      = 00000010
FAB$B_DSBMSK     0000004A               FAB$M_MXV      = 00000002               FAB$V_NIL      = 00000005
FAB$B_FAC        00000016               FAB$M_NAM      = 01000000               FAB$V_OFP      = 0000001D
FAB$B_FNS        00000034               FAB$M_NEF      = 00000400               FAB$V_ORG      = 00000004
FAB$B_FSZ        0000003F               FAB$M_NFS      = 00010000               FAB$V_POS      = 00000008
FAB$B_ORG        0000001D               FAB$M_NIL      = 00000020               FAB$V_PPF      = 00000012
FAB$B_RAT        0000001E               FAB$M_OFP      = 20000000               FAB$V_PPF_IND  = 0000000E
FAB$B_RFM        0000001F               FAB$M_POS      = 00000100               FAB$V_PPF_RAT  = 00000006
FAB$B_RTV        0000001C               FAB$M_PPF      = 00040000               FAB$V_PRN      = 00000002
FAB$B_SHR        00000017               FAB$M_PPF_IND  = 00004000               FAB$V_PUT      = 00000000
FAB$C_BID      = 00000003               FAB$M_PPF_RAT  = 00003FC0               FAB$V_RCK      = 00000017
FAB$C_BLN        00000050               FAB$M_PRN      = 00000004               FAB$V_RWC      = 0000000B
FAB$C_FIX      = 00000001               FAB$M_PUT      = 00000001               FAB$V_RWO      = 00000007
FAB$C_HSH      = 00000030               FAB$M_RCK      = 00800000               FAB$V_SCF      = 0000000E
FAB$C_IDX      = 00000020               FAB$M_RWC      = 00000800               FAB$V_SHRDEL   = 00000002
FAB$C_MAXRFM   = 00000006               FAB$M_RWO      = 00000080               FAB$V_SHRGET   = 00000001
FAB$C_REL      = 00000010               FAB$M_SCF      = 00004000               FAB$V_SHRPUT   = 00000000
FAB$C_RFM_DFLT = 00000002               FAB$M_SHRDEL   = 00000004               FAB$V_SHRUPD   = 00000003
FAB$C_SEQ      = 00000000               FAB$M_SHRGET   = 00000002               FAB$V_SPL      = 0000000D
FAB$C_STM      = 00000004               FAB$M_SHRPUT   = 00000001               FAB$V_SQO      = 00000006
FAB$C_STMCR    = 00000006               FAB$M_SHRUPD   = 00000008               FAB$V_SUP      = 00000002
FAB$C_STMLF    = 00000005               FAB$M_SPL      = 00002000               FAB$V_TEF      = 0000001C
FAB$C_UDF      = 00000000               FAB$M_SQO      = 00000040               FAB$V_TMD      = 00000004
FAB$C_VAR      = 00000002               FAB$M_SUP      = 00000004               FAB$V_TMP      = 00000003
FAB$C_VFC      = 00000003               FAB$M_TEF      = 10000000               FAB$V_TRN      = 00000004
FAB$K_BLN        00000050               FAB$M_TMD      = 00000010               FAB$V_UFM      = 0000001A
FAB$L_ALQ        00000010               FAB$M_TMP      = 00000008               FAB$V_UFO      = 00000011
FAB$L_CTX        00000018               FAB$M_TRN      = 00000010               FAB$V_UPD      = 00000003
FAB$L_DEV        00000040               FAB$M_UFM      = 04000000               FAB$V_UPI      = 00000006
FAB$L_DNA        00000030               FAB$M_UFO      = 00020000               FAB$V_WCK      = 00000009
FAB$L_FNA        0000002C               FAB$M_UPD      = 00000008               FAB$W_BLS        0000003C
FAB$L_FOP        00000004               FAB$M_UPI      = 00000040               FAB$W_DEQ        00000014
FAB$L_JNL        00000020               FAB$M_WCK      = 00000200               FAB$W_GBC        00000048
FAB$L_MRN        00000038               FAB$S_ORG      = 00000004               FAB$W_IFI        00000002
FAB$L_NAM        00000028               FAB$S_PPF_RAT  = 00000008               FAB$W_MRS        00000036
FAB$L_SDC        00000044               FAB$V_BIO      = 00000005               FILE_OPEN        000002F8 R     03
FAB$L_STS        00000008               FAB$V_BLK      = 00000003               FSZ              0000136A R     02
FAB$L_STV        0000000C               FAB$V_BRO      = 00000006               LOOKPRINT_LIS    00000307 R     03
FAB$L_XAB        00000024               FAB$V_CBT      = 00000015               LOOKTEMP_LIS     000002FB R     03
FAB$M_BIO      = 00000020               FAB$V_CIF      = 00000019               NAM$B_BID        00000000
FAB$M_BLK      = 00000008               FAB$V_CR       = 00000001               NAM$B_BLN        00000001
FAB$M_BRO      = 00000040               FAB$V_CTG      = 00000014               NAM$B_DEV        00000039
FAB$M_CBT      = 00200000               FAB$V_DEL      = 00000002               NAM$B_DID_NMX    0000002F
FAB$M_CIF      = 02000000               FAB$V_DFW      = 00000005               NAM$B_DID_RVN    0000002E
FAB$M_CR       = 00000002               FAB$V_DLT      = 0000000F               NAM$B_DIR        0000003A
FAB$M_CTG      = 00100000               FAB$V_DMO      = 0000000C               NAM$B_ESL        0000000B
FAB$M_DEL      = 00000004               FAB$V_ESC      = 0000001B               NAM$B_ESS        0000000A
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  20
Symbol table                                                             26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
NAM$B_FID_NMX    00000029               NAM$M_SRCHNMF  = 40000000               NAM$W_DID        0000002A
NAM$B_FID_RVN    00000028               NAM$M_SVCTX    = 80000000               NAM$W_DID_NUM    0000002A
NAM$B_NAME       0000003B               NAM$M_WILDCARD = 00000100               NAM$W_DID_RVN    0000002E
NAM$B_NODE       00000038               NAM$M_WILD_DIR = 00100000               NAM$W_DID_SEQ    0000002C
NAM$B_NOP        00000008               NAM$M_WILD_GRP = 01000000               NAM$W_FID        00000024
NAM$B_RFS        00000009               NAM$M_WILD_MBR = 02000000               NAM$W_FID_NUM    00000024
NAM$B_RSL        00000003               NAM$M_WILD_NAME= 00000020               NAM$W_FID_RVN    00000028
NAM$B_RSS        00000002               NAM$M_WILD_SFD1= 02000000               NAM$W_FID_SEQ    00000026
NAM$B_TYPE       0000003C               NAM$M_WILD_SFD2= 04000000               PRINT            000002FA R     03
NAM$B_VER        0000003D               NAM$M_WILD_SFD3= 08000000               PRTCLS           00000000 RG    07
NAM$C_BID      = 00000002               NAM$M_WILD_SFD4= 10000000               PRTFAB           00000000 R     03
NAM$C_BLN        00000060               NAM$M_WILD_SFD5= 20000000               PRTNAM           00000050 R     03
NAM$C_BLN_DIRWC  00000060               NAM$M_WILD_SFD6= 40000000               PRTOPN           00000000 RG    06
NAM$C_BLN_V2     00000038               NAM$M_WILD_SFD7= 80000000               PRTOUT           00000000 RG    05
NAM$C_DVI      = 00000010               NAM$M_WILD_TYPE= 00000010               PRTRAB           000000B0 R     03
NAM$C_FCS11    = 00000004               NAM$M_WILD_UFD = 01000000               RAB$B_BID        00000000
NAM$C_MAXRSS   = 000000FC               NAM$M_WILD_VER = 00000008               RAB$B_BLN        00000001
NAM$C_MAXRSSLCL= 000000FC               NAM$S_DID      = 00000006               RAB$B_KRF        00000035
NAM$C_RMS11    = 00000001               NAM$S_DIR_LVLS = 00000003               RAB$B_KSZ        00000034
NAM$C_RMS20    = 00000002               NAM$S_DVI      = 00000010               RAB$B_MBC        00000037
NAM$C_RMS32    = 00000003               NAM$S_FID      = 00000006               RAB$B_MBF        00000036
NAM$C_RT11FS   = 00000005               NAM$T_DVI        00000014               RAB$B_PSZ        00000034
NAM$C_TOPS10FS = 00000008               NAM$V_CNCL_DEV = 0000000C               RAB$B_RAC        0000001E
NAM$C_TOPS20FS = 00000007               NAM$V_DIR_LVLS = 00000015               RAB$B_ROP1       00000005
NAM$C_UFS      = 00000000               NAM$V_EXP_DEV  = 00000007               RAB$B_ROP2       00000006
NAM$K_BLN        00000060               NAM$V_EXP_DIR  = 00000006               RAB$B_ROP3       00000007
NAM$K_BLN_DIRWC  00000060               NAM$V_EXP_NAME = 00000002               RAB$B_TMO        0000001F
NAM$K_BLN_V2     00000038               NAM$V_EXP_TYPE = 00000001               RAB$C_BID      = 00000001
NAM$L_DEV        00000044               NAM$V_EXP_VER  = 00000000               RAB$C_BLN        00000044
NAM$L_DIR        00000048               NAM$V_GRP_MBR  = 00000013               RAB$C_KEY      = 00000001
NAM$L_ESA        0000000C               NAM$V_HIGHVER  = 0000000F               RAB$C_RFA      = 00000002
NAM$L_FNB        00000034               NAM$V_IFI      = 00000010               RAB$C_SEQ      = 00000000
NAM$L_NAME       0000004C               NAM$V_LOWVER   = 0000000E               RAB$C_STM      = 00000003
NAM$L_NODE       00000040               NAM$V_NODE     = 00000011               RAB$K_BLN        00000044
NAM$L_RLF        00000010               NAM$V_PPF      = 00000010               RAB$L_BKT        00000038
NAM$L_RSA        00000004               NAM$V_PWD      = 00000000               RAB$L_CTX        00000018
NAM$L_TYPE       00000050               NAM$V_QUOTED   = 00000012               RAB$L_DCT        00000038
NAM$L_VER        00000054               NAM$V_ROD      = 00000001               RAB$L_FAB        0000003C
NAM$L_WCC        00000030               NAM$V_ROOT_DIR = 0000000D               RAB$L_KBF        00000030
NAM$M_CNCL_DEV = 00001000               NAM$V_SOD      = 00000002               RAB$L_PBF        00000030
NAM$M_DIR_LVLS = 00E00000               NAM$V_SRCHNMF  = 0000001E               RAB$L_RBF        00000028
NAM$M_EXP_DEV  = 00000080               NAM$V_SVCTX    = 0000001F               RAB$L_RFA0       00000010
NAM$M_EXP_DIR  = 00000040               NAM$V_WILDCARD = 00000008               RAB$L_RHB        0000002C
NAM$M_EXP_NAME = 00000004               NAM$V_WILD_DIR = 00000014               RAB$L_ROP        00000004
NAM$M_EXP_TYPE = 00000002               NAM$V_WILD_GRP = 00000018               RAB$L_STS        00000008
NAM$M_EXP_VER  = 00000001               NAM$V_WILD_MBR = 00000019               RAB$L_STV        0000000C
NAM$M_GRP_MBR  = 00080000               NAM$V_WILD_NAME= 00000005               RAB$L_UBF        00000024
NAM$M_HIGHVER  = 00008000               NAM$V_WILD_SFD1= 00000019               RAB$M_ASY      = 00000001
NAM$M_IFI      = 00010000               NAM$V_WILD_SFD2= 0000001A               RAB$M_BIO      = 00000800
NAM$M_LOWVER   = 00004000               NAM$V_WILD_SFD3= 0000001B               RAB$M_CCO      = 80000000
NAM$M_NODE     = 00020000               NAM$V_WILD_SFD4= 0000001C               RAB$M_CVT      = 04000000
NAM$M_PPF      = 00010000               NAM$V_WILD_SFD5= 0000001D               RAB$M_EOF      = 00000100
NAM$M_PWD      = 00000001               NAM$V_WILD_SFD6= 0000001E               RAB$M_FDL      = 00000040
NAM$M_QUOTED   = 00040000               NAM$V_WILD_SFD7= 0000001F               RAB$M_HSH      = 00000080
NAM$M_ROD      = 00000002               NAM$V_WILD_TYPE= 00000004               RAB$M_KGE      = 00200000
NAM$M_ROOT_DIR = 00002000               NAM$V_WILD_UFD = 00000018               RAB$M_KGT      = 00400000
NAM$M_SOD      = 00000004               NAM$V_WILD_VER = 00000003               RAB$M_LIM      = 00004000
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  21
Symbol table                                                             26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     
RAB$M_LOA      = 00002000               RAB$W_RSZ        00000022
RAB$M_LOC      = 00010000               RAB$W_STV0       0000000C
RAB$M_MAS      = 00000020               RAB$W_STV2       0000000E
RAB$M_NLK      = 00100000               RAB$W_USZ        00000020
RAB$M_NXR      = 00800000               RAT              00001376 R     02
RAB$M_PMT      = 40000000               RFA              000002F2 R     03
RAB$M_PPF_IND  = 00004000               RFM              00001372 R     02
RAB$M_PPF_RAT  = 00003FC0               RMS$_NORMAL      ********   X   06
RAB$M_PTA      = 20000000               RSA              000001F3 R     03
RAB$M_RAH      = 00000200               SYS$CLOSE        ********  GX   06
RAB$M_REA      = 00000004               SYS$CONNECT      ********  GX   06
RAB$M_RLK      = 00080000               SYS$CREATE       ********  GX   06
RAB$M_RNE      = 01000000               SYS$DISCONNECT   ********  GX   07
RAB$M_RNF      = 08000000               SYS$FIND         ********  GX   07
RAB$M_RRL      = 00000008               SYS$OPEN         ********  GX   06
RAB$M_TMO      = 02000000               SYS$PUT          ********  GX   05
RAB$M_TPT      = 00000002               SYS$REMOVE       ********  GX   06
RAB$M_UIF      = 00000010               SYS$TRUNCATE     ********  GX   07
RAB$M_ULK      = 00040000
RAB$M_WAT      = 00020000
RAB$M_WBH      = 00000400
RAB$S_PPF_RAT  = 00000008
RAB$S_RFA      = 00000006
RAB$V_ASY      = 00000000
RAB$V_BIO      = 0000000B
RAB$V_CCO      = 0000001F
RAB$V_CVT      = 0000001A
RAB$V_EOF      = 00000008
RAB$V_FDL      = 00000006
RAB$V_HSH      = 00000007
RAB$V_KGE      = 00000015
RAB$V_KGT      = 00000016
RAB$V_LIM      = 0000000E
RAB$V_LOA      = 0000000D
RAB$V_LOC      = 00000010
RAB$V_MAS      = 00000005
RAB$V_NLK      = 00000014
RAB$V_NXR      = 00000017
RAB$V_PMT      = 0000001E
RAB$V_PPF_IND  = 0000000E
RAB$V_PPF_RAT  = 00000006
RAB$V_PTA      = 0000001D
RAB$V_RAH      = 00000009
RAB$V_REA      = 00000002
RAB$V_RLK      = 00000013
RAB$V_RNE      = 00000018
RAB$V_RNF      = 0000001B
RAB$V_RRL      = 00000003
RAB$V_TMO      = 00000019
RAB$V_TPT      = 00000001
RAB$V_UIF      = 00000004
RAB$V_ULK      = 00000012
RAB$V_WAT      = 00000011
RAB$V_WBH      = 0000000A
RAB$W_ISI        00000002
RAB$W_RFA        00000010
RAB$W_RFA4       00000014
PRTOUT                          - OUTPUT ROUTINES FOR PRINTER OUTPUT     29-SEP-1983 15:41:50  VAX-11 Macro V03-00         Page  22
Psect synopsis                                                           26-SEP-1983 18:11:35  JPLSCR:[JLV.LOOK]PRTOUT.MAR;14    (1)
                                                                                                                                     

                                                +----------------+
                                                ! Psect synopsi
PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          -
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE
. BLANK .                       00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
LNCN                            0000137A  ( 4986.)  02 (  2.)    PIC   USR   OVR   REL   GBL   SHR NOEXE   RD    WRT NOVEC LONG
PRTDAT                          00000314  (  788.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC LONG
$ABS$                           00000060  (   96.)  04 (  4.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
PRTOUT                          0000006B  (  107.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE
PRTOPN                          0000018A  (  394.)  06 (  6.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE
PRTCLS                          000000C7  (  199.)  07 (  7.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE

                                             +------------------------+
                                             ! Performance
Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------
Initialization                   27     00:00:00.04    00:00:14.04
Command processing               26     00:00:00.11    00:00:15.88
Pass 1                          233     00:00:07.68    00:04:11.08
Symbol table sort                 2     00:00:00.51    00:00:08.59
Pass 2                           63     00:00:01.25    00:00:20.03
Symbol table output              36     00:00:00.35    00:00:04.35
Psect synopsis output             5     00:00:00.05    00:00:00.62
Cross-reference output            0     00:00:00.00    00:00:00.00
Assembler run totals            394     00:00:10.02    00:05:14.60
                                                                                                                                     
The working set limit was 680 pages.
29335 bytes (58 pages) of virtual memory were used to buffer the intermediate code.
There were 30 pages of symbol table space allocated to hold 417 non-local and 23 local symbols.
197 source lines were read in Pass 1, producing 0 object records in Pass 2.
30 pages of virtual memory were used to define 24 macros.

                                            +--------------------------+
                                            ! Macro libra
Macro library name                           Macros defined      
------------------                           --------------
SYS$SYSROOT:[SYSLIB]STARLET.MLB;1                      21
                                                                                                                                     
689 GETS were required to define 21 macros.
                                                                                                                                     
There were no errors, warnings or information messages.
                                                                                                                                     
/NOOBJECT/LIST PRTOUT.MAR
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  23
Table of contents
                                                                                                                                     
    (1)        2        SETERM - SETS TERMINAL CHARACTERISTICS
    (1)      194        RESTRM - RESTORES THE TERMINAL CHARACTER
    (1)      246        SETWRP - SETS THE TERMINAL /WRAP
    (1)      268        CLRWRP - SETS THE TERMINAL /NOWRAP
    (1)      290        SETNAR - SETS THE TERMINAL TO 80 COLUMN
    (1)      335        SETWID - SETS THE TERMINAL TO 132 COLUMN
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  24
                                                                         29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                                     0000     1 	.TITLE	SETERM - SETS TERMINAL CHARACTERISITICS
                                     0000     2 	.SUBTITLE	SETERM - SETS TERMINAL CHARACTERISTICS
                                     0000     3
                                     0000     4 ;DM   These routines sets and resets the terminal characteristics
                                     0000     5 ;DME  CLRWRP  sets the terminal NOWRAP
                                     0000     6 ;DME  RESTRM  restores original terminal characterisitics
                                     0000     7 ;DME  SETERM  sets terminal characteristics
                                     0000     8 ;DME  SETNAR  sets a VT100 to 80 columns
                                     0000     9 ;DME  SETWID  sets a VT100 to 132 columns
                                     0000    10 ;DME  SETWRP  sets the terminal WRAP
                                     0000    11 ;DM
                                     0000    12 ;DM   Programmer - Jon Vavrus  31 MAR 1981
                                     0000    13 ;DM   Revised    - Jon vavrus  12 MAY 1981
                                     0000    14 ;DM   Revised    - Jon Vavrus  31 JUL 1981
                                     0000    15 ;DM   Revised    - Jon Vavrus  26 AUG 1981
                                     0000    16 ;DM   Revised    - Jon Vavrus   3 MAR 1982 (added SETWID/SETNAR)
                                     0000    17 ;DM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
                                     0000    18 ;DM   Revised    - Jon Vavrus  15 JUL 1982 (Use FORM for <FF> fixing)
                                     0000    19 ;DM   Revised    - Jon Vavrus  27 JUL 1982 (Recognizes printer-ports)
                                     0000    20 ;DM   Revised    - Jon Vavrus  12 AUG 1982 (@# references changed to G^)
                                     0000    21 ;DM   Revised    - Jon Vavrus   2 SEP 1982
                                     0000    22 ;DM   Revised    - Jon Vavrus  29 SEP 1983
                                     0000    23 ;DM
                                     0000    24 ;DM   SETERM sets up the terminal with the appropriate characteristics.
                                     0000    25 ;DM   It also determines whether the terminal is a VT100 and (if so)
                                     0000    26 ;DM   whether it has the advanced video option installed.
                                     0000    27 ;M
                                     0000    28 ;M         The routines are called with the terminal channel number as
                                     0000    29 ;M    their first argument, and SETERM has a flag set to 0 for 132 char-
                                     0000    30 ;M    acter mode in the second argument, and a word set to -1 for WRAP
                                     0000    31 ;M    as the third argument.
                                     0000    32 ;M
                                     0000    33 ;M         SETERM sets the terminal to page=1,width=150 and then tries
                                     0000    34 ;M    to change the terminal to 132 character mode if terminal is a VT100
                                     0000    35 ;M    with advanced video and the low bit of the second argument is set.
                                     0000    36 ;M    If the low bit of the third argument is set the terminal is set up to
                                     0000    37 ;M    cause line wrapping.  The terminal channel number is filled in and
                                     0000    38 ;M    should not be provided by the calling routine.
                                     0000    39 ;
                                     0000    40 ;	COMMON AREAS
                                     0000    41 ;
                                     0000    42 ;S    DOITNM  contains the VT100 flag to be set or cleared
                                     0000    43 ;
                                     0000    44 ;	CALLED ROUTINES
                                     0000    45 ;
                                     0000    46 ;C    SETNAR  sets a VT100 to 80 columns
                                     0000    47 ;C    SETWID  sets a VT100 to 132 columns
                                     0000    48 ;
                                     0000    49 		$DCDEF
                                     0000    50 		$TTDEF
                                     0000    51
                                 00000000    52 		.PSECT	DOITNM,PIC,USR,OVR,REL,GBL,SHR,NOEXE,RD,WRT,LONG
                           00000035  0000    53 		.BLKB	53
                           00000036  0035    54 VT100:		.BLKB	1
                           0000003A  0036    55 		.BLKL	1
                           0000003C  003A    56 		.BLKW	1
                           00000040  003C    57 		.BLKL	1
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  25
                                SETERM - SETS TERMINAL CHARACTERISTICS   29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                           00000042  0040    58 PAGLEN:		.BLKW	1
                           00000044  0042    59 COMLIN:		.BLKW	1
                           00000045  0044    60 VT100A:		.BLKB	1
                                     0045    61
                                 00000000    62 		.PSECT	SETDAT,LONG
                  00000000 00000000  0000    63 OLD_CHARS:	.QUAD
                               0000  0008    64 NEW_CHARS:	.WORD
                               0096  000A    65 		.WORD	150			; width=132
                           00000000  000C    66 		.LONG
                                     0010    67
                              3C 1B  0010    68 TERM_MODES:	.BYTE	27,^A\<\		; ANSI
                                 1B  0012    69 WRAP_MODE:	.BYTE	27
                           37 3F 5B  0013    70 		.ASCII	\[?7\			; nowrap
                                 6C  0016    71 WRAP_BYTE:	.ASCII	\l\
                                 1B  0017    72 		.BYTE	27
                           4A 32 5B  0018    73 		.ASCII	\[2J\			; erase screen
                                 1B  001B    74 		.BYTE	27
                           71 30 5B  001C    75 LEDS_OFF:	.ASCII	\[0q\			; all LED's off
                           0000000F  001F    76 	MODE_LEN=.-TERM_MODES
                                 1B  001F    77 WIDE:		.BYTE	27
                        68 33 3F 5B  0020    78 		.ASCII	\[?3h\			; 132 columns
                           00000005  0024    79 	WIDE_LEN=.-WIDE
                                 1B  0024    80 NARROW:		.BYTE	27
                        6C 33 3F 5B  0025    81 		.ASCII	\[?3l\			; 80 columns
                           00000005  0029    82 	NARROW_LEN=.-NARROW
                                 1B  0029    83 BOTTOM:		.BYTE	27
                  66 31 3B 34 32 5B  002A    84 		.ASCII	\[24;1f\		; go to bottom
                                 1B  0030    85 		.BYTE	27
                              4B 5B  0031    86 		.ASCII	\[K\			; erase line
                                 1B  0033    87 		.BYTE	27
                  66 31 3B 33 32 5B  0034    88 		.ASCII	\[23;1f\		; Set at bottom - 1
                                 1B  003A    89 		.BYTE	27
                           71 30 5B  003B    90 		.ASCII	\[0q\			; all LED's off
                           00000015  003E    91 	BOTTOM_LEN=.-BOTTOM
                                 00  003E    92 FLAG:		.BYTE
                           00000001  003F    93 TEMP_STORAGE:	.LONG	1
                           00000000  0043    94 		.LONG
                                 1B  0047    95 TEST_BUF:	.BYTE	27			; Sets cursor to 13,120
            48 30 32 31 3B 33 31 5B  0048    96 		.ASCII	\[13;120H\		; and then asks for pos-
                                 1B  0050    97 		.BYTE	27			; ition
                           6E 36 5B  0051    98 		.ASCII	\[6n\
                           0000000D  0054    99 	TEST_BUF_LEN=.-TEST_BUF
                  0000005C'0000000B  0054   100 TEST_END:	.LONG	11,.+4
   04 00'00'00'00'00'00'00'00'00'00' 005C   101 		.BYTE	0[10],4
                  00000000 00000000  0067   102 TEST_IOSB:	.QUAD
                           00000078  006F   103 TEST_RET:	.BLKB	9
                                 1B  0078   104 AVO_BUF:	.BYTE	27			; Tests for advanced
                           63 30 5B  0079   105 		.ASCII	\[0c\			; option
                           00000004  007C   106 	AVO_BUF_LEN=.-AVO_BUF
                  00000084'0000000D  007C   107 AVO_END:	.LONG	13,.+4
00'00'00'00'00'00'00'00'00'00'00'00' 0084   108 		.BYTE	0[12],8
                                 08  0090
                                     0091   109
                                     0091   110 ;
                                     0091   111 ;	SETERM
                                     0091   112 ;
                                 00000000   113 	.PSECT		SETERM,NOWRT
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  26
                                SETERM - SETS TERMINAL CHARACTERISTICS   29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                               0004  0000   114 	.ENTRY		SETERM,^M<R2>
                                     0002   115
                                     0002   116 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_SENSEMODE,P1=OLD_CHARS
                                     0024   117 ;						  get old characteristics
           60 8F   00000001'EF   91  0024   118 	CMPB		<OLD_CHARS+1>,#DT$_VT100
                            27   13  002C   119 	BEQL		5$
               0C BC   0050 8F   B1  002E   120 	CMPW		#80,@12(AP)
                            1C   13  0034   121 	BEQL		3$
               0C BC   FFB0 8F   B1  0036   122 	CMPW		#-80,@12(AP)
                            14   13  003C   123 	BEQL		3$
                         0C BC   B5  003E   124 	TSTW		@12(AP)
                            09   19  0041   125 	BLSS		2$
               0C BC   0050 8F   B0  0043   126 	MOVW		#80,@12(AP)
                          00C9   31  0049   127 	BRW		40$
               0C BC   FFB0 8F   B0  004C   128 2$:	MOVW		#-80,@12(AP)
                          00C0   31  0052   129 3$:	BRW		40$
           00000035'EF   FF 8F   90  0055   130 5$:	MOVB		#-1,VT100		; set VT100 flag
                       52   0A   D0  005D   131 	MOVL		#10,R2
                         09 52   F4  0060   132 10$:	SOBGEQ		R2,20$
                   00000035'EF   94  0063   133 	CLRB		VT100
                          00A9   31  0069   134 	BRW		40$
                                     006C   135
                                     006C   136 20$:	$QIOW_S		CHAN=@4(AP),-			; Check for AVO
                                     006C   137 		FUNC=#IO$_READPROMPT!IO$M_NOECHO!IO$M_PURGE!IO$M_TIMED,-
                                     006C   138 			IOSB=TEST_IOSB,P1=TEST_RET,P2=#8,P3=#2,-
                                     006C   139 			P4=#AVO_END,P5=#AVO_BUF,P6=#AVO_BUF_LEN
         0000'8F   00000067'EF   B1  009E   140 	CMPW		TEST_IOSB,#SS$_NORMAL
                            B7   12  00A7   141 	BNEQ		10$
              50   00000069'EF   3C  00A9   142 	MOVZWL		<TEST_IOSB+2>,R0
                       50   04   B1  00B0   143 	CMPW		#4,R0
                            AB   14  00B3   144 	BGTR		10$
              0000006F'EF   1B   91  00B5   145 	CMPB		#27,TEST_RET
                            A2   12  00BC   146 	BNEQ		10$
         00000070'EF   3F5B 8F   B1  00BE   147 	CMPW		#^A\[?\,<TEST_RET+1>
                            97   12  00C7   148 	BNEQ		10$
              32   0000006E'E0   91  00C9   149 	CMPB		L^TEST_RET-1(R0),#^A\2\
                            39   13  00D0   150 	BEQL		30$
              33   0000006E'E0   91  00D2   151 	CMPB		L^TEST_RET-1(R0),#^A\3\
                            30   13  00D9   152 	BEQL		30$
              36   0000006E'E0   91  00DB   153 	CMPB		L^TEST_RET-1(R0),#^A\6\
                            27   13  00E2   154 	BEQL		30$
              37   0000006E'E0   91  00E4   155 	CMPB		L^TEST_RET-1(R0),#^A\7\
                            1E   13  00EB   156 	BEQL		30$
         3131 8F   0000006D'E0   B1  00ED   157 	CMPW		L^TEST_RET-2(R0),#^A\11\
                            13   13  00F6   158 	BEQL		30$
         3531 8F   0000006D'E0   B1  00F8   159 	CMPW		L^TEST_RET-2(R0),#^A\15\
                            08   13  0101   160 	BEQL		30$
                   00000044'EF   94  0103   161 	CLRB		VT100A
                            2A   11  0109   162 	BRB		50$
           00000044'EF   FF 8F   90  010B   163 30$:	MOVB		#-1,VT100A
                            20   11  0113   164 	BRB		50$
                   00000035'EF   94  0115   165 40$:	CLRB		VT100
              00000043'EF   01   D0  011B   166 	MOVL		#1,<TEMP_STORAGE+4>	; top of page for non-VT100
                   0000003F'EF   DF  0122   167 	PUSHAL		TEMP_STORAGE
                   00000043'EF   DF  0128   168 	PUSHAL		<TEMP_STORAGE+4>
              00000000'GF   02   FB  012E   169 	CALLS		#2,G^SCR$ERASE_PAGE
     00000008'EF   00000000'EF   B0  0135   170 50$:	MOVW		OLD_CHARS,NEW_CHARS
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  27
                                SETERM - SETS TERMINAL CHARACTERISTICS   29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                         0C BC   B5  0140   171 	TSTW		@12(AP)
                            12   19  0143   172 	BLSS		60$
     00000004'EF   00000200 8F   CB  0145   173 	BICL3		#TT$M_WRAP,<OLD_CHARS+4>,<NEW_CHARS+4>	; nowrap
                   0000000C'EF       0150
                            18   11  0155   174 	BRB		70$
     00000004'EF   00000200 8F   C9  0157   175 60$:	BISL3		#TT$M_WRAP,<OLD_CHARS+4>,<NEW_CHARS+4>	; wrap
                   0000000C'EF       0162
           00000016'EF   68 8F   90  0167   176 	MOVB		#^A\h\,WRAP_BYTE
     0000000C'EF   00080000 8F   C8  016F   177 70$:	BISL2		#TT$M_MECHFORM,<NEW_CHARS+4>
                                     017A   178 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_SETMODE,P1=NEW_CHARS ; set char.
                57 00000035'EF   E9  019C   179 	BLBC		VT100,90$
                                     01A3   180 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,-	; term setup
                                     01A3   181 			P1=TERM_MODES,P2=#MODE_LEN
           0000003E'EF   08 BC   90  01C5   182 	MOVB		@8(AP),FLAG
                            0C   13  01CD   183 	BEQL		80$
                         04 AC   DD  01CF   184 	PUSHL		4(AP)
              00000371'EF   01   FB  01D2   185 	CALLS		#1,SETNAR
                            1F   11  01D9   186 	BRB		90$
                         04 AC   DD  01DB   187 80$:	PUSHL		4(AP)
              0000042F'EF   01   FB  01DE   188 	CALLS		#1,SETWID
                0E 00000044'EF   E8  01E5   189 	BLBS		VT100A,90$
              00000042'EF   0E   B0  01EC   190 	MOVW		#14,COMLIN
              00000040'EF   0A   A2  01F3   191 	SUBW2		#10,PAGLEN
                                 04  01FA   192 90$:	RET
                                     01FB   193
                                     01FB   194 	.SUBTITLE	RESTRM - RESTORES THE TERMINAL CHARACTERISTICS
                                     01FB   195 ;
                                     01FB   196 ;	RESTRM
                                     01FB   197 ;
                                     01FB   198 ;DM
                                     01FB   199 ;DM   RESTRM is called to restore the terminal to the characteristics it
                                     01FB   200 ;DM   had prior to the call to SETERM.
                                     01FB   201 ;M
                                     01FB   202 ;M         RESTRM sets the terminal back to what it was when SETERM was
                                     01FB   203 ;M    called.  For VT100 terminals If the original width was > 80 then
                                     01FB   204 ;M    the terminal is left in 132 character mode, otherwise it is put in
                                     01FB   205 ;M    to 80 character mode, and the terminal is always left NOWRAP (second
                                     01FB   206 ;M    bit of byte 3 off).  It is called with the terminal channel number
                                     01FB   207 ;M    as its sole argument.
                                     01FB   208 ;
                                     01FB   209 ;	CALLED ROUTINES
                                     01FB   210 ;
                                     01FB   211 ;C    SETNAR  sets a VT100 to 80 columns
                                     01FB   212 ;C    SETWID  sets a VT100 to 132 columns
                                     01FB   213
                               0000  01FB   214 	.ENTRY		RESTRM,0
                                     01FD   215
                                     01FD   216 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_SETMODE,P1=OLD_CHARS ; restore
                35 00000035'EF   E8  021F   217 	BLBS		VT100,10$
              00000043'EF   18   D0  0226   218 	MOVL		#24,<TEMP_STORAGE+4>
                   0000003F'EF   DF  022D   219 	PUSHAL		TEMP_STORAGE
                   00000043'EF   DF  0233   220 	PUSHAL		<TEMP_STORAGE+4>
              00000000'GF   02   FB  0239   221 	CALLS		#2,G^LIB$ERASE_LINE
              00000043'EF   17   D0  0240   222 	MOVL		#23,<TEMP_STORAGE+4>
                   0000003F'EF   DF  0247   223 	PUSHAL		TEMP_STORAGE
                   00000043'EF   DF  024D   224 	PUSHAL		<TEMP_STORAGE+4>
              00000000'GF   02   FB  0253   225 	CALLS		#2,G^LIB$SET_CURSOR
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  28
                                RESTRM - RESTORES THE TERMINAL CHARACTER 29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                                 04  025A   226 	RET
                                     025B   227
         00000002'EF   0050 8F   B1  025B   228 10$:	CMPW		#80,<OLD_CHARS+2>
                            13   18  0264   229 	BGEQ		20$
                   0000003E'EF   95  0266   230 	TSTB		FLAG
                            13   13  026C   231 	BEQL		30$
                         04 AC   DD  026E   232 	PUSHL		4(AP)
              0000042F'EF   01   FB  0271   233 	CALLS		#1,SETWID			; back to wide
                                 04  0278   234 	RET
                                     0279   235
                   0000003E'EF   95  0279   236 20$:	TSTB		FLAG
                            23   13  027F   237 	BEQL		40$
                                     0281   238 30$:	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,P1=BOTTOM,-
                                     0281   239 			P2=#BOTTOM_LEN			; go to bottom
                                 04  02A3   240 	RET
                                     02A4   241
                         04 AC   DD  02A4   242 40$:	PUSHL		4(AP)
              00000371'EF   01   FB  02A7   243 	CALLS		#1,SETNAR			; back to narrow
                                 04  02AE   244 	RET
                                     02AF   245
                                     02AF   246 	.SUBTITLE	SETWRP - SETS THE TERMINAL /WRAP
                                     02AF   247 ;
                                     02AF   248 ;	SETWRP
                                     02AF   249 ;
                                     02AF   250 ;DM
                                     02AF   251 ;DM   SETWRP sets the terminal characteristics to WRAP so that lines of
                                     02AF   252 ;DM   output will be continued on subsequent lines of the screen, rather
                                     02AF   253 ;DM   than truncated to fit on one.
                                     02AF   254 ;M
                                     02AF   255 ;M    SETWRP is called with the terminal channel number as its sole
                                     02AF   256 ;M    argument.
                                     02AF   257
                               0000  02AF   258 	.ENTRY		SETWRP,^M<>
                                     02B1   259
                2A 00000035'EF   E9  02B1   260 	BLBC		VT100,190$
           00000016'EF   68 8F   90  02B8   261 	MOVB		#^A\h\,WRAP_BYTE
                                     02C0   262 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,P1=WRAP_MODE,-
                                     02C0   263 			P2=#5
     0000000C'EF   00000200 8F   C8  02E2   264 190$:	BISL2		#TT$M_WRAP,<NEW_CHARS+4>
                                     02ED   265 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_SETMODE,P1=NEW_CHARS
                                 04  030F   266 	RET
                                     0310   267
                                     0310   268 	.SUBTITLE	CLRWRP - SETS THE TERMINAL /NOWRAP
                                     0310   269 ;
                                     0310   270 ;	CLRWRP
                                     0310   271 ;
                                     0310   272 ;DM
                                     0310   273 ;DM   CLRWRP sets the terminal characteristics to NOWRAP so that lines of
                                     0310   274 ;DM   output will be truncated to fit on one line of the screen, rather
                                     0310   275 ;DM   continued on subsequent lines.
                                     0310   276 ;M
                                     0310   277 ;M    CLRWRP is called with the terminal channel number as its sole
                                     0310   278 ;M    argument.
                                     0310   279
                               0000  0310   280 	.ENTRY		CLRWRP,^M<>
                                     0312   281
                2A 00000035'EF   E9  0312   282 	BLBC		VT100,200$
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  29
                                CLRWRP - SETS THE TERMINAL /NOWRAP       29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
           00000016'EF   6C 8F   90  0319   283 	MOVB		#^A\l\,WRAP_BYTE
                                     0321   284 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,P1=WRAP_MODE,-
                                     0321   285 			P2=#5
     0000000C'EF   00000200 8F   CA  0343   286 200$:	BICL2		#TT$M_WRAP,<NEW_CHARS+4>
                                     034E   287 	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_SETMODE,P1=NEW_CHARS
                                 04  0370   288 	RET
                                     0371   289
                                     0371   290 	.SUBTITLE	SETNAR - SETS THE TERMINAL TO 80 COLUMN MODE
                                     0371   291 ;
                                     0371   292 ;	SETNAR
                                     0371   293 ;
                                     0371   294 ;DM
                                     0371   295 ;DM   SETNAR sets the terminal to narrow mode (80 columns).
                                     0371   296 ;M
                                     0371   297 ;M    SETNAR is called with the terminal channel number as its sole
                                     0371   298 ;M    argument.  It should only be called if the terminal in use is
                                     0371   299 ;M    a VT100 with advanced video.  The routine will check (by cursor
                                     0371   300 ;M    positioning) to see if the transition has been made (some VT100's
                                     0371   301 ;M    have been known to be flaky at 132<->80 column transitions).  If
                                     0371   302 ;M    it cannot successfully cause the transition after 10 tries it will
                                     0371   303 ;M    cause the program to exit with DEVCMDERR status.
                                     0371   304
                               0004  0371   305 	.ENTRY		SETNAR,^M<R2>
                                     0373   306
                       52   0A   D0  0373   307 	MOVL		#10,R2
                         15 52   F4  0376   308 10$:	SOBGEQ		R2,20$
                         04 AC   DD  0379   309 	PUSHL		4(AP)
                  FE7A CF   01   FB  037C   310 	CALLS		#1,RESTRM
                                     0381   311 	$EXIT_S		CODE=#SS$_DEVCMDERR
                                     038E   312
                                     038E   313 20$:	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,P1=NARROW,-
                                     038E   314 			P2=#NARROW_LEN			; Set narrow
                                     03B0   315 	$QIOW_S		CHAN=@4(AP),-			; Check it
                                     03B0   316 		FUNC=#IO$_READPROMPT!IO$M_NOECHO!IO$M_PURGE!IO$M_TIMED,-
                                     03B0   317 			IOSB=TEST_IOSB,P1=TEST_RET,P2=#8,P3=#2,-
                                     03B0   318 			P4=#TEST_END,P5=#TEST_BUF,P6=#TEST_BUF_LEN
         00000067'EF   0000'8F   B1  03E2   319 	CMPW		#SS$_NORMAL,TEST_IOSB
                            89   12  03EB   320 	BNEQ		10$
              00000069'EF   07   B1  03ED   321 	CMPW		#7,<TEST_IOSB+2>
                            03   13  03F4   322 	BEQL		25$
                          FF7D   31  03F6   323 	BRW		10$
     00000071'EF   383B3331 8F   D1  03F9   324 25$:	CMPL		#^A\13;8\,<TEST_RET+2>
                            0B   12  0404   325 	BNEQ		30$
         00000075'EF   5230 8F   B1  0406   326 	CMPW		#^A\0R\,<TEST_RET+6>
                            03   13  040F   327 	BEQL		40$
                          FF62   31  0411   328 30$:	BRW		10$
              0000003F'EF   01   D0  0414   329 40$:	MOVL		#1,TEMP_STORAGE		; Move to top of screen
                   0000003F'EF   DF  041B   330 	PUSHAL		TEMP_STORAGE
                   0000003F'EF   DF  0421   331 	PUSHAL		TEMP_STORAGE
              00000000'GF   02   FB  0427   332 	CALLS		#2,G^LIB$SET_CURSOR
                                 04  042E   333 	RET
                                     042F   334
                                     042F   335 	.SUBTITLE	SETWID - SETS THE TERMINAL TO 132 COLUMN MODE
                                     042F   336 ;
                                     042F   337 ;	SETWID
                                     042F   338 ;
                                     042F   339 ;DM
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  30
                                SETWID - SETS THE TERMINAL TO 132 COLUMN 29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
                                     042F   340 ;DM   SETWID sets the terminal to wide mode (132 columns).
                                     042F   341 ;M
                                     042F   342 ;M    SETWID is called with the terminal channel number as its sole
                                     042F   343 ;M    argument.  It should only be called if the terminal in use is
                                     042F   344 ;M    a VT100 with advanced video.  The routine will check (by cursor
                                     042F   345 ;M    positioning) to see if the transition has been made (some VT100's
                                     042F   346 ;M    have been known to be flaky at 132<->80 column transitions).  If
                                     042F   347 ;M    it cannot successfully cause the transition after 10 tries it will
                                     042F   348 ;M    cause the program to exit with DEVCMDERR status.
                                     042F   349
                               0004  042F   350 	.ENTRY		SETWID,^M<R2>
                                     0431   351
                       52   0A   D0  0431   352 	MOVL		#10,R2
                         15 52   F4  0434   353 10$:	SOBGEQ		R2,20$
                         04 AC   DD  0437   354 	PUSHL		4(AP)
                  FDBC CF   01   FB  043A   355 	CALLS		#1,RESTRM
                                     043F   356 	$EXIT_S		CODE=#SS$_DEVCMDERR
                                     044C   357
                                     044C   358 20$:	$QIOW_S		CHAN=@4(AP),FUNC=#IO$_WRITEVBLK,P1=WIDE,-
                                     044C   359 			P2=#WIDE_LEN			; Set wide
                                     046E   360 	$QIOW_S		CHAN=@4(AP),-			; Check it
                                     046E   361 		FUNC=#IO$_READPROMPT!IO$M_NOECHO!IO$M_PURGE!IO$M_TIMED,-
                                     046E   362 			IOSB=TEST_IOSB,P1=TEST_RET,P2=#9,P3=#2,-
                                     046E   363 			P4=#TEST_END,P5=#TEST_BUF,P6=#TEST_BUF_LEN
         00000067'EF   0000'8F   B1  04A0   364 	CMPW		#SS$_NORMAL,TEST_IOSB
                            89   12  04A9   365 	BNEQ		10$
              00000069'EF   08   B1  04AB   366 	CMPW		#8,<TEST_IOSB+2>
                            03   13  04B2   367 	BEQL		25$
                          FF7D   31  04B4   368 	BRW		10$
     00000071'EF   313B3331 8F   D1  04B7   369 25$:	CMPL		#^A\13;1\,<TEST_RET+2>
                            0D   12  04C2   370 	BNEQ		30$
     00000074'EF   52303231 8F   D1  04C4   371 	CMPL		#^A\120R\,<TEST_RET+5>
                            03   13  04CF   372 	BEQL		40$
                          FF60   31  04D1   373 30$:	BRW		10$
              0000003F'EF   01   D0  04D4   374 40$:	MOVL		#1,TEMP_STORAGE		; Move to top of screen
                   0000003F'EF   DF  04DB   375 	PUSHAL		TEMP_STORAGE
                   0000003F'EF   DF  04E1   376 	PUSHAL		TEMP_STORAGE
              00000000'GF   02   FB  04E7   377 	CALLS		#2,G^LIB$SET_CURSOR
                                 04  04EE   378 	RET
                                     04EF   379
                                     04EF   380 	.END
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  31
Symbol table                                                             29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
$$T1           = 00000001               DT$_LA24       = 00000025               DT$_VT131      = 00000065
AT$_CI         = 00000004               DT$_LA34       = 00000022               DT$_VT132      = 00000066
AT$_DR         = 00000002               DT$_LA36       = 00000020               DT$_VT173      = 00000003
AT$_MBA        = 00000000               DT$_LA38       = 00000023               DT$_VT52       = 00000040
AT$_MPM        = 00000003               DT$_LAX        = 00000020               DT$_VT55       = 00000041
AT$_NULL       = 00000005               DT$_LP11       = 00000001               DT$_VT5X       = 00000040
AT$_UBA        = 00000001               DT$_LPA11      = 00000001               DT$_XI_DR11C   = 00000008
AVO_BUF          00000078 R     04      DT$_LQP02      = 00000026               DT$_XJ_2780    = 00000004
AVO_BUF_LEN    = 00000004               DT$_MBX        = 00000001               DT$_XK_3271    = 00000003
AVO_END          0000007C R     04      DT$_ML11       = 00000011               DT$_XV_3271    = 0000000B
BOTTOM           00000029 R     04      DT$_MX_MUX200  = 00000008               DT$_YN_X25     = 0000000F
BOTTOM_LEN     = 00000015               DT$_NI         = 0000000D               DT$_YO_X25     = 00000010
CLRWRP           00000310 RG    05      DT$_NV_X29     = 00000006               DT$_YP_ADCCP   = 00000011
COMLIN           00000042 R     03      DT$_NW_X25     = 00000005               DT$_YQ_3271    = 00000012
DC$_BUS        = 00000080               DT$_PCL11R     = 00000005               DT$_YR_DDCMP   = 00000013
DC$_CARD       = 00000041               DT$_PCL11T     = 00000006               DT$_YS_SDLC    = 00000014
DC$_DISK       = 00000001               DT$_RA60       = 00000016               FLAG             0000003E R     04
DC$_JOURNAL    = 000000A1               DT$_RA80       = 00000014               IO$M_NOECHO      ********   X   05
DC$_LP         = 00000043               DT$_RA81       = 00000015               IO$M_PURGE       ********   X   05
DC$_MAILBOX    = 000000A0               DT$_RB02       = 00000012               IO$M_TIMED       ********   X   05
DC$_MISC       = 000000C8               DT$_RB80       = 00000013               IO$_READPROMPT   ********   X   05
DC$_REALTIME   = 00000060               DT$_RK06       = 00000001               IO$_SENSEMODE    ********   X   05
DC$_SCOM       = 00000020               DT$_RK07       = 00000002               IO$_SETMODE      ********   X   05
DC$_TAPE       = 00000002               DT$_RL01       = 00000009               IO$_WRITEVBLK    ********   X   05
DC$_TERM       = 00000042               DT$_RL02       = 0000000A               LEDS_OFF         0000001C R     04
DT$_AIJNL      = 00000003               DT$_RM03       = 00000006               LIB$ERASE_LINE   ********   X   05
DT$_ATJNL      = 00000004               DT$_RM05       = 0000000F               LIB$SET_CURSOR   ********   X   05
DT$_BIJNL      = 00000002               DT$_RM80       = 0000000D               MODE_LEN       = 0000000F
DT$_CI         = 0000000C               DT$_RP04       = 00000003               NARROW           00000024 R     04
DT$_CI750      = 00000002               DT$_RP05       = 00000004               NARROW_LEN     = 00000005
DT$_CI780      = 00000001               DT$_RP06       = 00000005               NEW_CHARS        00000008 R     04
DT$_CR11       = 00000001               DT$_RP07       = 00000007               OLD_CHARS        00000000 R     04
DT$_DMC11      = 00000001               DT$_RP07HT     = 00000008               PAGLEN           00000040 R     03
DT$_DMF32      = 0000000A               DT$_RUJNL      = 00000001               RESTRM           000001FB RG    05
DT$_DMP11      = 00000009               DT$_RX01       = 00000010               SCR$ERASE_PAGE   ********   X   05
DT$_DMR11      = 00000002               DT$_RX02       = 0000000B               SETERM           00000000 RG    05
DT$_DN11       = 00000001               DT$_RX04       = 0000000C               SETNAR           00000371 RG    05
DT$_DR11C      = 00000007               DT$_RZ01       = 00000017               SETWID           0000042F RG    05
DT$_DR11W      = 00000004               DT$_RZF01      = 00000018               SETWRP           000002AF RG    05
DT$_DR750      = 00000003               DT$_SB_ISB11   = 00000007               SS$_DEVCMDERR    ********   X   05
DT$_DR780      = 00000002               DT$_TE16       = 00000001               SS$_NORMAL       ********   X   05
DT$_DZ11       = 00000042               DT$_TS11       = 00000004               SYS$EXIT         ********  GX   05
DT$_DZ32       = 00000043               DT$_TTYUNKN    = 00000000               SYS$QIOW         ********  GX   05
DT$_DZ730      = 00000044               DT$_TU45       = 00000002               TEMP_STORAGE     0000003F R     04
DT$_FT1        = 00000010               DT$_TU58       = 0000000E               TERM_MODES       00000010 R     04
DT$_FT2        = 00000011               DT$_TU77       = 00000003               TEST_BUF         00000047 R     04
DT$_FT3        = 00000012               DT$_TU78       = 00000005               TEST_BUF_LEN   = 0000000D
DT$_FT4        = 00000013               DT$_UDA50      = 00000003               TEST_END         00000054 R     04
DT$_FT5        = 00000014               DT$_UNA11      = 0000000E               TEST_IOSB        00000067 R     04
DT$_FT6        = 00000015               DT$_UNKNJNL    = 00000000               TEST_RET         0000006F R     04
DT$_FT7        = 00000016               DT$_VK100      = 00000002               TT$C_BAUD_110  = 00000003
DT$_FT8        = 00000017               DT$_VT05       = 00000001               TT$C_BAUD_1200 = 00000008
DT$_LA100      = 00000025               DT$_VT100      = 00000060               TT$C_BAUD_134  = 00000004
DT$_LA11       = 00000002               DT$_VT101      = 00000061               TT$C_BAUD_150  = 00000005
DT$_LA12       = 00000024               DT$_VT102      = 00000062               TT$C_BAUD_1800 = 00000009
DT$_LA120      = 00000021               DT$_VT105      = 00000063               TT$C_BAUD_19200= 00000010
DT$_LA180      = 00000003               DT$_VT125      = 00000064               TT$C_BAUD_2000 = 0000000A
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  32
Symbol table                                                             29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     
TT$C_BAUD_2400 = 0000000B               TT$V_HALFDUP   = 00000014               WIDE_LEN       = 00000005
TT$C_BAUD_300  = 00000006               TT$V_HOLDSCREEN= 0000000E               WRAP_BYTE        00000016 R     04
TT$C_BAUD_3600 = 0000000C               TT$V_HOSTSYNC  = 00000004               WRAP_MODE        00000012 R     04
TT$C_BAUD_4800 = 0000000D               TT$V_LFFILL    = 0000000B
TT$C_BAUD_50   = 00000001               TT$V_LOWER     = 00000007
TT$C_BAUD_600  = 00000007               TT$V_MBXDSABL  = 00000010
TT$C_BAUD_7200 = 0000000E               TT$V_MECHFORM  = 00000013
TT$C_BAUD_75   = 00000002               TT$V_MECHTAB   = 00000008
TT$C_BAUD_9600 = 0000000F               TT$V_MODEM     = 00000015
TT$M_ALTRPAR   = 00000020               TT$V_NOBRDCST  = 00000011
TT$M_CRFILL    = 00000400               TT$V_NOECHO    = 00000001
TT$M_DS_CARRIER= 00000020               TT$V_NOTYPEAHD = 00000002
TT$M_DS_CTS    = 00000010               TT$V_ODD       = 00000007
TT$M_DS_DSR    = 00000080               TT$V_OPER      = 00000016
TT$M_DS_DTR    = 00000002               TT$V_PAGE      = 00000018
TT$M_DS_RING   = 00000040               TT$V_PARITY    = 00000006
TT$M_DS_RTS    = 00000010               TT$V_PASSALL   = 00000000
TT$M_DS_SECREC = 00000008               TT$V_READSYNC  = 00000012
TT$M_DS_SECTX  = 00000008               TT$V_REMOTE    = 0000000D
TT$M_EIGHTBIT  = 00008000               TT$V_SCOPE     = 0000000C
TT$M_ESCAPE    = 00000008               TT$V_SCRIPT    = 00000006
TT$M_HALFDUP   = 00100000               TT$V_TTSYNC    = 00000005
TT$M_HOLDSCREEN= 00004000               TT$V_WRAP      = 00000009
TT$M_HOSTSYNC  = 00000010               TT$_FT1        = 00000010
TT$M_LFFILL    = 00000800               TT$_FT2        = 00000011
TT$M_LOWER     = 00000080               TT$_FT3        = 00000012
TT$M_MBXDSABL  = 00010000               TT$_FT4        = 00000013
TT$M_MECHFORM  = 00080000               TT$_FT5        = 00000014
TT$M_MECHTAB   = 00000100               TT$_FT6        = 00000015
TT$M_MODEM     = 00200000               TT$_FT7        = 00000016
TT$M_NOBRDCST  = 00020000               TT$_FT8        = 00000017
TT$M_NOECHO    = 00000002               TT$_LA100      = 00000025
TT$M_NOTYPEAHD = 00000004               TT$_LA12       = 00000024
TT$M_ODD       = 00000080               TT$_LA120      = 00000021
TT$M_OPER      = 00400000               TT$_LA24       = 00000025
TT$M_PAGE      = FF000000               TT$_LA34       = 00000022
TT$M_PARITY    = 00000040               TT$_LA36       = 00000020
TT$M_PASSALL   = 00000001               TT$_LA38       = 00000023
TT$M_READSYNC  = 00040000               TT$_LAX        = 00000020
TT$M_REMOTE    = 00002000               TT$_LQP02      = 00000026
TT$M_SCOPE     = 00001000               TT$_UNKNOWN    = 00000000
TT$M_SCRIPT    = 00000040               TT$_VK100      = 00000002
TT$M_TTSYNC    = 00000020               TT$_VT05       = 00000001
TT$M_WRAP      = 00000200               TT$_VT100      = 00000060
TT$S_PAGE      = 00000008               TT$_VT101      = 00000061
TT$V_ALTRPAR   = 00000005               TT$_VT102      = 00000062
TT$V_CRFILL    = 0000000A               TT$_VT105      = 00000063
TT$V_DS_CARRIER= 00000005               TT$_VT125      = 00000064
TT$V_DS_CTS    = 00000004               TT$_VT131      = 00000065
TT$V_DS_DSR    = 00000007               TT$_VT132      = 00000066
TT$V_DS_DTR    = 00000001               TT$_VT173      = 00000003
TT$V_DS_RING   = 00000006               TT$_VT52       = 00000040
TT$V_DS_RTS    = 00000004               TT$_VT55       = 00000041
TT$V_DS_SECREC = 00000003               TT$_VT5X       = 00000040
TT$V_DS_SECTX  = 00000003               VT100            00000035 R     03
TT$V_EIGHTBIT  = 0000000F               VT100A           00000044 R     03
TT$V_ESCAPE    = 00000003               WIDE             0000001F R     04
SETERM                          - SETS TERMINAL CHARACTERISITICS         29-SEP-1983 15:51:36  VAX-11 Macro V03-00         Page  33
Psect synopsis                                                           29-SEP-1983 09:52:15  JPLSCR:[JLV.LOOK]SETERM.MAR;16    (1)
                                                                                                                                     

                                                +----------------+
                                                ! Psect synopsi
PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          -
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE
. BLANK .                       00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
$ABS$                           00000000  (    0.)  02 (  2.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
DOITNM                          00000045  (   69.)  03 (  3.)    PIC   USR   OVR   REL   GBL   SHR NOEXE   RD    WRT NOVEC LONG
SETDAT                          00000091  (  145.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC LONG
SETERM                          000004EF  ( 1263.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE

                                             +------------------------+
                                             ! Performance
Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------
Initialization                   24     00:00:00.11    00:00:16.95
Command processing               24     00:00:00.14    00:00:17.90
Pass 1                          209     00:00:05.64    00:02:52.02
Symbol table sort                 0     00:00:00.46    00:00:09.02
Pass 2                           94     00:00:01.57    00:00:24.91
Symbol table output              25     00:00:00.25    00:00:05.97
Psect synopsis output             5     00:00:00.05    00:00:00.97
Cross-reference output            0     00:00:00.00    00:00:00.00
Assembler run totals            384     00:00:08.25    00:04:07.76
                                                                                                                                     
The working set limit was 415 pages.
28771 bytes (57 pages) of virtual memory were used to buffer the intermediate code.
There were 20 pages of symbol table space allocated to hold 288 non-local and 28 local symbols.
380 source lines were read in Pass 1, producing 0 object records in Pass 2.
14 pages of virtual memory were used to define 13 macros.

                                            +--------------------------+
                                            ! Macro libra
Macro library name                           Macros defined      
------------------                           --------------
SYS$SYSROOT:[SYSLIB]STARLET.MLB;1                      10
                                                                                                                                     
371 GETS were required to define 10 macros.
                                                                                                                                     
There were no errors, warnings or information messages.
                                                                                                                                     
/NOOBJECT/LIST SETERM.MAR
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  34
Table of contents
                                                                                                                                     
    (1)        2        TTBRDINI - Terminal broadcast handler in
    (1)       95        TTBRDAST
    (1)      129        TTBRDEND - CLOSES THINGS DOWN
    (1)      156        TTSPAWN - SPAWNS A SUB-PROCESS
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  35
                                                                         27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
                                     0000     1 	.TITLE	TTBRDINI - Routines to handle terminal broadcasts
                                     0000     2 	.SUBTITLE	TTBRDINI - Terminal broadcast handler initialization
                                     0000     3
                                     0000     4 ;DM   This is a package which enables a program to intercept messages that
                                     0000     5 ;DM   are broadcast to its terminal without having them actually appear on
                                     0000     6 ;DM   the terminal.  This allows them to be examined/thrown-away or whatever
                                     0000     7 ;DM   by a user routine.  It consists of the following routines:
                                     0000     8 ;DME  TTBRDINI - Initializes things
                                     0000     9 ;DME  TTBRDEND - Shuts things down
                                     0000    10 ;DME  TTBRDAST - AST to handle messages received
                                     0000    11 ;DME  TTSPAWN  - Spawns off a sub-process correctly.
                                     0000    12 ;DM
                                     0000    13 ;DM   Programmer  Jon Vavrus -  4 APR 1983
                                     0000    14 ;M
                                     0000    15 ;M         An initial call is made to TTBRDINI with an argument list
                                     0000    16 ;M    consisting of the address of a user routine to be called when a
                                     0000    17 ;M    broadcast message is received.  There is an exit handler established
                                     0000    18 ;M    to handle the necessary clean-up, thus no termination routine is
                                     0000    19 ;M    provided.  If an error occurs on initialization TTBRDINI will return
                                     0000    20 ;M    an even valued integer as its function value.
                                     0000    21 ;
                                     0000    22 ;	CALLED ROUTINES
                                     0000    23 ;
                                     0000    24 ;C    TTBRDEND - This cleans things up on exit.
                                     0000    25 ;C    TTBRDAST - This is invoked on receipt of a broadcast message.
                                     0000    26
                                     0000    27 	$IODEF
                                     0000    28 	$JPIDEF
                                     0000    29 	$MSGDEF
                                     0000    30 	$TTDEF
                                     0000    31 	$TT2DEF
                                     0000    32
                                 00000000    33 		.PSECT	TT_BRD_DATA,LONG,RD,WRT,NOEXE
                                     0000    34
                  00000008'00000010  0000    35 DEV:		.LONG	16,.+4			; Descriptor for terminal
                           00000018  0008    36 		.BLKB	16			; device name
                           00000000  0018    37 END_BLOCK:	.LONG	0			; Exit handler descriptor block
                           000001BB' 001C    38 		.LONG	TTBRDEND
                           00000001  0020    39 		.LONG	1
                           000000E2' 0024    40 		.LONG	PID
                          0319 0010  0028    41 GETJPI_LIST:	.WORD	16,JPI$_PID		; GETJPI list
                           000000E2' 002C    42 		.LONG	PID
                  00000000 00000000  0030    43 		.LONG	0,0
                           000000B8  0038    44 MBX_BUFFER:	.BLKB	128			; Buffer for mailbox
                           00000000  00B8    45 MBX_CHAN:	.LONG				; Mailbox channel
                  00000000 00000000  00BC    46 MBX_IOSB:	.QUAD				; Mailbox IOSB
                  000000CC'00000008  00C4    47 MBX_NAME:	.LONG	8,.+4			; Mailbox logical name
                           000000D4  00CC    48 		.BLKB	8			; Process ID will go here
                  58 42 4D 54 54 5F  00D4    49 		.ASCII	\_TTMBX\
                           000000E2  00DA    50 MSG_DSC:	.BLKL	2			; Message descriptor
                           00000000  00E2    51 PID:		.LONG
            54 54 000000EE'010E0000' 00E6    52 TT:		.ASCID	\TT\			; Terminal logical name
                           00000000  00F0    53 TT_CHAN:	.LONG				; Terminal channel
                           00000100  00F4    54 TT_CHAR:	.BLKL	3			; Terminal characteristics
                           00000000  0100    55 USER_ROUTINE:	.LONG				; Storage for user routine
                                     0104    56 						; address
                                     0104    57
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  36
                                TTBRDINI - Terminal broadcast handler in 27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
                                 00000000    58 	.PSECT		TT_BRD_CODE,BYTE,RD,NOWRT,EXE
                                     0000    59
                               0000  0000    60 	.ENTRY		TTBRDINI,^M<>
                                     0002    61
                                     0002    62 ;	This is the initialization routine.  It should be called with one
                                     0002    63 ;	argument.  This should be the address of the routine to be called
                                     0002    64 ;	when a broadcast message is received.
                                     0002    65
           00000100'EF   04 AC   D0  0002    66 	MOVL		4(AP),USER_ROUTINE	; Save routine address
                                     000A    67 	$TRNLOG_S	LOGNAM=TT,RSLLEN=DEV,RSLBUF=DEV
                         59 50   E9  0029    68 	BLBC		R0,3$
                                     002C    69 	$GETJPI_S	ITMLST=GETJPI_LIST	; Get process name
                            08   DD  0043    70 	PUSHL		#8
                   000000C4'EF   7F  0045    71 	PUSHAQ		MBX_NAME
                   000000E2'EF   DF  004B    72 	PUSHAL		PID
              00000000'GF   03   FB  0051    73 	CALLS		#3,G^OTS$CVT_L_TZ
              000000C4'EF   0E   D0  0058    74 	MOVL		#14,MBX_NAME		; Create mailbox
                                     005F    75 	$CREMBX_S	CHAN=MBX_CHAN,MAXMSG=#128,BUFQUO=#128,-
                                     005F    76 			LOGNAM=MBX_NAME
                         03 50   E8  0082    77 	BLBS		R0,6$
                          00BB   31  0085    78 3$:	BRW		10$
                                     0088    79 6$:	$ASSIGN_S	CHAN=TT_CHAN,DEVNAM=DEV,MBXNAM=MBX_NAME
                         DF 50   E9  00A3    80 	BLBC		R0,3$			; Assign channel
                                     00A6    81 	$QIOW_S		CHAN=TT_CHAN,FUNC=#IO$_SENSEMODE,-
                                     00A6    82 			P1=TT_CHAR,P2=#12	; Set TT2$M_BRDCSTMBX
                         77 50   E9  00C9    83 	BLBC		R0,10$
              000000FC'EF   10   C8  00CC    84 	BISL2		#TT2$M_BRDCSTMBX,<TT_CHAR+8>
     000000F8'EF   00020000 8F   C8  00D3    85 	BISL2		#TT$M_NOBRDCST,<TT_CHAR+4>
                                     00DE    86 	$QIOW_S		CHAN=TT_CHAN,FUNC=#IO$_SETMODE,-
                                     00DE    87 			P1=TT_CHAR,P2=#12
                         3F 50   E9  0101    88 	BLBC		R0,10$
                                     0104    89 	$DCLEXH_S	DESBLK=END_BLOCK	; Declare exit handler
                                     0111    90 	$QIO_S		CHAN=MBX_CHAN,FUNC=#IO$_READVBLK,-
                                     0111    91 			IOSB=MBX_IOSB,ASTADR=TTBRDAST,ASTPRM=4(AP),-
                                     0111    92 			P1=MBX_BUFFER,P2=#128
                                 04  0143    93 10$:	RET
                                     0144    94
                                     0144    95 	.SUBTITLE	TTBRDAST
                                     0144    96 ;
                                     0144    97 ;	TTBRDAST
                                     0144    98 ;
                                     0144    99 ;DM
                                     0144   100 ;DM   TTBRDAST is the actual AST routine invoked on message receipt.
                                     0144   101 ;M
                                     0144   102 ;M         TTBRDAST will call the user routine correctly.
                                     0144   103 ;
                                     0144   104 ;	CALLED ROUTINES
                                     0144   105 ;
                                     0144   106 ;C    BRDCST  - User routine to field broadcast messages.
                                     0144   107
                               0000  0144   108 	.ENTRY		TTBRDAST,^M<>
                                     0146   109
                                     0146   110 ;	This is the AST which actually calls the user routine.
                                     0146   111
                            03   BB  0146   112 	PUSHR		#^M<R0,R1>
         000000BC'EF   0000'8F   B1  0148   113 	CMPW		#SS$_ABORT,MBX_IOSB
                            65   13  0151   114 	BEQL		20$
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  37
                                TTBRDAST                                 27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
         000000BC'EF   0000'8F   B1  0153   115 	CMPW		#SS$_CANCEL,MBX_IOSB
                            5A   13  015C   116 	BEQL		20$
         00000038'EF   0053 8F   B1  015E   117 	CMPW		#MSG$_TRMBRDCST,MBX_BUFFER
                            20   12  0167   118 	BNEQ		10$
     000000DA'EF   0000004C'EF   3C  0169   119 	MOVZWL		<MBX_BUFFER+20>,MSG_DSC	; Set up message descriptor
     000000DE'EF   0000004E'EF   DE  0174   120 	MOVAL		<MBX_BUFFER+22>,<MSG_DSC+4>
                   000000DA'EF   7F  017F   121 	PUSHAQ		MSG_DSC			; Call user routine
                    04 BC   01   FB  0185   122 	CALLS		#1,@4(AP)
                                     0189   123 10$:	$QIO_S		CHAN=MBX_CHAN,FUNC=#IO$_READVBLK,-
                                     0189   124 			IOSB=MBX_IOSB,ASTADR=TTBRDAST,ASTPRM=4(AP),-
                                     0189   125 			P1=MBX_BUFFER,P2=#128
                            03   BA  01B8   126 20$:	POPR		#^M<R0,R1>
                                 04  01BA   127 	RET
                                     01BB   128
                                     01BB   129 	.SUBTITLE	TTBRDEND - CLOSES THINGS DOWN
                                     01BB   130 ;
                                     01BB   131 ;	TTBRDEND
                                     01BB   132 ;
                                     01BB   133 ;DM
                                     01BB   134 ;DM   TTBRDEND returns broadcast message processing to the normal procedure.
                                     01BB   135 ;M
                                     01BB   136 ;M         TTBRDEND is never really called but, rather, it is queued as an
                                     01BB   137 ;M    exit handler and invoked on image exit.
                                     01BB   138
                               0000  01BB   139 	.ENTRY		TTBRDEND,^M<>
                                     01BD   140
                                     01BD   141 ;	This is a termination handler which is designed to restore the terminal
                                     01BD   142 ;	to the proper configuration.
                                     01BD   143
                                     01BD   144 	$CANCEL_S	CHAN=MBX_CHAN		; Kill mailbox
                                     01CB   145 	$DASSGN_S	CHAN=MBX_CHAN
                                     01D9   146 	$QIOW_S		CHAN=TT_CHAN,FUNC=#IO$_SENSEMODE,-
                                     01D9   147 			P1=TT_CHAR,P2=#12	; Reset terminal
                         35 50   E9  01FC   148 	BLBC		R0,10$
              000000FC'EF   10   CA  01FF   149 	BICL2		#TT2$M_BRDCSTMBX,<TT_CHAR+8>
     000000F8'EF   00020000 8F   CA  0206   150 	BICL2		#TT$M_NOBRDCST,<TT_CHAR+4>
                                     0211   151 	$QIOW_S		CHAN=TT_CHAN,FUNC=#IO$_SETMODE,-
                                     0211   152 			P1=TT_CHAR,P2=#12
                                     0234   153 10$:	$DASSGN_S	CHAN=TT_CHAN		; Get rid of channel
                                 04  0242   154 	RET
                                     0243   155
                                     0243   156 	.SUBTITLE	TTSPAWN - SPAWNS A SUB-PROCESS
                                     0243   157 ;
                                     0243   158 ;	TTSPAWN
                                     0243   159 ;
                                     0243   160 ;DM
                                     0243   161 ;DM   TTSPAWN spawns a sub-process.
                                     0243   162 ;M
                                     0243   163 ;M         TTSPAWN takes no arguments and causes a sub-process running
                                     0243   164 ;M    DCL to be spawned from the current process and given control.
                                     0243   165 ;M    A direct call to LIB$SPAWN is not possible because of the structure
                                     0243   166 ;M    which has been set up to handle broadcast messages.
                                     0243   167
                               0000  0243   168 	.ENTRY		TTSPAWN,^M<>
                                     0245   169
                                     0245   170 ;	This routine spawns a sub-process.
                                     0245   171
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  38
                                TTSPAWN - SPAWNS A SUB-PROCESS           27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
                                     0245   172 	$CANCEL_S	CHAN=MBX_CHAN		; Get rid of mailbox
                                     0253   173 	$DASSGN_S	CHAN=TT_CHAN
              00000000'GF   6C   FA  0261   174 	CALLG		(AP),G^LIB$SPAWN	; Spawn away
                         47 50   E9  0268   175 	BLBC		R0,10$
                            50   DD  026B   176 	PUSHL		R0			; Bring back MBX
                                     026D   177 	$ASSIGN_S	CHAN=TT_CHAN,DEVNAM=DEV,MBXNAM=MBX_NAME
                                     0288   178 	$QIOW_S		CHAN=MBX_CHAN,FUNC=#IO$_SETMODE!IO$M_WRTATTN,-
                                     0288   179 			P1=TTBRDAST,P2=USER_ROUTINE	; Enable AST
                            50 8ED0  02AF   180 	POPL		R0
                                 04  02B2   181 10$:	RET
                                     02B3   182 	
                                     02B3   183 	.END
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  39
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
$$T1                           = 00000001                 IO$M_MORE                      = 00000040
BIT...                         = 00000103                 IO$M_MOUNT                     = 00000200
DEV                              00000000 R     03        IO$M_MOVETRACKD                = 00000080
END_BLOCK                        00000018 R     03        IO$M_MULTIPLE                  = 00000100
GETJPI_LIST                      00000028 R     03        IO$M_NOCTSWAIT                 = 00000040
IO$K_LOOPTEST                  = 0000E000                 IO$M_NODSRWAIT                 = 00000100
IO$K_PTPBSC                    = 00002000                 IO$M_NOECHO                    = 00000040
IO$K_SRRUNOUT                  = 00000000                 IO$M_NOFILTR                   = 00000200
IO$M_ABORT                     = 00000100                 IO$M_NOFORMAT                  = 00000100
IO$M_ACCEPT                    = 00000080                 IO$M_NOMRSP                    = 00000040
IO$M_ACCESS                    = 00000040                 IO$M_NOW                       = 00000040
IO$M_ATTNAST                   = 00000100                 IO$M_NOWAIT                    = 00000080
IO$M_BINARY                    = 00000040                 IO$M_OPPOSITE                  = 00000200
IO$M_CANCTRLO                  = 00000040                 IO$M_OUTBAND                   = 00000400
IO$M_CECYL                     = 00000400                 IO$M_PACKED                    = 00000080
IO$M_CLEAR                     = 00001000                 IO$M_PURGE                     = 00000800
IO$M_CLR_COUNT                 = 00000400                 IO$M_QUALIFIED                 = 00000080
IO$M_CNTRLENTRY                = 00000080                 IO$M_RD_COUNT                  = 00000100
IO$M_COMMOD                    = 00000040                 IO$M_RD_MEM                    = 00000040
IO$M_CREATE                    = 00000080                 IO$M_RD_MODEM                  = 00000080
IO$M_CTRL                      = 00000200                 IO$M_READATTN                  = 00000080
IO$M_CTRLCAST                  = 00000100                 IO$M_READCSR                   = 00008000
IO$M_CTRLYAST                  = 00000080                 IO$M_REDIRECT                  = 00000040
IO$M_CVTLOW                    = 00000100                 IO$M_REFRESH                   = 00002000
IO$M_CYCLE                     = 00001000                 IO$M_RESET                     = 00000800
IO$M_DATACHECK                 = 00004000                 IO$M_REVERSE                   = 00000040
IO$M_DATAPATH                  = 00000400                 IO$M_SETBSIZE                  = 00000200
IO$M_DELDATA                   = 00000040                 IO$M_SETCUADR                  = 00000100
IO$M_DELETE                    = 00000100                 IO$M_SETENQCNT                 = 00000800
IO$M_DIAGNOSTIC                = 00000100                 IO$M_SETEVF                    = 00000040
IO$M_DMOUNT                    = 00000400                 IO$M_SETFNCT                   = 00000200
IO$M_DSABLMBX                  = 00000400                 IO$M_SETPOOLSZ                 = 00000400
IO$M_DSABL_ALT                 = 00001000                 IO$M_SETPROT                   = 00000200
IO$M_ENABLMBX                  = 00000080                 IO$M_SET_MODEM                 = 00000400
IO$M_ENABL_ALT                 = 00000800                 IO$M_SHUTDOWN                  = 00000080
IO$M_ESCAPE                    = 00004000                 IO$M_SKPSECINH                 = 00000200
IO$M_EXTEND                    = 00008000                 IO$M_SLAVLOOP                  = 00000080
IO$M_FCODE                     = 0000003F                 IO$M_STARTUP                   = 00000040
IO$M_FORCE                     = 00000040                 IO$M_SWAP                      = 00000400
IO$M_HANGUP                    = 00000200                 IO$M_SYNCH                     = 00000200
IO$M_INCLUDE                   = 00000800                 IO$M_TIMED                     = 00000080
IO$M_INHERLOG                  = 00000800                 IO$M_TRMNOECHO                 = 00001000
IO$M_INHEXTGAP                 = 00001000                 IO$M_TYPEAHDCNT                = 00000040
IO$M_INHRETRY                  = 00008000                 IO$M_UNLOOP                    = 00000100
IO$M_INHSEEK                   = 00001000                 IO$M_WORD                      = 00000040
IO$M_INTCLOCK                  = 00001000                 IO$M_WRTATTN                   = 00000100
IO$M_INTERRUPT                 = 00000040                 IO$S_FCODE                     = 00000006
IO$M_INTSKIP                   = 00000100                 IO$V_ABORT                     = 00000008
IO$M_LASTBLOCK                 = 00000400                 IO$V_ACCEPT                    = 00000007
IO$M_LINE_OFF                  = 00000200                 IO$V_ACCESS                    = 00000006
IO$M_LINE_ON                   = 00000800                 IO$V_ATTNAST                   = 00000008
IO$M_LOOP                      = 00000080                 IO$V_BINARY                    = 00000006
IO$M_LOOP_EXT                  = 00001000                 IO$V_CANCTRLO                  = 00000006
IO$M_LPBEXT                    = 00002000                 IO$V_CECYL                     = 0000000A
IO$M_LPBINT                    = 00004000                 IO$V_CLEAR                     = 0000000C
IO$M_MAINT                     = 00000040                 IO$V_CLR_COUNT                 = 0000000A
IO$M_MAINTLOOP                 = 00000200                 IO$V_CNTRLENTRY                = 00000007
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  40
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
IO$V_COMMOD                    = 00000006                 IO$V_RD_MEM                    = 00000006
IO$V_CREATE                    = 00000007                 IO$V_RD_MODEM                  = 00000007
IO$V_CTRL                      = 00000009                 IO$V_READATTN                  = 00000007
IO$V_CTRLCAST                  = 00000008                 IO$V_READCSR                   = 0000000F
IO$V_CTRLYAST                  = 00000007                 IO$V_REDIRECT                  = 00000006
IO$V_CVTLOW                    = 00000008                 IO$V_REFRESH                   = 0000000D
IO$V_CYCLE                     = 0000000C                 IO$V_RESET                     = 0000000B
IO$V_DATACHECK                 = 0000000E                 IO$V_REVERSE                   = 00000006
IO$V_DATAPATH                  = 0000000A                 IO$V_SETBSIZE                  = 00000009
IO$V_DELDATA                   = 00000006                 IO$V_SETCUADR                  = 00000008
IO$V_DELETE                    = 00000008                 IO$V_SETENQCNT                 = 0000000B
IO$V_DIAGNOSTIC                = 00000008                 IO$V_SETEVF                    = 00000006
IO$V_DMOUNT                    = 0000000A                 IO$V_SETFNCT                   = 00000009
IO$V_DSABLMBX                  = 0000000A                 IO$V_SETPOOLSZ                 = 0000000A
IO$V_DSABL_ALT                 = 0000000C                 IO$V_SETPROT                   = 00000009
IO$V_ENABLMBX                  = 00000007                 IO$V_SET_MODEM                 = 0000000A
IO$V_ENABL_ALT                 = 0000000B                 IO$V_SHUTDOWN                  = 00000007
IO$V_ESCAPE                    = 0000000E                 IO$V_SKPSECINH                 = 00000009
IO$V_EXTEND                    = 0000000F                 IO$V_SLAVLOOP                  = 00000007
IO$V_FCODE                     = 00000000                 IO$V_STARTUP                   = 00000006
IO$V_FORCE                     = 00000006                 IO$V_SWAP                      = 0000000A
IO$V_HANGUP                    = 00000009                 IO$V_SYNCH                     = 00000009
IO$V_INCLUDE                   = 0000000B                 IO$V_TIMED                     = 00000007
IO$V_INHERLOG                  = 0000000B                 IO$V_TRMNOECHO                 = 0000000C
IO$V_INHEXTGAP                 = 0000000C                 IO$V_TYPEAHDCNT                = 00000006
IO$V_INHRETRY                  = 0000000F                 IO$V_UNLOOP                    = 00000008
IO$V_INHSEEK                   = 0000000C                 IO$V_WORD                      = 00000006
IO$V_INTCLOCK                  = 0000000C                 IO$V_WRTATTN                   = 00000008
IO$V_INTERRUPT                 = 00000006                 IO$_ACCESS                     = 00000032
IO$V_INTSKIP                   = 00000008                 IO$_ACPCONTROL                 = 00000038
IO$V_LASTBLOCK                 = 0000000A                 IO$_AVAILABLE                  = 00000011
IO$V_LINE_OFF                  = 00000009                 IO$_CLEAN                      = 0000001E
IO$V_LINE_ON                   = 0000000B                 IO$_CONINTREAD                 = 0000003C
IO$V_LOOP                      = 00000007                 IO$_CONINTWRITE                = 0000003D
IO$V_LOOP_EXT                  = 0000000C                 IO$_CREATE                     = 00000033
IO$V_LPBEXT                    = 0000000D                 IO$_DEACCESS                   = 00000034
IO$V_LPBINT                    = 0000000E                 IO$_DELETE                     = 00000035
IO$V_MAINT                     = 00000006                 IO$_DIAGNOSE                   = 0000001D
IO$V_MAINTLOOP                 = 00000009                 IO$_DRVCLR                     = 00000004
IO$V_MORE                      = 00000006                 IO$_DSE                        = 00000015
IO$V_MOUNT                     = 00000009                 IO$_ENDRU1                     = 0000003A
IO$V_MOVETRACKD                = 00000007                 IO$_ENDRU2                     = 0000003B
IO$V_MULTIPLE                  = 00000008                 IO$_ERASETAPE                  = 00000006
IO$V_NOCTSWAIT                 = 00000006                 IO$_FORCE                      = 00000037
IO$V_NODSRWAIT                 = 00000008                 IO$_FORMAT                     = 0000001E
IO$V_NOECHO                    = 00000006                 IO$_INITIALIZE                 = 00000004
IO$V_NOFILTR                   = 00000009                 IO$_LOADMCODE                  = 00000001
IO$V_NOFORMAT                  = 00000008                 IO$_LOGICAL                    = 0000002F
IO$V_NOMRSP                    = 00000006                 IO$_MODIFY                     = 00000036
IO$V_NOW                       = 00000006                 IO$_MOUNT                      = 00000039
IO$V_NOWAIT                    = 00000007                 IO$_NETCONTROL                 = 00000036
IO$V_OPPOSITE                  = 00000009                 IO$_NOP                        = 00000000
IO$V_OUTBAND                   = 0000000A                 IO$_OFFSET                     = 00000006
IO$V_PACKED                    = 00000007                 IO$_PACKACK                    = 00000008
IO$V_PURGE                     = 0000000B                 IO$_PHYSICAL                   = 0000001F
IO$V_QUALIFIED                 = 00000007                 IO$_QSTOP                      = 00000007
IO$V_RD_COUNT                  = 00000008                 IO$_RDSTATS                    = 0000000D
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  41
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
IO$_READHEAD                   = 0000000E                 JPI$_ASTLM                     = 00000409
IO$_READINIT                   = 0000003C                 JPI$_AUTHPRI                   = 00000418
IO$_READLBLK                   = 00000021                 JPI$_AUTHPRIV                  = 00000412
IO$_READPBLK                   = 0000000C                 JPI$_BIOCNT                    = 0000030F
IO$_READPRESET                 = 00000019                 JPI$_BIOLM                     = 00000310
IO$_READPROMPT                 = 00000037                 JPI$_BUFIO                     = 0000040C
IO$_READTRACKD                 = 00000010                 JPI$_BYTCNT                    = 00000311
IO$_READVBLK                   = 00000031                 JPI$_BYTLM                     = 0000031A
IO$_RECAL                      = 00000003                 JPI$_CPULIM                    = 0000040D
IO$_RELEASE                    = 00000005                 JPI$_CPUTIM                    = 00000407
IO$_REREADN                    = 00000016                 JPI$_CURPRIV                   = 00000400
IO$_REREADP                    = 00000017                 JPI$_DFPFC                     = 00000406
IO$_RETCENTER                  = 00000007                 JPI$_DFWSCNT                   = 00000403
IO$_REWIND                     = 00000024                 JPI$_DIOCNT                    = 00000312
IO$_REWINDOFF                  = 00000022                 JPI$_DIOLM                     = 00000313
IO$_SEARCH                     = 00000009                 JPI$_DIRIO                     = 0000040B
IO$_SEEK                       = 00000002                 JPI$_EFCS                      = 00000317
IO$_SENSECHAR                  = 0000001B                 JPI$_EFCU                      = 00000318
IO$_SENSEMODE                  = 00000027                 JPI$_EFWM                      = 00000316
IO$_SETCHAR                    = 0000001A                 JPI$_ENQCNT                    = 0000031F
IO$_SETCLOCK                   = 00000037                 JPI$_ENQLM                     = 00000320
IO$_SETCLOCKP                  = 00000005                 JPI$_EXCVEC                    = 00000100
IO$_SETMODE                    = 00000023                 JPI$_FILCNT                    = 00000314
IO$_SKIPFILE                   = 00000025                 JPI$_FILLM                     = 0000040F
IO$_SKIPRECORD                 = 00000026                 JPI$_FINALEXC                  = 00000101
IO$_SPACEFILE                  = 00000002                 JPI$_FREP0VA                   = 00000404
IO$_SPACERECORD                = 00000009                 JPI$_FREP1VA                   = 00000405
IO$_STARTDATA                  = 00000038                 JPI$_FREPTECNT                 = 00000415
IO$_STARTDATAP                 = 00000006                 JPI$_GPGCNT                    = 0000030C
IO$_STARTMPROC                 = 00000002                 JPI$_GRP                       = 00000308
IO$_STARTSPNDL                 = 00000019                 JPI$_IMAGECOUNT                = 0000041A
IO$_STOP                       = 00000003                 JPI$_IMAGNAME                  = 00000207
IO$_TTYREADALL                 = 0000003A                 JPI$_IMAGPRIV                  = 00000413
IO$_TTYREADPALL                = 0000003B                 JPI$_JOBPRCCNT                 = 0000031E
IO$_UNLOAD                     = 00000001                 JPI$_LASTADR                   = 00000102
IO$_VIRTUAL                    = 0000003F                 JPI$_LASTCTL                   = 00000209
IO$_WRITECHECK                 = 0000000A                 JPI$_LASTPCB                   = 00000322
IO$_WRITECHECKH                = 00000018                 JPI$_LASTPHD                   = 0000041B
IO$_WRITEHEAD                  = 0000000D                 JPI$_LOGINTIM                  = 00000206
IO$_WRITELBLK                  = 00000020                 JPI$_MEM                       = 00000307
IO$_WRITEMARK                  = 0000001C                 JPI$_OWNER                     = 00000303
IO$_WRITEOF                    = 00000028                 JPI$_PAGEFLTS                  = 0000040A
IO$_WRITEPBLK                  = 0000000B                 JPI$_PAGFILCNT                 = 00000414
IO$_WRITERET                   = 00000018                 JPI$_PAGFILLOC                 = 00000419
IO$_WRITETRACKD                = 0000000F                 JPI$_PGFLQUOTA                 = 0000040E
IO$_WRITEVBLK                  = 00000030                 JPI$_PID                       = 00000319
IO$_WRTTMKR                    = 0000001D                 JPI$_PPGCNT                    = 0000030D
JPI$C_ADRTYPE                  = 00000001                 JPI$_PRCCNT                    = 0000031B
JPI$C_CTLTYPE                  = 00000002                 JPI$_PRCLM                     = 00000408
JPI$C_LISTEND                  = 00000000                 JPI$_PRCNAM                    = 0000031C
JPI$C_PCBTYPE                  = 00000003                 JPI$_PRI                       = 00000302
JPI$C_PHDTYPE                  = 00000004                 JPI$_PRIB                      = 00000309
JPI$_ACCOUNT                   = 00000203                 JPI$_PROCPRIV                  = 00000204
JPI$_APTCNT                    = 0000030A                 JPI$_SITESPEC                  = 00000208
JPI$_ASTACT                    = 00000300                 JPI$_STATE                     = 00000306
JPI$_ASTCNT                    = 0000030E                 JPI$_STS                       = 00000305
JPI$_ASTEN                     = 00000301                 JPI$_SWPFILLOC                 = 00000321
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  42
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
JPI$_TERMINAL                  = 0000031D                 MSG$_RESET                     = 00000041
JPI$_TMBU                      = 0000030B                 MSG$_RESOPR                    = 00000013
JPI$_TQCNT                     = 00000315                 MSG$_SCANBAD                   = 00000028
JPI$_TQLM                      = 00000410                 MSG$_SCANRSP                   = 00000029
JPI$_UIC                       = 00000304                 MSG$_SMBDON                    = 00000009
JPI$_USERNAME                  = 00000202                 MSG$_SMBINI                    = 00000008
JPI$_VIRTPEAK                  = 00000200                 MSG$_SMBRSP                    = 00000020
JPI$_VOLUMES                   = 00000205                 MSG$_SNDACC                    = 0000000A
JPI$_WSAUTH                    = 00000401                 MSG$_SNDSMB                    = 00000004
JPI$_WSAUTHEXT                 = 00000417                 MSG$_SUSOPR                    = 00000012
JPI$_WSEXTENT                  = 00000416                 MSG$_SYSFUNC                   = 0000000E
JPI$_WSPEAK                    = 00000201                 MSG$_THIRDPARTY                = 00000039
JPI$_WSQUOTA                   = 00000402                 MSG$_TIMEOUT                   = 0000003A
JPI$_WSSIZE                    = 00000411                 MSG$_TRMBRDCST                 = 00000053
LIB$SPAWN                        ********   X   04        MSG$_TRMHANGUP                 = 00000006
MBX_BUFFER                       00000038 R     03        MSG$_TRMUNSOLIC                = 00000001
MBX_CHAN                         000000B8 R     03        MSG$_UDA50MVER                 = 00000057
MBX_IOSB                         000000BC R     03        MSG$_WRONGVOL                  = 00000051
MBX_NAME                         000000C4 R     03        MSG$_XM_ATTN                   = 0000000D
MSG$_ABOOPR                    = 00000011                 MSG$_XM_DATAVL                 = 0000000B
MSG$_ABORT                     = 00000030                 MSG$_XM_SHUTDN                 = 0000000C
MSG$_ACCRSP                    = 00000021                 MSG_DSC                          000000DA R     03
MSG$_CONFIRM                   = 00000031                 OTS$CVT_L_TZ                     ********   X   04
MSG$_CONNECT                   = 00000032                 PID                              000000E2 R     03
MSG$_CRUNSOLIC                 = 00000002                 SS$_ABORT                        ********   X   04
MSG$_DELIMAG                   = 0000000C                 SS$_CANCEL                       ********   X   04
MSG$_DELPROC                   = 00000003                 SYS$ASSIGN                       ********  GX   04
MSG$_DELSMB                    = 00000014                 SYS$CANCEL                       ********  GX   04
MSG$_DEVOFFLIN                 = 00000005                 SYS$CREMBX                       ********  GX   04
MSG$_DEVOFFLINX                = 00000050                 SYS$DASSGN                       ********  GX   04
MSG$_DEVONLIN                  = 00000007                 SYS$DCLEXH                       ********  GX   04
MSG$_DEVWRTLCK                 = 00000052                 SYS$GETJPI                       ********  GX   04
MSG$_DISCON                    = 00000033                 SYS$QIO                          ********  GX   04
MSG$_DISMOUNTED                = 00000056                 SYS$QIOW                         ********  GX   04
MSG$_DUPUNITNO                 = 00000058                 SYS$TRNLOG                       ********  GX   04
MSG$_EVTAVL                    = 0000003E                 TT                               000000E6 R     03
MSG$_EVTRCVCHG                 = 0000003F                 TT$C_BAUD_110                  = 00000003
MSG$_EVTXMTCHG                 = 00000044                 TT$C_BAUD_1200                 = 00000008
MSG$_EXIT                      = 00000034                 TT$C_BAUD_134                  = 00000004
MSG$_INCDAT                    = 00000040                 TT$C_BAUD_150                  = 00000005
MSG$_INIOPR                    = 00000010                 TT$C_BAUD_1800                 = 00000009
MSG$_INTMSG                    = 00000035                 TT$C_BAUD_19200                = 00000010
MSG$_LINDWN                    = 00000043                 TT$C_BAUD_2000                 = 0000000A
MSG$_LINUP                     = 00000042                 TT$C_BAUD_2400                 = 0000000B
MSG$_MVABORTED                 = 00000055                 TT$C_BAUD_300                  = 00000006
MSG$_MVCOMPLETE                = 00000054                 TT$C_BAUD_3600                 = 0000000C
MSG$_NETSHUT                   = 0000003B                 TT$C_BAUD_4800                 = 0000000D
MSG$_NODEACC                   = 0000003C                 TT$C_BAUD_50                   = 00000001
MSG$_NODEINACC                 = 0000003D                 TT$C_BAUD_600                  = 00000007
MSG$_OPREPLY                   = 00000009                 TT$C_BAUD_7200                 = 0000000E
MSG$_OPRQST                    = 00000008                 TT$C_BAUD_75                   = 00000002
MSG$_PATHLOST                  = 00000036                 TT$C_BAUD_9600                 = 0000000F
MSG$_PROTOCOL                  = 00000037                 TT$M_ALTRPAR                   = 00000020
MSG$_PURIMAG                   = 0000000D                 TT$M_CRFILL                    = 00000400
MSG$_PURPROC                   = 0000000B                 TT$M_DS_CARRIER                = 00000020
MSG$_REJECT                    = 00000038                 TT$M_DS_CTS                    = 00000010
MSG$_REQUE                     = 00000015                 TT$M_DS_DSR                    = 00000080
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  43
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
TT$M_DS_DTR                    = 00000002                 TT$V_PAGE                      = 00000018
TT$M_DS_RING                   = 00000040                 TT$V_PARITY                    = 00000006
TT$M_DS_RTS                    = 00000010                 TT$V_PASSALL                   = 00000000
TT$M_DS_SECREC                 = 00000008                 TT$V_READSYNC                  = 00000012
TT$M_DS_SECTX                  = 00000008                 TT$V_REMOTE                    = 0000000D
TT$M_EIGHTBIT                  = 00008000                 TT$V_SCOPE                     = 0000000C
TT$M_ESCAPE                    = 00000008                 TT$V_SCRIPT                    = 00000006
TT$M_HALFDUP                   = 00100000                 TT$V_TTSYNC                    = 00000005
TT$M_HOLDSCREEN                = 00004000                 TT$V_WRAP                      = 00000009
TT$M_HOSTSYNC                  = 00000010                 TT$_FT1                        = 00000010
TT$M_LFFILL                    = 00000800                 TT$_FT2                        = 00000011
TT$M_LOWER                     = 00000080                 TT$_FT3                        = 00000012
TT$M_MBXDSABL                  = 00010000                 TT$_FT4                        = 00000013
TT$M_MECHFORM                  = 00080000                 TT$_FT5                        = 00000014
TT$M_MECHTAB                   = 00000100                 TT$_FT6                        = 00000015
TT$M_MODEM                     = 00200000                 TT$_FT7                        = 00000016
TT$M_NOBRDCST                  = 00020000                 TT$_FT8                        = 00000017
TT$M_NOECHO                    = 00000002                 TT$_LA100                      = 00000025
TT$M_NOTYPEAHD                 = 00000004                 TT$_LA12                       = 00000024
TT$M_ODD                       = 00000080                 TT$_LA120                      = 00000021
TT$M_OPER                      = 00400000                 TT$_LA24                       = 00000025
TT$M_PAGE                      = FF000000                 TT$_LA34                       = 00000022
TT$M_PARITY                    = 00000040                 TT$_LA36                       = 00000020
TT$M_PASSALL                   = 00000001                 TT$_LA38                       = 00000023
TT$M_READSYNC                  = 00040000                 TT$_LAX                        = 00000020
TT$M_REMOTE                    = 00002000                 TT$_LQP02                      = 00000026
TT$M_SCOPE                     = 00001000                 TT$_UNKNOWN                    = 00000000
TT$M_SCRIPT                    = 00000040                 TT$_VK100                      = 00000002
TT$M_TTSYNC                    = 00000020                 TT$_VT05                       = 00000001
TT$M_WRAP                      = 00000200                 TT$_VT100                      = 00000060
TT$S_PAGE                      = 00000008                 TT$_VT101                      = 00000061
TT$V_ALTRPAR                   = 00000005                 TT$_VT102                      = 00000062
TT$V_CRFILL                    = 0000000A                 TT$_VT105                      = 00000063
TT$V_DS_CARRIER                = 00000005                 TT$_VT125                      = 00000064
TT$V_DS_CTS                    = 00000004                 TT$_VT131                      = 00000065
TT$V_DS_DSR                    = 00000007                 TT$_VT132                      = 00000066
TT$V_DS_DTR                    = 00000001                 TT$_VT173                      = 00000003
TT$V_DS_RING                   = 00000006                 TT$_VT52                       = 00000040
TT$V_DS_RTS                    = 00000004                 TT$_VT55                       = 00000041
TT$V_DS_SECREC                 = 00000003                 TT$_VT5X                       = 00000040
TT$V_DS_SECTX                  = 00000003                 TT2$M_ALTYPEAHD                = 00000080
TT$V_EIGHTBIT                  = 0000000F                 TT2$M_ANSICRT                  = 01000000
TT$V_ESCAPE                    = 00000003                 TT2$M_AUTOBAUD                 = 00000002
TT$V_HALFDUP                   = 00000014                 TT2$M_AVO                      = 08000000
TT$V_HOLDSCREEN                = 0000000E                 TT2$M_BLOCK                    = 04000000
TT$V_HOSTSYNC                  = 00000004                 TT2$M_BRDCSTMBX                = 00000010
TT$V_LFFILL                    = 0000000B                 TT2$M_DCL_CTRLC                = 00000400
TT$V_LOWER                     = 00000007                 TT2$M_DCL_MAILBX               = 00000200
TT$V_MBXDSABL                  = 00000010                 TT2$M_DCL_OUTBND               = 00000800
TT$V_MECHFORM                  = 00000013                 TT2$M_DECCRT                   = 20000000
TT$V_MECHTAB                   = 00000008                 TT2$M_DMA                      = 00000040
TT$V_MODEM                     = 00000015                 TT2$M_EDIT                     = 10000000
TT$V_NOBRDCST                  = 00000011                 TT2$M_HANGUP                   = 00000004
TT$V_NOECHO                    = 00000001                 TT2$M_LOCALECHO                = 00000001
TT$V_NOTYPEAHD                 = 00000002                 TT2$M_MODHANGUP                = 00000008
TT$V_ODD                       = 00000007                 TT2$M_REGIS                    = 02000000
TT$V_OPER                      = 00000016                 TT2$M_SETSPEED                 = 00000100
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  44
Symbol table                                                             27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
TT2$M_XON                      = 00000020
TT2$V_ALTYPEAHD                = 00000007
TT2$V_ANSICRT                  = 00000018
TT2$V_AUTOBAUD                 = 00000001
TT2$V_AVO                      = 0000001B
TT2$V_BLOCK                    = 0000001A
TT2$V_BRDCSTMBX                = 00000004
TT2$V_DCL_CTRLC                = 0000000A
TT2$V_DCL_MAILBX               = 00000009
TT2$V_DCL_OUTBND               = 0000000B
TT2$V_DECCRT                   = 0000001D
TT2$V_DMA                      = 00000006
TT2$V_EDIT                     = 0000001C
TT2$V_HANGUP                   = 00000002
TT2$V_LOCALECHO                = 00000000
TT2$V_MODHANGUP                = 00000003
TT2$V_REGIS                    = 00000019
TT2$V_SETSPEED                 = 00000008
TT2$V_XON                      = 00000005
TTBRDAST                         00000144 RG    04
TTBRDEND                         000001BB RG    04
TTBRDINI                         00000000 RG    04
TTSPAWN                          00000243 RG    04
TT_CHAN                          000000F0 R     03
TT_CHAR                          000000F4 R     03
USER_ROUTINE                     00000100 R     03

                                                +----------------+
                                                ! Psect synopsi
PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          -
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE
. BLANK .                       00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
$ABS$                           00000000  (    0.)  02 (  2.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE
TT_BRD_DATA                     00000104  (  260.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG
TT_BRD_CODE                     000002B3  (  691.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE

                                             +------------------------+
                                             ! Performance
Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------
Initialization                   29     00:00:00.05    00:00:00.47
Command processing               22     00:00:00.17    00:00:02.60
Pass 1                          292     00:00:09.43    00:04:21.08
Symbol table sort                 0     00:00:01.00    00:00:12.15
Pass 2                          157     00:00:01.80    00:00:27.63
Symbol table output              82     00:00:00.49    00:00:06.66
Psect synopsis output             7     00:00:00.03    00:00:00.17
Cross-reference output            0     00:00:00.00    00:00:00.00
Assembler run totals            592     00:00:12.98    00:05:11.00
                                                                                                                                     
The working set limit was 495 pages.
43813 bytes (86 pages) of virtual memory were used to buffer the intermediate code.
TTBRDINI                        - Routines to handle terminal broadcasts 29-SEP-1983 15:56:49  VAX-11 Macro V03-00         Page  45
VAX-11 Macro Run Statistics                                              27-SEP-1983 08:05:17  JPLSCR:[JLV.LOOK]TTBRDINI.MAR;16  (1)
                                                                                                                                     
There were 40 pages of symbol table space allocated to hold 596 non-local and 7 local symbols.
183 source lines were read in Pass 1, producing 0 object records in Pass 2.
27 pages of virtual memory were used to define 26 macros.

                                            +--------------------------+
                                            ! Macro libra
Macro library name                           Macros defined      
------------------                           --------------
SYS$SYSROOT:[SYSLIB]STARLET.MLB;1                      22
                                                                                                                                     
855 GETS were required to define 22 macros.
                                                                                                                                     
There were no errors, warnings or information messages.
                                                                                                                                     
/NOOBJECT/LIST TTBRDINI.MAR
