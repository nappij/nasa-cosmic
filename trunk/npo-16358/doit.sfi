      SUBROUTINE DOIT(COMAND,NUMFLG,TANUMB,MINFLG)
CDM   This subroutine executes the commands passed by the main program or
CDM   rings the terminal bell and turns LED 3 on (error signal) if the
CDM   command is invalid.
CDM
CDM   Programmer - Jon Vavrus  13 NOV 1980
CDM   Revised    - Jon Vavrus  30 MAR 1981
CDM   Revised    - Jon Vavrus  12 MAY 1981
CDM   Revised    - Jon Vavrus  21 JUL 1981
CDM   Revised    - Jon Vavrus  31 JUL 1981 (change CCLINE usage)
CDM   Revised    - Jon Vavrus  27 AUG 1981
CDM   Revised    - Jon Vavrus  10 SEP 1981
CDM   Revised    - Jon Vavrus  23 SEP 1981
CDM   Revised    - Jon Vavrus   6 NOV 1981
CDM   Revised    - Jon Vavrus  30 DEC 1981 (make LED's work right)
CDM   Revised    - Jon Vavrus   4 MAY 1982 (non-advanced video VT100's)
CDM   Revised    - Jon Vavrus  18 AUG 1982 (bigger arrays)
CDM   Revised    - Jon Vavrus   9 SEP 1982
CDM   Revised    - Jon Vavrus  30 NOV 1982
CDM   Revised    - Jon Vavrus  12 JAN 1983
CDM   Revised    - Jon Vavrus   4 APR 1983 (Take care of "Quitting")
CM
CM         The routine is called with the numeric code for the command
CM    (COMAND) which if negative, means that it is not to be "saved" for
CM    possible command #13 execution; a flag set .TRUE. if there is an
CM    associated number (NUMFLG); a number (TANUMB); and a flag set
CM    .TRUE. if there is an associated minus sign.
CM
CM         For VT100's the given command is executed after which LED 1 is 
CM    turned off (indicating operation finished), LED 3 is turned off
CM    if successful and on if not (error indication), LED 2 is turned
CM    on if the reverse option is currently set or off if not (reverse
CM    indicator), and LED 4 is turned on if the search buffer now contains
CM    something (buffer indicator).
CM
CM         The valid commands types are:
CM              1 - jump TANUMB lines (positive or negative)
CM              2 - jump by TANUMB blocks (positive or negative)
CM              3 - search (forward) for string(s) in SRCHBF array and
CM                  display from that line if found, if not found the
CM                  terminal bell is rung and LED 3 is turned on.  Matches
CM                  are found regardless of lower/uppercase differences.
CM                  Search backward if MINFLG = .TRUE..  Repeat TANUMB
CM                  times if NUMFLG = .TRUE..
CM              4 - set reverse switch, all commands will now work in re-
CM                  verse (i.e. n$ will jump -n lines, etc.).  Repeat
CM                  TANUMB times if NUMFLG = .TRUE..
CM              5 - scroll (backwards if MINFLG = .TRUE.)
CM              6 - stop scrolling or cancel current line jump, search,
CM                  or & command.
CM              7 - set scrolling speed to TANUMB lines per second (positive
CM                  or negative) (originally set to 2).
CM                  NOTE:  there is a maximum speed that will not be ex-
CM                  ceeded (varies with situation) even if scrolling
CM                  speed is set at a high value.
CM              8 - mark the TANUMB line form the top of the screen as one
CM                  of the boundaries of the print range.  The last two so
CM                  marked lines define the print range.
CM              9 - output TANUMB lines to the file LOOKPRINT.LIS in the
CM                  default directory (file format will be the same as the
CM                  original file, with sequential organization).  Creates
CM                  a new file.  If no number is specified (or is zero)
CM                  and there is a valid print range marked, then that
CM                  range will be output, if no valid print range then
CM                  23 lines are output.
CM             10 - same as 9 except the lines are output to SYS$PRINT.
CM                  If MINFLG = .TRUE. then output goes to LOOKPRINT.LIS
CM                  file (new file if no previous command created one
CM                  during this job, otherwise appended to the end of the
CM                  existing file).
CM             11 - exit the program.
CM             12 - re-write the screen
CM             13 - re-execute the last command that was passed to DOIT
CM                  with a positive value (except for 13)
C
C***   CALLED ROUTINES
C
CC    BLKCLS  Closes the input file.
CC    BLKIN   Reads in one block of data.
CC    BLKSIN  Reads in 7 blocks of data.
CC    CONVUP  Converts a string to upper-case.
CC    INTASC  Converts a given character variable to upper-case.
CC    LINCON  Converts data to output lines in the output arrays.
CC    PRTCLS  Closes the printer output file used in & commands.
CC    PRTOPN  Opens the printer output file.
CC    PRTOUT  Outputs a record to the printer output file.
CC    REDOIT  Calls DOIT, allows for recursion.
CC    STOPSC  AST routine to handle "stop" command.
CC    WORKNG  Writes flashing "WORKING" message.
C
C***   COMMON AREAS
C
CS    CHARS   Used to pass character variables; contains LINES a character
CS            array of the output lines, and SRCHBF the search buffer, and
CS            CRLF which contains <CR><LF>, and REVVID + REGVID which are
CS            the VT100 control sequences to set/unset reverse video.
C
CS    DOITNM  Contains information transferred from the main program:
CS                 INCHAN - input channel of the terminal
CS                 TIME   - scrolling speed in -10000000*seconds/line
CS                 SBFFLG - flag indicating whether there is a string
CS                          in the search buffer
CS                 DIRECT - flag for reverse (-1 for reverse, else 1)
CS                 EBK    - EBK of input file
CS                 SBFLEN - length(s) of string(s) in search buffer(s)
CS                 RECBLK - number of bytes used per block in FIX-BLK files
CS                 RANGE  - starting and ending block numbers and pointers
CS                          of print range
CS                 VT100  - flag set .TRUE. if terminal is a VT100
CS                 LRL    - length of longest record in input file
CS                 LENLMT - maximum output length (if <0 then WRAP set)
CS                 PAGEND - line number of last line output to screen.
CS                 PAGLEN - number of lines per page
CS                 COMLIN - line number for command input (bottom of screen)
CS                 VT100A - flag set .TRUE. if VT100 has advanced video option
C
CS    LNCN    Contains output arrays, and file pointers and information:
CS                 LINLEN - array of output line lengths
CS                 LINEP  - top of screen line (or last line output by
CS                          backward scroll)
CS                 NLINES - number of lines in arrays
CS                 BUFFER - array of unconverted data
CS                 PBUF   - current position in BUFFER
CS                 NBUF   - number of bytes in BUFFER
CS                 BLK    - next block in file
CS                 FSZ    - record length for FIX files, or FSZ for VFC files
CS                 IFSZ   - word extended record length for FIX files
CS                 RFM    - files RFM
CS                 RAT    - files RAT (1=CR,2=FTN,3=PRN,4=none,<0=BLK set)
CS                 SBLK   - starting block of current batch of output lines
CS                 CCLINE - array containing pointer to where the line's
CS                          record starts in the file (CCLINE(1,x) = block
CS                          #, CCLINE(2,x) = byte number in block).  If
CS                          CCLINE(1,x) = 0 then it is a carriage control
CS                          line.
CS                 LBLK   - last block processed by LINCON
CS                 LPBUF  - last value of PBUF processed by LINCON
C
CS    STOPCM  Used to pass information back and forth to/from the stop
CS            scrolling AST.  STOPIT is a flag set .TRUE. if scrolling
CS            should be stopped, INBUF is the input character, IOFLAG and
CS            TIMFLG are event flags, and IOSB is the I/O IOSB.
C
C***   INPUT VARIABLES
C
CI    INBUF   One byte buffer used to get stop scrolling command.
C
C***   OUTPUT VARIABLES
C
CO    BUFFER  Buffer holding input data.  During back scrolling output
CO            is done directly from here.
CO    ESC     Used to output an ASCII <ESC>.
CO    LINES   Lines of output converted by LINCON.
C
C***   INPUT UNITS
C
CR    INCHAN  Channel number of the terminal.
C
C***   OUTPUT UNITS
C
CW    9       Output to the terminal (no carriage-control).
CW    20      Output for the List, Print, and Append commands
C
      EXTERNAL STOPSC
      CHARACTER*132 LINES(600),HLIN(600),CAPLIN
      CHARACTER*33 CHAR
      CHARACTER*30 SRCHBF(10)
      CHARACTER*5 TEMPCH
      CHARACTER*4 REVVID,REGVID
      CHARACTER*2 CRLF
      INTEGER*4 TIME,BLK,PBUF,EBK,HNBUF,HPBUF,FSZ,RFM,RAT,TIMFLG,
     1          DELTIM(2),SBLK,PAUSTM(2),PRINT,HBLK,HSBLK,
     2          RANGE(2,2),CCLINE(2,600),HLBLK,HLPBUF,HCCLIN(2,600),
     3          PAGEND,OLDEND,SAVCOM,IDESCR(2),STRPOS(10)
      INTEGER*2 IOSB(4),LINLEN(600),HLINLN(600),HLINES,HLINEP,DIRECT,
     1          SBFLEN(10),RECBLK,LENLMT,PAGLEN,COMAND,COMLIN
      LOGICAL*1 SBFFLG,INBUF,BUFFER(3750),FIRST,NUMFLG,MINFLG,
     1          HBUFER(150),STOPIT,ESC,TEMP(30),CAPBUF(3750),VT100,
     2          BELL,BSP,RFLAG,SECOND,SAVFLG(2),VT100A

      COMMON /DOITNM/INCHAN,TIME,SBFFLG,DIRECT,EBK,SBFLEN,RECBLK,RANGE,
     1               VT100,LRL,LENLMT,PAGEND,PAGLEN,COMLIN,VT100A
      COMMON /LNCN/LINLEN,LINEP,NLINES,BUFFER,PBUF,NBUF,BLK,FSZ,IFSZ,
     1             RFM,RAT,SBLK,CCLINE,LBLK,LPBUF
      COMMON /CHARS/LINES,SRCHBF,CRLF,REVVID,REGVID
      COMMON /STOPCM/STOPIT,INBUF,IOFLAG,IOSB,TIMFLG

      DATA ESC,BELL,BSP/27,7,8/
      DATA DELTIM(2)/-1/
      DATA PAUSTM/-30000000,-1/
      DATA OPNFIL/.FALSE./

      ANUMB = TANUMB
C
C***   Turn LED #1 on
C
      IF (COMAND .NE. 13)
        EXECUTE (WORKING)
      ENDIF
C
C***   Save command
C
      IF (COMAND .LT. 0)
        ICOM = -COMAND
      ELSE
        IF (COMAND .NE. 13)
          SAVFLG(1) = NUMFLG
          SAVFLG(2) = MINFLG
          SAVCOM = COMAND
          SAVNUM = TANUMB
        ENDIF
        ICOM = COMAND
      ENDIF
      DO CASE ICOM
      CASE 1
C
C***   Line jump
C
        NUMBER = ANUMB*DIRECT
        IF (.NOT.NUMFLG)
          EXECUTE (ERROR_EXIT)
        ENDIF
        EXECUTE (HOLD_CURRENT_SETUP)
C
C***   Execute line jumps
C
        EXECUTE (JUMP_LINES)
        EXECUTE (GET_LAST_LINE)
        EXECUTE (CANCEL_STOPPER)
        IF (IABS(NUMBER) .LE. PAGLEN)
          EXECUTE (SCROLL_REFRESH_EXIT)
        ELSE
          EXECUTE (REFRESH_EXIT)
        ENDIF
      CASE 2
C
C***   Block jumps
C
        IF (.NOT.NUMFLG)
          EXECUTE (ERROR_EXIT)
        ENDIF
        EXECUTE (FIND_NON_CC_LINE)
        BLK = CCLINE(1,I) + ANUMB*DIRECT
        IF (BLK .LE. 0) BLK = 1
        IF (BLK .GT. EBK) BLK = EBK
        IBLK = BLK
        EXECUTE (INPUT_SEVEN_BLOCKS)
        CALL LINCON(.TRUE.)
C
C***   If input was at end of file, must find line position
C
        IF (BLK .GT. EBK)
          DO FOR LINEP=1,NLINES
           UNDO IF (CCLINE(1,LINEP) .EQ. IBLK)
          END DO FOR
          IF (NLINES .LT. (LINEP + PAGLEN - 1))
            LINEP = NLINES - PAGLEN + 1
            IF (LINEP .LE. 0) LINEP = 1
          ENDIF
        ENDIF
        EXECUTE (GET_LAST_LINE)
        EXECUTE (REFRESH_EXIT)
      CASE 3
C
C***   Searches
C
        IF (.NOT.SBFFLG)
          EXECUTE (ERROR_EXIT)
        ENDIF
C
C***   Loop ANUMB times
C
        IF (NUMFLG)
          NUMBER = ANUMB
        ELSE
          NUMBER = 1
        ENDIF
        DO FOR III=1,NUMBER
         IF (MINFLG)
           IF (DIRECT .EQ. -1)
             EXECUTE (FORWARD_SEARCH)
           ELSE
             EXECUTE (BACKWARD_SEARCH)
           ENDIF
         ELSE
           IF (DIRECT .EQ. -1)
             EXECUTE (BACKWARD_SEARCH)
           ELSE
             EXECUTE (FORWARD_SEARCH)
           ENDIF
         ENDIF
        END DO FOR
      CASE 4
C
C***   Reversing operation
C
        IF (MINFLG) DIRECT = -DIRECT
        IF (NUMFLG)
          NUMBER = ANUMB
          DIRECT = -1**NUMBER*DIRECT
        ELSE
          DIRECT = -DIRECT
        ENDIF
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      CASE 5
C
C***   Scrolling
C
        CALL WORKNG(.FALSE.)
        IF (NUMFLG) TIME = (-10000000./ANUMB)*DIRECT
        CALL LIB$GET_EF(TIMFLG)
        IF (TIMFLG .EQ. -1)
          CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//
     1            'flags.  SCROLLING ABORTED.',COMLIN,20)
          EXECUTE (ERROR_EXIT)
        ENDIF
        EXECUTE (QUEUE_STOPPER)
        DELTIM(1) = TIME*DIRECT
        IF ((DELTIM(1) .LT. 0 .AND. .NOT.MINFLG) .OR. (DELTIM(1) .GT. 0
     1      .AND. MINFLG))
          EXECUTE (FORWARD_SCROLLING)
        ELSE
          EXECUTE (BACKWARD_SCROLLING)
        ENDIF
      CASE 7
C
C***   Set scrolling speed
C
        IF (.NOT.NUMFLG)
          EXECUTE (ERROR_EXIT)
        ENDIF
        TIME = (-10000000./ANUMB)*DIRECT
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      CASE 8
C
C***   Mark command
C
        IF (NUMFLG)
          NUMBER = ANUMB*DIRECT
        ELSE
          NUMBER = 0
        ENDIF
        EXECUTE (HOLD_CURRENT_SETUP)
C
C***   Point to line we want
C
        JNUMB = 0
        EXECUTE (JUMP_LINES)
        LINEP = LINEP + JNUMB
        IF (LINEP .GT. NLINES) LINEP = NLINES
        DO FOR I=LINEP,NLINES
         IF (CCLINE(1,I) .NE. 0)
           IF (RANGE(1,1) .NE. 0)
             RANGE(1,2) = RANGE(1,1)
             RANGE(2,2) = RANGE(2,1)
           ENDIF
           RANGE(1,1) = CCLINE(1,I)
           RANGE(2,1) = CCLINE(2,I)
           UNDO
         ENDIF
        END DO FOR
        EXECUTE (CANCEL_STOPPER)
        EXECUTE (RESTORE_HELD_SETUP)
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      CASE 9
C
C***   Print, List, and Append commands
C
        PRINT = 1
        EXECUTE (OUTPUT_RANGE)
      CASE 10
        IF (MINFLG)
          PRINT = 0
        ELSE
          PRINT = -1
        ENDIF
        EXECUTE (OUTPUT_RANGE)
      CASE 11
C
C***   Exit
C
        CALL EXIT
      CASE 12
C
C***   Re-write screen
C
        EXECUTE (REFRESH_EXIT)
C
C***   Repeat last command
C
      CASE 13
        IF (NUMFLG)
          III = ANUMB
        ELSE
          III = 1
        ENDIF
        DO FOR IIII=1,III
         CALL REDOIT(SAVCOM,SAVFLG(1),SAVNUM,SAVFLG(2))
        END DO FOR
      END DO CASE
      EXECUTE (CANCEL_STOPPER)
      CALL WORKNG(.FALSE.)
      RETURN
C
C******************************************************************************
C***********************   HERE FOLLOW THE PROCEDURES   ***********************
C******************************************************************************
C
      PROCEDURE (BACK_SCROLL_EXIT)
CP    This routine exits from scrolling backward in FIX files.  It converts
CP    the data at the current position into output lines, frees the event
CP    event flags, resets the LEDs (#3 off) and returns.
        II = PBUF
        SBLK = BLK - 1
        IF (BLK .LE. EBK)
          CALL BLKIN(BLK,I,BUFFER(513))
          IF (I .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
          NBUF = 512 + I
        ENDIF
        CALL LINCON(.TRUE.)
        DO FOR LINEP=1,NLINES
         UNDO IF (CCLINE(1,LINEP) .EQ. SBLK .AND. CCLINE(2,LINEP).EQ.II)
        END DO FOR
        EXECUTE (GET_LAST_LINE)
        EXECUTE (WRITE_BLOCK_NUMBER)
        EXECUTE (FREE_FLAGS_EXIT)
        RETURN
      END PROCEDURE
      PROCEDURE (BACKWARD_SEARCH)
CP    This procedure searches backward through the file for a string. IF
CP    found the position is located there, the screen refreshed and the
CP    LEDs reset (#3 off), otherwise the screen is left alone, the position
CP    is not changed, and the LEDs are reset (#3 on).  In either case the
CP    a return from DOIT is executed.
C
C***   First search lines in buffer
C
1650    DO
         IF (LINEP .NE. 1)
           DO FOR I=LINEP-1,1,-1
            CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))
            DO FOR JJ=1,10
             UNDO IF (SBFLEN(JJ) .EQ. 0)
             IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ)))
     1           .NE. 0)
               NUMBER = I - LINEP
               LINEP = I
               EXECUTE (GET_LAST_LINE)
               IF (IABS(NUMBER) .GT. PAGLEN)
                 EXECUTE (REFRESH_EXIT)
               ELSE
                 EXECUTE (SCROLL_REFRESH_EXIT)
               ENDIF
               UNDO 1650
             ENDIF
            END DO FOR
           END DO FOR
         ENDIF
C
C***   Then start searching backward if not found
C
         EXECUTE (HOLD_CURRENT_SETUP)
         IBLK = SBLK - 1
         IF (IBLK .LE. 0)
           EXECUTE (SEARCH_ERROR_EXIT)
         ENDIF
         CALL BLKIN(IBLK,NBUF,BUFFER)
         IF (NBUF .EQ. 0)
           EXECUTE (READ_ERROR)
         ENDIF
         CALL BLKIN(IBLK,I,BUFFER(NBUF+1))
         IF (I .EQ. 0)
           EXECUTE (READ_ERROR)
         ENDIF
         IF (I .GT. 140)
           NBUF = NBUF + 140
         ELSE
           NBUF = NBUF + I
         ENDIF
         IBLK = SBLK
C
C===   Search loop
C
         DO FOREVER
          CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))
          DO FOR JJ=1,10
           UNDO IF (SBFLEN(JJ) .EQ. 0)
           IDESCR(1) = NBUF
           IDESCR(2) = %LOC(CAPBUF(1))
           I = 1
           DO FOREVER
            K = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))
            IF (STOPIT)
              EXECUTE (CANCEL_COMMAND)
            ENDIF
            IF (K .EQ. 0)
              STRPOS(JJ) = I - 1
              UNDO
            ENDIF
            IDESCR(1) = IDESCR(1) - K
            I = I + K
            IDESCR(2) = %LOC(CAPBUF(I))
           END DO FOREVER
          END DO FOR
          I = 0
          DO FOR K=1,10
           UNDO IF (SBFLEN(K) .EQ. 0)
           IF (STRPOS(K) .GT. I)
             JJ = K
             I = STRPOS(K)
           ENDIF
          END DO FOR
C
C===   Found
C
          IF (I .NE. 0)
            BLK = IBLK - 2
            IF (BLK .LE. 0) BLK = 1
            SBLK = BLK
            CALL BLKIN(BLK,NBUF,BUFFER)
            IF (NBUF .EQ. 0)
              EXECUTE (READ_ERROR)
            ENDIF
            IF (BLK .LE. EBK)
              CALL BLKIN(BLK,I,BUFFER(NBUF+1))
              IF (I .EQ. 0)
                EXECUTE (READ_ERROR)
              ENDIF
              NBUF = NBUF + I
              IF (BLK .LE. EBK)
                CALL BLKIN(BLK,I,BUFFER(NBUF+1))
                IF (I .EQ. 0)
                  EXECUTE (READ_ERROR)
                ENDIF
                NBUF = NBUF + I
              ENDIF
            ENDIF
            CALL LINCON(.TRUE.)
C
C===   Find right line
C
            DO FOR J=NLINES,1,-1
             CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))
             IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))
     1           .NE. 0)
               LINEP = J
               EXECUTE (GET_LAST_LINE)
               EXECUTE (CANCEL_STOPPER)
               EXECUTE (REFRESH_EXIT)
               UNDO 1650
             ENDIF
            END DO FOR
C
C===   Not found
C
          ENDIF
          IBLK = IBLK - 2
          IF (IBLK .LE. 0)
            EXECUTE (SEARCH_ERROR_EXIT)
          ENDIF
          DO FOR I=1,30
           TEMP(I) = CAPBUF(I)
          END DO FOR
          CALL BLKIN(IBLK,NBUF,BUFFER)
          IF (NBUF .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
          DO FOR I=1,30
           BUFFER(NBUF+I) = TEMP(I)
          END DO FOR
          NBUF = NBUF + 30
          IF (STOPIT)
            EXECUTE (CANCEL_COMMAND)
          ENDIF
         END DO FOREVER
        END DO
      END PROCEDURE
      PROCEDURE (BACKWARD_SCROLLING)
CP    This procedure handles scrolling backward through the file.
        IF (.NOT.MINFLG) DELTIM(1) = -DELTIM(1)
C
C***   Scroll through line buffer
C
        IF (LINEP .NE. 1)
          DO FOR LINEP=LINEP-1,1,-1
           IF (LENLMT .LT. 0)
             K = -LENLMT
             DO FOR L=1,LINLEN(LINEP)/K+1
              EXECUTE (SCROLL_DOWN)
             END DO FOR
             IF (K .LT. LINLEN(LINEP))
               CALL LIB$PUT_SCREEN(LINES(LINEP)(:K)//CRLF//
     1              LINES(LINEP)(K+1:LINLEN(LINEP))//CRLF,1,1)
             ELSE
               CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,
     1                             1,1)
             ENDIF
           ELSE
             EXECUTE (SCROLL_DOWN)
             IF (LINLEN(LINEP) .GT. LENLMT)
               CALL LIB$PUT_SCREEN(LINES(LINEP)(:LENLMT)//CRLF,1,1)
             ELSE
               CALL LIB$PUT_SCREEN(LINES(LINEP)(:LINLEN(LINEP))//CRLF,
     1                             1,1)
             ENDIF
           ENDIF
           EXECUTE (WAIT_FOR_SCROLL_AST)
           IF (STOPIT)
             EXECUTE (GET_LAST_LINE)
             EXECUTE (WRITE_BLOCK_NUMBER)
             EXECUTE (FREE_FLAGS_EXIT)
             RETURN
           ENDIF
          END DO FOR
        ENDIF
C
C***   Scroll through file
C
        DO FOR I=1,NLINES
         UNDO IF (CCLINE(1,I) .NE. 0)
        END DO FOR
        BLK = CCLINE(1,I) - 1
        IF (BLK .GT. 0)
          CALL BLKIN(BLK,PBUF,BUFFER)
          IF (PBUF .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
        ELSE
          PBUF = 0
          BLK = 1
        ENDIF
        CALL BLKIN(BLK,NBUF,BUFFER(PBUF+1))
        IF (NBUF .EQ. 0)
          EXECUTE (READ_ERROR)
        ENDIF
        IF (PBUF .NE. 0) BLK = BLK - 1
        PBUF = PBUF + CCLINE(2,I)
        NBUF = PBUF
        ISAVE = PBUF
        DO FOREVER
         IF (RFM .EQ. 1)
C
C---   Fixed length records
C
C===   Establish output record length
C
           IF (RAT .EQ. 2 .OR. RAT .EQ. -2)
             IF ((FSZ - 1) .LT. LENLMT .OR. LENLMT .LT. 0)
               LENREC = FSZ - 1
             ELSE
               LENREC = LENLMT
             ENDIF
           ELSE
             IF (FSZ .LT. LENLMT .OR. LENLMT .LT. 0)
               LENREC = FSZ
             ELSE
               LENREC = LENLMT
             ENDIF
           ENDIF
           DO FOREVER
            EXECUTE (WAIT_FOR_SCROLL)
            IF (STOPIT)
              EXECUTE (BACK_SCROLL_EXIT)
            ENDIF
            PBUF = PBUF - IFSZ
            UNDO IF (PBUF .LE. 0)
            EXECUTE (SCROLL_DOWN)
            IF (LENLMT .LT. 0 .AND. RECLEN .GT. (-LENLMT))
              DO FOR K=1,(-LENLMT)/RECLEN
               EXECUTE (SCROLL_DOWN)
              END DO FOR
            ENDIF
            IF (RAT .NE. 2 .AND. RAT .NE. -2)
              CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,BUFFER(PBUF),
     1                      %VAL(LENREC),,,,)
              CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),
     1                     IOSB,STOPSC,,INBUF,%VAL(1),,,,)
            ELSE
              CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,
     1                      BUFFER(PBUF+1),%VAL(LENREC),,,,)
              CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),
     1                     IOSB,STOPSC,,INBUF,%VAL(1),,,,)
              IF (BUFFER(PBUF) .EQ. '1')
                EXECUTE (SCROLL_BLANK_LINE_PRE)
                EXECUTE (SCROLL_BLANK_LINE_PRE)
              ELSE
                IF (BUFFER(PBUF) .EQ. '0')
                  EXECUTE (SCROLL_BLANK_LINE_PRE)
                ENDIF
              ENDIF
            ENDIF
           END DO FOREVER
         ELSE
C
C---   Variable length records
C
           DO FOR I=PBUF,2,-1
            IF (.NOT.I)
              IF (BUFFER(I) .EQ. 0)
                CYCLE IF (I .GT. ISAVE)
                LEN = LIB$EXTZV(0,8,BUFFER(I-1))
                IF ((LEN - FSZ) .EQ. 0)
                  EXECUTE (SCROLL_BLANK_LINE_POST)
                  ISAVE = I - 4 - FSZ
                  CYCLE
                ENDIF
                IF (LEN)
                  ILEN = LEN + 1
                ELSE
                  ILEN = LEN
                ENDIF
                IF (BUFFER(I+ILEN+2) .EQ. 0 .AND. LEN .LE. LRL .AND.
     1              LIB$EXTZV(0,8,BUFFER(I+ILEN+1)) .LE. LRL)
                  ISAVE = I - 4 - FSZ
                  IF (RAT .EQ. 3 .OR. RAT .EQ. -3)
                    IF (LIB$EXTZV(7,1,BUFFER(I+2)) .EQ. 0)
                      J = LIB$EXTZV(0,7,BUFFER(I+2)) - 1
                      IF (J .GT. 0)
                        DO FOR K=1,J
                         EXECUTE (SCROLL_BLANK_LINE_POST)
                        END DO FOR
                      ENDIF
                    ENDIF
                    EXECUTE (SCROLL_DOWN)
                    CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,
     1                       BUFFER(I+FSZ+1),%VAL(LEN-FSZ),,,,)
                    CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),
     1                           %VAL('1171'X),IOSB,STOPSC,,INBUF,
     2                           %VAL(1),,,,)
                    IF (LIB$EXTZV(7,1,BUFFER(I+1)) .EQ. 0)
                      J = LIB$EXTZV(0,7,BUFFER(I+1))
                      IF (J .NE. 0)
                        DO FOR K=1,J
                         EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)
                        END DO FOR
                      ENDIF
                    ENDIF
                  ELSE
                    EXECUTE (SCROLL_DOWN)
                    IF (RAT .EQ. 2 .OR. RAT .EQ. -2)
                      IF (LEN .NE. 1)
                        IF (LENLMT .LT. 0)
                          IF (LENLMT .GT. (1 + FSZ - LEN))
                            DO FOR M=1,(FSZ-LEN)/LENLMT
                             EXECUTE (SCROLL_DOWN)
                            END DO FOR
                            M = LEN - FSZ - 1
                          ELSE
                            M = -LENLMT
                          ENDIF
                        ELSE
                          IF (LENLMT .GT. (LEN - FSZ - 1))
                            M = LEN - FSZ - 1
                          ELSE
                            M = LENLMT
                          ENDIF
                        ENDIF
                        CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,
     1                                ,BUFFER(I+FSZ+2),%VAL(M),,,,)
                      ENDIF
                      CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),
     1                             %VAL('1171'X),IOSB,STOPSC,,
     2                             INBUF,%VAL(1),,,,)
                      IF (BUFFER(I+FSZ+1) .EQ. '1')
                        EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)
                        EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)
                      ELSE
                        IF (BUFFER(I+FSZ+1) .EQ. '0')
                          EXECUTE (SCROLL_BLANK_LINE_VAR_PRE)
                        ENDIF
                      ENDIF
                    ELSE
                      IF (LENLMT .LT. 0)
                        IF (LENLMT .GT. (FSZ - LEN))
                          DO FOR M=1,(FSZ-LEN-1)/LENLMT
                           EXECUTE (SCROLL_DOWN)
                          END DO FOR
                          M = LEN - FSZ
                        ELSE
                          M = -LENLMT
                        ENDIF
                      ELSE
                        IF (LENLMT .GT. (LEN - FSZ))
                          M = LEN - FSZ
                        ELSE
                          M = LENLMT
                        ENDIF
                      ENDIF
                      CALL SYS$QIOW(,%VAL(INCHAN),%VAL('30'X),,,,
     1                              BUFFER(I+FSZ+1),%VAL(M),,,,)
                      CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),
     1                             %VAL('1171'X),IOSB,STOPSC,,
     2                             INBUF,%VAL(1),,,,)
                    ENDIF
                    EXECUTE (WAIT_FOR_SCROLL)
                    IF (STOPIT)
                      EXECUTE (VAR_BACK_SCROLL_EXIT)
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
           END DO FOR
         ENDIF
         BLK = BLK - 2
         IF (BLK .LE. 0)
           EXECUTE (HIT_BEGINNING)
           EXECUTE (GET_LAST_LINE)
           EXECUTE (FREE_FLAGS_EXIT)
           RETURN
         ENDIF
         DO FOR I=1,150
          HBUFER(I) = BUFFER(I)
         END DO FOR
         CALL BLKIN(BLK,PBUF,BUFFER)
         IF (PBUF .EQ. 0)
           EXECUTE (READ_ERROR)
         ENDIF
         DO FOR I=1,150
          BUFFER(PBUF+I) = HBUFER(I)
         END DO FOR
         ISAVE = PBUF
         NBUF = PBUF + 150
        END DO FOREVER
      END PROCEDURE
      PROCEDURE (CANCEL_COMMAND)
CP    This routine is used to terminate either line jumps or searches on
CP    input of a (.
        CALL LIB$FREE_EF(IOFLAG)
        EXECUTE (RESTORE_HELD_SETUP)
        EXECUTE (HOME_PLUS_LEDS_EXIT)
        RETURN
      END PROCEDURE
      PROCEDURE (CANCEL_STOPPER)
CP    This routine gets rid of the stopping AST.
        CALL SYS$CANCEL(%VAL(INCHAN))
        CALL LIB$FREE_EF(IOFLAG)
      END PROCEDURE
      PROCEDURE (ERROR_EXIT)
CP    This routine rings the terminal bell then resets the LEDs (#3 on)
CP    and returns.
        EXECUTE (CANCEL_STOPPER)
        CALL WORKNG(.FALSE.)
        CALL LIB$PUT_SCREEN(CHAR(BELL))
        IF (VT100)
          CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;3q')
          IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')
          IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)
     1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')
        ENDIF
        RETURN
      END PROCEDURE
      PROCEDURE (FIND_NON_CC_LINE)
CP    This procedure locates a non-carriage-control line near LINEP
1550    DO
         DO FOR I=LINEP,NLINES
          UNDO 1550 IF (CCLINE(1,I) .NE. 0)
         END DO FOR
         DO FOR I=LINEP-1,1,-1
          UNDO 1550 IF (CCLINE(1,I) .NE. 0)
         END DO FOR
        END DO
      END PROCEDURE
      PROCEDURE (FORWARD_SEARCH)
CP    This routine searchs forward through the file for a given string.
CP    If it is found the screen is reset to that position, and the LEDs are
CP    reset (#3 off), otherwise the position and screen remain unchanged
CP    and the LEDs are reset (#3 on).  In either case a return from DOIT
CP    is executed.
C
C***   First search lines in buffer
C
1750    DO
         IF (LINEP .LT. NLINES)
           DO FOR I=LINEP+1,NLINES
            DO FOR JJ=1,10
             UNDO IF (SBFLEN(JJ) .EQ. 0)
             CALL CONVUP(LINLEN(I),%REF(LINES(I)),%REF(CAPLIN))
             IF (INDEX(CAPLIN(:LINLEN(I)),SRCHBF(JJ)(:SBFLEN(JJ))) .NE.
     1           0)
               NUMBER = I - LINEP
               LINEP = I
               EXECUTE (GET_LAST_LINE)
               IF ((NUMBER+LINEP) .LT. PAGEND)
                 EXECUTE (SCROLL_REFRESH_EXIT)
               ELSE
                 EXECUTE (REFRESH_EXIT)
               ENDIF
               UNDO 1750
             ENDIF
            END DO FOR
           END DO FOR
         ENDIF
C
C***   Then search file
C
         EXECUTE (HOLD_CURRENT_SETUP)
         IBLK = BLK
         IF (NBUF .GT. 0)
           I = NBUF + 1
         ELSE
           I = 1
         ENDIF
         IDESCR(2) = %LOC(CAPBUF(1))
         DO FOREVER
C
C---   Input some buffer
C
          IF (IBLK .GT. EBK)
            EXECUTE (SEARCH_ERROR_EXIT)
          ENDIF
          IF (IBLK .LT. (EBK - 6))
C
C===   Not near the end of the file
C
            CALL BLKSIN(IBLK,J,BUFFER(I))
            IF (J .EQ. 0)
              EXECUTE (READ_ERROR)
            ENDIF
          ELSE
C
C===   Near the end of the file
C
            J = 0
            DO FOR II=IBLK,EBK
             CALL BLKIN(IBLK,JJ,BUFFER(J+I))
             IF (JJ .EQ. 0)
               EXECUTE (READ_ERROR)
             ENDIF
             J = J + JJ
            END DO FOR
          ENDIF
          NBUF = J + I - 1
          CALL CONVUP(NBUF,BUFFER(1),CAPBUF(1))
          IDESCR(1) = NBUF
          DO FOR JJ=1,10
           UNDO IF (SBFLEN(JJ) .EQ. 0)
           STRPOS(JJ) = LIB$INDEX(IDESCR,SRCHBF(JJ)(:SBFLEN(JJ)))
           IF (STOPIT)
             EXECUTE (CANCEL_COMMAND)
           ENDIF
          END DO FOR
          I = NBUF
          DO FOR K=1,10
           UNDO IF (SBFLEN(K) .EQ. 0)
           IF (STRPOS(K) .NE. 0 .AND. STRPOS(K) .LT. I)
             I = STRPOS(K)
             JJ = K
           ENDIF
          END DO FOR
          IF (I .NE. NBUF)
C
C===   Found it
C
            IBLK = IBLK - (NBUF - I)/512 - 2
            IF (IBLK .LE. 0) IBLK = 1
            IF (IBLK .LE. (EBK - 6))
              BLK = IBLK
              I = 1
            ELSE
              BLK = EBK - 6
              I = 0
            ENDIF
            EXECUTE (INPUT_SEVEN_BLOCKS)
            CALL LINCON(.TRUE.)
            IF (I .EQ. 0)
              DO FOR I=1,NLINES
               UNDO IF (CCLINE(1,I) .EQ. IBLK)
              END DO FOR
            ENDIF
            DO FOR J=I,NLINES
             CALL CONVUP(LINLEN(J),%REF(LINES(J)),%REF(CAPLIN))
             IF (INDEX(CAPLIN(:LINLEN(J)),SRCHBF(JJ)(:SBFLEN(JJ)))
     1           .NE. 0)
               LINEP = J
               EXECUTE (GET_LAST_LINE)
               EXECUTE (CANCEL_STOPPER)
               EXECUTE (REFRESH_EXIT)
               UNDO 1750
             ENDIF
             IF (STOPIT)
               EXECUTE (CANCEL_COMMAND)
             ENDIF
            END DO FOR
C
C===   Not found
C
          ENDIF
          I = 31
          DO FOR J=1,30
           BUFFER(J) = CAPBUF(NBUF-30+J)
          END DO FOR
         END DO FOREVER
        END DO
      END PROCEDURE
      PROCEDURE (FORWARD_SCROLLING)
CP    This procedure executes scrolling in a forward direction.
        LINEP = PAGEND
        FIRST = .TRUE.
        IF (PAGLEN .EQ. (COMLIN - 2))
          SECOND = .TRUE.
        ELSE
          SECOND = .FALSE.
        ENDIF
        DO FOREVER
C
C***   Scroll through line buffer
C
         UNDO IF (LINEP .EQ. NLINES)
         DO FOR I=LINEP+1,NLINES
          CALL SYS$CANCEL(%VAL(INCHAN))
          IF (FIRST)
            FIRST = .FALSE.
            DO FOR J=PAGLEN+1,COMLIN
             CALL LIB$ERASE_LINE(J,1)
            END DO FOR
            IF (LENLMT .LT. 0)
              IF (LINLEN(I) .LE. -LENLMT)
                CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)
              ELSE
                CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//
     1               LINES(I)(1-LENLMT:LINLEN(I)),PAGLEN+1,1)
              ENDIF
            ELSE
              IF (LINLEN(I) .GT. LENLMT)
                CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),PAGLEN+1,1)
              ELSE
                CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),PAGLEN+1,1)
              ENDIF
            ENDIF
          ELSE
            IF (SECOND)
              SECOND = .FALSE.
              IF (LENLMT .LT. 0 .AND. LINLEN(I) .GT. (-LENLMT))
     1            CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)
            ELSE
              CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)
            ENDIF
            IF (LENLMT .LT. 0)
              IF (LINLEN(I) .LE. -LENLMT)
                CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)
              ELSE
                CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//
     1               LINES(I)(1-LENLMT:LINLEN(I)),COMLIN,1)
              ENDIF
            ELSE
              IF (LINLEN(I) .GT. LENLMT)
                CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT),COMLIN,1)
              ELSE
                CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)),COMLIN,1)
              ENDIF
            ENDIF
          ENDIF
          CALL LIB$SET_CURSOR(1,1)
          EXECUTE (WAIT_FOR_SCROLL_AST)
          IF (STOPIT)
            PAGEND = I
            EXECUTE (GET_START_LINE)
            IF (.NOT.FIRST)
              CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)
              IF (PAGLEN .EQ. (COMLIN - 2))
     1            CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)
              CALL LIB$SET_CURSOR(1,1)
            ENDIF
            EXECUTE (WRITE_BLOCK_NUMBER)
            EXECUTE (FREE_FLAGS_EXIT)
            RETURN
          ENDIF
         END DO FOR
C
C***   Input to line buffer
C
C
C---   End of file
C
         IF (BLK .GT. EBK)
           PAGEND = NLINES
           EXECUTE (GET_START_LINE)
           CALL SYS$CANCEL(%VAL(INCHAN))
           IF (.NOT.FIRST)
             CALL LIB$PUT_SCREEN(CRLF,COMLIN,1)
             CALL LIB$SET_CURSOR(1,1)
           ENDIF
           EXECUTE (WRITE_BLOCK_NUMBER)
           EXECUTE (FREE_FLAGS_EXIT)
           RETURN
         ENDIF
         IF (BLK .LT. (EBK - 6))
C
C---   Not near the end of the file
C
           CALL BLKSIN(BLK,I,BUFFER(NBUF+1))
           IF (I .EQ. 0)
             EXECUTE (READ_ERROR)
           ENDIF
         ELSE
C
C---   Near the end of the file
C
           I = 0
           DO FOR J=BLK,EBK
            CALL BLKIN(BLK,II,BUFFER(NBUF+I+1))
            IF (II .EQ. 0)
              EXECUTE (READ_ERROR)
            ENDIF
            I = I + II
           END DO FOR
         ENDIF
         NBUF = NBUF + I
         LINEP = NLINES
         PBUF = 1
         CALL LINCON(.FALSE.)
        END DO FOREVER
      END PROCEDURE
      PROCEDURE (FREE_FLAGS_EXIT)
CP    This routine exits from scrolling.  It frees the event flags, cancels
CP    any input requests to the terminal, resets the LEDs (#3 off) and
CP    returns.
        EXECUTE (CANCEL_STOPPER)
        CALL LIB$FREE_EF(TIMFLG)
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      END PROCEDURE
      PROCEDURE (GET_LAST_LINE)
CP    This procedure determines PAGEND given LINEP
        OLDEND = PAGEND
        IF (LENLMT .LT. 0)
          I = PAGLEN
          DO FOR PAGEND=LINEP,LINEP+PAGLEN
           I = I + (LINLEN(PAGEND) - 1)/LENLMT - 1
           UNDO IF (I .LE. 0)
          END DO FOR
        ELSE
          PAGEND = LINEP + PAGLEN - 1
        ENDIF
      END PROCEDURE
      PROCEDURE (GET_START_LINE)
CP    This procedure determines LINEP given a value for PAGEND
        IF (LENLMT .LT. 0)
          I = PAGLEN
          DO FOR LINEP=PAGEND,PAGEND-PAGLEN,-1
           I = I + (LINLEN(LINEP) - 1)/LENLMT - 1
           UNDO IF (I .LE. 0)
          END DO FOR
        ELSE
          LINEP = PAGEND - PAGLEN + 1
        ENDIF
      END PROCEDURE
      PROCEDURE (HIT_BEGINNING)
CP    This procedure is executed if the position goes past the beginning
CP    of the file.  Everything is reset to the beginning of the file.
        BLK = 1
        EXECUTE (INPUT_SEVEN_BLOCKS)
        CALL LINCON(.TRUE.)
        LINEP = 1
      END PROCEDURE
      PROCEDURE (HOLD_CURRENT_SETUP)
CP    This routine is used in searches.  It holds all the information
CP    needed to recreate the current position and array conditions.
        DO FOR I=1,NLINES
         HLIN(I) = LINES(I)
         HLINLN(I) = LINLEN(I)
         HCCLIN(1,I) = CCLINE(1,I)
         HCCLIN(2,I) = CCLINE(2,I)
        END DO FOR
        HLINES = NLINES
        HLINEP = LINEP
        IF (NBUF .NE. 0)
          DO FOR I=1,NBUF
           HBUFER(I) = BUFFER(I)
          END DO FOR
        ENDIF
        HPBUF = PBUF
        HNBUF = NBUF
        HBLK = BLK
        HSBLK = SBLK
        HLBLK = LBLK
        HLPBUF = LPBUF
        EXECUTE (QUEUE_STOPPER)
      END PROCEDURE
      PROCEDURE (HOME_PLUS_LEDS_EXIT)
CP    This routine homes the cursor, resets the LEDs (#3 off).
        IF (VT100)
          CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0q',1,1)
          IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)
     1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')
          IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')
        ELSE
          CALL LIB$SET_CURSOR(1,1)
        ENDIF
      END PROCEDURE
      PROCEDURE (INPUT_SEVEN_BLOCKS)
CP    This procedure inputs seven blocks of data
        IF (BLK .LT. (EBK - 6))
C
C***   Not near the end of the file
C
          SBLK = BLK
          CALL BLKSIN(BLK,NBUF,BUFFER)
          IF (NBUF .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
        ELSE
C
C***   Near the end of the file
C
          BLK = EBK - 6
          IF (BLK .GT. 0)
            SBLK = BLK
            CALL BLKSIN(BLK,NBUF,BUFFER)
            IF (NBUF .EQ. 0)
              EXECUTE (READ_ERROR)
            ENDIF
          ELSE
C
C***   Do this if file size is < 7 blocks
C
            BLK = 1
            SBLK = 1
            NBUF = 0
            DO FOR I=BLK,EBK
             CALL BLKIN(BLK,J,BUFFER(NBUF+1))
             IF (J .EQ. 0)
               EXECUTE (READ_ERROR)
             ENDIF
             NBUF = NBUF + J
            END DO FOR
          ENDIF
        ENDIF
      END PROCEDURE
      PROCEDURE (JUMP_LINES)
CP    This procedure moves the current position NUMBER lines.
        IF ((NUMBER + LINEP) .GT. (NLINES - PAGLEN + 1))
C
C***   Big jumps forward
C
          SECOND = .FALSE.
          DO FOREVER
           IF (BLK .GT. EBK)
             LINEP = NLINES - PAGLEN + 1
             IF (LINEP .LT. 1) LINEP = 1
             JNUMB = NUMBER
             UNDO
           ENDIF
           CALL BLKIN(BLK,I,BUFFER(NBUF+1))
           IF (I .EQ. 0)
             EXECUTE (READ_ERROR)
           ENDIF
           NBUF = NBUF + I
           PBUF = 1
           CALL LINCON(.FALSE.)
           IF (STOPIT)
             EXECUTE (CANCEL_COMMAND)
           ENDIF
           IF ((LINEP + NUMBER) .LE. (NLINES - PAGLEN + 1))
             LINEP = LINEP + NUMBER
             UNDO
           ENDIF
           IF ((NLINES - LINEP) .GE. (600 - 100))
             SECOND = .TRUE.
             NUMBER = NUMBER - NLINES + LINEP - 1
             LINEP = NLINES
           ENDIF
          END DO FOREVER
          IF (SECOND) NUMBER = 25
        ELSE
          IF ((NUMBER + LINEP) .LE. 0)
C
C***   Big jumps backward
C
            NUMBER = -(NUMBER + LINEP)
            INUMBR = 1 - LINEP
            IF (RFM .EQ. 1 .AND. RAT .NE. 2 .AND. RAT .NE. -2)
C
C---   Fixed record length with no carriage-control
C
              IF (RAT .LT. 0)
C===   No spanned
                BLK = SBLK - NUMBER*IFSZ/RECBLK - 1
                J = RECBLK/IFSZ - NUMBER + (SBLK-BLK-1)*RECBLK/IFSZ
              ELSE
C===   Spanned
                I = 512*(CCLINE(1,1) - 1) + CCLINE(2,1) -
     1              IFSZ*NUMBER
                J = LIB$EXTZV(0,8,I)
                IF (J .EQ. 0) J = 512
                BLK = I/512 + 1
              ENDIF
              IF (STOPIT)
                EXECUTE (CANCEL_COMMAND)
              ENDIF
              IF (BLK .LE. 0)
                BLK = 1
                J = 1
              ENDIF
C===   Input lines
              EXECUTE (INPUT_SEVEN_BLOCKS)
              CALL LINCON(.TRUE.)
              LINEP = J
              NUMBER = 25
            ELSE
C
C---   Variable length records and/or carriage-control
C
              DO FOR I=1,NLINES
               UNDO IF (CCLINE(1,I) .NE. 0)
              END DO FOR
              BLK = CCLINE(1,I)
              PBUF = CCLINE(2,I)
              CALL BLKIN(BLK,NBUF,BUFFER)
              IF (NBUF .EQ. 0)
                EXECUTE (READ_ERROR)
              ENDIF
1810          DO
               SECOND = .TRUE.
1820           DO FOREVER
                IF (NUMBER .LT. 0)
                  NUMBER = 25
                  UNDO
                ENDIF
                IF (RFM .EQ. 1)
C
C===  Fixed length records (must have carriage-control)
C
                  PBUF = PBUF - IFSZ
                  IF (PBUF .LT. 1)
                    BLK = BLK - 2
                    IF (BLK .LE. 0)
                      EXECUTE (HIT_BEGINNING)
                      IF (SECOND)
                        NUMBER = INUMBR
                      ELSE
                        NUMBER = 25
                      ENDIF
                      UNDO 1810
                    ENDIF
                    CALL BLKIN(BLK,NBUF,BUFFER)
                    IF (NBUF .EQ. 0)
                      EXECUTE (READ_ERROR)
                    ENDIF
                    SECOND = .FALSE.
                    PBUF = PBUF + NBUF
                  ENDIF
                  IF (BUFFER(PBUF) .EQ. '1')
                    NUMBER = NUMBER - 3
                  ELSE
                    IF (BUFFER(PBUF) .EQ. '0')
                      NUMBER = NUMBER - 2
                    ELSE
                      NUMBER = NUMBER - 1
                    ENDIF
                  ENDIF
                ELSE
C
C===   Variable length records
C
                  DO FOREVER
                   DO FOR I=PBUF-1,2,-1
                    IF (.NOT.I)
                      IF (BUFFER(I) .EQ. 0)
                        J = LIB$EXTZV(0,8,BUFFER(I-1))
                        IF (J .LE. LRL)
                          IF (J) J = J + 1
                          IF (BUFFER(I+J+2) .EQ. 0)
                            IF (RAT .EQ. 2 .OR. RAT .EQ. -2)
                              IF (BUFFER(I+FSZ+1) .EQ. '1')
                                NUMBER = NUMBER - 3
                              ELSE
                                IF (BUFFER(I+FSZ+1) .EQ. '0')
                                  NUMBER = NUMBER - 2
                                ELSE
                                  NUMBER = NUMBER - 1
                                ENDIF
                              ENDIF
                            ELSE
                              NUMBER = NUMBER - 1
                              IF (RAT .EQ. 3 .OR. RAT .EQ. -3)
                                IF (LIB$EXTZV(7,1,BUFFER(I+1)) .EQ. 0)
     1                              NUMBER = NUMBER -
     2                              LIB$EXTZV(0,7,BUFFER(I+1))
                                IF (LIB$EXTZV(7,1,BUFFER(I+2)) .EQ. 0)
     1                              NUMBER = NUMBER -
     2                              LIB$EXTZV(0,7,BUFFER(I+2))
                              ENDIF
                            ENDIF
                            PBUF = I - 1
                            CYCLE 1820
                          ENDIF
                        ENDIF
                      ENDIF
                    ENDIF
                    IF (STOPIT)
                      EXECUTE (CANCEL_COMMAND)
                    ENDIF
                   END DO FOR
C===  New block
                   DO FOR I=1,150
                    CAPBUF(I) = BUFFER(I)
                   END DO FOR
                   BLK = BLK - 2
                   IF (BLK .LE. 0)
                     IF (SECOND)
                       NUMBER = INUMBR
                     ELSE
                       NUMBER = 25
                     ENDIF
                     EXECUTE (HIT_BEGINNING)
                     UNDO 1810
                   ENDIF
                   CALL BLKIN(BLK,PBUF,BUFFER)
                   IF (PBUF .EQ. 0)
                     EXECUTE (READ_ERROR)
                   ENDIF
                   SECOND = .FALSE.
                   DO FOR I=1,150
                    BUFFER(PBUF+I) = CAPBUF(I)
                   END DO FOR
                  END DO FOREVER
                ENDIF
               END DO FOREVER
               BLK = BLK - 1
               J = PBUF
               EXECUTE (INPUT_SEVEN_BLOCKS)
               CALL LINCON(.TRUE.)
               DO FOR I=1,NLINES
                IF (CCLINE(1,I) .EQ. SBLK .AND. CCLINE(2,I) .EQ. J)
                  LINEP = I
                  UNDO
                ENDIF
               END DO FOR
              END DO
            ENDIF
          ELSE
C
C---   Jumps within the stored buffer
C
            LINEP = LINEP + NUMBER
          ENDIF
        ENDIF
        EXECUTE (CANCEL_STOPPER)
      END PROCEDURE
      PROCEDURE (OUTPUT_RANGE)
CP    This procedure performs the output for the print, list, and append
CP    commands.  Which is being used is determined by the value of PRINT
CP    (-1 = print, 0 = append, 1 = list).
C
C---   Open printer output file
C
        CALL PRTOPN(PRINT)
        IF (PRINT .EQ. 47)
          EXECUTE (ERROR_EXIT)
        ENDIF
        EXECUTE (HOLD_CURRENT_SETUP)
C
C---   Point to right place
C
        IF (NUMFLG)
          NUMBER = DIRECT*ANUMB
          RFLAG = .FALSE.
        ELSE
          IF (RANGE(1,2) .EQ. 0)
            NUMBER = PAGLEN
            RFLAG = .FALSE.
          ELSE
            RFLAG = .TRUE.
          ENDIF
        ENDIF
        IF (RFLAG)
          IF (RANGE(1,1) .LT. RANGE(1,2) .OR. (RANGE(1,1) .EQ.
     1        RANGE(1,2) .AND. RANGE(2,1) .LE. RANGE(2,2)))
            BLK = RANGE(1,1)
            PBUF = RANGE(2,1)
            IENDPB = RANGE(1,2)
            IENDPP = RANGE(2,2)
          ELSE
            BLK = RANGE(1,2)
            PBUF = RANGE(2,2)
            IENDPB = RANGE(1,1)
            IENDPP = RANGE(2,1)
          ENDIF
          SBLK = BLK
          CALL BLKIN(BLK,NBUF,BUFFER)
          IF (NBUF .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
        ELSE
          IF (NUMBER .LT. 0)
            INUMB = NUMBER
            EXECUTE (FIND_NON_CC_LINE)
            IENDPB = CCLINE(1,I)
            IENDPP = CCLINE(2,I)
            EXECUTE (JUMP_LINES)
            NUMBER = -1000
          ENDIF
          EXECUTE (FIND_NON_CC_LINE)
          BLK = CCLINE(1,I)
          PBUF = CCLINE(2,I)
          SBLK = BLK
          CALL BLKIN(BLK,NBUF,BUFFER)
          IF (NBUF .EQ. 0)
            EXECUTE (READ_ERROR)
          ENDIF
        ENDIF
        IBLK = SBLK
C
C---   Print loop
C
        DO FOREVER
         IF (STOPIT)
           CALL PRTCLS(STOPIT)
           EXECUTE (RESTORE_HELD_SETUP)
           EXECUTE (FREE_FLAGS_EXIT)
           RETURN
         ENDIF
         IF (RFM .EQ. 1)
           I = FSZ
         ELSE
           I = LIB$EXTZV(0,8,BUFFER(PBUF))
         ENDIF
         IF (I)
           K = 1
         ELSE
           K = 0
         ENDIF
         IF ((PBUF + I + K - 1) .GT. NBUF .OR. (RFM .NE. 1 .AND.
     1       (PBUF + K + I + 1) .GT. NBUF))
           UNDO IF (BLK .GT. EBK)
           DO FOR J=PBUF,NBUF
            BUFFER(J-PBUF+1) = BUFFER(J)
           END DO FOR
           IBLK = BLK
           CALL BLKIN(BLK,J,BUFFER(NBUF-PBUF+2))
           IF (J .EQ. 0)
             EXECUTE (READ_ERROR)
           ENDIF
           IF (PBUF .GT. NBUF .AND. RFM .NE. 1)
             I = LIB$EXTZV(0,8,BUFFER(1))
             IF (I)
               K = 1
             ELSE
               K = 0
             ENDIF
           ENDIF
           INDSFT = PBUF - NBUF - 1
           NBUF = NBUF - PBUF + J + 1
           PBUF = 1
         ENDIF
         J = PBUF + INDSFT
         IF (RFM .NE. 1)
           PBUF = PBUF + 2 + FSZ
           I = I - FSZ
         ENDIF
         IF (.NOT.RFLAG)
           IF (RAT .EQ. 2 .OR. RAT .EQ. -2)
             IF (BUFFER(PBUF) .EQ. '0')
               NUMBER = NUMBER - 1
             ELSE
               IF (BUFFER(PBUF) .EQ. '1') NUMBER = NUMBER - 2
             ENDIF
           ELSE
             IF (RAT .EQ. 3 .OR. RAT .EQ. -3)
               IF (LIB$EXTZV(7,1,BUFFER(PBUF-2)) .EQ. 0)
     1             NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-2))
               IF (LIB$EXTZV(7,1,BUFFER(PBUF-1)) .EQ. 0)
     1             NUMBER = NUMBER - LIB$EXTZV(0,7,BUFFER(PBUF-1))
             ENDIF
           ENDIF
         ENDIF
         CALL PRTOUT(I,BUFFER(PBUF))
         IF (.NOT.RFLAG) NUMBER = NUMBER - 1
         PBUF = PBUF + I + K
         UNDO IF ((.NOT.RFLAG .AND. NUMBER .LE. 0) .OR. (RFLAG .AND.
     1            (IBLK .GT. IENDPB .OR. (IBLK .LE. IENDPB .AND.
     2            J .GE. (IENDPP + 512*(IENDPB - IBLK))))))
        END DO FOREVER
        CALL PRTCLS
        EXECUTE (RESTORE_HELD_SETUP)
        EXECUTE (FREE_FLAGS_EXIT)
      END PROCEDURE
      PROCEDURE (QUEUE_STOPPER)
CP    This procedure sets up an AST to allow the user to stop an
CP    operation.
        STOPIT = .FALSE.
        CALL LIB$GET_EF(IOFLAG)
        IF (IOFLAG .EQ. -1)
          CALL LIB$PUT_SCREEN('Unable to allocate necessary event '//
     1                        'flag.  OPERATION ABORTED.',COMLIN,20)
          EXECUTE (ERROR_EXIT)
        ENDIF
        CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,
     1               STOPSC,,INBUF,%VAL(1),,,,)
      END PROCEDURE
      PROCEDURE (READ_ERROR)
CP    This procedure terminates program execution with an error message.
CP    It is used when an input error occurs.
        CALL RESTRM(INCHAN)
        CALL BLKCLS
        CLOSE (UNIT=9)
        CALL SYS$DASSGN(%VAL(INCHAN))
        CALL LIB$PUT_OUTPUT(CRLF//'ERROR READING FILE')
        CALL EXIT
      END PROCEDURE
      PROCEDURE (REFRESH_EXIT)
CP    This procedure refreshes the screen (puts up a new set of lines
CP    corresponding to the current line position), resets the LEDs (#3
CP    off).
        CALL WORKNG(.FALSE.)
        IF (NLINES .LT. PAGEND)
          DO FOREVER
           IF (BLK .GT. EBK)
             PAGEND = NLINES
             UNDO
           ELSE
             CALL BLKIN(BLK,I,BUFFER(NBUF+1))
             IF (I .EQ. 0)
               EXECUTE (READ_ERROR)
             ENDIF
             NBUF = NBUF + I
             PBUF = 1
             CALL LINCON(.FALSE.)
             UNDO IF (NLINES .GE. PAGEND)
           ENDIF
          END DO FOREVER
        ENDIF
        CALL LIB$ERASE_PAGE(1,1)
        DO FOR I=LINEP,PAGEND
         IF (LENLMT .GT. 0)
           IF (LENLMT .GT. LINLEN(I))
             CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)
           ELSE
             CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)
           ENDIF
         ELSE
           IF (LINLEN(I) .LE. -LENLMT)
             CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)
           ELSE
             CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//
     1                           LINES(I)(1-LENLMT:LINLEN(I))//CRLF)
           ENDIF
         ENDIF
        END DO FOR
        EXECUTE (WRITE_BLOCK_NUMBER)
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      END PROCEDURE
      PROCEDURE (RESTORE_HELD_SETUP)
CP    This routine is used in searches.  It restores the position and
CP    arrays that have previously been saved by HOLD_CURRENT_SETUP.
        CALL WORKNG(.FALSE.)
        NBUF = HNBUF
        PBUF = HPBUF
        NLINES = HLINES
        LINEP = HLINEP
        DO FOR I=1,NLINES
         LINES(I) = HLIN(I)
         LINLEN(I) = HLINLN(I)
         CCLINE(1,I) = HCCLIN(1,I)
         CCLINE(2,I) = HCCLIN(2,I)
        END DO FOR
        IF (NBUF .NE. 0)
          DO FOR I=1,NBUF
           BUFFER(I) = HBUFER(I)
          END DO FOR
        ENDIF
        BLK = HBLK
        SBLK = HSBLK
        LBLK = HLBLK
        LPBUF = HLPBUF
      END PROCEDURE
      PROCEDURE (SCROLL_BLANK_LINE_POST)
CP    This routine is used in scrolling backwards in non-FIXfiles.  It prints
CP    a blank line then waits for one timer interval (which is set by the
CP    scrolling speed), and then checks for the stop signal.
        EXECUTE (SCROLL_DOWN)
        EXECUTE (WAIT_FOR_SCROLL_AST)
        IF (STOPIT)
          EXECUTE (VAR_BACK_SCROLL_EXIT)
        ENDIF
      END PROCEDURE
      PROCEDURE (SCROLL_BLANK_LINE_PRE)
CP    This routine is used in scrolling backward in FIX files.  It waits
CP    one timer interval (set by scrolling speed), checks for the stop
CP    signal, then writes one blank line.
        EXECUTE (WAIT_FOR_SCROLL)
        IF (STOPIT)
          EXECUTE (BACK_SCROLL_EXIT)
        ENDIF
        EXECUTE (SCROLL_DOWN)
        CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,
     1               STOPSC,,INBUF,%VAL(1),,,,)
      END PROCEDURE
      PROCEDURE (SCROLL_BLANK_LINE_VAR_PRE)
CP    This routine is used in scrolling backward in non-FIX files.  It
CP    waits for one timer interval (set by scrolling speed), checks for
CP    the stop signal, and then writes one blank line.
        EXECUTE (WAIT_FOR_SCROLL)
        IF (STOPIT)
          EXECUTE (VAR_BACK_SCROLL_EXIT)
        ENDIF
        EXECUTE (SCROLL_DOWN)
        CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,
     1               STOPSC,,INBUF,%VAL(1),,,,)
      END PROCEDURE
      PROCEDURE (SCROLL_DOWN)
CP    This procedure scrolls the screen down one line and leaves the
CP    cursor at the upper left hand corner.
        CALL SYS$CANCEL(%VAL(INCHAN))
        CALL LIB$SET_CURSOR(1,1)
        CALL LIB$DOWN_SCROLL()
        CALL LIB$SET_CURSOR(1,1)
      END PROCEDURE
      PROCEDURE (SCROLL_REFRESH_EXIT)
CP    This procedure scrolls to the proper line, resets the LED's (#3
CP    off).
        CALL WORKNG(.FALSE.)
        IF (NUMBER .GT. 0)
C
C***   Forward scrolling
C
          IF (OLDEND .NE. PAGEND)
C
C---   Make sure there is something to do
C
C---   Get extra lines if necessary
C
            IF (NLINES .LT. PAGEND)
              DO FOREVER
               IF (BLK .GT. EBK)
                 PAGEND = NLINES
                 UNDO
               ELSE
                 CALL BLKIN(BLK,I,BUFFER(NBUF+1))
                 IF (I .EQ. 0)
                   EXECUTE (READ_ERROR)
                 ENDIF
                 NBUF = NBUF + I
                 PBUF = 1
                 CALL LINCON(.FALSE.)
                 UNDO IF (NLINES .GE. PAGEND)
               ENDIF
              END DO FOREVER
            ENDIF
C
C---   Output new lines
C
            DO FOR I=PAGLEN+1,COMLIN
             CALL LIB$ERASE_LINE(I,1)
            END DO FOR
            CALL LIB$SET_CURSOR(PAGLEN+1,1)
            DO FOR I=OLDEND+1,PAGEND
             IF (LENLMT .GT. 0)
               IF (LINLEN(I) .GE. LENLMT)
                 CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT)//CRLF)
               ELSE
                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)
               ENDIF
             ELSE
               IF (LINLEN(I) .LE. -LENLMT)
                 CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I))//CRLF)
               ELSE
                 CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//
     1                LINES(I)(1-LENLMT:LINLEN(I))//CRLF)
               ENDIF
             ENDIF
            END DO FOR
          ENDIF
        ELSE
          IF (NUMBER .LT. 0)
C
C***   Backward scrolling
C
            DO FOR I=LINEP-NUMBER-1,LINEP,-1
             EXECUTE (SCROLL_DOWN)
             IF (ABS(LENLMT) .GE. LINLEN(I))
               CALL LIB$PUT_SCREEN(LINES(I)(:LINLEN(I)))
             ELSE
               IF (LENLMT .LT. 0)
C
C---   This assumes that LINLEN<=2*LENLMT
C
                 EXECUTE (SCROLL_DOWN)
                 CALL LIB$PUT_SCREEN(LINES(I)(:-LENLMT)//CRLF//
     1                               LINES(I)(1-LENLMT:LINLEN(I)))
               ELSE
                 CALL LIB$PUT_SCREEN(LINES(I)(:LENLMT))
               ENDIF
             ENDIF
            END DO FOR
          ENDIF
          CALL LIB$SET_CURSOR(PAGLEN+1,1)
        ENDIF
        EXECUTE (WRITE_BLOCK_NUMBER)
        EXECUTE (HOME_PLUS_LEDS_EXIT)
      END PROCEDURE
      PROCEDURE (SEARCH_ERROR_EXIT)
CP    This procedure stops execution of a search command with an error.
CP    while restoring the held setup and getting rid of the I/O request
CP    to the terminal
        EXECUTE (CANCEL_STOPPER)
        IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)
        JJ = 1
        DO FOR I=1,10
         UNDO IF (SBFLEN(I) .EQ. 0 .OR. JJ .GT. (IABS(LENLMT) - 58))
         CAPLIN(JJ:) = SRCHBF(I)(:SBFLEN(I))
         JJ = SBFLEN(I) + JJ + 2
        END DO FOR
        IF (JJ .GT. (IABS(LENLMT) - 58)) JJ = IABS(LENLMT) - 58
        CALL LIB$PUT_SCREEN(CAPLIN(:JJ-2)//'  Not found',COMLIN,
     1                      IABS(LENLMT)-JJ-34)
        IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)
        EXECUTE (STOP_WITH_ERROR)
      END PROCEDURE
      PROCEDURE (STOP_WITH_ERROR)
CP    This procedure stops execution of a command with an error exit,
CP    while restoring the held setup and getting rid of the I/O request
CP    to the terminal
        EXECUTE (CANCEL_STOPPER)
        EXECUTE (RESTORE_HELD_SETUP)
        EXECUTE (ERROR_EXIT)
      END PROCEDURE
      PROCEDURE (VAR_BACK_SCROLL_EXIT)
CP    This routine exits from scrolling backwards in non-FIX files.  It
CP    sets the position to the correct place in the buffer, then converts
CP    the rest of the buffer, sets the current line position, resets the
CP    LEDs (#3 off) and returns.
        NBUF = PBUF
        PBUF = I - 1
        EXECUTE (BACK_SCROLL_EXIT)
      END PROCEDURE
      PROCEDURE (WAIT_FOR_SCROLL)
CP    This procedure waits for the scrolling interval to pass.
        CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)
        CALL SYS$WAITFR(%VAL(TIMFLG))
      END PROCEDURE
      PROCEDURE (WAIT_FOR_SCROLL_AST)
CP    This procedure waits for the scrolling interval to pass after
CP    queueing the stop command AST.
        CALL SYS$QIO(%VAL(IOFLAG),%VAL(INCHAN),%VAL('1171'X),IOSB,
     1               STOPSC,,INBUF,%VAL(1),,,,)
        CALL SYS$SETIMR(%VAL(TIMFLG),DELTIM,,)
        CALL SYS$WAITFR(%VAL(TIMFLG))
      END PROCEDURE
      PROCEDURE (WORKING)
CP    This procedure turns on LED 1 and starts up the working message.
        IF (VT100)
          CALL LIB$PUT_SCREEN(CHAR(ESC)//'[0;1q')
          IF (DIRECT .LT. 0) CALL LIB$PUT_SCREEN(CHAR(ESC)//'[2q')
          IF (RANGE(1,1) .NE. 0 .AND. RANGE(1,2) .NE. 0)
     1        CALL LIB$PUT_SCREEN(CHAR(ESC)//'[4q')
        ENDIF
        CALL WORKNG(.TRUE.)
      END PROCEDURE
      PROCEDURE (WRITE_BLOCK_NUMBER)
CP    This procedure scrolls an extra line if needed (if dividing line
CP    (BOX) switch is chosen, and writes out the block number in the
CP    lower right corner.
        IF (PAGLEN .EQ. (COMLIN - 2)) CALL LIB$PUT_SCREEN(CRLF)
        CALL LIB$ERASE_LINE(COMLIN,1)
C
C***   Output block number
C
        IF (VT100A) CALL LIB$PUT_SCREEN(REVVID)
        DO FOR I=LINEP,NLINES
         UNDO IF (CCLINE(1,I) .NE. 0)
        END DO FOR
        WRITE (UNIT=TEMPCH,FMT=2000)CCLINE(1,I)
2000    FORMAT (I5)
        I = LIB$SKPC(' ',TEMPCH)
        CALL LIB$PUT_SCREEN('Block '//TEMPCH(I:),COMLIN,
     1                      IABS(LENLMT)+I-11)
        IF (VT100A) CALL LIB$PUT_SCREEN(REGVID,1,1)
      END PROCEDURE
      END
