C
      SUBROUTINE GCPFT2 (GCP, MGCP, MAXDEG)
C
C     TO FIND GEOMETRIC TRANSFORMATION NEEDED FOR GEOGRAPHIC REFERENCING
C
      DIMENSION GCP(4,MGCP)
      DOUBLE PRECISION COEF(21,4)
      LOGICAL CCT
      INTEGER NTERM(5)/3,6,10,15,21/
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
      COMMON /LSQCFC/ COEF, LSQDEG, IER1(2), TOL
      COMMON / MEANS/ GCPM(4)
C
C     GCP IS GROUND CONTROL POINT TABLE INPUT BY USER
C     1. PIXEL IN MAP DATA
C     2. LINE IN MAP DATA
C     3. PIXEL IN LANDSAT DATA
C     4. LINE IN LANDSAT DATA
C
      IF (CCT) CALL GCPCR2 (GCP, MGCP)
      AMGCP=MGCP
      RADDEG = 180.0/3.14159265
      TOL=1.E-20
      DO 1 I=1,4
    1 GCPM(I) = 0.0
      WRITE (6,101)
      WRITE (6,1020)
C
C     COMPUTE SUMS OF INPUT DATA
      DO 10 J=1,MGCP
      DO 5 I=1,4
    5 GCPM(I) = GCPM(I) + GCP(I,J)
      WRITE (6,102) J, (GCP(I,J), I=1,4)
   10 CONTINUE
C
C     COMPUTE MEANS OF INPUT DATA
      DO 11 I=1,4
   11 GCPM(I) = GCPM(I) / AMGCP
      WRITE (6,104) GCPM
C
C     SUBTRACT MEANS OF INPUT DATA
      WRITE (6,1019)
      WRITE (6,1020)
      DO 13 J=1,MGCP
      DO 12 I=1,4
   12 GCP(I,J) = GCP(I,J) - GCPM(I)
      WRITE (6,102) J, (GCP(I,J), I=1,4)
   13 CONTINUE
C
C     FIND POLYNOMIAL FITS FOR DEGREES 1 - INPUT VALUE OF LSQDEG
      DO 100 LSQDEG=1,MAXDEG
      ISTOP=NTERM(LSQDEG)
      IF (ISTOP.GT.MGCP) GO TO 400
      CALL LSQCF (0, GCP, MGCP)
      WRITE(6,383) LSQDEG,IER1,((COEF(J,I),I=1,4),J=1,ISTOP)
      WRITE(6,111)
      RESPX=0.0
      RESUT=0.0
C
C     PERFORM ACCURACY ANALYSIS OF FIT
      DO 388 I=1,MGCP
      GP=GCP(1,I) + GCPM(1)
      GL=GCP(2,I) + GCPM(2)
      GE=GCP(3,I) + GCPM(3)
      GN=GCP(4,I) + GCPM(4)
C
      CALL EVPOLY(1,GE,GN,ANS)
      DP=GP-ANS
      CALL EVPOLY(2,GE,GN,ANS)
      DL=GL-ANS
      SQ = DP**2 + DL**2
      RESPX = RESPX + SQ
      XMAG = SQRT (SQ)
      XDIR = RADDEG * ATAN2(-DL,DP)
C
      CALL EVPOLY(3,GP,GL,ANS)
      DE=GE-ANS
      CALL EVPOLY(4,GP,GL,ANS)
      DN=GN-ANS
      SQ = DE**2 + DN**2
      RESUT = RESUT + SQ
      UMAG = SQRT (SQ)
      UDIR = RADDEG * ATAN2(DE,DN)
      WRITE (6,109) I, XMAG, XDIR, DP, DL, UMAG, UDIR, DE, DN
388   CONTINUE
C
      AGCP1=MGCP-1
      RESPX = SQRT (RESPX/AGCP1)
      RESUT = SQRT (RESUT/AGCP1)
      WRITE (6,390) RESPX, RESUT
  100 CONTINUE
      LSQDEG = MAXDEG
      RETURN
C
  400 WRITE (6,1100) LSQDEG, ISTOP, MGCP
      LSQDEG = LSQDEG - 1
      RETURN
C
C     FORMAT STATEMENTS.
  101 FORMAT ('1',20X,'GROUND CONTROL POINTS'/)
  102 FORMAT (1X,I4,4F15.3)
  104 FORMAT (///20X,'MEANS OF INPUT DATA ARE'//5X,4F15.3/
     .     '0THESE MEANS ARE FIRST SUBTRACTED')
  109 FORMAT (1X,I3,2(F10.3,F10.1,8X,2F10.3,8X))
  111 FORMAT (/35X,'COMPARISON OF OBSERVED AND PREDICTED VALUES'/
     .25X,'GEOGRAPHIC',45X,'LANDSAT'/15X,'ERROR',20X,'OBS - PRED',20X,
     .'ERROR',20X,'OBS - PRED'/5X,'MAGNITUDE  DIRECTION',10X,'P ERROR
     .L ERROR',10X,'MAGNITUDE  DIRECTION',10X,'E ERROR   N ERROR'/)
  383 FORMAT ('1  LEAST SQUARES FIT OF DEGREE',I3,25X,'ERROR CODES =',
     .2I3/40X,'COEFFICIENTS'/10X,'EAST PIXEL',10X,'NORTH LINE',10X,
     .'PIXEL',15X,'LINE'/(1X,1P4E20.6))
  390 FORMAT (/2(15X,'RMS ERROR =',E13.6,15X))
 1019 FORMAT ('1',7X'CONTROL POINTS AFTER SUBTRACTING MEANS'/)
 1020 FORMAT (18X,'GEOGRAPHIC',22X,'LANDSAT'/18X,'COORDINATES',18X,
     .'COORDINATES'/)
 1100 FORMAT (/20X,'FIT OF DEGREE',I2,' REQUIRES',I3,' GROUND CONTROL PO
     .INTS.',I5,' WERE SUPPLIED.'/)
      END
C
      SUBROUTINE LSQCF (IDEL, GCP, MGCP)
C
C     THIS SUBROUTINE CALCULATES THE LEAST-SQUARES COEFFICIENTS
C     FOR THE BIVARIATE POLYNOMIAL
C
      DIMENSION GCP(4,MGCP)
      DOUBLE PRECISION COEF(21,4), CORE(2500), X(45), B(200), AUX(100),
     .A(2100), S(45), XXX, YYY, AMAX, C
      INTEGER NTERM(5)/3,6,10,15,21/
      INTEGER XP(21)/0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0/
      INTEGER YP(21)/0,0,1,0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,4,5/
      INTEGER IPIV(50),IND1(2)/1,3/,IND2(2)/3,1/
      EQUIVALENCE (CORE(1),X(1)), (CORE(46),B(1)), (CORE(246),AUX(1)),
     .(CORE(346),A(1)), (CORE(2446),S(1))
      COMMON /LSQCFC/ COEF, LSQDEG, IER1(2), TOL
C
C     GCP IS GROUND CONTROL POINT TABLE INPUT BY USER
C     1.  PIXEL WITHIN LINE
C     2.  LINE WITHIN FRAME
C     3.  EASTING
C     4.  NORTHING
C     COEF(21,I)- COEFFICIENTS FOR : 1- PIXEL
C                                    2- LINE
C                                    3- EASTING
C                                    4- NORTHING
      L=MGCP
      L1=MGCP
      IF(IDEL.NE.0) L=MGCP-1
      ISTOP=NTERM(LSQDEG)
      IF (ISTOP.GT.L) RETURN
C
      DO 10 II=1,2
      III=IND1(II)
      IIII=(II-1)*2+1
      IV=IND2(II)
      NGCP1=0
C
      DO 50 NGCP=1,L1
      IF(NGCP.EQ.IDEL) GO TO 50
      NGCP1=NGCP1+1
      B(NGCP1)=GCP(III,NGCP)
      NN=NGCP1+L
      B(NN)=GCP(III+1,NGCP)
      DO 50 I=1,ISTOP
      XXX=1.0D0
      IF(XP(I).NE.0) XXX=GCP(IV,NGCP)**XP(I)
      YYY=1.0D0
      IF(YP(I).NE.0) YYY=GCP(IV+1,NGCP)**YP(I)
      K=(I-1)*L+NGCP1
      A(K)=XXX*YYY
50    CONTINUE
C
C     SCALE THE MATRIX
      DO 70 I=1,ISTOP
      AMAX=0.D0
C
      DO 60 J=1,L
      K=(I-1)*L+J
      C=DABS(A(K))
60    AMAX=DMAX1(AMAX,C)
      IF(AMAX.EQ.0.D0) AMAX=1.D0
C
      DO 70 J=1,L
      K=(I-1)*L+J
      A(K)=A(K)/AMAX
70    S(I)=AMAX
C
      CALL DLLSQ(A,B,L,ISTOP,2,X,IPIV,TOL,IER,AUX)
      IER1(II)=IER
      DO 80 I=1,ISTOP
      J=I+ISTOP
      COEF(I,IIII)=X(I)/S(I)
      COEF(I,IIII+1)=X(J)/S(I)
80    CONTINUE
10    CONTINUE
      RETURN
      END
C
      SUBROUTINE GCPCR2 (GCP, MGCP)
C
C     GCPCR2 REMOVES MIRROR VELOCITY PROFILE AND EARTH CURVATURE
C     DISTORTIONS PRIOR TO OBTAINING LEAST SQUARES FITS
C
C     GCP IS GROUND CONTROL POINT TABLE INPUT BY USER
C
      DIMENSION GCP(4,MGCP)
      REAL*4 MVPOFF
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
C
C     ADD BACK DELAY TO GET ORIGINAL CCT PIXEL NUMBER
      WRITE (6,100)
      DO 10 NGCP = 1,MGCP
      WRITE (6,101) GCP(4,NGCP), GCP(3,NGCP)
      LINE = GCP(4,NGCP) + 0.5
      SAMP = GCP(3,NGCP) + DELAY(LINE)
C
C     APPLY MIRROR VELOCITY PROFILE CORRECTION
      OFF = MVPOFF(SAMP)
      GCP(3,NGCP) = GCP(3,NGCP) - OFF
C
C     APPLY EARTH CURVATURE CORRECTION
      CURV = ERCURV(SAMP-OFF)
      GCP(3,NGCP) = GCP(3,NGCP) - CURV
C
      SAMP0 = SAMP + SAMPOF
      SHIFT = OFF + CURV
      WRITE (6,102) SAMP, SAMP0, OFF, CURV, SHIFT, GCP(3,NGCP)
   10 CONTINUE
      RETURN
C
  100 FORMAT ('1',20X,'GROUND CONTROL POINT CORRECTIONS'//19X,'OFFSET',
     .5X,'ORIGINAL',3X,'CCT SCENE',7X,'MVP',9X,'CURV',8X,'NET',8X,
     .'CORR.'/7X,'RECORD',3(6X,'SAMPLE'),3(7X,'SHIFT'),6X,'OFFSET'/)
  101 FORMAT (1X,2F12.3)
  102 FORMAT ('+',24X,8F12.3)
      END
C
      SUBROUTINE GRDMP2
C
C     GRDMP2 COMPUTES THE INTERPOLATION GRID INTERSECTIONS AND THE
C     INTERPOLATION ERRORS IN INPUT IMAGE COORDINATES
C     THIS ROUTINE IS FOR TRANSFORMATION FROM A MAP (E & N COORDINATES)
C     TO AN IMAGE (P & L COORDINATES).
C     GRID IS COORDINATES (UTM & PIXEL) OF HORIZONTAL & VERTICAL GRID
C     INTERSECTIONS
C
      DIMENSION GRIDPL(2,30), GRIDEN(2,30,30), NUMPXC(30), CPXVAL(30),
     .NUMLNC(30), ERRCEL(29)
      LOGICAL*1 CELLCG(29,29)
      REAL LINE, LCEN, MVPOFF, MVP
      COMMON /PIXDAT/ NLINPX, NPIXLN, NHGL, NVGL, SRATE, NLPI, NSPL,
     .                KDUM, INTERP, NB
      COMMON /MAPDAT/ STRTL, STOPL, STRTP, STOPP
      COMMON /  GRID/ GRIDPL, GRIDEN, NUMPXC, CPXVAL, NUMLNC, CELLCG
C
C     COMPUTE NUMBER OF OUTPUT LINES AND SAMPLES
      NLPI = STOPL - STRTL + 1.5
      NSPL = STOPP - STRTP + 1.5
C
C     FIND MAXIMUM AND MINIMUM OFFSET COORDINATES
      DLYMIN = 10000.0
      DLYMAX = 0.0
      DO 55 NR=1,6
      DLYMIN = AMIN1 (DLYMIN, DELAY(NR))
   55 DLYMAX = AMAX1 (DLYMAX, DELAY(INT(STOPL)+1-NR))
      STRTP = STRTP - DLYMAX
      STOPP = STOPP - DLYMIN
C
C     COMPUTE GX AND GY GRID SPACING
      NHGL1=NHGL-1
      NVGL1=NVGL-1
      GX = (STOPP-STRTP) / NVGL1
      GY = (STOPL-STRTL) / NHGL1
C
C     CALCULATE GRID INTERSECTIONS BY STEPPING THROUGH IMAGE GRID AND
C     TRANSFORMING TO UTM MAP OR GEOGRAPHIC COORDINATES
        DO 1010 I=1,NVGL
        GRIDPL(1,I) = STRTP + (I-1)*GX
C
          DO 1000 J=1,NHGL
          GRIDPL(2,J) = STRTL + (J-1)*GY
C
C         APPLY MIRROR VELOCITY AND EARTH CURVATURE CORRECTIONS
C         TO GET PIXEL GROUND LOCATION
          LINE = GRIDPL(2,J)
          PIXCCT = GRIDPL(1,I) + DELAY(INT(LINE+0.5))
          MVP = MVPOFF(PIXCCT)
          CRV = ERCURV(PIXCCT-MVP)
          PIX = GRIDPL(1,I) - MVP - CRV
C
          CALL EVPOLY (1, PIX, LINE, PE)
          CALL EVPOLY (2, PIX, LINE, PN)
C
          GRIDEN(1,J,I) = PE
          GRIDEN(2,J,I) = PN
 1000     CONTINUE
 1010   CONTINUE
C
      WRITE (6,1050)
      DO 1011 J=1,NHGL
 1011 WRITE (6,1051) (GRIDEN(1,J,K), GRIDEN(2,J,K), GRIDPL(1,K),
     .GRIDPL(2,J), K=1,NVGL)
C
C     COMPUTE AND PRINT FINAL GRID ERRORS
      ERRMAX = 0.0
      WRITE (6,1065)
        DO 1030 I4=2,NHGL
        I41=I4-1
          DO 1020 J4=2,NVGL
          J41=J4-1
C
C         COMPUTE MAP COORDINATES BY BILINEAR INTERPOLATION IN A CELL
          PEB = (GRIDEN(1,I4,J4)+GRIDEN(1,I41,J4)+GRIDEN(1,I41,J41)
     .    +GRIDEN(1,I4,J41)) / 4.0
          PNB = (GRIDEN(2,I4,J4)+GRIDEN(2,I41,J4)+GRIDEN(2,I41,J41)
     .    +GRIDEN(2,I4,J41)) / 4.0
C
C         COMPUTE CENTER PIXEL AND LINE
          PCEN = (GRIDPL(1,J4)+GRIDPL(1,J41)) / 2.0
          LCEN = (GRIDPL(2,I4)+GRIDPL(2,I41)) / 2.0
C
C         APPLY MIRROR VELOCITY AND EARTH CURVATURE CORRECTIONS
C         TO GET PIXEL GROUND LOCATION
          PCNCCT = PCEN + DELAY(INT(LCEN+0.5))
          MVP = MVPOFF(PCNCCT)
          CRV = ERCURV(PCNCCT-MVP)
          PCEN = PCEN - MVP - CRV
C
C         COMPUTE MAP COORDINATES BY FUNCTION
          CALL EVPOLY (1, PCEN, LCEN, PE)
          CALL EVPOLY (2, PCEN, LCEN, PN)
C
C         COMPUTE ERROR
          ERR=SQRT((PEB-PE)**2+(PNB-PN)**2)
          ERRCEL(J41) = ERR
          ERRMAX = AMAX1 (ERRMAX, ERR)
 1020     CONTINUE
        WRITE (6,1070) (ERRCEL(J), J=1,NVGL1)
 1030   CONTINUE
      WRITE (6,1060) ERRMAX
C
C     COMPUTE TABLE OF FIRST OUTPUT LINE NUMBER IN EACH CELL
      NUMLNC(1) = 1
      DO 1039 J=2,NHGL1
 1039 NUMLNC(J) = GRIDPL(2,J) - GRIDPL(2,1) + 2.0
      NUMLNC(NVGL) = NLPI + 1
      RETURN
C
 1050 FORMAT ('1',30X,'INTERPOLATION GRID INTERSECTIONS'/31X,32('*')//
     .10X,'EAST PIXEL',10X,'NORTH LINE',14X,'PIXEL',16X,'LINE')
 1051 FORMAT (/(4F20.3))
 1060 FORMAT (//21X,'MAXIMUM GRID ERROR =',1PE10.2,'  PIXELS')
 1065 FORMAT ('1',20X,'MAGNITUDE OF INTERPOLATION ERROR AT GRID CELL CEN
     .TERS'/21X,53('*'))
 1070 FORMAT (/(1P13E10.2))
      END
C
      SUBROUTINE CELMP2 (CORE)
C
C     *COMPUTE DIMENSIONS OF INPUT ARRAY WHICH CAN BE HELD IN CORE AT A
C      TIME AND NUMBER OF PARTITIONS REQUIRED.
C     PIX AND ROW VARIABLES HAVE DIRECTIONS APPENDED, E.G. PIXNW IS
C     NORTHWEST CORNER PIXEL OF A CELL
C
      INTEGER ROWNW, PIXNW, ROWNE, PIXNE, ROWSE, PIXSE, ROWSW, PIXSW,
     .RN, RS, SW, SE, R1, R2, S1, S2, CORE, RSTRT
      DIMENSION GRIDPL(2,30), GRIDEN(2,30,30), NUMPXC(30), CPXVAL(30),
     .NUMLNC(30)
      LOGICAL*1 CELLCG(29,29)
      COMMON /PIXDAT/ NLINPX, NPIXLN, NHGL, NVGL, SRATE, NLPI, NSPL,
     .                KDUM, INTRP, NB
      COMMON /  GRID/ GRIDPL, GRIDEN, NUMPXC, CPXVAL, NUMLNC, CELLCG
      COMMON /SEGMNT/ NCGP, NBSAM(10), NBLIN(10), NSTRT(10),
     .                RSTRT(29,10)
C
C     INITIALIZE CELL COLUMN GROUP INDICATOR (CELLCG)
      NHGL1 = NHGL - 1
      NVGL1 = NVGL - 1
      DO 1100 I=1,NHGL1
      DO 1100 J=1,NVGL1
 1100 CELLCG(I,J) = 255
C
C     FIND NCGP, THE NUMBER OF COLUMN GROUPS.
C     S1 IS FIRST INPUT PIXEL FOR THIS COLUMN GROUP
      NCGP = 0
      S1 = 1
C
C     START A NEW COLUMN GROUP OR SEGMENT
 1800 CONTINUE
      NCGP = NCGP + 1
      MINNC = 1000000
C
C     LOOP OVER CELL ROWS
      DO 2100 I=1,NHGL1
      R1 = 1000000
      R2 = 0
      S2 = 0
C
C         LOOP OVER CELLS FOR THIS SEGMENT
          DO 2000 J=1,NVGL1
          IF (CELLCG(I,J).NE.255) GO TO 2000
C
C         FIND RANGE OF IMAGE COORDINATES REQUIRED FOR THE OUTPUT CELL
          ROWNW = GRIDEN(2,I,J) + 0.5
          PIXNW = GRIDEN(1,I,J) + 0.5
          ROWNE = GRIDEN(2,I,J+1) + 0.5
          PIXNE = GRIDEN(1,I,J+1) + 0.5
          ROWSE = GRIDEN(2,I+1,J+1) + 0.5
          PIXSE = GRIDEN(1,I+1,J+1) + 0.5
          ROWSW = GRIDEN(2,I+1,J) + 0.5
          PIXSW = GRIDEN(1,I+1,J) + 0.5
          RN = MAX0 (MIN0(ROWNW,ROWNE), 1)
          RS = MIN0 (MAX0(ROWSW,ROWSE), NLINPX)
          SW = MAX0 (MIN0(PIXNW,PIXSW), 1)
          SE = MIN0 (MAX0(PIXNE,PIXSE), NPIXLN)
C
C         CHECK FOR IMAGE COORDINATES OUTSIDE THE INPUT IMAGE
          IF (RN.GT.NLINPX.OR.RS.LT.1.OR.SW.GT.NPIXLN.OR.SE.LT.1)
     .    GO TO 1920
C
C           FIND RANGE OF IMAGE COORDINATES FOR THIS ROW OF CELLS AND
C           FIND NO. OF OUTPUT CELLS THAT CAN BE FILLED GIVEN CORE LIMIT
            R1 = MIN0 (R1, RN)
            R2 = MAX0 (R2, RS)
            S2 = MAX0 (S2, SE)
            NR = R2 - R1 + 1
            NC = S2 - S1 + 1
            IF (NR*NC.LE.CORE) GO TO 1950
C
C           CORE REQUIRED EXCEEDS THAT AVAILABLE
C           GO TO NEXT ROW OF CELLS
            MINNC = MIN0 (NCSAVE, MINNC)
            CELLCG(I,J) = 222
            GO TO 2100
C
 1920     CELLCG(I,J) = 0
          GO TO 2000
C
C           CORE IS AVAILABLE.  SAVE REQUIRED DIMENSIONS.
 1950       NCSAVE = NC
 2000     CONTINUE
 2100 CONTINUE
C
      LASTPX = S1 + MINNC - 1
      IF (LASTPX.LT.NPIXLN) GO TO 2110
      LASTPX = NPIXLN
      MINNC = NPIXLN - S1 + 1
 2110 CONTINUE
C
C     NOW USE NUMBER OF INPUT COLUMNS AVAILABLE TO SET CELL SEGMENT
C     INDICATORS AND TO FIND ROW AND COLUMN INFORMATION
      MINS1 = 1000000
C
C     LOOP OVER CELL ROWS
      DO 2150 I=1,NHGL1
      IC1 = 100
      IC2 = 0
      RSTRT(I,NCGP) = 0
C
C         LOOP OVER CELLS
          DO 2130 J=1,NVGL1
C
C         CHECK WHETHER THE CELL REQUIRES INPUT OUTSIDE OF THE IMAGE
          IF (CELLCG(I,J).EQ.0) GO TO 2126
C
C         JUMP OUT IF THE CELL REQUIRES TOO MUCH CORE.
          IF (CELLCG(I,J).EQ.222) GO TO 2140
C
C         IF THE CELL USES INPUT DATA, CHECK FOR THE LAST PIXEL
          IF (CELLCG(I,J).EQ.255) GO TO 2125
          GO TO 2130
C
C         JUMP OUT IF THE CELL REQUIRES SAMPLES PAST LASTPX.
 2125     PIXNE = GRIDEN(1,I,J+1) + 0.5
          PIXSE = GRIDEN(1,I+1,J+1) + 0.5
          SE = MIN0 (MAX0(PIXNE,PIXSE), NPIXLN)
          IF (SE.GT.LASTPX) GO TO 2140
C
C         FIND FIRST AND LAST CELLS THAT USE INPUT DATA
          IC1 = MIN0 (J, IC1)
          IC2 = MAX0 (J, IC2)
C
C         ELSE SET COLUMN GROUP INDICATOR TO GROUP NUMBER.
          CELLCG(I,J) = NCGP
          GO TO 2130
C
 2126     CELLCG(I,J) = NCGP + 100
 2130     CONTINUE
C
C         FIND FIRST INPUT ROW FOR THIS ROW OF CELLS
 2140     IF (IC2.EQ.0) GO TO 2150
          ROWNW = GRIDEN(2,I,IC1) + 0.5
          ROWNE = GRIDEN(2,I,IC2+1) + 0.5
          RN = MAX0 (MIN0(ROWNW,ROWNE), 1)
          RSTRT(I,NCGP) = RN
C
C         FIND STARTING INPUT COLUMN FOR NEXT SEGMENT
          IF (J.EQ.NVGL) GO TO 2150
          NEXTCL = IC2 + 1
          PIXNW = GRIDEN(1,I,NEXTCL) + 0.5
          PIXSW = GRIDEN(1,I+1,NEXTCL) + 0.5
          SW = MAX0 (MIN0(PIXNW,PIXSW), 1)
          MINS1 = MIN0 (SW, MINS1)
C
C         SET INDICATOR FOR STARTING CELL IN NEXT SEGMENT
          DO 2145 J=NEXTCL,NVGL1
 2145     CELLCG(I,J) = 255
 2150 CONTINUE
C
C     SET PARAMETERS OF INPUT DATA SEGMENT
      MAXNR = MIN0 (CORE/MINNC, NLINPX)
      NBSAM(NCGP) = MINNC
      NBLIN(NCGP) = MAXNR
      NSTRT(NCGP) = S1
      S1 = MINS1
C
C     IF ALL CELLS NOT DONE, START A NEW SEGMENT
      IF (LASTPX.LT.NPIXLN) GO TO 1800
C
      WRITE (6,100)
      DO 2160 I=1,NHGL1
 2160 WRITE (6,101) (CELLCG(I,J), J=1,NVGL1)
      RETURN
C
  100 FORMAT (///5X,'COLUMN GROUP NUMBERS FOR THE GRID CELLS'/5X,
     .39('*')/)
  101 FORMAT (5X,29I2)
      END
C
      SUBROUTINE RECTF2 (INPIX, PIXEL, PIXOUT)
C
C     HANDLE READING AND WRITING OF DATA RECORDS
C     CALL NEAREST NEIGHBOR RESAMPLING ROUTINE
C     EACH OUTPUT LINE IS SHIFTED TO THE OFFSET IMAGE COORDINATES
C     TO MATCH THE INTERPOLATION GRID.
C
      LOGICAL*1 INPIX(1), PIXEL(1), PIXOUT(NSPL), CELLCG(29,29)
      DIMENSION GRDOUT(2,30), GRIDIN(2,30,30), NUMPXC(30), CPXVAL(30),
     .NUMLNC(30)
      INTEGER*2 MNDEX(1000)
      INTEGER SAMPSG(29,10), RSTRT, PSTRT, SAMP0
      COMMON /PIXDAT/ NLINPX, NPIXLN, NHGL, NVGL, SRATE, NLPI, NSPL,
     .                KDUM, INTERP, NB
      COMMON /  GRID/ GRDOUT, GRIDIN, NUMPXC, CPXVAL, NUMLNC, CELLCG
      COMMON /SEGMNT/ NCGP, NBSAM(10), NBLIN(10), PSTRT(10),
     .                RSTRT(29,10)
      COMMON / PIXIN/ MAXSP, MAXLN, MNDEX, SAMP0, LINE0
      COMMON / TRANS/ TRANIO(6)
      EQUIVALENCE (NPIX,TRANIO(5)), (ISAMP,TRANIO(6))
C
      NHGL1 = NHGL - 1
      NVGL1 = NVGL - 1
C
C     LOOP OVER COLUMN GROUPS
      DO 1020 ICGP=1,NCGP
      MAXSP = NBSAM(ICGP)
      MAXLN = NBLIN(ICGP)
      SAMP0 = PSTRT(ICGP)
      LUNIT = ICGP + 20
      REWIND LUNIT
      CALL LOADLN (.TRUE., 1, MAXLN, INPIX, PIXEL)
C
C       LOOP OVER OUTPUT IMAGE CELLS
      DO 1010 IGY1=1,NHGL1
      IGY2 = IGY1 + 1
      LSTRT = NUMLNC(IGY1)
      LSTOP = NUMLNC(IGY2) - 1
C
C     LOAD LINES OF INPUT NECESSARY FOR RESAMPLED LINE
      LMIN = RSTRT(IGY1,ICGP)
      IF (LMIN.EQ.0) GO TO 150
      LMAX = MIN0 (LMIN+MAXLN-1, NLINPX)
      CALL LOADLN (.FALSE., LMIN, LMAX, INPIX, PIXEL)
C
C         LOOP OVER OUTPUT IMAGE LINES IN THE CELL
  150 DO 1000 ILINE=LSTRT,LSTOP
      OUTLIN = GRDOUT(2,1) + ILINE - 1
C
C         COMPUTE OFFSET COORDINATE OF FIRST CCT PIXEL IN THE GRID
          OFF1 = 1.0 - DELAY(ILINE)
C
C         FIND STARTING SAMPLE NUMBERS AND COORDINATES FOR EACH CELL
          NUMPXC(1) = 1
          CPXVAL(1) = OFF1
          DO 200 J=2,NVGL1
          NUMPXC(J) = GRDOUT(1,J) - OFF1 + 2.0
          IF (NUMPXC(J).LT.1) NUMPXC(J) = 1
          IF (NUMPXC(J).GT.NSPL+1) NUMPXC(J) = NSPL + 1
  200     CPXVAL(J) = OFF1 + NUMPXC(J) - 1
          NUMPXC(NVGL) = NSPL + 1
C
C     LOOP OVER GRID CELLS COVERING OUTPUT AREA
      ISAMP = 0
      DO 300 IGX1 = 1,NVGL1
      IGX2=IGX1+1
C
C     FIND NUMBER OF OUTPUT PIXELS IN THE CELL
      NPIX = NUMPXC(IGX2) - NUMPXC(IGX1)
      IF (NPIX.EQ.0) GO TO 300
C
C     CHECK FOR CELLS NOT REQUIRING INPUT DATA
      IF (CELLCG(IGY1,IGX1).EQ.ICGP+100) GO TO 250
      IF (CELLCG(IGY1,IGX1).EQ.ICGP) GO TO 210
      GO TO 300
C
C     LOAD OUTPUT COORDINATES OF GRID CELL CORNERS
  210 AX = GRDOUT(1,IGX1)
      AY = GRDOUT(2,IGY1)
      BX = GRDOUT(1,IGX2)
      CY = GRDOUT(2,IGY2)
C
C     LOAD INPUT COORDINATES OF GRID CELL CORNERS
      AS = GRIDIN(1,IGY1,IGX1)
      AL = GRIDIN(2,IGY1,IGX1)
      BS = GRIDIN(1,IGY1,IGX2)
      BL = GRIDIN(2,IGY1,IGX2)
      CS = GRIDIN(1,IGY2,IGX1)
      CL = GRIDIN(2,IGY2,IGX1)
      DS = GRIDIN(1,IGY2,IGX2)
      DL = GRIDIN(2,IGY2,IGX2)
C
C     COMPUTE FRACTIONAL CELL DISTANCE ALONG OUTPUT Y AXIS
            ACRATO = (AY-OUTLIN) / (AY-CY)
C
C     COMPUTE INTERPOLATED SAMPLE AND LINE VALUES AT CELL EDGES
      QS=AS+ACRATO*(CS-AS)
      QL=AL+ACRATO*(CL-AL)
      RS=BS+ACRATO*(DS-BS)
      RL=BL+ACRATO*(DL-BL)
C
C     COMPUTE SLOPE WITHIN THE CELL FOR SAMPLES AND LINES
      DELTAX = BX - AX
      TRANIO(3) = (RS-QS) / DELTAX
      TRANIO(4) = (RL-QL) / DELTAX
C
C     FIND INPUT COORDINATES OF FIRST POINT IN THIS GRID CELL
      UX1 = CPXVAL(IGX1) - AX
      TRANIO(1) = QS + UX1*TRANIO(3)
      TRANIO(2) = QL + UX1*TRANIO(4)
C
C     INTERPOLATE IMAGE DATA
            CALL NN2 (PIXEL, PIXOUT)
            GO TO 300
C
C     FILL IN THE CELL NOT REQUIRING INPUT DATA
  250 DO 255 I=1,NPIX
      ISAMP = ISAMP + 1
  255 PIXOUT(ISAMP) = KDUM
  300 CONTINUE
C
C     WRITE THE LINE SEGMENT OUT
      IF (NCGP.EQ.1) GO TO 500
      IF (ISAMP.EQ.0) GO TO 1005
      WRITE (LUNIT) ISAMP
      CALL WRITAR (LUNIT, PIXOUT, ISAMP)
      GO TO 1000
C
  500 WRITE (11) PIXOUT
1000  CONTINUE
      GO TO 1010
C
 1005 SAMPSG(IGY1,ICGP) = 0
 1010 CONTINUE
C
      REWIND LUNIT
      WRITE (6,100) LSTOP, ICGP
 1020 CONTINUE
C
C     ASSEMBLE AND WRITE OUTPUT IMAGE
      IF (NCGP.EQ.1) RETURN
      DO 1050 IGY1=1,NHGL1
      LSTRT = NUMLNC(IGY1)
      LSTOP = NUMLNC(IGY1+1) - 1
C
C     ASSEMBLE AND WRITE OUT THE LINE SEGMENTS
      DO 1040 ILINE=LSTRT,LSTOP
      NS = 1
      DO 1030 ICGP=1,NCGP
      IF (SAMPSG(IGY1,ICGP).EQ.0) GO TO 1030
      LUNIT= ICGP + 20
      READ (LUNIT) NSAMP
      CALL READAR (LUNIT, PIXOUT(NS), NSAMP)
      NS = NS + NSAMP
 1030 CONTINUE
 1040 WRITE (11) PIXOUT
 1050 CONTINUE
      RETURN
C
  100 FORMAT ('   FINISHED RESAMPLING',I5,' RECORDS IN COLUMN GROUP',I3)
      END
C
      SUBROUTINE NN2 (PIXEL, PIXOUT)
C
C     PERFORM NEAREST NEIGHBOR INTERPOLATION
C
      LOGICAL*1 PIXEL(NBSAM,MAXLN), PIXOUT(1)
      INTEGER SAMP0, SLR
      INTEGER*2 MNDEX(1000)
      COMMON /PIXDAT/ NLINPX, NPIXLN, NHGL, NVGL, SRATE, NLPI, NSPL,
     .                KDUM, INTERP, NB
      COMMON / PIXIN/ NBSAM, MAXLN, MNDEX, SAMP0, LINE0
      COMMON / TRANS/ TRANIO(6)
      EQUIVALENCE (NPIX,TRANIO(5)), (ISAMP,TRANIO(6))
C
      PSI = TRANIO(1) - SAMP0 + 1
      PLI = TRANIO(2) - LINE0 + 1
      SPACE1 = TRANIO(3)
      SPACE2 = TRANIO(4)
C
        DO 1050 I=1,NPIX
        ISAMP = ISAMP + 1
        DE = I-1
        IPL = PLI + DE*SPACE2 + 0.5
        IF (IPL.LT.1.OR.IPL.GT.MAXLN) GO TO 1030
C
        IPS = PSI + DE*SPACE1 + 0.5
        IF (IPS.LT.1.OR.IPS.GT.NBSAM) GO TO 1030
C
        SLR = MNDEX(IPL)
        PIXOUT(ISAMP) = PIXEL(IPS,SLR)
        GO TO 1050
C
 1030 PIXOUT(ISAMP) = KDUM
 1050   CONTINUE
      RETURN
      END
C
      SUBROUTINE LOADLN (FIRST, LMIN, LMAX, INPIX, PIXEL)
C
C     THIS SUBROUTINE LOADS ARRAY 'PIXEL' WITH INPUT IMAGE LINES
C     LMIN THROUGH LMAX. IT FIRST CHECKS WHICH LINES ARE ALREADY
C     LOADED (L1 THROUGH L2) TO DETERMINE WHICH LINES CAN BE LEFT
C     IN MEMORY AND WHICH MUST BE READ.
C     LNDEX(I) IS THE LINE NUMBER OF DATA STORED IN PIXEL(*,I)
C     MNDEX(L) IS STORAGE LOCATION OF LINE NUMBER 'L'
C     IPOSN IS THE LINE NUMBER TAPE IS POSITIONED AT
C
      LOGICAL*1 INPIX(NB,NPIXLN), PIXEL(NB,NBSAM,MAXLN)
      INTEGER*2 LNDEX(1000),MNDEX(1000), SAMP0*4
      LOGICAL EOF, FIRST
      COMMON /PIXDAT/ NLINPX, NPIXLN, NHGL, NVGL, SRATE, NLPI, NSPL,
     .                KDUM, INTERP, NB
      COMMON / PIXIN/ NBSAM, MAXLN, MNDEX, SAMP0, LINE0
C
C     INITIALIZE BY CALLING LAST LINE IN CORE LINE '0'
      IF (.NOT.FIRST) GO TO 200
      NBSAM4 = NB*NBSAM
      REWIND 10
      EOF = .FALSE.
      IPOSN = 1
      L2 = MAXLN
      L1 = 1
      LNDEX(L1)=1-MAXLN
      LNDEX(L2)=0
      GO TO 1200
C
C     JFIRST, JLAST - FIRST AND LAST LINES ALREADY LOADED
  200 IF (EOF) RETURN
      JFIRST=LNDEX(L1)
      JLAST=LNDEX(L2)
      IF(LMIN.GE.JFIRST) GO TO 211
      WRITE(6,190) LMIN,LMAX,JFIRST,JLAST
      STOP 41
C
C     NLINRD - NUMBER OF LINES REQUIRED TO FILL IN FROM JLAST TO LMAX
C     JNEW   - NEW FIRST LINE AFTER LOADING NLINRD LINES FROM JFIRST
211   CONTINUE
      NLINRD=LMAX-JLAST
      JNEW=JFIRST+NLINRD
      IF(NLINRD.LE.0) GO TO 1200
      IF(NLINRD.GE.MAXLN) GO TO 300
C
C     FIND INDEX OF LINE JNEW (I)
C     LMINX1 - INDEX OF LAST LINE TO BE READ IN (I-1)
      DO 210 I=1,MAXLN
      IF(LNDEX(I).NE.JNEW) GO TO 210
      LMINX1 = I - 1
      IF(LMINX1.LE.0)LMINX1=MAXLN
      GO TO 220
  210 CONTINUE
  220 CONTINUE
      IF(L1.GT.LMINX1) GO TO 240
C
C *** CASE 1 - LOAD DATA FROM L1 TO LMINX1
      DO 230 I=L1,LMINX1
      READ (10,END=1300,ERR=1400) INPIX
      CALL MVL (INPIX(1,SAMP0), PIXEL(1,1,I), NBSAM4)
      LNDEX(I)=IPOSN
      IPOSN = IPOSN + 1
  230 CONTINUE
      L1 = LMINX1 + 1
      L2 = LMINX1
      IF(L1.GT.MAXLN) L1 =1
      GO TO 1000
C
C *** CASE 2 - LOAD DATA FROM L1 THROUGH MAXLN AND 1 THROUGH LMINX1
  240 DO 250 I = L1,MAXLN
      READ (10,END=1300,ERR=1400) INPIX
      CALL MVL (INPIX(1,SAMP0), PIXEL(1,1,I), NBSAM4)
      LNDEX(I) = IPOSN
      IPOSN = IPOSN + 1
  250 CONTINUE
      DO 260 I = 1,LMINX1
      READ (10,END=1300,ERR=1400) INPIX
      CALL MVL (INPIX(1,SAMP0), PIXEL(1,1,I), NBSAM4)
      LNDEX(I) = IPOSN
      IPOSN = IPOSN + 1
  260 CONTINUE
      L1 = LMINX1 + 1
      L2 = LMINX1
      GO TO 1000
C
C *** CASE 3 - NO OVERLAP OF OLD AND NEW DATA
C     POSITION TAPE
  300 IF(IPOSN.EQ.JNEW)GO TO 320
      READ (10,END=1300,ERR=1400)
      IPOSN =IPOSN + 1
      GO TO 300
  320 DO 330 I=1,MAXLN
      READ (10,END=1300,ERR=1400) INPIX
      CALL MVL (INPIX(1,SAMP0), PIXEL(1,1,I), NBSAM4)
      LNDEX(I) = IPOSN
      IPOSN = IPOSN + 1
  330 CONTINUE
      L1 = 1
      L2  = MAXLN
C
C     LOAD STORAGE LOCATIONS INTO ELEMENT OF MNDEX EQUAL TO LINE NUMBER
C     LINE0 - FIRST IMAGE LINE HELD IN CORE
C     MX    - STORAGE LINE NUMBER AT IMAGE LINE LNDEX(I)
 1000 LINE0 = LNDEX(L1)
      DO 1100 I = 1,MAXLN
      MX = LNDEX(I) - LINE0 + 1
      MNDEX(MX) = I
 1100 CONTINUE
 1200 CONTINUE
      RETURN
C
 1300 EOF = .TRUE.
      WRITE(6,1301) IPOSN
      STOP 41
 1400 WRITE (6,1401) IPOSN
      STOP 43
C
190   FORMAT(1H0,'ERROR: BACKWARD READ REQUESTED',4I10)
1301  FORMAT(1H0,'EOF AT LINE ',I5)
1401  FORMAT(1H0,'READ ERROR AT LINE',I5)
      END
C
      SUBROUTINE EVPOLY (IFUN, X, Y, ANS)
C
C     EVALUATE POLYNOMIAL FIT FUNCTIONS
C
      DOUBLE PRECISION COEF(21,4), ANSD, XD, YD, XXX, YYY
      INTEGER NTERM(5)/3,6,10,15,21/
      INTEGER XP(21)/0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0/
      INTEGER YP(21)/0,0,1,0,1,2,0,1,2,3,0,1,2,3,4,0,1,2,3,4,5/
      COMMON /LSQCFC/ COEF, LSQDEG, IER1(2), TOL
      COMMON / MEANS/ GCPM(4)
C
C     COEF(21,I)- COEFFICIENTS FOR : 1- PIXEL
C                                    2- LINE
C                                    3- EASTING
C                                    4- NORTHING
      ISTOP = NTERM(LSQDEG)
      ANSD = 0.0
      IF (IFUN.EQ.3.OR.IFUN.EQ.4) GO TO 1
      XD = X - GCPM(3)
      YD = Y - GCPM(4)
      GO TO 5
    1 XD = X - GCPM(1)
      YD = Y - GCPM(2)
    5 CONTINUE
C
      DO 10 I=1,ISTOP
      XXX = 1.0
      IF (XP(I).NE.0) XXX = XD**XP(I)
      YYY = 1.0
      IF (YP(I).NE.0) YYY = YD**YP(I)
   10 ANSD = ANSD + COEF(I,IFUN)*XXX*YYY
C
      ANS = ANSD + GCPM(IFUN)
      RETURN
      END
C
      FUNCTION DELAY (LINE)
C
C     COMPUTE ROTATIONAL AND SENSOR DELAY RELATIVE TO FIRST SWATH
C
C     DEGCEN - LATITUDE AT THE CENTER OF THE LANDSAT SCENE
C     PIXDLY - EQUATORIAL EARTH ROTATION PER SWATH IN PIXELS
C     DEGPLN - CHANGE IN LATITUDE PER SCAN LINE
C     RADDEG - RADIANS PER DEGREE
C     SDELAY - SENSOR SAMPLING INTERVAL BETWEEN LINES (2) / TOTAL NUMBER
C              OF DETECTORS (25)
C     LINESW - LINE NUMBER IN THE SWATH (1 - 6)
C
      DIMENSION SDELAY(6)
      INTEGER CCTLIN, SWATH
      LOGICAL CCT
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
      DATA PIXDLY, DEGPLN, RADDEG, SDELAY /0.6, 0.00071086, 0.01745329,
     .0.0, 0.08, 0.16, 0.24, 0.32, 0.40/
C
      IF (CCT) GO TO 10
      DELAY=0.0
      RETURN
C
   10 CONTINUE
      CCTLIN = LINE + LINOFF
      DEGLAT = DEGCEN + (1170.5-CCTLIN) * DEGPLN
      RDELAY = PIXDLY * COS (DEGLAT*RADDEG)
      SWATH = (CCTLIN-1)/6 + 1
      LINESW = MOD(CCTLIN-1,6) + 1
      DELAY = RDELAY*(SWATH-1) - SDELAY(LINESW)
      RETURN
      END
C
      REAL FUNCTION MVPOFF (PS)
C
C     COMPUTE MIRROR VELOCITY PROFILE OFFSET
C
C     LLC - NUMBER OF PIXELS IN THE RAW SCAN LINE
C     SAMPOF - NUMBER OF PIXELS SKIPPED IN THE LANDSAT SCENE
C     AMPL, PHASE - AMPLITUDE, PHASE OF MIRROR VELOCITY PROFILE CURVE
C
      LOGICAL CCT
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
C
      IF (CCT) GO TO 12
      MVPOFF = 0.0
      RETURN
C
   12 CONTINUE
      PS1 = PS + SAMPOF
      MVPOFF = AMPL * SIN (6.2831853 * (PS1+PHASE-1.0) / (LLC-1))
      RETURN
      END
C
      REAL FUNCTION MVPINV (PS)
C
C     COMPUTE NEGATIVE MIRROR VELOCITY PROFILE CORRECTION
C
C     LLC - NUMBER OF PIXELS IN THE RAW SCAN LINE
C     SAMPOF - NUMBER OF PIXELS SKIPPED IN THE LANDSAT SCENE
C     AMPL, PHASE - AMPLITUDE, PHASE OF MIRROR VELOCITY PROFILE CURVE
C
      LOGICAL CCT
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
C
      IF (CCT) GO TO 10
      MVPINV = 0.0
      RETURN
C
   10 CONTINUE
      PS1 = PS + SAMPOF
      MVPINV = AMPL * SIN (6.2831853 * (PS1+PHASE-1.0) / (LLC-1))
      RETURN
      END
C
      FUNCTION ERCURV (PS)
C
C     COMPUTE EARTH CURVATURE CORRECTION
C
C     RE, RSAT - EARTH RADIUS, SATELLITE ORBIT RADIUS
C     TFOV - TOTAL FIELD OF VIEW OF THE SCANNER (11.56 DEGREES)
C     LLC  - NUMBER OF PIXELS IN THE RAW SCAN LINE
C     SAMPOF - NUMBER OF PIXELS SKIPPED IN THE LANDSAT SCENE
C
      LOGICAL CCT
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
      DATA RE, RSAT, TFOV /6367.4, 7285.6, 0.20176/
C
      IF (CCT) GO TO 10
      ERCURV = 0.0
      RETURN
C
C     COMPUTE SCANNER ANGLE AT PIXEL NO. PS AND ANGLE SUBTENDED AT
C     THE CENTER OF THE EARTH
   10 CONTINUE
      TFOV2 = TFOV/2.0
      PS1 = PS + SAMPOF
      ANGSCN = (PS1-1.0)*TFOV/(LLC-1) - TFOV2
      ANGERT = ARSIN(SIN(ANGSCN)*RSAT/RE) - ANGSCN
      TOTERT = ARSIN (SIN(TFOV2)*RSAT/RE) - TFOV2
C
C     FIND SCANNER ANGLE BASED ON FRACTION OF TOTAL ARC ON THE EARTH'S
C     SURFACE AND CONVERT TO PIXEL NUMBER
      ANGSC1 = TFOV2 * ANGERT / TOTERT
      PS2 = 1.0 + (ANGSC1+TFOV2) * (LLC-1) / TFOV
      ERCURV = PS1 - PS2
      RETURN
      END
C
      FUNCTION ERCURI (PS)
C
C     COMPUTE EARTH CURVATURE DE-CORRECTION
C
C     RE, RSAT - EARTH RADIUS, SATELLITE ORBIT RADIUS
C     TFOV - TOTAL FIELD OF VIEW OF THE SCANNER (11.56 DEGREES)
C     LLC  - NUMBER OF PIXELS IN THE RAW SCAN LINE
C     SAMPOF - NUMBER OF PIXELS SKIPPED IN THE LANDSAT SCENE
C
      LOGICAL CCT
      COMMON /LANDST/ CCT, LLC, DEGCEN, SAMPOF, LINOFF, AMPL, PHASE
      DATA RE, RSAT, TFOV /6367.4, 7285.6, 0.20176/
C
      IF (CCT) GO TO 10
      ERCURI = 0.0
      RETURN
C
C     EARTH ANGLE IS PROPORTIONAL TO CORRECTED PIXEL NUMBER.
   10 CONTINUE
      TFOV2 = TFOV/2.0
      CENTER = (LLC+1)/2.0
      PS1 = PS + SAMPOF
      TOTERT = ARSIN (SIN(TFOV2)*RSAT/RE) - TFOV2
      ANGERT = -TOTERT * (CENTER-PS1) / (CENTER-1.0)
C
C     COMPUTE ORIGINAL SCAN ANGLE BASED ON EARTH ANGLE.
C     C IS LINE FROM SATELLITE TO PIXEL LOCATION ON THE EARTH'S SURFACE.
      C = (RSAT**2 + RE**2 - 2.0*RSAT*RE*COS(ANGERT)) ** 0.5
      ANGSCN = ARSIN(RE/C*SIN(ANGERT))
      PS2 = 1.0 + (ANGSCN+TFOV2) * (LLC-1) / TFOV
      ERCURI = PS2 - PS1
      RETURN
      END
C
      SUBROUTINE READAR (NTAPE1, W, NSAMP)
C
C  READ NSAMP BYTES INTO ARRAY W FROM LOGICAL UNIT NTAPE1
C
      LOGICAL*1 W(NSAMP)
C
      READ (NTAPE1) W
      RETURN
C
C     ******************************************************************
C
      ENTRY WRITAR (NTAPE1, W, NSAMP)
C
C  WRITE NSAMP BYTES FROM ARRAY W ONTO LOGICAL UNIT NTAPE1
C
      WRITE (NTAPE1) W
      RETURN
      END
