C
      SUBROUTINE TRANC (IV, IOUT, D)
C
C     TRANX IS AN ADAPTIVE TRANSFORM CODING PROGRAM WHICH PERFORMS
C     A 16 X 16 BLOCKED HADAMARD OR COSINE TRANSFORM ON A 16*N PIXELS
C     BY 16*M ROW IMAGE.  THE TWO-DIMENSIONAL ARRAY IS MAPPED INTO A
C     ONE-DIMENSIONAL ARRAY IN A ZIGZAG MANNER.
C     A FIRST ORDER RECURSIVE RELATION IS USED TO ESTIMATE VARIANCE
C     OF EACH TRANSFORMED COEFFICIENT = WHT*VA+(1-WHT)*CURRENT REP VALUE
C     A LAPLACIAN FUNCTION IS USED TO MODEL THE PROBABILITY DENSITY
C     FUNCTION OF THE AC TRANSFORMED COEFFICIENTS.
C     THE IMAGE IS RECONSTRUCTED BY MAPPING
C     BACK INTO A 16 X 16 ARRAY AND PERFORMING A 2-D INVERSE MAPPING.
C     TRANC PERFORMS THE PROCESS FOR ONE BAND AT A TIME.
C     INPUT AND RECONSTRUCTED IMAGES ARE IN BYTE ARRAYS.
C     THIS METHOD USES A FIXED TRANSFORMATION AND A FIXED 16 X 16
C     BLOCK SIZE.  THE NUMBER OF BITS ASSIGNED TO EACH COEFFICIENT
C     VARIES FROM BLOCK TO BLOCK.
C
C     INPUT PARAMETERS
C        NB    = BAND NUMBER TO BE PROCESSED
C        NPL   = NUMBER OF PIXELS PER LINE
C        NLINE = NUMBER OF LINES TO BE READ
C        FIXB  = APPROXIMATE BIT RATE
C
C        ITT   = TRANSFORM TYPE
C                1 - HADAMARD (TRANH)  2 - COSINE (TRANC)
C        NBPL  = NUMBER OF BLOCKS PER LINE
C        NBPV  = NUMBER OF BLOCKS IN VERTICAL DIRECTION
C        NTB   = NUMBER OF TOTAL 16 X 16 BLOCKS IN IMAGE
C        MAXP  = MAXIMUM VALUE OF PICTURE
C        MINP  = MINIMUM VALUE OF PICTURE
C        WHT   = WEIGHTING COEFFICIENT FOR RECURSIVE RELATION USED
C                TO ESTIMATE VARIANCE
C        INITB = NUMBER OF BITS REQUIRED FOR FIRST VARIANCE (5)
C        IBIT  = NUMBER OF BITS ASSIGNED TO EACH COEFFICIENT
C        ITCNT = COUNTER FOR THE NUMBER OF BITS USED FOR ENTIRE IMAGE
C        ICONT = COUNTER FOR NUMBER OF BITS USED FOR EACH 16 X 16 BLOCK
C***********************************************************************
C
      DIMENSION IV(4,NPL), IOUT(NPL), D(16,NPL), A(16), B(16), V(256),
     . C(16,16)
      REAL ITCNT, MAXP, MINP, MAX(4) /3*127.0,63.0/, MIN(4) /4*0.0/
      LOGICAL*1 IV, IOUT
      COMMON NB, NLINE, FIXB, NPL
      DATA M, N /16, 256/
C
C     ENTRY FOR COSINE TRANSFORM
      ITT = 2
      WRITE (6,35)
      GO TO 1
C
C     ENTRY FOR HADAMARD TRANSFORM
      ENTRY TRANH (IV, IOUT, D)
      ITT = 1
      WRITE (6,34)
C
C     INPUT PARAMETERS
    1 NBPL = NPL/M
      NBPV=NLINE/M
      NTB=NBPV*NBPL
      ALN2 = ALOG(2.0)
      WHT=0.75
      WHTC=1.-WHT
      INITB=5
C
C     INITIALIZE COUNTERS, SET IMAGE PARAMETERS
      ITCNT=0.0
      ISUM1=0
      ISUM2=0
      MAXP = MAX(NB)
      MINP = MIN(NB)
      CCC=MAXP+1.0
      DCONS=FIXB-ALOG(CCC/128.)/ALOG(2.)
C
C     A 16 X NPL BLOCK OF DATA IS INPUT FOR ONE BAND.  AFTER PROCESSING
C     ENTIRE BLOCK THE RECONSTRUCTED IMAGE IS WRITTEN OFF AND THE
C     NEXT 16 X NPL BLOCK IS INPUT.  THIS CONTINUES UNTIL ALL THE DATA
C     FOR ONE BAND IS PROCESSED.
      DO 950 L=1,NBPV
C
C     READ DATA ONE LINE AT A TIME, PICK OFF DESIRED BAND AND STORE
C     IN ARRAY D.  CONTINUE UNTIL 16 LINES HAVE BEEN READ.  AFTER
C     COMPLETION, D CONTAINS A 16 X NPL BLOCK OF DATA.
      DO 100 I=1,M
      READ (10) IV
      DO 100 J=1,NPL
      IIV = IV(NB,J)
      D(I,J) = IIV
      ISUM1 = ISUM1 + IIV
  100 CONTINUE
C
C     A 16 X 16 BLOCK OF DATA IS TRANSFORMED, ENCODED AND
C     RECONSTRUCTED.  THIS CONTINUES UNTIL THE ENTIRE 16 X NPL BLOCK
C     OF DATA IS PROCESSED.
      DO 900 NH=1,NBPL
C
C     PERFORM A 2-D ORTHOGONAL TRANSFORM (HADAMARD OR COSINE)
C     ON A 16 X 16 BLOCK OF DATA
      DO 230 J=1,M
      JJ=(NH-1)*M+J
      DO 220 I=1,M
  220 A(I) = D(I,JJ)
      GO TO (221,222), ITT
  221 CALL HADD (A, B)
      GO TO 225
  222 CALL COST (A, B, 1)
  225 CONTINUE
      DO 230 I=1,M
  230 C(I,J)=B(I)
C
      DO 250 I=1,M
      DO 240 J=1,M
  240 A(J) = C(I,J)
      GO TO (241,242), ITT
  241 CALL HADD (A, B)
      GO TO 245
  242 CALL COST (A, B, 1)
  245 CONTINUE
      DO 250 J=1,M
  250 C(I,J)=B(J)
C
C     A 16 X 16 BLOCK OF 2-D TRANSFORMED DATA IS CONVERTED TO A
C     1-D FORMAT
      CALL MAP(C,V)
C
C     AVERAGE THE SUM OF THE SQUARES OF THE FIRST 4 AC COEFFICIENTS AND
C     QUANTIZE TO FORM THE FIRST VARIANCE.
      S=0.0
      DO 310 J=2,5
      S=S+V(J)*V(J)
  310 CONTINUE
      VA=S/4.0
      S=SQRT(VA)
      XMULT=3.0
      CALL DSQ (XMULT, S)
      LEVEL=2**INITB
      CALL QUAN (S, LEVEL, EQ)
      VA=EQ*EQ
C
C     QUANTIZATION OF COEFFICIENTS
C
C     ASSIGN THE NUMBER OF BITS TO EACH COEFFICIENT.  INCREMENT
C     COUNTERS.  IF THE NUMBER OF BINARY DIGITS ASSIGNED FOR THE
C     QUANTIZATION IS LESS THAN ONE, THE REMAINING COEFFICIENTS IN THE
C     BLOCK ARE NOT TRANSMITTED.
      ICONT=0
      V(1) = AINT (V(1)+0.5)
      DO 350 I=2,N
      IBIT = 0.5*ALOG(VA)/ALN2 + DCONS
      IF(IBIT.EQ.1)XMULT=1.8
      IF(IBIT.LT.1) GO TO 360
      ICONT=ICONT+IBIT
      S=SQRT(VA)
      CALL DSQ (XMULT, S)
      LEVEL=2**(IBIT-1)
      CALL QUAN (V(I), LEVEL, EQ)
      V(I)=EQ
      VA=WHT*VA+WHTC*EQ*EQ
  350 CONTINUE
      GO TO 375
C
  360 DO 370 J=I,N
  370 V(J)=0.0
C
C     ADD OVERHEAD BITS AND ADJUST 'DCONS' BASED ON DESIRED BIT RATE
  375 CONTINUE
      IBITDC = ALOG(V(1))/ALN2 + 1.0
      ICONT = ICONT + INITB + IBITDC
      XICONT=ICONT
      II=NH+(L-1)*NBPL
      DCONS=DCONS+1./FLOAT(II)*(FIXB-XICONT/256.)
      ITCNT=ITCNT+FLOAT(ICONT)/256.
C
C     MAP 1-D ARRAY OF COEFFICIENTS BACK INTO A 16 X 16 BLOCK.
      CALL UNMAP(C,V)
C
C     PERFORM INVERSE OF 2-D TRANSFORMATION ON A 16 X 16 BLOCK
C     CHECK FOR POINTS WHICH ARE OUT-OF-RANGE.
      DO 440 J=1,M
      DO 430 I=1,M
  430 A(I) = C(I,J)
      GO TO (431,432), ITT
  431 CALL HADD (A, B)
      GO TO 435
  432 CALL COST (A, B, -1)
  435 CONTINUE
      DO 440 I=1,M
  440 C(I,J)=B(I)
C
      DO 460 I=1,M
      DO 450 J=1,M
  450 A(J) = C(I,J)
      GO TO (451,452), ITT
  451 CALL HADD (A, B)
      GO TO 455
  452 CALL COST (A, B, -1)
  455 CONTINUE
      DO 460 J=1,M
      IF (B(J).LT.MINP) B(J) = MINP
      IF (B(J).GT.MAXP) B(J) = MAXP
      K=(NH-1)*M+J
  460 D(I,K) = B(J)
  900 CONTINUE
C
C     AFTER A 16 X NPL BLOCK OF DATA HAS BEEN RECONSTRUCTED, PUT IN
C     BYTE ARRAY AND WRITE ON UNIT NO. NB ONE LINE AT A TIME.
      DO 920 I=1,M
      DO 910 J=1,NPL
      IOUT(J)=D(I,J)+0.5
      ISUM2 = ISUM2 + IOUT(J)
  910 CONTINUE
      WRITE(NB) IOUT
  920 CONTINUE
  950 CONTINUE
C
C     COMPUTE AVERAGE BIT RATE, MEANS OF ORIGINAL, RECONSTRUCTED IMAGES
      ITCNT=ITCNT/FLOAT(NTB)
      PIX=NLINE*NPL
      AMEAN1 = ISUM1 / PIX
      AMEAN2 = ISUM2 / PIX
C
      WRITE (6,40) NPL, NLINE, NB, MAXP, MINP, FIXB
      WRITE(6,60) ITCNT
      WRITE(6,61) AMEAN1, AMEAN2
      RETURN
C
   34 FORMAT(22X,'ADAPTIVE TRANSFORM CODING USING TWO-DIMENSIONAL HADAMA
     .RD TRANSFORM'//)
   35 FORMAT(23X,'ADAPTIVE TRANSFORM CODING USING TWO-DIMENSIONAL COSINE
     . TRANSFORM'//)
   40 FORMAT(' NPL = ',I4,20X,'NLINE = ',I4,16X,'BAND NO.',I2//
     .' MAXP =',F5.1,19X,'MINP =',F5.1,17X,'FIXB =',F5.1/)
   60 FORMAT(' AVERAGE BIT RATE = ',F8.3,/)
   61 FORMAT(' MEAN OF ORIGINAL IMAGE =',F8.3,26X,'MEAN OF RECONSTRUCTED
     . IMAGE =',F8.3//)
      END
C
      SUBROUTINE MAP(A,B)
C
C     MAP CONVERTS A 16 X 16 COEFFICIENT MATRIX INTO A 1-D ARRAY IN A
C     ZIGZAG SEQUENCE.
C
C        A - INPUT 16 X 16 BLOCK MATRIX
C        B - OUTPUT 256 X 1 ARRAY IN ZIGZAG FORMAT
C***********************************************************************
C
      DIMENSION A(16,16), B(256)
      B(1)=A(1,1)
      B(2)=A(1,2)
      B(3)=A(2,1)
      K=4
      L=3
C
C     THIS PART CONVERTS THE UPPER TRIANGLE OF MATRIX
  4   CONTINUE
      J=1
      I=L
   10 CONTINUE
      B(K)=A(I,J)
      K=K+1
        IF(K.GT.136) GO TO 30
      I=I-1
      J=J+1
        IF(I.GE.1) GO TO 10
      J=L+1
      I=1
   20 CONTINUE
      B(K)=A(I,J)
      I=I+1
      J=J-1
      K=K+1
        IF(K.GT.136) GO TO 30
        IF(J.GE.1) GO TO 20
      L=L+2
      GO TO 4
   30 CONTINUE
C
C     THIS PART CONVERTS THE LOWER TRIANGLE OF MATRIX
      L=2
   34 CONTINUE
      J=L
      I=16
   40 CONTINUE
      B(K)=A(I,J)
      K=K+1
      IF(K.GT.256) GO TO 60
      I=I-1
      J=J+1
        IF(J.LE.16) GO TO 40
      I=L+1
      J=16
   50 CONTINUE
      B(K)=A(I,J)
      I=I+1
      J=J-1
      K=K+1
        IF(K.GT.256) GO TO 60
        IF(I.LE.16) GO TO 50
      L=L+2
      GO TO 34
   60 CONTINUE
      RETURN
C***********************************************************************
C
      ENTRY UNMAP (A, B)
C
C     UNMAP CONVERTS THE 1-D COEFFICIENT ARRAY IN A ZIGZAG FORMAT TO
C     A 16 X 16 BLOCK MATRIX
C***********************************************************************
C
      A(1,1)=B(1)
      A(1,2)=B(2)
      A(2,1)=B(3)
      K=4
      L=3
C
C     THIS PART RECONSTRUCTS THE UPPER TRIANGLE OF COEFFICIENTS
  100 CONTINUE
      J=1
      I=L
  110 CONTINUE
      A(I,J)=B(K)
      K=K+1
        IF (K.GT.136) GO TO 130
      I=I-1
      J=J+1
        IF (I.GE.1) GO TO 110
      J=L+1
      I=1
  120 CONTINUE
      A(I,J)=B(K)
      I=I+1
      J=J-1
      K=K+1
        IF (K.GT.136) GO TO 130
        IF (J.GE.1) GO TO 120
      L=L+2
      GO TO 100
C
C     THIS PART RECONSTRUCTS THE LOWER TRIANGLE OF COEFFICIENTS
  130 CONTINUE
      L=2
  134 CONTINUE
      J=L
      I=16
  140 CONTINUE
      A(I,J)=B(K)
      K=K+1
        IF (K.GT.256) GO TO 160
      I=I-1
      J=J+1
        IF (J.LE.16) GO TO 140
      I=L+1
      J=16
  150 CONTINUE
      A(I,J)=B(K)
      I=I+1
      J=J-1
      K=K+1
        IF (K.GT.256) GO TO 160
        IF (I.LE.16) GO TO 150
      L=L+2
      GO TO 134
  160 CONTINUE
      RETURN
      END
C
      SUBROUTINE DSQ (XMULT, SIGMA)
C
C     AN ASSUMED LAPLACIAN DISTRIBUTION OF THE COEFFICIENTS IS TRANS-
C     FORMED TO A UNIFORM DISTRIBUTION BEFORE QUANTIZATION.
C     DSQ COMPUTES THE CONSTANTS OF THE MAPPING FUNCTION.
C        XMULT = ESTIMATED NUMBER OF SIGMAS IN THE DATA RANGE
C        SIGMA = ESTIMATED VARIANCE OF THE INPUT VALUE
C **********************************************************************
C
      EMAX=XMULT*SIGMA
      EM = SQRT(2.0*EMAX) / (3.0*SIGMA)
      EXPM=EXP(-EM)
      EM1 = -EM/EMAX
      RETURN
C***********************************************************************
C
      ENTRY QUAN (F, LEVEL, EQ)
C
C      QUANTIZATION OF AC COEFFICIENTS.
C        F     = VALUE TO BE QUANTIZED
C        LEVEL = NUMBER OF LEVELS IN THE QUANTIZER
C        EQ    = REPRESENTATIVE VALUE FOR F
C **********************************************************************
C
      II=0
      IF(F.GE.0.0)GO TO 2
      F=-F
      II=1
 2    CONTINUE
C
C     FORWARD MAPPING
      EW = F*EM1
      EXPE=EXP(EW)
      Z=EMAX*(1.-EXPE)/(1.-EXPM)
C
      LEVEL1=LEVEL-1
      IZ=(Z/EMAX)*LEVEL
      IF(IZ.LT.0)IZ=0
      IF(IZ.GT.LEVEL1)IZ=LEVEL1
C
C     INVERSE MAPPING
      ZQ=(FLOAT(IZ)+0.5)/FLOAT(LEVEL)
      ZQW=1.-ZQ*(1.-EXPM)
      EQ=-EMAX/EM*ALOG(ZQW)
      IF(II.EQ.1)EQ=-EQ
      RETURN
      END
C
      SUBROUTINE HADD(SPACE,HAD)
C
C     HADD DOES A FAST HADAMARD TRANSFORMATION ON A 16 X 1 ARRAY
C     THE MATRIX IS NORMALIZED SO THAT THE FORWARD AND INVERSE
C     MAPPINGS ARE THE SAME.
C
C        SPACE - INPUT ARRAY
C        HAD   - TRANSFORMED OUTPUT ARRAY
C***********************************************************************
C
      REAL      SPACE(16),BLOCK5(8),BLOCK6(4),BLOCK7(2),IPGM(8),HAD(16)
C
      XN=4.
      IPGM(1)=1
        DO 30 N=2,4
        IDISPL=2**(N-2)+1
        IDELT=0
   20   IPGM(IDISPL+IDELT)=N
        IDELT=IDELT+2**(N-1)
        IF(IDELT+IDISPL-8) 20,20,30
   30   CONTINUE
C
        DO 150 J=1,8
        L=J+J
        I=IPGM(J)
        GO TO (50,200,220,240),I
   50     DO 60 I=1,8
          K=I+I
   60     BLOCK5(I)=SPACE(K-1)+SPACE(K)
   70       DO 80 I=1,4
            K=I+I
   80       BLOCK6(I)=BLOCK5(K-1)+BLOCK5(K)
   90         DO 100 I=1,2
              K=I+I
  100         BLOCK7(I)=BLOCK6(K-1)+BLOCK6(K)
  120   HAD(L-1)=(BLOCK7(1)+BLOCK7(2))/XN
  150   HAD(L) = (BLOCK7(1)-BLOCK7(2))/XN
      RETURN
C
  200 BLOCK7(1)=BLOCK6(1)-BLOCK6(2)
      BLOCK7(2)=BLOCK6(4)-BLOCK6(3)
      GO TO 120
  220   DO 230 I=1,4,2
        K=I+I
        BLOCK6(I)=BLOCK5(K-1)-BLOCK5(K)
  230   BLOCK6(I+1)=BLOCK5(K+2)-BLOCK5(K+1)
      GO TO 90
  240   DO 250 I=1,8,2
        K=I+I
        BLOCK5(I)=SPACE(K-1)-SPACE(K)
  250   BLOCK5(I+1)=SPACE(K+2)-SPACE(K+1)
      GO TO 70
      END
C
      SUBROUTINE COST (INPUT, COSOUT, ITYPE)
C
C GENERALIZED FAST COSINE TRANSFORM ROUTINE
C THERE IS A CHECK MADE SO THE TABLE IS ONLY CALCULATED THE FIRST TIME
C MAXIMUM SIZE ARRAY = 256 ELEMENTS
C
C INPUT = INPUT ARRAY
C COSOUT= COSINE TRANSFORMED ARRAY
C ITYPE:   1= FORWARD TRANSFORM
C         -1= INVERSE TRANSFORM
C ISIZE = NUMBER OF ELEMENTS IN INPUT/OUTPUT ARRAY
C***********************************************************************
C
      REAL INPUT(1)
      DIMENSION COSOUT(1), COSINE(15), SINE(15), OUTPUT(64), S(15)
      LOGICAL FIRST /.TRUE./
      DATA ISIZE, MM /16, 5/
C
      IF (.NOT.FIRST) GO TO 951
      ISIZEF=ISIZE*4
      SQRT2=SQRT(2.0)
C
C COSINE TRANSFORM TABLE GENERATION
      Y=3.1415927/2.0/FLOAT(ISIZE)
      CC=COS(Y)
      SC=SIN(Y)
      COSINE(1)=CC
      SINE(1)=SC
      JJ=ISIZE-2
      DO 950 I=1,JJ
      COSINE(I+1)=COSINE(I)*CC - SINE(I)*SC
950   SINE(I+1)=SINE(I)*CC + COSINE(I)*SC
      CALL MDFT (OUTPUT, MM, 1, S, 0, IFERR)
      FIRST = .FALSE.
C
C BRANCH TO DO FORWARD OR INVERSE TRANSFORM
  951 IF (ITYPE.EQ.-1) GO TO 888
C
C FORWARD TRANSFORM
      OUTPUT(1)=INPUT(1)
      OUTPUT(2)=0.0
      DO 900 I=2,ISIZE
      OUTPUT(I*2-1)=INPUT(I)
      OUTPUT(ISIZEF+3-I*2)=0.0
      OUTPUT(ISIZEF+4-I*2)=0.0
900   OUTPUT(I*2)=0.0
      OUTPUT(2*ISIZE+1)=0.
      OUTPUT(2*ISIZE+2)=0.
C
      CALL MDFT (OUTPUT, MM, 1, S, 2*ITYPE, IFERR)
C
      COSOUT(1) = OUTPUT(1)*SQRT2
      DO 810 I=2,ISIZE
810   COSOUT(I) = 2.0*(OUTPUT(2*I-1)*COSINE(I-1)-OUTPUT(2*I)*SINE(I-1))
      RETURN
C
C INVERSE TRANSFORM
888   SUM=INPUT(1)/SQRT2
      CT=SUM*(1.0-1.0/SQRT2)/FLOAT(ISIZE)
C
      OUTPUT(1)=INPUT(1)
      OUTPUT(2)=0.0
      DO 910 I=2,ISIZE
      OUTPUT(2*I-1)=       INPUT(I)*COSINE(I-1)
      OUTPUT(ISIZEF+3-I*2)=INPUT(I)*COSINE(I-1)
      OUTPUT(ISIZEF+4-I*2)=INPUT(I)*SINE(I-1)
910   OUTPUT(2*I)=       -(INPUT(I)*SINE(I-1))
      OUTPUT(2*ISIZE+1)=0.
      OUTPUT(2*ISIZE+2)=0.
C
      CALL MDFT (OUTPUT, MM, 1, S, 2*ITYPE, IFERR)
C
      DO 811 I=1,ISIZE
811   COSOUT(I) = OUTPUT(2*I-1) + CT
      RETURN
      END
C
      SUBROUTINE MDFT(A,MC,ND,S,IFS,IFERR)
C
C         MDFT, MULTI-DIMENSIONAL FINITE FOURIER TRANSFORM
C
C     MDFT TOGETHER WITH MFORT IS A MODIFICATION OF FORT
C     A SUBROUTINE SUPPLIED BY J.W. COOLEY OF IBM. FORT
C     COMPUTES ONE-DIMENSIONAL FOURIER TRANSFORMS, MDFT-
C     MFORT GIVES TRANSFORMS IN UP TO SIX DIMENSIONS
C
C     A IS A COMPLEX ARRAY WITH DIMENSION A(NN(1),...,NN(ND)),
C     WHERE NN(K)=2**MC(K).  A IS TO BE SET BY THE USER.
C
C     MC IS A VECTOR SET BY USER. 0.LT.MC(K).LE.13 FOR
C     K=1,2,...,ND.  IN ADDITION MC(1)+MC(2)+...+NC(ND).LE.13.
C     (IF IFS=0 THE 13 IN THE TWO ABOVE COMMENTS CAN BE REPLACED BY 14.)
C     IN THE COMMENTS WHICH FOLLOW, M=MAX(MC(K)).
C
C     ND IS THE DIMENSION OF THE COMPLEX ARRAY A.  ND IS
C     SUPPLIED BY THE USER.
C
C     S IS A VECTOR S(J)= SIN(2*PI*J/NP ), J=1,2,....,NP/4-1,
C     WHERE NP=MAX(NN(K)).  S IS COMPUTED BY THE PROGRAM.
C
C     IFS IS A PARAMETER TO BE SET BY USER AS FOLLOWS-
C     IFS=0 TO SET NP=2**M AND SET UP SINE TABLE.
C
C     IFS=1 TO SET N=NP=2**M, SET UP SIN TABLE, AND DO FOURIER
C     SYNTHESIS.  THE ARRAY A(J(1),J(2),...,J(ND)) IS REPLACED BY
C     X(J(1),J(2),...,J(ND))= SUM OVER 0.LE.K(1).LE.NN(1)-1,
C     0.LE.K(2).LE.NN(2)-1,...,0.LE.K(ND).LE.NN(ND)-1  OF
C     A(K(1),K(2),...,K(ND))*(EXP(2*PI*J(1)*K(1)*I/NN(1)))*
C     (EXP(2*PI*J(2)*K(2)*I/NN(2)))*...*(EXP(2*PI*J(ND)*K(ND)*I/NN(ND)))
C     0.LE.J(1).LE.NN(1)-1,0.LE.J(2).LE.NN(2)-1,...,
C     0.LE.J(ND).LE.NN(ND)-1, WHERE I=SQRT(-1).
C     THE X'S ARE STORED WITH RE X(J(1),J(2),...,J(ND)) IN CELL
C     1+2*(J(1)+J(2)*NN(1)+J(3)*NN(1)*NN(2)+...
C     +J(ND)*NN(1)*NN(2)*...*NN(ND-1)),  AND
C     IM X(J(1),...,J(ND)) IN THE CELL FOLLOWING
C     RE X(J(1),...,J(ND)).
C     THE  A'S  ARE STORED IN THE SAME MANNER.
C
C     IFS=-1   TO SET  N=NP=2**M,SET UP SIN TABLE, AND DO FOURIER
C     ANALYSIS,TAKING THE INPUT ARRAY A AS X AND
C     REPLACING IT BY THE A  SATISFYING THE ABOVE FOURIER SERIES.
C
C     IFS=+2 TO DO FOURIER SYNTHESIS ONLY, WITH A PRE-COMPUTED S.
C
C     IFS=-2 TO DO FOURIER ANALYSIS ONLY, WITH A PRE-COMPUTED S.
C
C     IFERR   IS SET BY PROGRAM TO-
C     =0 IF NO ERROR DETECTED.
C     =1 IF THE MC(K)'S DO NOT SATISFY THE CONDITIONS ABOVE,
C         OR ND DOES NOT SATISFY 1.LE.ND.LE.6.
C     =-1 WHEN IFS=1,0,OR -1 AND THE S TABLE NEED NOT BE COMPUTED.
C     =-2 WHEN IFS=2 OR -2 AND THE S TABLE NEED BE COMPUTED.
C
C     AS STATED ABOVE, MC(1)+MC(2)+...+MC(ND).LE.13.IF THE
C     COMPUTER USED HAS A GREATER STORAGE CAPACITY THAN THE
C     IBM 7094 THIS MAXIMUM MAY BE INCREASED BY REPLACING
C     13 IN STATEMENT 6 BELOW WITH M=LOG2 N,WHERE N IS
C     THE MAXIMUM NUMBER OF COMPLEX NUMBERS ONE CAN STORE
C     IN HIGH SPEED CORE.  THE DIMENSION OF KE MUST BE SET
C     EQUAL TO M+1 IN BOTH MDFT AND MFORT. THE DO LOOP
C     JUST BEFORE STATEMENT 40 MUST EXTEND TO M-1 INSTEAD OF 12.
C     THE 14 IN STATEMENT 105 MUST BE CHANGED TO M+1.
C     IN MFORT ONE MUST CHANGE THE EQUIVALENCE STATEMENTS FOR
C     THE KE'S AND ADD MORE DO STATEMENTS TO THE BINARY SORT
C     JUST ABOVE STATEMENT 28.
C
      DIMENSION A(1),S(1),MC(1)
      DIMENSION NF(7),NN(6)
      DIMENSION KE(14)
      EQUIVALENCE (KE(1),JD)
      DATA NF(1)/2/, NPD/0/
C
C     NOTE THAT THE NAMED COMMON,CFORTC, IS USED FOR
C     COMMUNICATION BETWEEN MDFT AND MFORT.
      COMMON/CFORTC/M,N,NT,KS,KS2,KST,KE
C
      NDD=ND
      IF (NDD) 110,110,2
 2    IF(ND.GT.6) GO TO 110
      IFSS=IFS
      MS=0
      KM=1
      DO 10 K=1,NDD
      M=MC(K)
      IF(M) 110,110,4
 4    MS=MS+M
      IF(MS.GT.13) GO TO 105
 8    NN(K)=2**M
      NF(K+1)=NF(K)*NN(K)
 10   IF(NN(K).GT.NN(KM)) KM=K
      IFERR=0
      IF (IABS(IFSS).LT.2) GO TO 160
      IF(NPD.LT.NN(KM)) GO TO 150
 15   NTOT2=NF(NDD+1)
      IF(IFSS) 20,110,30
C
C     DOING FOURIER ANALYSIS SO DIVIDE BY NN(1)*NN(2)*...*NN(ND) AND
C     CONJUGATE.
 20   FN=NTOT2/2
      DO 25 I=1,NTOT2,2
      A(I)=A(I)/FN
 25   A(I+1)=-A(I+1)/FN
C
C     BEGINNING OF LOOP FOR COMPUTING MULTIPLE SUM
 30   DO 50 K=1,NDD
      M=MC(K)
      N=NN(K)
      KS=NF(K)
      KS1=KS-1
      KS2=2*KS
      KST=KS+2
      KE(1)=NF(K+1)
      DO 35 L=2,M
 35   KE(L)=KE(L-1)/2
      DO 40 L=M,12
 40   KE(L+1)=KS
      DO 50 J=1,NTOT2,JD
      KSS=J+KS1
      DO 50 I=J,KSS,2
 50   CALL MFORT(A(I),S)
C     END OF LOOP FOR COMPUTING MULTIPLE SUM
C
 70   IF(IFSS) 75,110,100
C
C     DOING FOURIER ANALYSIS. REPLACE A BY CONJUGATE.
 75   DO 80 I=2,NTOT2,2
 80   A(I)=-A(I)
      GO TO 100
 105  IF((IFS.EQ.0).AND.(MS.EQ.14)) GO TO 8
 110  IFERR=1
      GO TO 100
 150  IFERR=-2
 160  NPD=NN(KM)
      M=MC(KM)
      IF (NP.GE.NPD) IFERR=-1
C
C     MAKE TABLE OF S(J)=SIN(2*PI*J/NP),J=1,2,....NT-1,NT=NP/4
 200  NP=NPD
      NT=NP/4
      MT=M-2
      IF(MT) 260,260,205
 205  THETA=.7853981633974483
C
C     THETA=PI/2**(L+1)    FOR L=1
      JSTEP = NT
C
C     JSTEP = 2**( MT-L+1 ) FOR L=1
      JDIF = NT/2
C
C     JDIF = 2**(MT-L)  FOR L=1
      S(JDIF) = SIN(THETA)
      IF (MT-2)260,220,220
  220 DO 250 L=2,MT
      THETA = THETA/2.
      JSTEP2 = JSTEP
      JSTEP = JDIF
      JDIF = JDIF/2
      S(JDIF)=SIN(THETA)
      JC1=NT-JDIF
      S(JC1)=COS(THETA)
      JLAST=NT-JSTEP2
      IF(JLAST-JSTEP)250,230,230
  230 DO 240 J=JSTEP,JLAST,JSTEP
      JC=NT-J
      JD=J+JDIF
  240 S(JD)=S(J)*S(JC1)+S(JDIF)*S(JC)
  250 CONTINUE
 260  IF(IFSS) 15,100,15
 100  RETURN
      END
C
      SUBROUTINE MFORT(A,S)
C
C         MFORT, MODIFIED VERSION OF FORT FOR USE
C         AS SUBROUTINE BY MDFT
C
      DIMENSION A(1),S(1)
      DIMENSION KE(14)
      COMMON/CFORTC/M,N,NT,KS,KS2,KST,KE
      EQUIVALENCE (KE(13),K1),(KE(12),K2),(KE(11),K3),(KE(10),K4)
      EQUIVALENCE (KE( 9),K5),(KE( 8),K6),(KE( 7),K7),(KE( 6),K8)
      EQUIVALENCE (KE( 5),K9),(KE(4),K10),(KE(3),K11),(KE(2),K12)
      EQUIVALENCE (KE(1),K13),(KE(1),N2)
C
C     SCRAMBLE A, BY SANDE'S METHOD
C     NOTE EQUIVALENCE OF KL AND KE(14-L)
C     BINARY SORT-
      IJ=2
      DO 30 J1=2,K1,KS
      DO 30 J2=J1,K2,K1
      DO 30 J3=J2,K3,K2
      DO 30 J4=J3,K4,K3
      DO 30 J5=J4,K5,K4
      DO 30 J6=J5,K6,K5
      DO 30 J7=J6,K7,K6
      DO 30 J8=J7,K8,K7
      DO 30 J9=J8,K9,K8
      DO 30 J10=J9,K10,K9
      DO 30 J11=J10,K11,K10
      DO 30 J12=J11,K12,K11
      DO 30 JI=J12,K13,K12
      IF(IJ-JI)28,30,30
   28 T=A(IJ-1 )
      A(IJ-1)=A(JI-1)
      A(JI-1)=T
      T=A(IJ)
      A(IJ)=A(JI)
      A(JI)=T
 30   IJ=IJ+KS
C
C     SPECIAL CASE- L=1
 36   DO 40 I=2,N2,KS2
      KSI=I+KS
      T=A(I-1)
      A(I-1)=T+A(KSI-1)
      A(KSI-1)=T-A(KSI-1)
      T=A(I)
      A(I)=T+A(KSI)
 40   A(KSI)=T-A(KSI)
      IF (M.LE.1) GO TO 1
C
C     SET FOR L=2
 50   LEXP1=KS
C
C     LEXP1=KS*2**(L-2)
      LEXP=4*LEXP1
C
C     LEXP=KS*2**L
      NPL=NT
C
C     NPL=NT*2**(2-L)
C     NT=NP/4,NP IS DEFINED IN COMMENTS IN MDFT.
      DO 130 L=2,M
C
C     SPECIAL CASE- J=0
      DO 80 I=2,N2,LEXP
      I1=I + LEXP1
      I2=I1+ LEXP1
      I3 =I2+LEXP1
      T=A(I-1)
      A(I-1) = T +A(I2-1)
      A(I2-1) = T-A(I2-1)
      T =A(I)
      A(I) = T+A(I2)
      A(I2) = T-A(I2)
      T= -A(I3)
      TI = A(I3-1)
      A(I3-1) = A(I1-1) - T
      A(I3   ) = A(I1 )   - TI
      A(I1-1) = A(I1-1) +T
   80 A(I1)   = A(I1   )  +TI
      IF(L-2) 120,120,90
   90 KLAST=N2-LEXP
      JJ=NPL
C
      DO 110 J=KST,LEXP1,KS
      NPJJ=NT-JJ
      UR=S(NPJJ)
      UI=S(JJ)
      ILAST=J+KLAST
C
      DO 100 I= J,ILAST,LEXP
      I1=I+LEXP1
      I2=I1+LEXP1
      I3=I2+LEXP1
      T=A(I2-1)*UR-A(I2)*UI
      TI=A(I2-1)*UI+A(I2)*UR
      A(I2-1)=A(I-1)-T
      A(I2  )=A(I   ) - TI
      A(I-1) =A(I-1)+T
      A(I)   =A(I)+TI
      T=-A(I3-1)*UI-A(I3)*UR
      TI=A(I3-1)*UR-A(I3)*UI
      A(I3-1)=A(I1-1)-T
      A(I3)   =A(I1  )-TI
      A(I1-1)=A(I1-1)+T
  100 A(I1)   =A(I1)   +TI
C     END OF I LOOP
C
  110 JJ=JJ+NPL
C     END OF J LOOP
C
  120 LEXP1=2*LEXP1
      LEXP = 2*LEXP
  130 NPL=NPL/2
C     END OF L LOOP
C
    1 RETURN
      END
