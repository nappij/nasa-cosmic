************************************************************************
*                          VARCAL.FOR                                  *
*                                                                      *
*  PROGRAM: SIMRAND I                                                  *
*  MODULE:  1.5.3.3                                                    *
*  DATE:    01/29/85                                                   *
*                                                                      *
*  THIS IS THE SUBROUTINE VARCAL.  IT CALCULATES THE RANDOM VARIABLE   *
*  MATRIX FOR TASK VARIABLES FROM THE RANDOM NUMBER MATRIX USING THE   *
*  CDF COEFFICIENTS GENERATED BY THE SUBROUTINE COEFF.                 *
*                                                                      *
*----------------------------------------------------------------------*
*                     CONFIGURATION CHANGES                            *
*                                                                      *
*    DATE                  CHANGE                                      *
*                                                                      *
*  01/18/85  * ORIGINAL.                                               *
*  01/22/85  * MODULE  8: ID LOOP CHANGED TO IC LOOP FOR CLARITY.      *
*  01/29/85  * MODULE  1: JDIAG .EQ. 2.                                *
*            * MODULE 11: JDIAG .EQ. 2.                                *
*                                                                      *
************************************************************************

$TITLE:'VARCAL.LST'
$DEBUG
$NOFLOATCALLS
$STORAGE:2

************************************************************************

      SUBROUTINE VARCAL

************************************************************************


***** INITIALIZE.  {MODULE 1}

$INCLUDE:'INITIAL.FOR'

      IF (JDIAG .EQ. 2) THEN
         WRITE  (*,100)
100      FORMAT (/1X,4X,'ENTER SUBROUTINE VARCAL')
      ENDIF

***   {END MODULE 1}


***** START (IA,IX) DO LOOPS FOR TASK VARIABLES VARMTX(IA,IX).
***** {MODULE 2}

      NIXX = NIX - 1
      DO 130 IA=1,NIA
         DO 130 IX=1,NIXX

            IDTASK = ITASK(IA,IX)
            RAN    = RANMTX(IA,IX)


*****       TEST WHETHER TASK VARIABLE USED AND MAKE TASK VARIABLE
*****       ASSIGNMENT.  {MODULE 3}

            IF (IDTASK .EQ. 0) THEN


*****          SET UNUSED TASK VARIABLE VARMTX(IA,IX) = 0.0.  {MODULE 4}

               VARMTX(IA,IX) = 0.0

***            {END MODULE 4}


*****       {CONTINUE MODULE 3}

            ELSE

*****          TASK VARIABLE VARMTX(IA,IX) USED.  TEST FOR SUCCESS OF
*****          TASK AND MAKE TASK VARIABLE ASSIGNMENT.  {MODULE 5}

               IF (RAN .GT. TDATA(IDTASK,2)) THEN


*****             TASK FAILED.  SET VARMTX(IA,IX) TO TASK FAILURE VALUE.
*****             {MODULE 6}

                  VARMTX(IA,IX) = TDATA(IDTASK,1)

***               {END MODULE 6}


*****          {CONTINUE MODULE 5}

               ELSE


*****             TASK SUCCESSFUL. CALCULATE CDF CONDITIONAL ON SUCCESS.
*****             {MODULE 7}
 
                  RAN1 = RAN/TDATA(IDTASK,2)

*                 ADJUST RAN1 IF > 1.0 DUE TO ROUNDOFF.

                  IF (RAN1 .GT. 1.0) RAN1 = 1.0

***               {END MODULE 7}


*****             START DO LOOP TO CALCULATE VARMTX(IA,IX) FOR 
*****             SUCCESSFUL TASK.  {MODULE 8}

                  DO 110 IC=1,NIC,2


*****                FIND CORRECT TASK VARIABLE COEFFICIENTS AND
*****                CALCULATE VARMTX(IA,IX).  {MODULE 9}

                     ID = IC + 4

                     IF (RAN1 .LE. TDATA(IDTASK,ID+1)) THEN

*                       CORRECT TASK VARIABLE COEFFICIENTS.  CALCULATE
*                       VARMTX(IA,IX). 

                        VARMTX(IA,IX) = TCOEF(IDTASK,IC)*RAN1 + 
     *                                  TCOEF(IDTASK,IC+1)

*                       JUMP OUT OF (IC) DO LOOP FOR CALCULATING ONE
*                       SUCCESSFUL TASK VARIABLE VARMTX(IA,IX).

                        GO TO 120

                     ENDIF

***                  {END MODULE 9}

110               CONTINUE

120               CONTINUE

***               END (IC) DO LOOP TO CALCULATE VARMTX(IA,IX) FOR ONE
***               SUCCESSFUL TASK VARIABLE.  {END MODULE 8}

               ENDIF

***            END ONE TASK VARIABLE VARMTX(IA,IX) USED AND TASK
***            VARIABLE ASSIGNMENT.  {END MODULE 5}

            ENDIF

***         END TEST WHETHER ONE TASK VARIABLE USED AND ONE TASK 
***         VARIABLE ASSIGNMENT.  {END MODULE 3}

130   CONTINUE  

***   END (IA,IX) DO LOOPS FOR TASK VARIABLES VARMTX(IA,IX).
***   {END MODULE 2}


***** WRITE TASK VARIABLES VARMTX(IA,IX).  {MODULE 10}

      IF (JDIAG .EQ. 2) THEN

         NIXX = NIX - 1
         DO 160 IA=1,NIA

            IF (NIXX .LE. 5) THEN
               WRITE  (*,140) IA,(VARMTX(IA,IX),IX=1,NIXX)
            ELSE
               WRITE  (*,140) IA,(VARMTX(IA,IX),IX=1,5)
               WRITE  (*,150)    (VARMTX(IA,IX),IX=6,NIXX)
            ENDIF

140         FORMAT (1X,I5,3X,1P5E14.4)
150         FORMAT (1X,   8X,1P5E14.4)

160      CONTINUE

      ENDIF

***   {END MODULE 10}


***** EXIT FROM SUBROUTINE VARCAL.  {MODULE 11}

      IF (JDIAG .EQ. 2) THEN
         WRITE (*,999)
999      FORMAT (1X,4X,'EXIT  SUBROUTINE VARCAL')
      ENDIF
     
      RETURN

      END

***   {END MODULE 11}

***************************** VARCAL.FOR *******************************
